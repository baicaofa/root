/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ajv-formats/dist/formats.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
function fmtDef(validate, compare) {
    return { validate, compare };
}
exports.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true,
};
exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
};
exports.formatNames = Object.keys(exports.fullFormats);
function isLeapYear(year) {
    // https://tools.ietf.org/html/rfc3339#appendix-C
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
    const matches = DATE.exec(str);
    if (!matches)
        return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return (month >= 1 &&
        month <= 12 &&
        day >= 1 &&
        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
}
function compareDate(d1, d2) {
    if (!(d1 && d2))
        return undefined;
    if (d1 > d2)
        return 1;
    if (d1 < d2)
        return -1;
    return 0;
}
const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
        return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (((hour <= 23 && minute <= 59 && second <= 59) ||
        (hour === 23 && minute === 59 && second === 60)) &&
        (!withTimeZone || timeZone !== ""));
}
function compareTime(t1, t2) {
    if (!(t1 && t2))
        return undefined;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
        return undefined;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
        return 1;
    if (t1 < t2)
        return -1;
    return 0;
}
const DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
        return undefined;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === undefined)
        return undefined;
    return res || compareTime(t1, t2);
}
const NOT_URI_FRAGMENT = /\/|:/;
const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
}
const MIN_INT32 = -(2 ** 31);
const MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
    return Number.isInteger(value);
}
function validateNumber() {
    return true;
}
const Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
    if (Z_ANCHOR.test(str))
        return false;
    try {
        new RegExp(str);
        return true;
    }
    catch (e) {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/ajv-formats/dist/index.js":
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const formats_1 = __webpack_require__("./node_modules/ajv-formats/dist/formats.js");
const limit_1 = __webpack_require__("./node_modules/ajv-formats/dist/limit.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const fullName = new codegen_1.Name("fullFormats");
const fastName = new codegen_1.Name("fastFormats");
const formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
        limit_1.default(ajv);
    return ajv;
};
formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
        throw new Error(`Unknown format "${name}"`);
    return f;
};
function addFormats(ajv, list, fs, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = codegen_1._ `require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
        ajv.addFormat(f, fs[f]);
}
module.exports = exports = formatsPlugin;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = formatsPlugin;


/***/ }),

/***/ "./node_modules/ajv-formats/dist/limit.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatLimitDefinition = void 0;
const ajv_1 = __webpack_require__("./node_modules/ajv/dist/ajv.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const ops = codegen_1.operators;
const KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error = {
    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
            return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fmt = gen.const("fmt", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != "object"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
            const format = fCxt.schema;
            const fmtDef = self.formats[format];
            if (!fmtDef || fmtDef === true)
                return;
            if (typeof fmtDef != "object" ||
                fmtDef instanceof RegExp ||
                typeof fmtDef.compare != "function") {
                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
                key: format,
                ref: fmtDef,
                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,
            });
            cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
    },
    dependencies: ["format"],
};
const formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
};
exports["default"] = formatLimitPlugin;


/***/ }),

/***/ "./node_modules/ajv/dist/ajv.js":
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
const core_1 = __webpack_require__("./node_modules/ajv/dist/core.js");
const draft7_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/draft7.js");
const discriminator_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/discriminator/index.js");
const draft7MetaSchema = __webpack_require__("./node_modules/ajv/dist/refs/json-schema-draft-07.json");
const META_SUPPORT_DATA = ["/properties"];
const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
class Ajv extends core_1.default {
    _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
            return;
        const metaSchema = this.opts.$data
            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
            : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
        return (this.opts.defaultMeta =
            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
    }
}
exports.Ajv = Ajv;
module.exports = exports = Ajv;
module.exports.Ajv = Ajv;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Ajv;
var validate_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/index.js");
Object.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));
var codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));
Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));
Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));
Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));
Object.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));
var validation_error_1 = __webpack_require__("./node_modules/ajv/dist/runtime/validation_error.js");
Object.defineProperty(exports, "ValidationError", ({ enumerable: true, get: function () { return validation_error_1.default; } }));
var ref_error_1 = __webpack_require__("./node_modules/ajv/dist/compile/ref_error.js");
Object.defineProperty(exports, "MissingRefError", ({ enumerable: true, get: function () { return ref_error_1.default; } }));


/***/ }),

/***/ "./node_modules/ajv/dist/compile/codegen/code.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class _CodeOrName {
}
exports._CodeOrName = _CodeOrName;
exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
class Name extends _CodeOrName {
    constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        return false;
    }
    get names() {
        return { [this.str]: 1 };
    }
}
exports.Name = Name;
class _Code extends _CodeOrName {
    constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        if (this._items.length > 1)
            return false;
        const item = this._items[0];
        return item === "" || item === '""';
    }
    get str() {
        var _a;
        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
    }
    get names() {
        var _a;
        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
            if (c instanceof Name)
                names[c.str] = (names[c.str] || 0) + 1;
            return names;
        }, {})));
    }
}
exports._Code = _Code;
exports.nil = new _Code("");
function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
    }
    return new _Code(code);
}
exports._ = _;
const plus = new _Code("+");
function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
}
exports.str = str;
function addCodeArg(code, arg) {
    if (arg instanceof _Code)
        code.push(...arg._items);
    else if (arg instanceof Name)
        code.push(arg);
    else
        code.push(interpolate(arg));
}
exports.addCodeArg = addCodeArg;
function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
        if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== undefined) {
                expr.splice(i - 1, 3, res);
                continue;
            }
            expr[i++] = "+";
        }
        i++;
    }
}
function mergeExprItems(a, b) {
    if (b === '""')
        return a;
    if (a === '""')
        return b;
    if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
            return;
        if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
        return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    return;
}
function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
}
exports.strConcat = strConcat;
// TODO do not allow arrays here
function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null
        ? x
        : safeStringify(Array.isArray(x) ? x.join(",") : x);
}
function stringify(x) {
    return new _Code(safeStringify(x));
}
exports.stringify = stringify;
function safeStringify(x) {
    return JSON.stringify(x)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
}
exports.safeStringify = safeStringify;
function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
}
exports.getProperty = getProperty;
//Does best effort to format the name properly
function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
}
exports.getEsmExportName = getEsmExportName;
function regexpCode(rx) {
    return new _Code(rx.toString());
}
exports.regexpCode = regexpCode;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/codegen/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
const code_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/code.js");
const scope_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/scope.js");
var code_2 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/code.js");
Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return code_2._; } }));
Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return code_2.str; } }));
Object.defineProperty(exports, "strConcat", ({ enumerable: true, get: function () { return code_2.strConcat; } }));
Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return code_2.nil; } }));
Object.defineProperty(exports, "getProperty", ({ enumerable: true, get: function () { return code_2.getProperty; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return code_2.stringify; } }));
Object.defineProperty(exports, "regexpCode", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));
Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return code_2.Name; } }));
var scope_2 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/scope.js");
Object.defineProperty(exports, "Scope", ({ enumerable: true, get: function () { return scope_2.Scope; } }));
Object.defineProperty(exports, "ValueScope", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));
Object.defineProperty(exports, "ValueScopeName", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));
Object.defineProperty(exports, "varKinds", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));
exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+"),
};
class Node {
    optimizeNodes() {
        return this;
    }
    optimizeNames(_names, _constants) {
        return this;
    }
}
class Def extends Node {
    constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
    }
    render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (!names[this.name.str])
            return;
        if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
}
class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
    }
    render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
    }
}
class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
    }
    render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
}
class Label extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        return `${this.label}:` + _n;
    }
}
class Break extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
    }
}
class Throw extends Node {
    constructor(error) {
        super();
        this.error = error;
    }
    render({ _n }) {
        return `throw ${this.error};` + _n;
    }
    get names() {
        return this.error.names;
    }
}
class AnyCode extends Node {
    constructor(code) {
        super();
        this.code = code;
    }
    render({ _n }) {
        return `${this.code};` + _n;
    }
    optimizeNodes() {
        return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
    }
    get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
}
class ParentNode extends Node {
    constructor(nodes = []) {
        super();
        this.nodes = nodes;
    }
    render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
            else if (n)
                nodes[i] = n;
            else
                nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i];
            if (n.optimizeNames(names, constants))
                continue;
            subtractNames(names, n.names);
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
}
class BlockNode extends ParentNode {
    render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
}
class Root extends ParentNode {
}
class Else extends BlockNode {
}
Else.kind = "else";
class If extends BlockNode {
    constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
    }
    render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
            code += "else " + this.else.render(opts);
        return code;
    }
    optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
            return this.nodes; // else is ignored here
        let e = this.else;
        if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
            if (cond === false)
                return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
                return this;
            return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
            return undefined;
        return this;
    }
    optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
            return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
            addNames(names, this.else.names);
        return names;
    }
}
If.kind = "if";
class For extends BlockNode {
}
For.kind = "for";
class ForLoop extends For {
    constructor(iteration) {
        super();
        this.iteration = iteration;
    }
    render(opts) {
        return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iteration.names);
    }
}
class ForRange extends For {
    constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
    }
    render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
    }
}
class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
    }
    render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iterable.names);
    }
}
class Func extends BlockNode {
    constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
    }
    render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
}
Func.kind = "func";
class Return extends ParentNode {
    render(opts) {
        return "return " + super.render(opts);
    }
}
Return.kind = "return";
class Try extends BlockNode {
    render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
            code += this.catch.render(opts);
        if (this.finally)
            code += this.finally.render(opts);
        return code;
    }
    optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
    }
    optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        if (this.catch)
            addNames(names, this.catch.names);
        if (this.finally)
            addNames(names, this.finally.names);
        return names;
    }
}
class Catch extends BlockNode {
    constructor(error) {
        super();
        this.error = error;
    }
    render(opts) {
        return `catch(${this.error})` + super.render(opts);
    }
}
Catch.kind = "catch";
class Finally extends BlockNode {
    render(opts) {
        return "finally" + super.render(opts);
    }
}
Finally.kind = "finally";
class CodeGen {
    constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
    }
    toString() {
        return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
        return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
        return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
        vs.add(name);
        return name;
    }
    getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
        return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== undefined && constant)
            this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
        if (typeof c == "function")
            c();
        else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
        return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
            if (code.length > 1)
                code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
                code.push(":");
                (0, code_1.addCodeArg)(code, value);
            }
        }
        code.push("}");
        return new code_1._Code(code);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
        }
        else if (thenBody) {
            this.code(thenBody).endIf();
        }
        else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
        return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
        return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
        return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
            this.code(forBody).endFor();
        return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
                this.var(name, (0, code_1._) `${arr}[${i}]`);
                forBody(name);
            });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
        return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
        return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
        return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
        }
        if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error) {
        return this._leafNode(new Throw(error));
    }
    // start self-balancing block
    block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
            this.code(body).endBlock(nodeCount);
        return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === undefined)
            throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
            this.code(funcBody).endFunc();
        return this;
    }
    // end function definition
    endFunc() {
        return this._endBlockNode(Func);
    }
    optimize(n = 1) {
        while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
        }
    }
    _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
    }
    _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop();
            return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
    }
    get _root() {
        return this._nodes[0];
    }
    get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
    }
    set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
    }
}
exports.CodeGen = CodeGen;
function addNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
}
function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
}
function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
        return replaceName(expr);
    if (!canOptimize(expr))
        return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
            c = replaceName(c);
        if (c instanceof code_1._Code)
            items.push(...c._items);
        else
            items.push(c);
        return items;
    }, []));
    function replaceName(n) {
        const c = constants[n.str];
        if (c === undefined || names[n.str] !== 1)
            return n;
        delete names[n.str];
        return c;
    }
    function canOptimize(e) {
        return (e instanceof code_1._Code &&
            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
    }
}
function subtractNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
}
function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
}
exports.not = not;
const andCode = mappend(exports.operators.AND);
// boolean AND (&&) expression with the passed arguments
function and(...args) {
    return args.reduce(andCode);
}
exports.and = and;
const orCode = mappend(exports.operators.OR);
// boolean OR (||) expression with the passed arguments
function or(...args) {
    return args.reduce(orCode);
}
exports.or = or;
function mappend(op) {
    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
}
function par(x) {
    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
}


/***/ }),

/***/ "./node_modules/ajv/dist/compile/codegen/scope.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
const code_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/code.js");
class ValueError extends Error {
    constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
    }
}
var UsedValueState;
(function (UsedValueState) {
    UsedValueState[UsedValueState["Started"] = 0] = "Started";
    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var"),
};
class Scope {
    constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
    }
    toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
        return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return (this._names[prefix] = { prefix, index: 0 });
    }
}
exports.Scope = Scope;
class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
    }
}
exports.ValueScopeName = ValueScopeName;
const line = (0, code_1._) `\n`;
class ValueScope extends Scope {
    constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
        return this._scope;
    }
    name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
        var _a;
        if (value.ref === undefined)
            throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
                return _name;
        }
        else {
            vs = this._values[prefix] = new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
    }
    getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
            return;
        return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_1._) `${scopeName}${name.scopePath}`;
        });
    }
    scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
            if (name.value === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
        }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
                continue;
            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
            vs.forEach((name) => {
                if (nameSet.has(name))
                    return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
                }
                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
                }
                else {
                    throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
            });
        }
        return code;
    }
}
exports.ValueScope = ValueScope;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/errors.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
};
exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType
        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
};
function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
        addError(gen, errObj);
    }
    else {
        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
    }
}
exports.reportError = reportError;
function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
    }
}
exports.reportExtraError = reportExtraError;
function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
}
exports.resetErrorsCount = resetErrorsCount;
function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
    /* istanbul ignore if */
    if (errsCount === undefined)
        throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
            gen.assign((0, codegen_1._) `${err}.data`, data);
        }
    });
}
exports.extendErrors = extendErrors;
function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
}
function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
    }
    else {
        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
        gen.return(false);
    }
}
const E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema"),
};
function errorObjectCode(cxt, error, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
        return (0, codegen_1._) `{}`;
    return errorObject(cxt, error, errorPaths);
}
function errorObject(cxt, error, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths),
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen.object(...keyValues);
}
function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath
        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
        : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
}
function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
    if (schemaPath) {
        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
}
function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
}


/***/ }),

/***/ "./node_modules/ajv/dist/compile/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const validation_error_1 = __webpack_require__("./node_modules/ajv/dist/runtime/validation_error.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const resolve_1 = __webpack_require__("./node_modules/ajv/dist/compile/resolve.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const validate_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/index.js");
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
exports.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._) `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1.Name ? undefined : props,
                items: items instanceof codegen_1.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1.Name,
                dynamicItems: items instanceof codegen_1.Name,
            };
            if (validate.source)
                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
exports.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        const { schemaId } = this.opts;
        if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
exports.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
exports.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
exports.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
            return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === undefined)
            return;
        schema = partSchema;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}


/***/ }),

/***/ "./node_modules/ajv/dist/compile/names.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const names = {
    // validation function arguments
    data: new codegen_1.Name("data"), // data passed to validation function
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
    errors: new codegen_1.Name("errors"), // counter of validation errors
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart"),
};
exports["default"] = names;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/ref_error.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const resolve_1 = __webpack_require__("./node_modules/ajv/dist/compile/resolve.js");
class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
}
exports["default"] = MissingRefError;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/resolve.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const equal = __webpack_require__("./node_modules/fast-deep-equal/index.js");
const traverse = __webpack_require__("./node_modules/json-schema-traverse/index.js");
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
exports.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
}
exports.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
}
exports._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
exports.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
}
exports.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
        return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
            innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const _resolve = this.opts.uriResolver.resolve;
            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
exports.getSchemaRefs = getSchemaRefs;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/rules.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRules = exports.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
exports.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
exports.getRules = getRules;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/util.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/code.js");
// TODO refactor to use Set
function toHash(arr) {
    const hash = {};
    for (const item of arr)
        hash[item] = true;
    return hash;
}
exports.toHash = toHash;
function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
        return schema;
    if (Object.keys(schema).length === 0)
        return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
}
exports.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
    const { opts, self } = it;
    if (!opts.strictSchema)
        return;
    if (typeof schema === "boolean")
        return;
    const rules = self.RULES.keywords;
    for (const key in schema) {
        if (!rules[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
    }
}
exports.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (rules[key])
            return true;
    return false;
}
exports.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
            return true;
    return false;
}
exports.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
        if (typeof schema == "string")
            return (0, codegen_1._) `${schema}`;
    }
    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
}
exports.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
exports.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
exports.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
    if (typeof str == "number")
        return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
exports.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
exports.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
    if (Array.isArray(xs)) {
        for (const x of xs)
            f(x);
    }
    else {
        f(xs);
    }
}
exports.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
    return (gen, from, to, toName) => {
        const res = to === undefined
            ? from
            : to instanceof codegen_1.Name
                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                : from instanceof codegen_1.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
}
exports.mergeEvaluated = {
    props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
            if (from === true) {
                gen.assign(to, true);
            }
            else {
                gen.assign(to, (0, codegen_1._) `${to} || {}`);
                setEvaluated(gen, to, from);
            }
        }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
    }),
    items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
    }),
};
function evaluatedPropsToName(gen, ps) {
    if (ps === true)
        return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._) `{}`);
    if (ps !== undefined)
        setEvaluated(gen, props, ps);
    return props;
}
exports.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
}
exports.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
    return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
    });
}
exports.useFunc = useFunc;
var Type;
(function (Type) {
    Type[Type["Num"] = 0] = "Num";
    Type[Type["Str"] = 1] = "Str";
})(Type || (exports.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    // let path
    if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
            ? isNumber
                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
            : isNumber
                ? (0, codegen_1._) `"/" + ${dataProp}`
                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
exports.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
        return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
        throw new Error(msg);
    it.self.logger.warn(msg);
}
exports.checkStrictMode = checkStrictMode;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/applicability.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
exports.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
exports.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined ||
        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
exports.shouldUseRule = shouldUseRule;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/boolSchema.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
const errors_1 = __webpack_require__("./node_modules/ajv/dist/compile/errors.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const boolError = {
    message: "boolean schema is false",
};
function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
        falseSchemaError(it, false);
    }
    else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
    }
    else {
        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
        gen.return(true);
    }
}
exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
        gen.var(valid, false); // TODO var
        falseSchemaError(it);
    }
    else {
        gen.var(valid, true); // TODO var
    }
}
exports.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    // TODO maybe some other interface should be used for non-keyword validation errors...
    const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
}


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/dataType.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
const rules_1 = __webpack_require__("./node_modules/ajv/dist/compile/rules.js");
const applicability_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/applicability.js");
const errors_1 = __webpack_require__("./node_modules/ajv/dist/compile/errors.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
var DataType;
(function (DataType) {
    DataType[DataType["Correct"] = 0] = "Correct";
    DataType[DataType["Wrong"] = 1] = "Wrong";
})(DataType || (exports.DataType = DataType = {}));
function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
        if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
    }
    else {
        if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
            types.push("null");
    }
    return types;
}
exports.getSchemaTypes = getSchemaTypes;
// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
        return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
}
exports.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 &&
        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
    if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
            if (coerceTo.length)
                coerceData(it, types, coerceTo);
            else
                reportTypeError(it);
        });
    }
    return checkTypes;
}
exports.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types, coerceTypes) {
    return coerceTypes
        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
        : [];
}
function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
    if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
            .assign(data, (0, codegen_1._) `${data}[0]`)
            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._) `${coerced} !== undefined`);
    for (const t of coerceTo) {
        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
            coerceSpecificType(t);
        }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
        switch (t) {
            case "string":
                gen
                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
                    .elseIf((0, codegen_1._) `${data} === null`)
                    .assign(coerced, (0, codegen_1._) `""`);
                return;
            case "number":
                gen
                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
                    .assign(coerced, (0, codegen_1._) `+${data}`);
                return;
            case "integer":
                gen
                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
                    .assign(coerced, (0, codegen_1._) `+${data}`);
                return;
            case "boolean":
                gen
                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
                    .assign(coerced, false)
                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
                    .assign(coerced, true);
                return;
            case "null":
                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
                gen.assign(coerced, null);
                return;
            case "array":
                gen
                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
                    .assign(coerced, (0, codegen_1._) `[${data}]`);
        }
    }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    // TODO use gen.property
    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
        case "null":
            return (0, codegen_1._) `${data} ${EQ} null`;
        case "array":
            cond = (0, codegen_1._) `Array.isArray(${data})`;
            break;
        case "object":
            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
        case "integer":
            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
            break;
        case "number":
            cond = numCond();
            break;
        default:
            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
    }
}
exports.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
    }
    else {
        cond = codegen_1.nil;
    }
    if (types.number)
        delete types.integer;
    for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
}
exports.checkDataTypes = checkDataTypes;
const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
};
function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
}
exports.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
    };
}


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/defaults.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assignDefaults = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
        for (const key in properties) {
            assignDefault(it, key, properties[key].default);
        }
    }
    else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
}
exports.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
        return;
    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
    }
    let condition = (0, codegen_1._) `${childData} === undefined`;
    if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
    }
    // `${childData} === undefined` +
    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
}


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
const boolSchema_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/boolSchema.js");
const dataType_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/dataType.js");
const applicability_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/applicability.js");
const dataType_2 = __webpack_require__("./node_modules/ajv/dist/compile/validate/dataType.js");
const defaults_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/defaults.js");
const keyword_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/keyword.js");
const subschema_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/subschema.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const resolve_1 = __webpack_require__("./node_modules/ajv/dist/compile/resolve.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const errors_1 = __webpack_require__("./node_modules/ajv/dist/compile/errors.js");
// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
exports.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
        });
    }
    else {
        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
}
function destructureValCxt(opts) {
    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
    });
}
function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    });
    return;
}
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
}
function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
}
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
}
function schemaCxtHasRules({ schema, self }) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
}
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
}
function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
}
function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
}
function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
    }
    else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
}
function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
    }
    else {
        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
    }
}
function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
}
function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self } = it;
    const { RULES } = self;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
        return;
    }
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(() => {
        for (const group of RULES.rules)
            groupKeywords(group);
        groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
        if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                (0, dataType_2.reportTypeError)(it);
            }
            gen.endIf();
        }
        else {
            iterateKeywords(it, group);
        }
        // TODO make it "ok" call?
        if (!allErrors)
            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
    }
}
function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults }, } = it;
    if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
        for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
                keywordCode(it, rule.keyword, rule.definition, group.type);
            }
        }
    });
}
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    }
    types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
    });
    narrowSchemaTypes(it, types);
}
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
}
function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type } = rule.definition;
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
            }
        }
    }
}
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
}
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
}
function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
            ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
            ts.push("integer");
    }
    it.dataTypes = ts;
}
function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
    constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        }
        else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
    }
    result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        }
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        }
    }
    pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen.if(false); // this branch will be removed by gen.optimize
            return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen.else();
    }
    fail$data(condition) {
        if (!this.$data)
            return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
        if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
        }
        this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
        if (!this.allErrors)
            this.gen.if(cond);
    }
    setParams(obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
        });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
            return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
                gen.assign(valid, false);
        }
        gen.else();
    }
    invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1.Name))
                    throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1.nil;
        }
        function invalid$DataSchema() {
            if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
        }
    }
    subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
        subschemaCode(nextContext, valid);
        return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
    }
    mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
        }
    }
}
exports.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    }
    else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
    }
    else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
        return names_1.default.rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
    }
    else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
        if (segment) {
            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
            expr = (0, codegen_1._) `${expr} && ${data}`;
        }
    }
    return expr;
    function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
}
exports.getData = getData;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/keyword.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const errors_1 = __webpack_require__("./node_modules/ajv/dist/compile/errors.js");
function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true,
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
}
exports.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
        if (def.errors === false) {
            assignValid();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => cxt.error());
        }
        else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
        }
    }
    function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
    }
    function validateSync() {
        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !(("compile" in def && !$data) || def.schema === false);
        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
        var _a;
        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
    }
}
exports.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
        gen
            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword, result) {
    if (result === undefined)
        throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
    // TODO add tests
    return (!schemaType.length ||
        schemaType.some((st) => st === "array"
            ? Array.isArray(schema)
            : st === "object"
                ? schema && typeof schema == "object" && !Array.isArray(schema)
                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
}
exports.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
    /* istanbul ignore if */
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
                self.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
                self.logger.error(msg);
            else
                throw new Error(msg);
        }
    }
}
exports.validateKeywordUsage = validateKeywordUsage;


/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/subschema.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
        const sch = it.schema[keyword];
        return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
            : {
                schema: sch[schemaProp],
                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
            };
    }
    if (schema !== undefined) {
        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath,
        };
    }
    throw new Error('either "keyword" or "schema" must be passed');
}
exports.getSubschema = getSubschema;
function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
        dataContextProps(nextData);
        if (propertyName !== undefined)
            subschema.propertyName = propertyName;
        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
    }
    if (dataTypes)
        subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
    }
}
exports.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
        subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
        subschema.createErrors = createErrors;
    if (allErrors !== undefined)
        subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
    subschema.jtdMetadata = jtdMetadata; // not inherited
}
exports.extendSubschemaMode = extendSubschemaMode;


/***/ }),

/***/ "./node_modules/ajv/dist/core.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
var validate_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/index.js");
Object.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));
var codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));
Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));
Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));
Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));
Object.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));
const validation_error_1 = __webpack_require__("./node_modules/ajv/dist/runtime/validation_error.js");
const ref_error_1 = __webpack_require__("./node_modules/ajv/dist/compile/ref_error.js");
const rules_1 = __webpack_require__("./node_modules/ajv/dist/compile/rules.js");
const compile_1 = __webpack_require__("./node_modules/ajv/dist/compile/index.js");
const codegen_2 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const resolve_1 = __webpack_require__("./node_modules/ajv/dist/compile/resolve.js");
const dataType_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/dataType.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const $dataRefSchema = __webpack_require__("./node_modules/ajv/dist/refs/data.json");
const uri_1 = __webpack_require__("./node_modules/ajv/dist/runtime/uri.js");
const defaultRegExp = (str, flags) => new RegExp(str, flags);
defaultRegExp.code = "new RegExp";
const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error",
]);
const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now.",
};
const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
};
const MAX_EXPRESSION = 200;
// eslint-disable-next-line complexity
function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver: uriResolver,
    };
}
class Ajv {
    constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = new Set();
        this._loading = {};
        this._cache = new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
        this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
        }
        if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
        const { meta, schemaId } = this.opts;
        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
    }
    validate(schemaKeyRef, // key, ref or schema object
    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
    data // to be validated
    ) {
        let v;
        if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        }
        else {
            v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
            this.errors = v.errors;
        return valid;
    }
    compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
            }
        }
        async function _compileAsync(sch) {
            try {
                return this._compileSchemaEnv(sch);
            }
            catch (e) {
                if (!(e instanceof ref_error_1.default))
                    throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
            }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
        }
        async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
                await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
            const p = this._loading[ref];
            if (p)
                return p;
            try {
                return await (this._loading[ref] = loadSchema(ref));
            }
            finally {
                delete this._loading[ref];
            }
        }
    }
    // Adds schema to the instance
    addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    ) {
        if (Array.isArray(schema)) {
            for (const sch of schema)
                this.addSchema(sch, undefined, _meta, _validateSchema);
            return this;
        }
        let id;
        if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id = schema[schemaId];
            if (id !== undefined && typeof id != "string") {
                throw new Error(`schema ${schemaId} must be string`);
            }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, // schema key
    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    ) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
            return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== undefined && typeof $schema != "string") {
            throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
                this.logger.error(message);
            else
                throw new Error(message);
        }
        return valid;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
        if (sch === undefined) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
                return;
            this.refs[keyRef] = sch;
        }
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
        }
        switch (typeof schemaKeyRef) {
            case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
            case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object")
                    this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
            }
            case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id = schemaKeyRef[this.opts.schemaId];
                if (id) {
                    id = (0, resolve_1.normalizeId)(id);
                    delete this.schemas[id];
                    delete this.refs[id];
                }
                return this;
            }
            default:
                throw new Error("ajv.removeSchema: invalid parameter");
        }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions) {
        for (const def of definitions)
            this.addKeyword(def);
        return this;
    }
    addKeyword(kwdOrDef, def // deprecated
    ) {
        let keyword;
        if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def.keyword = keyword;
            }
        }
        else if (typeof kwdOrDef == "object" && def === undefined) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
            }
        }
        else {
            throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
            return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
            ...def,
            type: (0, dataType_1.getJSONTypes)(def.type),
            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0
            ? (k) => addRule.call(this, k, definition)
            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
    }
    getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword) {
        // TODO return type should be Ajv
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i >= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, format) {
        if (typeof format == "string")
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors = this.errors, // optional array of validation errors
    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
    ) {
        if (!errors || errors.length === 0)
            return "No errors";
        return errors
            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
            let keywords = metaSchema;
            for (const seg of segments)
                keywords = keywords[seg];
            for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != "object")
                    continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                    delete schemas[keyRef];
                }
                else if (sch && !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
            id = schema[schemaId];
        }
        else {
            if (this.opts.jtd)
                throw new Error("schema must be object");
            else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId)
                this._checkUnique(baseId);
            this.refs[baseId] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
        }
    }
    _compileSchemaEnv(sch) {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile_1.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new Error("ajv implementation error");
        return sch.validate;
    }
    _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
            compile_1.compileSchema.call(this, sch);
        }
        finally {
            this.opts = currentOpts;
        }
    }
}
Ajv.ValidationError = validation_error_1.default;
Ajv.MissingRefError = ref_error_1.default;
exports["default"] = Ajv;
function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
}
function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
    return this.schemas[keyRef] || this.refs[keyRef];
}
function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
        return;
    if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
    else
        for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
}
function addInitialFormats() {
    for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
            this.addFormat(name, format);
    }
}
function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
            def.keyword = keyword;
        this.addKeyword(def);
    }
}
function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
    return metaOpts;
}
const noLogs = { log() { }, warn() { }, error() { } };
function getLogger(logger) {
    if (logger === false)
        return noLogs;
    if (logger === undefined)
        return console;
    if (logger.log && logger.warn && logger.error)
        return logger;
    throw new Error("logger must implement log, warn and error methods");
}
const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
        return;
    if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
    }
}
function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
        return;
    const rule = {
        keyword,
        definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
        },
    };
    if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
        ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
}
function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
    }
    else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
    }
}
function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
        return;
    if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
}
const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
};
function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
}


/***/ }),

/***/ "./node_modules/ajv/dist/runtime/equal.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://github.com/ajv-validator/ajv/issues/889
const equal = __webpack_require__("./node_modules/fast-deep-equal/index.js");
equal.code = 'require("ajv/dist/runtime/equal").default';
exports["default"] = equal;


/***/ }),

/***/ "./node_modules/ajv/dist/runtime/ucs2length.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
exports["default"] = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';


/***/ }),

/***/ "./node_modules/ajv/dist/runtime/uri.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const uri = __webpack_require__("./node_modules/fast-uri/index.js");
uri.code = 'require("ajv/dist/runtime/uri").default';
exports["default"] = uri;


/***/ }),

/***/ "./node_modules/ajv/dist/runtime/validation_error.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ValidationError extends Error {
    constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
    }
}
exports["default"] = ValidationError;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateAdditionalItems = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
};
const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        validateAdditionalItems(cxt, items);
    },
};
function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
    if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
    }
    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
    }
    function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
    }
}
exports.validateAdditionalItems = validateAdditionalItems;
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
};
const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
            return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1.nil;
            }
            if (patProps.length) {
                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
            }
            return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if((0, codegen_1.not)(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/allOf.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/anyOf.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/contains.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: ({ params: { min, max } }) => max === undefined
        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
};
const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._) `${len} >= ${min}`;
            if (max !== undefined)
                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else if (min === 0) {
            gen.let(valid, true);
            if (max !== undefined)
                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
        }
        else {
            gen.let(valid, false);
            validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code((0, codegen_1._) `${count}++`);
            if (max === undefined) {
                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/dependencies.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
};
const def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
    },
};
function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
        if (key === "__proto__")
            continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
}
function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
        return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
            continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", "),
        });
        if (it.allErrors) {
            gen.if(hasProperty, () => {
                for (const depProp of deps) {
                    (0, code_1.checkReportMissingProp)(cxt, depProp);
                }
            });
        }
        else {
            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
        }
    }
}
exports.validatePropertyDeps = validatePropertyDeps;
function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
            continue;
        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
        }, () => gen.var(valid, true) // TODO var
        );
        cxt.ok(valid);
    }
}
exports.validateSchemaDeps = validateSchemaDeps;
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/if.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
};
const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
}
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const additionalItems_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js");
const prefixItems_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js");
const items_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/items.js");
const items2020_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/items2020.js");
const contains_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/contains.js");
const dependencies_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/dependencies.js");
const propertyNames_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js");
const additionalProperties_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js");
const properties_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/properties.js");
const patternProperties_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js");
const not_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/not.js");
const anyOf_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/anyOf.js");
const oneOf_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/oneOf.js");
const allOf_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/allOf.js");
const if_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/if.js");
const thenElse_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/thenElse.js");
function getApplicator(draft2020 = false) {
    const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
    ];
    // array
    if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
    else
        applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
}
exports["default"] = getApplicator;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/items.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTuple = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
        cxt.ok((0, code_1.validateArray)(cxt));
    },
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
    schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
            keyword,
            schemaProp: i,
            dataProp: i,
        }, valid));
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
    }
}
exports.validateTuple = validateTuple;
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/items2020.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const additionalItems_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js");
const error = {
    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
};
const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
        if (prefixItems)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
            cxt.ok((0, code_1.validateArray)(cxt));
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/not.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/oneOf.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
};
const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
            return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1.alwaysValidSchema)(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if((0, codegen_1._) `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
                });
            });
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const util_2 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
                (!it.opts.unevaluated || it.props === true))) {
            return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                    const alwaysValid = alwaysValidPatterns.includes(pat);
                    if (!alwaysValid) {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                    }
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
                    }
                    else if (!alwaysValid && !it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if((0, codegen_1.not)(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const items_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/items.js");
const def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/properties.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/index.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const additionalProperties_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js");
const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
};
const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if((0, codegen_1.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/thenElse.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/code.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const util_2 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
        cxt.error();
    });
}
exports.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
}
exports.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
}
exports.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
    return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
    });
}
exports.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
}
exports.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
exports.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
}
exports.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
exports.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
}
exports.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
}
exports.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1._) `new RegExp`;
function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
    });
}
exports.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: util_1.Type.Num,
            }, valid);
            gen.if((0, codegen_1.not)(valid), notValid);
        });
    }
}
exports.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        }, schValid);
        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
exports.validateUnion = validateUnion;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/core/id.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const def = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/core/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const id_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/core/id.js");
const ref_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/core/ref.js");
const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default,
];
exports["default"] = core;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/core/ref.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callRef = exports.getValidate = void 0;
const ref_error_1 = __webpack_require__("./node_modules/ajv/dist/compile/ref_error.js");
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__("./node_modules/ajv/dist/compile/names.js");
const compile_1 = __webpack_require__("./node_modules/ajv/dist/compile/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
exports.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = (0, codegen_1._) `${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
            }
        }
    }
}
exports.callRef = callRef;
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/discriminator/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const types_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/discriminator/types.js");
const compile_1 = __webpack_require__("./node_modules/ajv/dist/compile/index.js");
const ref_error_1 = __webpack_require__("./node_modules/ajv/dist/compile/ref_error.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                    const ref = sch.$ref;
                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
                    if (sch instanceof compile_1.SchemaEnv)
                        sch = sch.schema;
                    if (sch === undefined)
                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
                }
                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
            }
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/discriminator/types.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiscrError = void 0;
var DiscrError;
(function (DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
})(DiscrError || (exports.DiscrError = DiscrError = {}));


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/draft7.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const core_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/core/index.js");
const validation_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/index.js");
const applicator_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/applicator/index.js");
const format_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/format/index.js");
const metadata_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/metadata.js");
const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
];
exports["default"] = draft7Vocabularies;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/format/format.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
};
const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1.nil;
                return (0, codegen_1._) `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : (0, codegen_1._) `${format}(${data})`;
                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
            }
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/format/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const format_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/format/format.js");
const format = [format_1.default];
exports["default"] = format;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/metadata.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.contentVocabulary = exports.metadataVocabulary = void 0;
exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/const.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const equal_1 = __webpack_require__("./node_modules/ajv/dist/runtime/equal.js");
const error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
};
const def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        }
        else {
            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/enum.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const equal_1 = __webpack_require__("./node_modules/ajv/dist/runtime/equal.js");
const error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
};
const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null
                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1._) `${data} === ${sch}`;
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const limitNumber_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/limitNumber.js");
const multipleOf_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/multipleOf.js");
const limitLength_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/limitLength.js");
const pattern_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/pattern.js");
const limitProperties_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/limitProperties.js");
const required_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/required.js");
const limitItems_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/limitItems.js");
const uniqueItems_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js");
const const_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/const.js");
const enum_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/validation/enum.js");
const validation = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default,
];
exports["default"] = validation;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitItems.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitLength.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const ucs2length_1 = __webpack_require__("./node_modules/ajv/dist/runtime/ucs2length.js");
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitNumber.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const ops = codegen_1.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitProperties.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/multipleOf.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
};
const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1._) `${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/pattern.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
};
const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        // TODO regexp should be wrapped in try/catchs
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/required.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__("./node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
};
const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    (0, code_1.checkReportMissingProp)(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
                (0, code_1.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
                gen.if((0, codegen_1.not)(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1.nil);
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const dataType_1 = __webpack_require__("./node_modules/ajv/dist/compile/validate/dataType.js");
const codegen_1 = __webpack_require__("./node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__("./node_modules/ajv/dist/compile/util.js");
const equal_1 = __webpack_require__("./node_modules/ajv/dist/runtime/equal.js");
const error = {
    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
};
const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1._) `{}`);
            gen.for((0, codegen_1._) `;${i}--;`, () => {
                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
                gen
                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
exports["default"] = def;


/***/ }),

/***/ "./node_modules/commander/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { Argument } = __webpack_require__("./node_modules/commander/lib/argument.js");
const { Command } = __webpack_require__("./node_modules/commander/lib/command.js");
const { CommanderError, InvalidArgumentError } = __webpack_require__("./node_modules/commander/lib/error.js");
const { Help } = __webpack_require__("./node_modules/commander/lib/help.js");
const { Option } = __webpack_require__("./node_modules/commander/lib/option.js");

exports.DM = new Command();

exports.gu = (name) => new Command(name);
exports.Ww = (flags, description) => new Option(flags, description);
exports.er = (name, description) => new Argument(name, description);

/**
 * Expose classes
 */

exports.uB = Command;
exports.c$ = Option;
exports.ef = Argument;
exports._V = Help;

exports.b7 = CommanderError;
exports.Di = InvalidArgumentError;
exports.a2 = InvalidArgumentError; // Deprecated


/***/ }),

/***/ "./node_modules/commander/lib/argument.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { InvalidArgumentError } = __webpack_require__("./node_modules/commander/lib/error.js");

class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string} name
   * @param {string} [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    }

    if (this._name.length > 3 && this._name.slice(-3) === '...') {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    }
  }

  /**
   * Return argument name.
   *
   * @return {string}
   */

  name() {
    return this._name;
  }

  /**
   * @package
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Argument}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function} [fn]
   * @return {Argument}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Only allow argument value to be one of choices.
   *
   * @param {string[]} values
   * @return {Argument}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Make argument required.
   *
   * @returns {Argument}
   */
  argRequired() {
    this.required = true;
    return this;
  }

  /**
   * Make argument optional.
   *
   * @returns {Argument}
   */
  argOptional() {
    this.required = false;
    return this;
  }
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument} arg
 * @return {string}
 * @private
 */

function humanReadableArgName(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}

exports.Argument = Argument;
exports.humanReadableArgName = humanReadableArgName;


/***/ }),

/***/ "./node_modules/commander/lib/command.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const EventEmitter = (__webpack_require__("node:events").EventEmitter);
const childProcess = __webpack_require__("node:child_process");
const path = __webpack_require__("node:path");
const fs = __webpack_require__("node:fs");
const process = __webpack_require__("node:process");

const { Argument, humanReadableArgName } = __webpack_require__("./node_modules/commander/lib/argument.js");
const { CommanderError } = __webpack_require__("./node_modules/commander/lib/error.js");
const { Help } = __webpack_require__("./node_modules/commander/lib/help.js");
const { Option, DualOptions } = __webpack_require__("./node_modules/commander/lib/option.js");
const { suggestSimilar } = __webpack_require__("./node_modules/commander/lib/suggestSimilar.js");

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this.registeredArguments = [];
    this._args = this.registeredArguments; // deprecated old name
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {(boolean | string)} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      getOutHelpWidth: () =>
        process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () =>
        process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str),
    };

    this._hidden = false;
    /** @type {(Option | null | undefined)} */
    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
    /** @type {Command} */
    this._helpCommand = undefined; // lazy initialised, inherited
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._helpOption = sourceCommand._helpOption;
    this._helpCommand = sourceCommand._helpCommand;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue =
      sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * @returns {Command[]}
   * @private
   */

  _getCommandAndAncestors() {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    for (let command = this; command; command = command.parent) {
      result.push(command);
    }
    return result;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this._registerCommand(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  }

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help(), this.configureHelp());
  }

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {(boolean|string)} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) {
      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
    }

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this._registerCommand(cmd);
    cmd.parent = this;
    cmd._checkForBrokenPassThrough();

    return this;
  }

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument(name, description);
  }

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {(Function|*)} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names
      .trim()
      .split(/ +/)
      .forEach((detail) => {
        this.argument(detail);
      });
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this.registeredArguments.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(
        `only the last argument can be variadic '${previousArgument.name()}'`,
      );
    }
    if (
      argument.required &&
      argument.defaultValue !== undefined &&
      argument.parseArg === undefined
    ) {
      throw new Error(
        `a default value for a required argument is never used: '${argument.name()}'`,
      );
    }
    this.registeredArguments.push(argument);
    return this;
  }

  /**
   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
   *
   * @example
   *    program.helpCommand('help [cmd]');
   *    program.helpCommand('help [cmd]', 'show help');
   *    program.helpCommand(false); // suppress default help command
   *    program.helpCommand(true); // add help command even if no subcommands
   *
   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
   * @param {string} [description] - custom description
   * @return {Command} `this` command for chaining
   */

  helpCommand(enableOrNameAndArgs, description) {
    if (typeof enableOrNameAndArgs === 'boolean') {
      this._addImplicitHelpCommand = enableOrNameAndArgs;
      return this;
    }

    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
    const helpDescription = description ?? 'display help for command';

    const helpCommand = this.createCommand(helpName);
    helpCommand.helpOption(false);
    if (helpArgs) helpCommand.arguments(helpArgs);
    if (helpDescription) helpCommand.description(helpDescription);

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;

    return this;
  }

  /**
   * Add prepared custom help command.
   *
   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
   * @return {Command} `this` command for chaining
   */
  addHelpCommand(helpCommand, deprecatedDescription) {
    // If not passed an object, call through to helpCommand for backwards compatibility,
    // as addHelpCommand was originally used like helpCommand is now.
    if (typeof helpCommand !== 'object') {
      this.helpCommand(helpCommand, deprecatedDescription);
      return this;
    }

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;
    return this;
  }

  /**
   * Lazy create help command.
   *
   * @return {(Command|null)}
   * @package
   */
  _getHelpCommand() {
    const hasImplicitHelpCommand =
      this._addImplicitHelpCommand ??
      (this.commands.length &&
        !this._actionHandler &&
        !this._findCommand('help'));

    if (hasImplicitHelpCommand) {
      if (this._helpCommand === undefined) {
        this.helpCommand(undefined, undefined); // use default name and description
      }
      return this._helpCommand;
    }
    return null;
  }

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        } else {
          // Async callback from spawn events, not useful to throw.
        }
      };
    }
    return this;
  }

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process.exit(exitCode);
  }

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this.registeredArguments.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  }

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  }

  /**
   * Wrap parseArgs to catch 'commander.invalidArgument'.
   *
   * @param {(Option | Argument)} target
   * @param {string} value
   * @param {*} previous
   * @param {string} invalidArgumentMessage
   * @private
   */

  _callParseArg(target, value, previous, invalidArgumentMessage) {
    try {
      return target.parseArg(value, previous);
    } catch (err) {
      if (err.code === 'commander.invalidArgument') {
        const message = `${invalidArgumentMessage} ${err.message}`;
        this.error(message, { exitCode: err.exitCode, code: err.code });
      }
      throw err;
    }
  }

  /**
   * Check for option flag conflicts.
   * Register option if no conflicts found, or throw on conflict.
   *
   * @param {Option} option
   * @private
   */

  _registerOption(option) {
    const matchingOption =
      (option.short && this._findOption(option.short)) ||
      (option.long && this._findOption(option.long));
    if (matchingOption) {
      const matchingFlag =
        option.long && this._findOption(option.long)
          ? option.long
          : option.short;
      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
    }

    this.options.push(option);
  }

  /**
   * Check for command name and alias conflicts with existing commands.
   * Register command if no conflicts found, or throw on conflict.
   *
   * @param {Command} command
   * @private
   */

  _registerCommand(command) {
    const knownBy = (cmd) => {
      return [cmd.name()].concat(cmd.aliases());
    };

    const alreadyUsed = knownBy(command).find((name) =>
      this._findCommand(name),
    );
    if (alreadyUsed) {
      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
      const newCmd = knownBy(command).join('|');
      throw new Error(
        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,
      );
    }

    this.commands.push(command);
  }

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    this._registerOption(option);

    const oname = option.name();
    const name = option.attributeName();

    // store default value
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(
          name,
          option.defaultValue === undefined ? true : option.defaultValue,
          'default',
        );
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // val is null for optional option used without an optional-argument.
      // val is undefined for boolean and negated option.
      if (val == null && option.presetArg !== undefined) {
        val = option.presetArg;
      }

      // custom processing
      const oldValue = this.getOptionValue(name);
      if (val !== null && option.parseArg) {
        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
      } else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      }

      // Fill-in appropriate missing values. Long winded but easy to follow.
      if (val == null) {
        if (option.negate) {
          val = false;
        } else if (option.isBoolean() || option.optional) {
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }
      this.setOptionValueWithSource(name, val, valueSource);
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @return {Command} `this` command for chaining
   * @private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option) {
      throw new Error(
        'To add an Option object use addOption() instead of option() or requiredOption()',
      );
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
   *
   * See the README for more details, and see also addOption() and requiredOption().
   *
   * @example
   * program
   *     .option('-p, --pepper', 'add pepper')
   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, parseArg, defaultValue) {
    return this._optionEx({}, flags, description, parseArg, defaultValue);
  }

  /**
   * Add a required option which must have a value after parsing. This usually means
   * the option must be specified on the command line. (Otherwise the same as .option().)
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  requiredOption(flags, description, parseArg, defaultValue) {
    return this._optionEx(
      { mandatory: true },
      flags,
      description,
      parseArg,
      defaultValue,
    );
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
   * @return {Command} `this` command for chaining
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  }

  /**
   * Allow unknown options on the command line.
   *
   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
   * @return {Command} `this` command for chaining
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  }

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
   * @return {Command} `this` command for chaining
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  }

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {boolean} [positional]
   * @return {Command} `this` command for chaining
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  }

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {boolean} [passThrough] for unknown options.
   * @return {Command} `this` command for chaining
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    this._checkForBrokenPassThrough();
    return this;
  }

  /**
   * @private
   */

  _checkForBrokenPassThrough() {
    if (
      this.parent &&
      this._passThroughOptions &&
      !this.parent._enablePositionalOptions
    ) {
      throw new Error(
        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
      );
    }
  }

  /**
   * Whether to store option values as properties on command object,
   * or store separately (specify false). In both cases the option values can be accessed using .opts().
   *
   * @param {boolean} [storeAsProperties=true]
   * @return {Command} `this` command for chaining
   */

  storeOptionsAsProperties(storeAsProperties = true) {
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    if (Object.keys(this._optionValues).length) {
      throw new Error(
        'call .storeOptionsAsProperties() before setting option values',
      );
    }
    this._storeOptionsAsProperties = !!storeAsProperties;
    return this;
  }

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  }

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    return this.setOptionValueWithSource(key, value, undefined);
  }

  /**
   * Store option value and where the value came from.
   *
   * @param {string} key
   * @param {object} value
   * @param {string} source - expected values are default/config/env/cli/implied
   * @return {Command} `this` command for chaining
   */

  setOptionValueWithSource(key, value, source) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    this._optionValueSources[key] = source;
    return this;
  }

  /**
   * Get source of option value.
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  }

  /**
   * Get source of option value. See also .optsWithGlobals().
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSourceWithGlobals(key) {
    // global overwrites local, like optsWithGlobals
    let source;
    this._getCommandAndAncestors().forEach((cmd) => {
      if (cmd.getOptionValueSource(key) !== undefined) {
        source = cmd.getOptionValueSource(key);
      }
    });
    return source;
  }

  /**
   * Get user arguments from implied or explicit arguments.
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
   *
   * @private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // auto-detect argument conventions if nothing supplied
    if (argv === undefined && parseOptions.from === undefined) {
      if (process.versions?.electron) {
        parseOptions.from = 'electron';
      }
      // check node specific options for scenarios where user CLI args follow executable without scriptname
      const execArgv = process.execArgv ?? [];
      if (
        execArgv.includes('-e') ||
        execArgv.includes('--eval') ||
        execArgv.includes('-p') ||
        execArgv.includes('--print')
      ) {
        parseOptions.from = 'eval'; // internal usage, not documented
      }
    }

    // default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
    }
    this.rawArgs = argv.slice();

    // extract the user args and scriptPath
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: because defaultApp is an unknown property
        if (process.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      case 'eval':
        userArgs = argv.slice(1);
        break;
      default:
        throw new Error(
          `unexpected parse option { from: '${parseOptions.from}' }`,
        );
    }

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath)
      this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * program.parse(); // parse process.argv and auto-detect electron and special node flags
   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Execute a sub-command executable.
   *
   * @private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    function findFile(baseDir, baseName) {
      // Look for specified file
      const localBin = path.resolve(baseDir, baseName);
      if (fs.existsSync(localBin)) return localBin;

      // Stop looking if candidate already has an expected extension.
      if (sourceExt.includes(path.extname(baseName))) return undefined;

      // Try all the extensions.
      const foundExt = sourceExt.find((ext) =>
        fs.existsSync(`${localBin}${ext}`),
      );
      if (foundExt) return `${localBin}${foundExt}`;

      return undefined;
    }

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // executableFile and executableDir might be full path, or just a name
    let executableFile =
      subcommand._executableFile || `${this._name}-${subcommand._name}`;
    let executableDir = this._executableDir || '';
    if (this._scriptPath) {
      let resolvedScriptPath; // resolve possible symlink for installed npm binary
      try {
        resolvedScriptPath = fs.realpathSync(this._scriptPath);
      } catch (err) {
        resolvedScriptPath = this._scriptPath;
      }
      executableDir = path.resolve(
        path.dirname(resolvedScriptPath),
        executableDir,
      );
    }

    // Look for a local file in preference to a command in PATH.
    if (executableDir) {
      let localFile = findFile(executableDir, executableFile);

      // Legacy search using prefix of script name instead of command name
      if (!localFile && !subcommand._executableFile && this._scriptPath) {
        const legacyName = path.basename(
          this._scriptPath,
          path.extname(this._scriptPath),
        );
        if (legacyName !== this._name) {
          localFile = findFile(
            executableDir,
            `${legacyName}-${subcommand._name}`,
          );
        }
      }
      executableFile = localFile || executableFile;
    }

    launchWithNode = sourceExt.includes(path.extname(executableFile));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
    }

    if (!proc.killed) {
      // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach((signal) => {
        process.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            // @ts-ignore because signals not typed to known strings
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    const exitCallback = this._exitCallback;
    proc.on('close', (code) => {
      code = code ?? 1; // code is null if spawned process terminated due to a signal
      if (!exitCallback) {
        process.exit(code);
      } else {
        exitCallback(
          new CommanderError(
            code,
            'commander.executeSubCommandAsync',
            '(close)',
          ),
        );
      }
    });
    proc.on('error', (err) => {
      // @ts-ignore: because err.code is an unknown property
      if (err.code === 'ENOENT') {
        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
        // @ts-ignore: because err.code is an unknown property
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(
          1,
          'commander.executeSubCommandAsync',
          '(error)',
        );
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    let promiseChain;
    promiseChain = this._chainOrCallSubCommandHook(
      promiseChain,
      subCommand,
      'preSubcommand',
    );
    promiseChain = this._chainOrCall(promiseChain, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return promiseChain;
  }

  /**
   * Invoke help directly if possible, or dispatch if necessary.
   * e.g. help foo
   *
   * @private
   */

  _dispatchHelpCommand(subcommandName) {
    if (!subcommandName) {
      this.help();
    }
    const subCommand = this._findCommand(subcommandName);
    if (subCommand && !subCommand._executableHandler) {
      subCommand.help();
    }

    // Fallback to parsing the help flag to invoke the help.
    return this._dispatchSubcommand(
      subcommandName,
      [],
      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
    );
  }

  /**
   * Check this.args against expected this.registeredArguments.
   *
   * @private
   */

  _checkNumberOfArguments() {
    // too few
    this.registeredArguments.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (
      this.registeredArguments.length > 0 &&
      this.registeredArguments[this.registeredArguments.length - 1].variadic
    ) {
      return;
    }
    if (this.args.length > this.registeredArguments.length) {
      this._excessArguments(this.args);
    }
  }

  /**
   * Process this.args using this.registeredArguments and save as this.processedArgs!
   *
   * @private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
        parsedValue = this._callParseArg(
          argument,
          value,
          previous,
          invalidValueMessage,
        );
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this.registeredArguments.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {(Promise|undefined)} promise
   * @param {Function} fn
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    this._getCommandAndAncestors()
      .reverse()
      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)
      .forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {Command} subCommand
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallSubCommandHook(promise, subCommand, event) {
    let result = promise;
    if (this._lifeCycleHooks[event] !== undefined) {
      this._lifeCycleHooks[event].forEach((hook) => {
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    this._parseOptionsImplied();
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (
      this._getHelpCommand() &&
      operands[0] === this._getHelpCommand().name()
    ) {
      return this._dispatchHelpCommand(operands[1]);
    }
    if (this._defaultCommandName) {
      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(
        this._defaultCommandName,
        operands,
        unknown,
      );
    }
    if (
      this.commands.length &&
      this.args.length === 0 &&
      !this._actionHandler &&
      !this._defaultCommandName
    ) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    this._outputHelpIfRequested(parsed.unknown);
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let promiseChain;
      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
      promiseChain = this._chainOrCall(promiseChain, () =>
        this._actionHandler(this.processedArgs),
      );
      if (this.parent) {
        promiseChain = this._chainOrCall(promiseChain, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }
      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
      return promiseChain;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) {
        // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @private
   * @return {Command | undefined}
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(
      (cmd) => cmd._name === name || cmd._aliases.includes(name),
    );
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @package
   */

  _findOption(arg) {
    return this.options.find((option) => option.is(arg));
  }

  /**
   * Display an error message if a mandatory option does not have a value.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd.options.forEach((anOption) => {
        if (
          anOption.mandatory &&
          cmd.getOptionValue(anOption.attributeName()) === undefined
        ) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    });
  }

  /**
   * Display an error message if conflicting options are used together in this.
   *
   * @private
   */
  _checkForConflictingLocalOptions() {
    const definedNonDefaultOptions = this.options.filter((option) => {
      const optionKey = option.attributeName();
      if (this.getOptionValue(optionKey) === undefined) {
        return false;
      }
      return this.getOptionValueSource(optionKey) !== 'default';
    });

    const optionsWithConflicting = definedNonDefaultOptions.filter(
      (option) => option.conflictsWith.length > 0,
    );

    optionsWithConflicting.forEach((option) => {
      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
        option.conflictsWith.includes(defined.attributeName()),
      );
      if (conflictingAndDefined) {
        this._conflictingOption(option, conflictingAndDefined);
      }
    });
  }

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd._checkForConflictingLocalOptions();
    });
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {string[]} argv
   * @return {{operands: string[], unknown: string[]}}
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else {
            // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (
            option.required ||
            (option.optional && this._combineFlagAndOptionalValue)
          ) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if (
        (this._enablePositionalOptions || this._passThroughOptions) &&
        operands.length === 0 &&
        unknown.length === 0
      ) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (
          this._getHelpCommand() &&
          arg === this._getHelpCommand().name()
        ) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] =
          key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  }

  /**
   * Return an object containing merged local and global option values as key-value pairs.
   *
   * @return {object}
   */
  optsWithGlobals() {
    // globals overwrite locals
    return this._getCommandAndAncestors().reduce(
      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
      {},
    );
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
   * @param {object} [errorOptions]
   * @param {string} [errorOptions.code] - an id string representing the error
   * @param {number} [errorOptions.exitCode] - used with process.exit
   */
  error(message, errorOptions) {
    // output handling
    this._outputConfiguration.outputError(
      `${message}\n`,
      this._outputConfiguration.writeErr,
    );
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }

    // exit handling
    const config = errorOptions || {};
    const exitCode = config.exitCode || 1;
    const code = config.code || 'commander.error';
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (
          this.getOptionValue(optionKey) === undefined ||
          ['default', 'config', 'env'].includes(
            this.getOptionValueSource(optionKey),
          )
        ) {
          if (option.required || option.optional) {
            // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else {
            // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * @private
   */
  _parseOptionsImplied() {
    const dualHelper = new DualOptions(this.options);
    const hasCustomOptionValue = (optionKey) => {
      return (
        this.getOptionValue(optionKey) !== undefined &&
        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
      );
    };
    this.options
      .filter(
        (option) =>
          option.implied !== undefined &&
          hasCustomOptionValue(option.attributeName()) &&
          dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option,
          ),
      )
      .forEach((option) => {
        Object.keys(option.implied)
          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
          .forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              'implied',
            );
          });
      });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, { code: 'commander.missingArgument' });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    this.error(message, { code: 'commander.optionMissingArgument' });
  }

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    this.error(message, { code: 'commander.missingMandatoryOptionValue' });
  }

  /**
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
   * @private
   */
  _conflictingOption(option, conflictingOption) {
    // The calling code does not know whether a negated option is the source of the
    // value, so do some work to take an educated guess.
    const findBestOptionFromValue = (option) => {
      const optionKey = option.attributeName();
      const optionValue = this.getOptionValue(optionKey);
      const negativeOption = this.options.find(
        (target) => target.negate && optionKey === target.attributeName(),
      );
      const positiveOption = this.options.find(
        (target) => !target.negate && optionKey === target.attributeName(),
      );
      if (
        negativeOption &&
        ((negativeOption.presetArg === undefined && optionValue === false) ||
          (negativeOption.presetArg !== undefined &&
            optionValue === negativeOption.presetArg))
      ) {
        return negativeOption;
      }
      return positiveOption || option;
    };

    const getErrorMessage = (option) => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };

    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, { code: 'commander.conflictingOption' });
  }

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      let command = this;
      do {
        const moreFlags = command
          .createHelp()
          .visibleOptions(command)
          .filter((option) => option.long)
          .map((option) => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, { code: 'commander.unknownOption' });
  }

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this.registeredArguments.length;
    const s = expected === 1 ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, { code: 'commander.excessArguments' });
  }

  /**
   * Unknown command.
   *
   * @private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp()
        .visibleCommands(this)
        .forEach((command) => {
          candidateNames.push(command.name());
          // just visible alias
          if (command.alias()) candidateNames.push(command.alias());
        });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, { code: 'commander.unknownCommand' });
  }

  /**
   * Get or set the program version.
   *
   * This method auto-registers the "-V, --version" option which will print the version number.
   *
   * You can optionally supply the flags and description to override the defaults.
   *
   * @param {string} [str]
   * @param {string} [flags]
   * @param {string} [description]
   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this._registerOption(versionOption);

    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set the description.
   *
   * @param {string} [str]
   * @param {object} [argsDescription]
   * @return {(string|Command)}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined)
      return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set the summary. Used when listed as subcommand of parent.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {(string|Command)}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let command = this;
    if (
      this.commands.length !== 0 &&
      this.commands[this.commands.length - 1]._executableHandler
    ) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name)
      throw new Error("Command alias can't be the same as its name");
    const matchingCommand = this.parent?._findCommand(alias);
    if (matchingCommand) {
      // c.f. _registerCommand
      const existingCmd = [matchingCommand.name()]
        .concat(matchingCommand.aliases())
        .join('|');
      throw new Error(
        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
      );
    }

    command._aliases.push(alias);
    return this;
  }

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {(string[]|Command)}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  }

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this.registeredArguments.map((arg) => {
        return humanReadableArgName(arg);
      });
      return []
        .concat(
          this.options.length || this._helpOption !== null ? '[options]' : [],
          this.commands.length ? '[command]' : [],
          this.registeredArguments.length ? args : [],
        )
        .join(' ');
    }

    this._usage = str;
    return this;
  }

  /**
   * Get or set the name of the command.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }

  /**
   * Set the name of the command from script filename, such as process.argv[1],
   * or require.main.filename, or __filename.
   *
   * (Used internally and public although not documented in README.)
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   *
   * @param {string} filename
   * @return {Command}
   */

  nameFromFilename(filename) {
    this._name = path.basename(filename, path.extname(filename));

    return this;
  }

  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   *
   * @param {string} [path]
   * @return {(string|null|Command)}
   */

  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth =
        contextOptions && contextOptions.error
          ? this._outputConfiguration.getErrHelpWidth()
          : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  }

  /**
   * @private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    this._getCommandAndAncestors()
      .reverse()
      .forEach((command) => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (
        typeof helpInformation !== 'string' &&
        !Buffer.isBuffer(helpInformation)
      ) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    if (this._getHelpOption()?.long) {
      this.emit(this._getHelpOption().long); // deprecated
    }
    this.emit('afterHelp', context);
    this._getCommandAndAncestors().forEach((command) =>
      command.emit('afterAllHelp', context),
    );
  }

  /**
   * You can pass in flags and a description to customise the built-in help option.
   * Pass in false to disable the built-in help option.
   *
   * @example
   * program.helpOption('-?, --help' 'show help'); // customise
   * program.helpOption(false); // disable
   *
   * @param {(string | boolean)} flags
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    // Support disabling built-in help option.
    if (typeof flags === 'boolean') {
      if (flags) {
        this._helpOption = this._helpOption ?? undefined; // preserve existing option
      } else {
        this._helpOption = null; // disable
      }
      return this;
    }

    // Customise flags and description.
    flags = flags ?? '-h, --help';
    description = description ?? 'display help for command';
    this._helpOption = this.createOption(flags, description);

    return this;
  }

  /**
   * Lazy create help option.
   * Returns null if has been disabled with .helpOption(false).
   *
   * @returns {(Option | null)} the help option
   * @package
   */
  _getHelpOption() {
    // Lazy create help option on demand.
    if (this._helpOption === undefined) {
      this.helpOption(undefined, undefined);
    }
    return this._helpOption;
  }

  /**
   * Supply your own option to use for the built-in help option.
   * This is an alternative to using helpOption() to customise the flags and description etc.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addHelpOption(option) {
    this._helpOption = option;
    return this;
  }

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (
      exitCode === 0 &&
      contextOptions &&
      typeof contextOptions !== 'function' &&
      contextOptions.error
    ) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {(string | Function)} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }

  /**
   * Output help information if help flags specified
   *
   * @param {Array} args - array of options to search for help flags
   * @private
   */

  _outputHelpIfRequested(args) {
    const helpOption = this._getHelpOption();
    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
    if (helpRequested) {
      this.outputHelp();
      // (Do not have all displayed text available so only passing placeholder.)
      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
    }
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null
    ) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null
    ) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

exports.Command = Command;


/***/ }),

/***/ "./node_modules/commander/lib/error.js":
/***/ ((__unused_webpack_module, exports) => {

/**
 * CommanderError class
 */
class CommanderError extends Error {
  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   */
  constructor(exitCode, code, message) {
    super(message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.code = code;
    this.exitCode = exitCode;
    this.nestedError = undefined;
  }
}

/**
 * InvalidArgumentError class
 */
class InvalidArgumentError extends CommanderError {
  /**
   * Constructs the InvalidArgumentError class
   * @param {string} [message] explanation of why argument is invalid
   */
  constructor(message) {
    super(1, 'commander.invalidArgument', message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
}

exports.CommanderError = CommanderError;
exports.InvalidArgumentError = InvalidArgumentError;


/***/ }),

/***/ "./node_modules/commander/lib/help.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { humanReadableArgName } = __webpack_require__("./node_modules/commander/lib/argument.js");

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// Although this is a class, methods are static in style to allow override using subclass or just functions.
class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
    this.showGlobalOptions = false;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);
    const helpCommand = cmd._getHelpCommand();
    if (helpCommand && !helpCommand._hidden) {
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: because overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Compare options for sort.
   *
   * @param {Option} a
   * @param {Option} b
   * @returns {number}
   */
  compareOptions(a, b) {
    const getSortKey = (option) => {
      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
      return option.short
        ? option.short.replace(/^-/, '')
        : option.long.replace(/^--/, '');
    };
    return getSortKey(a).localeCompare(getSortKey(b));
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Built-in help option.
    const helpOption = cmd._getHelpOption();
    if (helpOption && !helpOption.hidden) {
      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
      if (!removeShort && !removeLong) {
        visibleOptions.push(helpOption); // no changes needed
      } else if (helpOption.long && !removeLong) {
        visibleOptions.push(
          cmd.createOption(helpOption.long, helpOption.description),
        );
      } else if (helpOption.short && !removeShort) {
        visibleOptions.push(
          cmd.createOption(helpOption.short, helpOption.description),
        );
      }
    }
    if (this.sortOptions) {
      visibleOptions.sort(this.compareOptions);
    }
    return visibleOptions;
  }

  /**
   * Get an array of the visible global options. (Not including help.)
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleGlobalOptions(cmd) {
    if (!this.showGlobalOptions) return [];

    const globalOptions = [];
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      const visibleOptions = ancestorCmd.options.filter(
        (option) => !option.hidden,
      );
      globalOptions.push(...visibleOptions);
    }
    if (this.sortOptions) {
      globalOptions.sort(this.compareOptions);
    }
    return globalOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd.registeredArguments.forEach((argument) => {
        argument.description =
          argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd.registeredArguments.find((argument) => argument.description)) {
      return cmd.registeredArguments;
    }
    return [];
  }

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd.registeredArguments
      .map((arg) => humanReadableArgName(arg))
      .join(' ');
    return (
      cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '')
    );
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

  optionTerm(option) {
    return option.flags;
  }

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    }, 0);
  }

  /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  }

  /**
   * Get the longest global option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestGlobalOptionTermLength(cmd, helper) {
    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  }

  /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(max, helper.argumentTerm(argument).length);
    }, 0);
  }

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    }
    let ancestorCmdNames = '';
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
    }
    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.description();
  }

  /**
   * Get the subcommand summary to show in the list of subcommands.
   * (Fallback to description for backwards compatibility.)
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.summary() || cmd.description();
  }

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */

  optionDescription(option) {
    const extraInfo = [];

    if (option.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (option.defaultValue !== undefined) {
      // default for boolean and negated more for programmer than end user,
      // but show true/false for boolean option as may be for hand-rolled env or config processing.
      const showDefault =
        option.required ||
        option.optional ||
        (option.isBoolean() && typeof option.defaultValue === 'boolean');
      if (showDefault) {
        extraInfo.push(
          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,
        );
      }
    }
    // preset for boolean and negated are more for programmer than end user
    if (option.presetArg !== undefined && option.optional) {
      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
    }
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar}`);
    }
    if (extraInfo.length > 0) {
      return `${option.description} (${extraInfo.join(', ')})`;
    }

    return option.description;
  }

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(
        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,
      );
    }
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescripton}`;
      }
      return extraDescripton;
    }
    return argument.description;
  }

  /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
        return helper.wrap(
          fullText,
          helpWidth - itemIndentWidth,
          termWidth + itemSeparatorWidth,
        );
      }
      return term;
    }
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    }

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([
        helper.wrap(commandDescription, helpWidth, 0),
        '',
      ]);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(
        helper.argumentTerm(argument),
        helper.argumentDescription(argument),
      );
    });
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    }

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(
        helper.optionTerm(option),
        helper.optionDescription(option),
      );
    });
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    }

    if (this.showGlobalOptions) {
      const globalOptionList = helper
        .visibleGlobalOptions(cmd)
        .map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option),
          );
        });
      if (globalOptionList.length > 0) {
        output = output.concat([
          'Global Options:',
          formatList(globalOptionList),
          '',
        ]);
      }
    }

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(
        helper.subcommandTerm(cmd),
        helper.subcommandDescription(cmd),
      );
    });
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    }

    return output.join('\n');
  }

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestGlobalOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper),
    );
  }

  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str
   * @param {number} width
   * @param {number} indent
   * @param {number} [minColumnWidth=40]
   * @return {string}
   *
   */

  wrap(str, width, indent, minColumnWidth = 40) {
    // Full \s characters, minus the linefeeds.
    const indents =
      ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
    const manualIndent = new RegExp(`[\\n][${indents}]+`);
    if (str.match(manualIndent)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.slice(0, indent);
    const columnText = str.slice(indent).replace('\r\n', '\n');
    const indentString = ' '.repeat(indent);
    const zeroWidthSpace = '\u200B';
    const breaks = `\\s${zeroWidthSpace}`;
    // Match line end (so empty lines don't collapse),
    // or as much text as will fit in column, or excess text up to first break.
    const regex = new RegExp(
      `\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
      'g',
    );
    const lines = columnText.match(regex) || [];
    return (
      leadingStr +
      lines
        .map((line, i) => {
          if (line === '\n') return ''; // preserve empty lines
          return (i > 0 ? indentString : '') + line.trimEnd();
        })
        .join('\n')
    );
  }
}

exports.Help = Help;


/***/ }),

/***/ "./node_modules/commander/lib/option.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { InvalidArgumentError } = __webpack_require__("./node_modules/commander/lib/error.js");

class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.presetArg = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
    this.conflictsWith = [];
    this.implied = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Option}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
   * The custom processing (parseArg) is called.
   *
   * @example
   * new Option('--color').default('GREYSCALE').preset('RGB');
   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
   *
   * @param {*} arg
   * @return {Option}
   */

  preset(arg) {
    this.presetArg = arg;
    return this;
  }

  /**
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
   *
   * @example
   * new Option('--rgb').conflicts('cmyk');
   * new Option('--js').conflicts(['ts', 'jsx']);
   *
   * @param {(string | string[])} names
   * @return {Option}
   */

  conflicts(names) {
    this.conflictsWith = this.conflictsWith.concat(names);
    return this;
  }

  /**
   * Specify implied option values for when this option is set and the implied options are not.
   *
   * The custom processing (parseArg) is not called on the implied values.
   *
   * @example
   * program
   *   .addOption(new Option('--log', 'write logging information to file'))
   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
   *
   * @param {object} impliedOptionValues
   * @return {Option}
   */
  implies(impliedOptionValues) {
    let newImplied = impliedOptionValues;
    if (typeof impliedOptionValues === 'string') {
      // string is not documented, but easy mistake and we can do what user probably intended.
      newImplied = { [impliedOptionValues]: true };
    }
    this.implied = Object.assign(this.implied || {}, newImplied);
    return this;
  }

  /**
   * Set environment variable to check for option value.
   *
   * An environment variable is only used if when processed the current option value is
   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
   *
   * @param {string} name
   * @return {Option}
   */

  env(name) {
    this.envVar = name;
    return this;
  }

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */

  makeOptionMandatory(mandatory = true) {
    this.mandatory = !!mandatory;
    return this;
  }

  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */

  hideHelp(hide = true) {
    this.hidden = !!hide;
    return this;
  }

  /**
   * @package
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Return option name.
   *
   * @return {string}
   */

  name() {
    if (this.long) {
      return this.long.replace(/^--/, '');
    }
    return this.short.replace(/^-/, '');
  }

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   */

  attributeName() {
    return camelcase(this.name().replace(/^no-/, ''));
  }

  /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @package
   */

  is(arg) {
    return this.short === arg || this.long === arg;
  }

  /**
   * Return whether a boolean option.
   *
   * Options are one of boolean, negated, required argument, or optional argument.
   *
   * @return {boolean}
   * @package
   */

  isBoolean() {
    return !this.required && !this.optional && !this.negate;
  }
}

/**
 * This class is to make it easier to work with dual options, without changing the existing
 * implementation. We support separate dual options for separate positive and negative options,
 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
 * use cases, but is tricky for others where we want separate behaviours despite
 * the single shared option value.
 */
class DualOptions {
  /**
   * @param {Option[]} options
   */
  constructor(options) {
    this.positiveOptions = new Map();
    this.negativeOptions = new Map();
    this.dualOptions = new Set();
    options.forEach((option) => {
      if (option.negate) {
        this.negativeOptions.set(option.attributeName(), option);
      } else {
        this.positiveOptions.set(option.attributeName(), option);
      }
    });
    this.negativeOptions.forEach((value, key) => {
      if (this.positiveOptions.has(key)) {
        this.dualOptions.add(key);
      }
    });
  }

  /**
   * Did the value come from the option, and not from possible matching dual option?
   *
   * @param {*} value
   * @param {Option} option
   * @returns {boolean}
   */
  valueFromOption(value, option) {
    const optionKey = option.attributeName();
    if (!this.dualOptions.has(optionKey)) return true;

    // Use the value to deduce if (probably) came from the option.
    const preset = this.negativeOptions.get(optionKey).presetArg;
    const negativeValue = preset !== undefined ? preset : false;
    return option.negate === (negativeValue === value);
  }
}

/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @private
 */

function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
    shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

exports.Option = Option;
exports.DualOptions = DualOptions;


/***/ }),

/***/ "./node_modules/commander/lib/suggestSimilar.js":
/***/ ((__unused_webpack_module, exports) => {

const maxDistance = 3;

function editDistance(a, b) {
  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance
  // Calculating optimal string alignment distance, no substring is edited more than once.
  // (Simple implementation.)

  // Quick early exit, return worst case.
  if (Math.abs(a.length - b.length) > maxDistance)
    return Math.max(a.length, b.length);

  // distance between prefix substrings of a and b
  const d = [];

  // pure deletions turn a into empty string
  for (let i = 0; i <= a.length; i++) {
    d[i] = [i];
  }
  // pure insertions turn empty string into b
  for (let j = 0; j <= b.length; j++) {
    d[0][j] = j;
  }

  // fill matrix
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      let cost = 1;
      if (a[i - 1] === b[j - 1]) {
        cost = 0;
      } else {
        cost = 1;
      }
      d[i][j] = Math.min(
        d[i - 1][j] + 1, // deletion
        d[i][j - 1] + 1, // insertion
        d[i - 1][j - 1] + cost, // substitution
      );
      // transposition
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
      }
    }
  }

  return d[a.length][b.length];
}

/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */

function suggestSimilar(word, candidates) {
  if (!candidates || candidates.length === 0) return '';
  // remove possible duplicates
  candidates = Array.from(new Set(candidates));

  const searchingOptions = word.startsWith('--');
  if (searchingOptions) {
    word = word.slice(2);
    candidates = candidates.map((candidate) => candidate.slice(2));
  }

  let similar = [];
  let bestDistance = maxDistance;
  const minSimilarity = 0.4;
  candidates.forEach((candidate) => {
    if (candidate.length <= 1) return; // no one character guesses

    const distance = editDistance(word, candidate);
    const length = Math.max(word.length, candidate.length);
    const similarity = (length - distance) / length;
    if (similarity > minSimilarity) {
      if (distance < bestDistance) {
        // better edit distance, throw away previous worse matches
        bestDistance = distance;
        similar = [candidate];
      } else if (distance === bestDistance) {
        similar.push(candidate);
      }
    }
  });

  similar.sort((a, b) => a.localeCompare(b));
  if (searchingOptions) {
    similar = similar.map((candidate) => `--${candidate}`);
  }

  if (similar.length > 1) {
    return `\n(Did you mean one of ${similar.join(', ')}?)`;
  }
  if (similar.length === 1) {
    return `\n(Did you mean ${similar[0]}?)`;
  }
  return '';
}

exports.suggestSimilar = suggestSimilar;


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__("buffer").Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ "./node_modules/db-errors/lib/dbErrors.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parsers = __webpack_require__("./node_modules/db-errors/lib/parsers/index.js");

const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");
const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");
const ForeignKeyViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ForeignKeyViolationError.js");
const NotNullViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/NotNullViolationError.js");
const UniqueViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/UniqueViolationError.js");
const CheckViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/CheckViolationError.js");
const DataError = __webpack_require__("./node_modules/db-errors/lib/errors/DataError.js");

function wrapError(err) {
  const dbs = Object.keys(parsers);

  for (let i = 0, l = dbs.length; i < l; ++i) {
    const parserTree = parsers[dbs[i]];
    const result = parse(parserTree, err, null);

    if (result !== null) {
      return new result.node.error(result.args);
    }
  }

  return err;
}

function parse(node, err, parentResult) {
  const args = node.parse(err);

  if (args === null) {
    return null;
  }

  const result = {
    node,
    args: Object.assign({}, parentResult && parentResult.args, args)
  };

  for (let i = 0; i < node.subclassParsers.length; ++i) {
    const subResult = parse(node.subclassParsers[i], err, result);

    if (subResult !== null) {
      return subResult;
    }
  }

  return result;
}

module.exports = {
  wrapError,

  DBError,
  UniqueViolationError,
  NotNullViolationError,
  ForeignKeyViolationError,
  ConstraintViolationError,
  CheckViolationError,
  DataError
};

/***/ }),

/***/ "./node_modules/db-errors/lib/errorCodes/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const postgres = __webpack_require__("./node_modules/db-errors/lib/errorCodes/postgres.js");
const mysql = __webpack_require__("./node_modules/db-errors/lib/errorCodes/mysql.js");
const mssql = __webpack_require__("./node_modules/db-errors/lib/errorCodes/mssql.js");

module.exports = {
  postgres,
  mysql,
  mssql,
};

/***/ }),

/***/ "./node_modules/db-errors/lib/errorCodes/mssql.js":
/***/ ((module) => {

"use strict";


// select * from sysmessages where [error] in (2601, 2627, 515, 547, 241, 242, 8152, 245) and msglangid = 1033;

const codes = {
  16: new Set([
    241,
    242,
    245,
    515,
    547,
    8152,
    50000
  ]),
  14: new Set([2601, 2627])
};

function has(code) {
  const set = codes[code.severity];

  if (set) {
    return set.has(code.errorCode);
  }

  return false;
}

// Top level key is the severity
module.exports = {
  has,
}


/***/ }),

/***/ "./node_modules/db-errors/lib/errorCodes/mysql.js":
/***/ ((module) => {

"use strict";


module.exports = new Set([
  "ER_HASHCHK",
  "ER_NISAMCHK",
  "ER_NO",
  "ER_YES",
  "ER_YES",
  "ER_CANT_CREATE_FILE",
  "ER_CANT_CREATE_TABLE",
  "ER_CANT_CREATE_DB",
  "ER_DB_CREATE_EXISTS",
  "ER_DB_DROP_EXISTS",
  "ER_DB_DROP_DELETE",
  "ER_DB_DROP_RMDIR",
  "ER_CANT_DELETE_FILE",
  "ER_CANT_FIND_SYSTEM_REC",
  "ER_CANT_GET_STAT",
  "ER_CANT_GET_WD",
  "ER_CANT_LOCK",
  "ER_CANT_OPEN_FILE",
  "ER_FILE_NOT_FOUND",
  "ER_CANT_READ_DIR",
  "ER_CANT_SET_WD",
  "ER_CHECKREAD",
  "ER_DISK_FULL",
  "ER_DUP_KEY",
  "ER_ERROR_ON_CLOSE",
  "ER_ERROR_ON_READ",
  "ER_ERROR_ON_RENAME",
  "ER_ERROR_ON_WRITE",
  "ER_FILE_USED",
  "ER_FILSORT_ABORT",
  "ER_FORM_NOT_FOUND",
  "ER_GET_ERRNO",
  "ER_ILLEGAL_HA",
  "ER_KEY_NOT_FOUND",
  "ER_NOT_FORM_FILE",
  "ER_NOT_KEYFILE",
  "ER_OLD_KEYFILE",
  "ER_OPEN_AS_READONLY",
  "ER_OUTOFMEMORY",
  "ER_OUT_OF_SORTMEMORY",
  "ER_UNEXPECTED_EOF",
  "ER_CON_COUNT_ERROR",
  "ER_OUT_OF_RESOURCES",
  "ER_BAD_HOST_ERROR",
  "ER_HANDSHAKE_ERROR",
  "ER_DBACCESS_DENIED_ERROR",
  "ER_ACCESS_DENIED_ERROR",
  "ER_NO_DB_ERROR",
  "ER_UNKNOWN_COM_ERROR",
  "ER_BAD_NULL_ERROR",
  "ER_BAD_DB_ERROR",
  "ER_TABLE_EXISTS_ERROR",
  "ER_BAD_TABLE_ERROR",
  "ER_NON_UNIQ_ERROR",
  "ER_SERVER_SHUTDOWN",
  "ER_BAD_FIELD_ERROR",
  "ER_WRONG_FIELD_WITH_GROUP",
  "ER_WRONG_GROUP_FIELD",
  "ER_WRONG_SUM_SELECT",
  "ER_WRONG_VALUE_COUNT",
  "ER_TOO_LONG_IDENT",
  "ER_DUP_FIELDNAME",
  "ER_DUP_KEYNAME",
  "ER_DUP_ENTRY",
  "ER_DUP_ENTRY_WITH_KEY_NAME",
  "ER_WRONG_FIELD_SPEC",
  "ER_PARSE_ERROR",
  "ER_EMPTY_QUERY",
  "ER_NONUNIQ_TABLE",
  "ER_INVALID_DEFAULT",
  "ER_MULTIPLE_PRI_KEY",
  "ER_TOO_MANY_KEYS",
  "ER_TOO_MANY_KEY_PARTS",
  "ER_TOO_LONG_KEY",
  "ER_KEY_COLUMN_DOES_NOT_EXITS",
  "ER_BLOB_USED_AS_KEY",
  "ER_TOO_BIG_FIELDLENGTH",
  "ER_WRONG_AUTO_KEY",
  "ER_READY",
  "ER_NORMAL_SHUTDOWN",
  "ER_GOT_SIGNAL",
  "ER_SHUTDOWN_COMPLETE",
  "ER_FORCING_CLOSE",
  "ER_IPSOCK_ERROR",
  "ER_NO_SUCH_INDEX",
  "ER_WRONG_FIELD_TERMINATORS",
  "ER_BLOBS_AND_NO_TERMINATED",
  "ER_TEXTFILE_NOT_READABLE",
  "ER_FILE_EXISTS_ERROR",
  "ER_LOAD_INFO",
  "ER_ALTER_INFO",
  "ER_WRONG_SUB_KEY",
  "ER_CANT_REMOVE_ALL_FIELDS",
  "ER_CANT_DROP_FIELD_OR_KEY",
  "ER_INSERT_INFO",
  "ER_UPDATE_TABLE_USED",
  "ER_NO_SUCH_THREAD",
  "ER_KILL_DENIED_ERROR",
  "ER_NO_TABLES_USED",
  "ER_TOO_BIG_SET",
  "ER_NO_UNIQUE_LOGFILE",
  "ER_TABLE_NOT_LOCKED_FOR_WRITE",
  "ER_TABLE_NOT_LOCKED",
  "ER_BLOB_CANT_HAVE_DEFAULT",
  "ER_WRONG_DB_NAME",
  "ER_WRONG_TABLE_NAME",
  "ER_TOO_BIG_SELECT",
  "ER_UNKNOWN_ERROR",
  "ER_UNKNOWN_PROCEDURE",
  "ER_WRONG_PARAMCOUNT_TO_PROCEDURE",
  "ER_WRONG_PARAMETERS_TO_PROCEDURE",
  "ER_UNKNOWN_TABLE",
  "ER_FIELD_SPECIFIED_TWICE",
  "ER_INVALID_GROUP_FUNC_USE",
  "ER_UNSUPPORTED_EXTENSION",
  "ER_TABLE_MUST_HAVE_COLUMNS",
  "ER_RECORD_FILE_FULL",
  "ER_UNKNOWN_CHARACTER_SET",
  "ER_TOO_MANY_TABLES",
  "ER_TOO_MANY_FIELDS",
  "ER_TOO_BIG_ROWSIZE",
  "ER_STACK_OVERRUN",
  "ER_WRONG_OUTER_JOIN",
  "ER_NULL_COLUMN_IN_INDEX",
  "ER_CANT_FIND_UDF",
  "ER_CANT_INITIALIZE_UDF",
  "ER_UDF_NO_PATHS",
  "ER_UDF_EXISTS",
  "ER_CANT_OPEN_LIBRARY",
  "ER_CANT_FIND_DL_ENTRY",
  "ER_FUNCTION_NOT_DEFINED",
  "ER_HOST_IS_BLOCKED",
  "ER_HOST_NOT_PRIVILEGED",
  "ER_PASSWORD_ANONYMOUS_USER",
  "ER_PASSWORD_NOT_ALLOWED",
  "ER_PASSWORD_NO_MATCH",
  "ER_UPDATE_INFO",
  "ER_CANT_CREATE_THREAD",
  "ER_WRONG_VALUE_COUNT_ON_ROW",
  "ER_CANT_REOPEN_TABLE",
  "ER_INVALID_USE_OF_NULL",
  "ER_REGEXP_ERROR",
  "ER_MIX_OF_GROUP_FUNC_AND_FIELDS",
  "ER_NONEXISTING_GRANT",
  "ER_TABLEACCESS_DENIED_ERROR",
  "ER_COLUMNACCESS_DENIED_ERROR",
  "ER_ILLEGAL_GRANT_FOR_TABLE",
  "ER_GRANT_WRONG_HOST_OR_USER",
  "ER_NO_SUCH_TABLE",
  "ER_NONEXISTING_TABLE_GRANT",
  "ER_NOT_ALLOWED_COMMAND",
  "ER_SYNTAX_ERROR",
  "ER_DELAYED_CANT_CHANGE_LOCK",
  "ER_TOO_MANY_DELAYED_THREADS",
  "ER_ABORTING_CONNECTION",
  "ER_NET_PACKET_TOO_LARGE",
  "ER_NET_READ_ERROR_FROM_PIPE",
  "ER_NET_FCNTL_ERROR",
  "ER_NET_PACKETS_OUT_OF_ORDER",
  "ER_NET_UNCOMPRESS_ERROR",
  "ER_NET_READ_ERROR",
  "ER_NET_READ_INTERRUPTED",
  "ER_NET_ERROR_ON_WRITE",
  "ER_NET_WRITE_INTERRUPTED",
  "ER_TOO_LONG_STRING",
  "ER_TABLE_CANT_HANDLE_BLOB",
  "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT",
  "ER_DELAYED_INSERT_TABLE_LOCKED",
  "ER_WRONG_COLUMN_NAME",
  "ER_WRONG_KEY_COLUMN",
  "ER_WRONG_MRG_TABLE",
  "ER_DUP_UNIQUE",
  "ER_BLOB_KEY_WITHOUT_LENGTH",
  "ER_PRIMARY_CANT_HAVE_NULL",
  "ER_TOO_MANY_ROWS",
  "ER_REQUIRES_PRIMARY_KEY",
  "ER_NO_RAID_COMPILED",
  "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE",
  "ER_KEY_DOES_NOT_EXITS",
  "ER_CHECK_NO_SUCH_TABLE",
  "ER_CHECK_NOT_IMPLEMENTED",
  "ER_CANT_DO_THIS_DURING_AN_TRANSACTION",
  "ER_ERROR_DURING_COMMIT",
  "ER_ERROR_DURING_ROLLBACK",
  "ER_ERROR_DURING_FLUSH_LOGS",
  "ER_ERROR_DURING_CHECKPOINT",
  "ER_NEW_ABORTING_CONNECTION",
  "ER_DUMP_NOT_IMPLEMENTED",
  "ER_FLUSH_MASTER_BINLOG_CLOSED",
  "ER_INDEX_REBUILD",
  "ER_MASTER",
  "ER_MASTER_NET_READ",
  "ER_MASTER_NET_WRITE",
  "ER_FT_MATCHING_KEY_NOT_FOUND",
  "ER_LOCK_OR_ACTIVE_TRANSACTION",
  "ER_UNKNOWN_SYSTEM_VARIABLE",
  "ER_CRASHED_ON_USAGE",
  "ER_CRASHED_ON_REPAIR",
  "ER_WARNING_NOT_COMPLETE_ROLLBACK",
  "ER_TRANS_CACHE_FULL",
  "ER_SLAVE_MUST_STOP",
  "ER_SLAVE_NOT_RUNNING",
  "ER_BAD_SLAVE",
  "ER_MASTER_INFO",
  "ER_SLAVE_THREAD",
  "ER_TOO_MANY_USER_CONNECTIONS",
  "ER_SET_CONSTANTS_ONLY",
  "ER_LOCK_WAIT_TIMEOUT",
  "ER_LOCK_TABLE_FULL",
  "ER_READ_ONLY_TRANSACTION",
  "ER_DROP_DB_WITH_READ_LOCK",
  "ER_CREATE_DB_WITH_READ_LOCK",
  "ER_WRONG_ARGUMENTS",
  "ER_NO_PERMISSION_TO_CREATE_USER",
  "ER_UNION_TABLES_IN_DIFFERENT_DIR",
  "ER_LOCK_DEADLOCK",
  "ER_TABLE_CANT_HANDLE_FT",
  "ER_CANNOT_ADD_FOREIGN",
  "ER_NO_REFERENCED_ROW",
  "ER_ROW_IS_REFERENCED",
  "ER_CONNECT_TO_MASTER",
  "ER_QUERY_ON_MASTER",
  "ER_ERROR_WHEN_EXECUTING_COMMAND",
  "ER_WRONG_USAGE",
  "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT",
  "ER_CANT_UPDATE_WITH_READLOCK",
  "ER_MIXING_NOT_ALLOWED",
  "ER_DUP_ARGUMENT",
  "ER_USER_LIMIT_REACHED",
  "ER_SPECIFIC_ACCESS_DENIED_ERROR",
  "ER_LOCAL_VARIABLE",
  "ER_GLOBAL_VARIABLE",
  "ER_NO_DEFAULT",
  "ER_WRONG_VALUE_FOR_VAR",
  "ER_WRONG_TYPE_FOR_VAR",
  "ER_VAR_CANT_BE_READ",
  "ER_CANT_USE_OPTION_HERE",
  "ER_NOT_SUPPORTED_YET",
  "ER_MASTER_FATAL_ERROR_READING_BINLOG",
  "ER_SLAVE_IGNORED_TABLE",
  "ER_INCORRECT_GLOBAL_LOCAL_VAR",
  "ER_WRONG_FK_DEF",
  "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF",
  "ER_OPERAND_COLUMNS",
  "ER_SUBQUERY_NO_1_ROW",
  "ER_UNKNOWN_STMT_HANDLER",
  "ER_CORRUPT_HELP_DB",
  "ER_CYCLIC_REFERENCE",
  "ER_AUTO_CONVERT",
  "ER_ILLEGAL_REFERENCE",
  "ER_DERIVED_MUST_HAVE_ALIAS",
  "ER_SELECT_REDUCED",
  "ER_TABLENAME_NOT_ALLOWED_HERE",
  "ER_NOT_SUPPORTED_AUTH_MODE",
  "ER_SPATIAL_CANT_HAVE_NULL",
  "ER_COLLATION_CHARSET_MISMATCH",
  "ER_SLAVE_WAS_RUNNING",
  "ER_SLAVE_WAS_NOT_RUNNING",
  "ER_TOO_BIG_FOR_UNCOMPRESS",
  "ER_ZLIB_Z_MEM_ERROR",
  "ER_ZLIB_Z_BUF_ERROR",
  "ER_ZLIB_Z_DATA_ERROR",
  "ER_CUT_VALUE_GROUP_CONCAT",
  "ER_WARN_TOO_FEW_RECORDS",
  "ER_WARN_TOO_MANY_RECORDS",
  "ER_WARN_NULL_TO_NOTNULL",
  "ER_WARN_DATA_OUT_OF_RANGE",
  "ER_WARN_USING_OTHER_HANDLER",
  "ER_CANT_AGGREGATE_2COLLATIONS",
  "ER_DROP_USER",
  "ER_REVOKE_GRANTS",
  "ER_CANT_AGGREGATE_3COLLATIONS",
  "ER_CANT_AGGREGATE_NCOLLATIONS",
  "ER_VARIABLE_IS_NOT_STRUCT",
  "ER_UNKNOWN_COLLATION",
  "ER_SLAVE_IGNORED_SSL_PARAMS",
  "ER_SERVER_IS_IN_SECURE_AUTH_MODE",
  "ER_WARN_FIELD_RESOLVED",
  "ER_BAD_SLAVE_UNTIL_COND",
  "ER_MISSING_SKIP_SLAVE",
  "ER_UNTIL_COND_IGNORED",
  "ER_WRONG_NAME_FOR_INDEX",
  "ER_WRONG_NAME_FOR_CATALOG",
  "ER_WARN_QC_RESIZE",
  "ER_BAD_FT_COLUMN",
  "ER_UNKNOWN_KEY_CACHE",
  "ER_WARN_HOSTNAME_WONT_WORK",
  "ER_UNKNOWN_STORAGE_ENGINE",
  "ER_WARN_DEPRECATED_SYNTAX",
  "ER_NON_UPDATABLE_TABLE",
  "ER_FEATURE_DISABLED",
  "ER_OPTION_PREVENTS_STATEMENT",
  "ER_DUPLICATED_VALUE_IN_TYPE",
  "ER_TRUNCATED_WRONG_VALUE",
  "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS",
  "ER_INVALID_ON_UPDATE",
  "ER_UNSUPPORTED_PS",
  "ER_GET_ERRMSG",
  "ER_GET_TEMPORARY_ERRMSG",
  "ER_UNKNOWN_TIME_ZONE",
  "ER_WARN_INVALID_TIMESTAMP",
  "ER_INVALID_CHARACTER_STRING",
  "ER_WARN_ALLOWED_PACKET_OVERFLOWED",
  "ER_CONFLICTING_DECLARATIONS",
  "ER_SP_NO_RECURSIVE_CREATE",
  "ER_SP_ALREADY_EXISTS",
  "ER_SP_DOES_NOT_EXIST",
  "ER_SP_DROP_FAILED",
  "ER_SP_STORE_FAILED",
  "ER_SP_LILABEL_MISMATCH",
  "ER_SP_LABEL_REDEFINE",
  "ER_SP_LABEL_MISMATCH",
  "ER_SP_UNINIT_VAR",
  "ER_SP_BADSELECT",
  "ER_SP_BADRETURN",
  "ER_SP_BADSTATEMENT",
  "ER_UPDATE_LOG_DEPRECATED_IGNORED",
  "ER_UPDATE_LOG_DEPRECATED_TRANSLATED",
  "ER_QUERY_INTERRUPTED",
  "ER_SP_WRONG_NO_OF_ARGS",
  "ER_SP_COND_MISMATCH",
  "ER_SP_NORETURN",
  "ER_SP_NORETURNEND",
  "ER_SP_BAD_CURSOR_QUERY",
  "ER_SP_BAD_CURSOR_SELECT",
  "ER_SP_CURSOR_MISMATCH",
  "ER_SP_CURSOR_ALREADY_OPEN",
  "ER_SP_CURSOR_NOT_OPEN",
  "ER_SP_UNDECLARED_VAR",
  "ER_SP_WRONG_NO_OF_FETCH_ARGS",
  "ER_SP_FETCH_NO_DATA",
  "ER_SP_DUP_PARAM",
  "ER_SP_DUP_VAR",
  "ER_SP_DUP_COND",
  "ER_SP_DUP_CURS",
  "ER_SP_CANT_ALTER",
  "ER_SP_SUBSELECT_NYI",
  "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG",
  "ER_SP_VARCOND_AFTER_CURSHNDLR",
  "ER_SP_CURSOR_AFTER_HANDLER",
  "ER_SP_CASE_NOT_FOUND",
  "ER_FPARSER_TOO_BIG_FILE",
  "ER_FPARSER_BAD_HEADER",
  "ER_FPARSER_EOF_IN_COMMENT",
  "ER_FPARSER_ERROR_IN_PARAMETER",
  "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER",
  "ER_VIEW_NO_EXPLAIN",
  "ER_FRM_UNKNOWN_TYPE",
  "ER_WRONG_OBJECT",
  "ER_NONUPDATEABLE_COLUMN",
  "ER_VIEW_SELECT_DERIVED",
  "ER_VIEW_SELECT_CLAUSE",
  "ER_VIEW_SELECT_VARIABLE",
  "ER_VIEW_SELECT_TMPTABLE",
  "ER_VIEW_WRONG_LIST",
  "ER_WARN_VIEW_MERGE",
  "ER_WARN_VIEW_WITHOUT_KEY",
  "ER_VIEW_INVALID",
  "ER_SP_NO_DROP_SP",
  "ER_SP_GOTO_IN_HNDLR",
  "ER_TRG_ALREADY_EXISTS",
  "ER_TRG_DOES_NOT_EXIST",
  "ER_TRG_ON_VIEW_OR_TEMP_TABLE",
  "ER_TRG_CANT_CHANGE_ROW",
  "ER_TRG_NO_SUCH_ROW_IN_TRG",
  "ER_NO_DEFAULT_FOR_FIELD",
  "ER_DIVISION_BY_ZERO",
  "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD",
  "ER_ILLEGAL_VALUE_FOR_TYPE",
  "ER_VIEW_NONUPD_CHECK",
  "ER_VIEW_CHECK_FAILED",
  "ER_PROCACCESS_DENIED_ERROR",
  "ER_RELAY_LOG_FAIL",
  "ER_PASSWD_LENGTH",
  "ER_UNKNOWN_TARGET_BINLOG",
  "ER_IO_ERR_LOG_INDEX_READ",
  "ER_BINLOG_PURGE_PROHIBITED",
  "ER_FSEEK_FAIL",
  "ER_BINLOG_PURGE_FATAL_ERR",
  "ER_LOG_IN_USE",
  "ER_LOG_PURGE_UNKNOWN_ERR",
  "ER_RELAY_LOG_INIT",
  "ER_NO_BINARY_LOGGING",
  "ER_RESERVED_SYNTAX",
  "ER_WSAS_FAILED",
  "ER_DIFF_GROUPS_PROC",
  "ER_NO_GROUP_FOR_PROC",
  "ER_ORDER_WITH_PROC",
  "ER_LOGGING_PROHIBIT_CHANGING_OF",
  "ER_NO_FILE_MAPPING",
  "ER_WRONG_MAGIC",
  "ER_PS_MANY_PARAM",
  "ER_KEY_PART_0",
  "ER_VIEW_CHECKSUM",
  "ER_VIEW_MULTIUPDATE",
  "ER_VIEW_NO_INSERT_FIELD_LIST",
  "ER_VIEW_DELETE_MERGE_VIEW",
  "ER_CANNOT_USER",
  "ER_XAER_NOTA",
  "ER_XAER_INVAL",
  "ER_XAER_RMFAIL",
  "ER_XAER_OUTSIDE",
  "ER_XAER_RMERR",
  "ER_XA_RBROLLBACK",
  "ER_NONEXISTING_PROC_GRANT",
  "ER_PROC_AUTO_GRANT_FAIL",
  "ER_PROC_AUTO_REVOKE_FAIL",
  "ER_DATA_TOO_LONG",
  "ER_SP_BAD_SQLSTATE",
  "ER_STARTUP",
  "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR",
  "ER_CANT_CREATE_USER_WITH_GRANT",
  "ER_WRONG_VALUE_FOR_TYPE",
  "ER_TABLE_DEF_CHANGED",
  "ER_SP_DUP_HANDLER",
  "ER_SP_NOT_VAR_ARG",
  "ER_SP_NO_RETSET",
  "ER_CANT_CREATE_GEOMETRY_OBJECT",
  "ER_FAILED_ROUTINE_BREAK_BINLOG",
  "ER_BINLOG_UNSAFE_ROUTINE",
  "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER",
  "ER_EXEC_STMT_WITH_OPEN_CURSOR",
  "ER_STMT_HAS_NO_OPEN_CURSOR",
  "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG",
  "ER_NO_DEFAULT_FOR_VIEW_FIELD",
  "ER_SP_NO_RECURSION",
  "ER_TOO_BIG_SCALE",
  "ER_TOO_BIG_PRECISION",
  "ER_M_BIGGER_THAN_D",
  "ER_WRONG_LOCK_OF_SYSTEM_TABLE",
  "ER_CONNECT_TO_FOREIGN_DATA_SOURCE",
  "ER_QUERY_ON_FOREIGN_DATA_SOURCE",
  "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST",
  "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE",
  "ER_FOREIGN_DATA_STRING_INVALID",
  "ER_CANT_CREATE_FEDERATED_TABLE",
  "ER_TRG_IN_WRONG_SCHEMA",
  "ER_STACK_OVERRUN_NEED_MORE",
  "ER_TOO_LONG_BODY",
  "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE",
  "ER_TOO_BIG_DISPLAYWIDTH",
  "ER_XAER_DUPID",
  "ER_DATETIME_FUNCTION_OVERFLOW",
  "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG",
  "ER_VIEW_PREVENT_UPDATE",
  "ER_PS_NO_RECURSION",
  "ER_SP_CANT_SET_AUTOCOMMIT",
  "ER_MALFORMED_DEFINER",
  "ER_VIEW_FRM_NO_USER",
  "ER_VIEW_OTHER_USER",
  "ER_NO_SUCH_USER",
  "ER_FORBID_SCHEMA_CHANGE",
  "ER_ROW_IS_REFERENCED_2",
  "ER_NO_REFERENCED_ROW_2",
  "ER_SP_BAD_VAR_SHADOW",
  "ER_TRG_NO_DEFINER",
  "ER_OLD_FILE_FORMAT",
  "ER_SP_RECURSION_LIMIT",
  "ER_SP_PROC_TABLE_CORRUPT",
  "ER_SP_WRONG_NAME",
  "ER_TABLE_NEEDS_UPGRADE",
  "ER_SP_NO_AGGREGATE",
  "ER_MAX_PREPARED_STMT_COUNT_REACHED",
  "ER_VIEW_RECURSIVE",
  "ER_NON_GROUPING_FIELD_USED",
  "ER_TABLE_CANT_HANDLE_SPKEYS",
  "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA",
  "ER_REMOVED_SPACES",
  "ER_AUTOINC_READ_FAILED",
  "ER_USERNAME",
  "ER_HOSTNAME",
  "ER_WRONG_STRING_LENGTH",
  "ER_NON_INSERTABLE_TABLE",
  "ER_ADMIN_WRONG_MRG_TABLE",
  "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT",
  "ER_NAME_BECOMES_EMPTY",
  "ER_AMBIGUOUS_FIELD_TERM",
  "ER_FOREIGN_SERVER_EXISTS",
  "ER_FOREIGN_SERVER_DOESNT_EXIST",
  "ER_ILLEGAL_HA_CREATE_OPTION",
  "ER_PARTITION_REQUIRES_VALUES_ERROR",
  "ER_PARTITION_WRONG_VALUES_ERROR",
  "ER_PARTITION_MAXVALUE_ERROR",
  "ER_PARTITION_SUBPARTITION_ERROR",
  "ER_PARTITION_SUBPART_MIX_ERROR",
  "ER_PARTITION_WRONG_NO_PART_ERROR",
  "ER_PARTITION_WRONG_NO_SUBPART_ERROR",
  "ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR",
  "ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR",
  "ER_FIELD_NOT_FOUND_PART_ERROR",
  "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR",
  "ER_INCONSISTENT_PARTITION_INFO_ERROR",
  "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR",
  "ER_PARTITIONS_MUST_BE_DEFINED_ERROR",
  "ER_RANGE_NOT_INCREASING_ERROR",
  "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR",
  "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR",
  "ER_PARTITION_ENTRY_ERROR",
  "ER_MIX_HANDLER_ERROR",
  "ER_PARTITION_NOT_DEFINED_ERROR",
  "ER_TOO_MANY_PARTITIONS_ERROR",
  "ER_SUBPARTITION_ERROR",
  "ER_CANT_CREATE_HANDLER_FILE",
  "ER_BLOB_FIELD_IN_PART_FUNC_ERROR",
  "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF",
  "ER_NO_PARTS_ERROR",
  "ER_PARTITION_MGMT_ON_NONPARTITIONED",
  "ER_FOREIGN_KEY_ON_PARTITIONED",
  "ER_DROP_PARTITION_NON_EXISTENT",
  "ER_DROP_LAST_PARTITION",
  "ER_COALESCE_ONLY_ON_HASH_PARTITION",
  "ER_REORG_HASH_ONLY_ON_SAME_NO",
  "ER_REORG_NO_PARAM_ERROR",
  "ER_ONLY_ON_RANGE_LIST_PARTITION",
  "ER_ADD_PARTITION_SUBPART_ERROR",
  "ER_ADD_PARTITION_NO_NEW_PARTITION",
  "ER_COALESCE_PARTITION_NO_PARTITION",
  "ER_REORG_PARTITION_NOT_EXIST",
  "ER_SAME_NAME_PARTITION",
  "ER_NO_BINLOG_ERROR",
  "ER_CONSECUTIVE_REORG_PARTITIONS",
  "ER_REORG_OUTSIDE_RANGE",
  "ER_PARTITION_FUNCTION_FAILURE",
  "ER_PART_STATE_ERROR",
  "ER_LIMITED_PART_RANGE",
  "ER_PLUGIN_IS_NOT_LOADED",
  "ER_WRONG_VALUE",
  "ER_NO_PARTITION_FOR_GIVEN_VALUE",
  "ER_FILEGROUP_OPTION_ONLY_ONCE",
  "ER_CREATE_FILEGROUP_FAILED",
  "ER_DROP_FILEGROUP_FAILED",
  "ER_TABLESPACE_AUTO_EXTEND_ERROR",
  "ER_WRONG_SIZE_NUMBER",
  "ER_SIZE_OVERFLOW_ERROR",
  "ER_ALTER_FILEGROUP_FAILED",
  "ER_BINLOG_ROW_LOGGING_FAILED",
  "ER_BINLOG_ROW_WRONG_TABLE_DEF",
  "ER_BINLOG_ROW_RBR_TO_SBR",
  "ER_EVENT_ALREADY_EXISTS",
  "ER_EVENT_STORE_FAILED",
  "ER_EVENT_DOES_NOT_EXIST",
  "ER_EVENT_CANT_ALTER",
  "ER_EVENT_DROP_FAILED",
  "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG",
  "ER_EVENT_ENDS_BEFORE_STARTS",
  "ER_EVENT_EXEC_TIME_IN_THE_PAST",
  "ER_EVENT_OPEN_TABLE_FAILED",
  "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT",
  "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED",
  "ER_CANNOT_LOAD_FROM_TABLE",
  "ER_EVENT_CANNOT_DELETE",
  "ER_EVENT_COMPILE_ERROR",
  "ER_EVENT_SAME_NAME",
  "ER_EVENT_DATA_TOO_LONG",
  "ER_DROP_INDEX_FK",
  "ER_WARN_DEPRECATED_SYNTAX_WITH_VER",
  "ER_CANT_WRITE_LOCK_LOG_TABLE",
  "ER_CANT_LOCK_LOG_TABLE",
  "ER_FOREIGN_DUPLICATE_KEY",
  "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE",
  "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR",
  "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT",
  "ER_NDB_CANT_SWITCH_BINLOG_FORMAT",
  "ER_PARTITION_NO_TEMPORARY",
  "ER_PARTITION_CONST_DOMAIN_ERROR",
  "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED",
  "ER_DDL_LOG_ERROR",
  "ER_NULL_IN_VALUES_LESS_THAN",
  "ER_WRONG_PARTITION_NAME",
  "ER_CANT_CHANGE_TX_ISOLATION",
  "ER_DUP_ENTRY_AUTOINCREMENT_CASE",
  "ER_EVENT_MODIFY_QUEUE_ERROR",
  "ER_EVENT_SET_VAR_ERROR",
  "ER_PARTITION_MERGE_ERROR",
  "ER_CANT_ACTIVATE_LOG",
  "ER_RBR_NOT_AVAILABLE",
  "ER_BASE64_DECODE_ERROR",
  "ER_EVENT_RECURSION_FORBIDDEN",
  "ER_EVENTS_DB_ERROR",
  "ER_ONLY_INTEGERS_ALLOWED",
  "ER_UNSUPORTED_LOG_ENGINE",
  "ER_BAD_LOG_STATEMENT",
  "ER_CANT_RENAME_LOG_TABLE",
  "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT",
  "ER_WRONG_PARAMETERS_TO_NATIVE_FCT",
  "ER_WRONG_PARAMETERS_TO_STORED_FCT",
  "ER_NATIVE_FCT_NAME_COLLISION",
  "ER_DUP_ENTRY_WITH_KEY_NAME",
  "ER_DUP_ENTRY",
  "ER_BINLOG_PURGE_EMFILE",
  "ER_EVENT_CANNOT_CREATE_IN_THE_PAST",
  "ER_EVENT_CANNOT_ALTER_IN_THE_PAST",
  "ER_SLAVE_INCIDENT",
  "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT",
  "ER_BINLOG_UNSAFE_STATEMENT",
  "ER_SLAVE_FATAL_ERROR",
  "ER_SLAVE_RELAY_LOG_READ_FAILURE",
  "ER_SLAVE_RELAY_LOG_WRITE_FAILURE",
  "ER_SLAVE_CREATE_EVENT_FAILURE",
  "ER_SLAVE_MASTER_COM_FAILURE",
  "ER_BINLOG_LOGGING_IMPOSSIBLE",
  "ER_VIEW_NO_CREATION_CTX",
  "ER_VIEW_INVALID_CREATION_CTX",
  "ER_SR_INVALID_CREATION_CTX",
  "ER_TRG_CORRUPTED_FILE",
  "ER_TRG_NO_CREATION_CTX",
  "ER_TRG_INVALID_CREATION_CTX",
  "ER_EVENT_INVALID_CREATION_CTX",
  "ER_TRG_CANT_OPEN_TABLE",
  "ER_CANT_CREATE_SROUTINE",
  "ER_SLAVE_AMBIGOUS_EXEC_MODE",
  "ER_SLAVE_AMBIGOUS_EXEC_MODE",
  "ER_NEVER_USED",
  "ER_SLAVE_AMBIGOUS_EXEC_MODE",
  "ER_NEVER_USED",
  "ER_SLAVE_AMBIGOUS_EXEC_MODE",
  "ER_NEVER_USED",
  "ER_NEVER_USED",
  "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT",
  "ER_SLAVE_CORRUPT_EVENT",
  "ER_LOAD_DATA_INVALID_COLUMN",
  "ER_LOG_PURGE_NO_FILE",
  "ER_XA_RBTIMEOUT",
  "ER_XA_RBDEADLOCK",
  "ER_NEED_REPREPARE",
  "ER_DELAYED_NOT_SUPPORTED",
  "ER_VARIABLE_IS_READONLY",
  "ER_WARN_ENGINE_TRANSACTION_ROLLBACK",
  "ER_SLAVE_HEARTBEAT_FAILURE",
  "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE",
  "ER_NDB_REPLICATION_SCHEMA_ERROR",
  "ER_CONFLICT_FN_PARSE_ERROR",
  "ER_EXCEPTIONS_WRITE_ERROR",
  "ER_TOO_LONG_TABLE_COMMENT",
  "ER_TOO_LONG_FIELD_COMMENT",
  "ER_FUNC_INEXISTENT_NAME_COLLISION",
  "ER_DATABASE_NAME",
  "ER_TABLE_NAME",
  "ER_PARTITION_NAME",
  "ER_SUBPARTITION_NAME",
  "ER_TEMPORARY_NAME",
  "ER_RENAMED_NAME",
  "ER_TOO_MANY_CONCURRENT_TRXS",
  "ER_DEBUG_SYNC_TIMEOUT",
  "ER_DEBUG_SYNC_HIT_LIMIT",
  "ER_DUP_SIGNAL_SET",
  "ER_SIGNAL_WARN",
  "ER_SIGNAL_NOT_FOUND",
  "ER_SIGNAL_EXCEPTION",
  "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER",
  "ER_SIGNAL_BAD_CONDITION_TYPE",
  "ER_COND_ITEM_TOO_LONG",
  "ER_UNKNOWN_LOCALE",
  "ER_SLAVE_IGNORE_SERVER_IDS",
  "ER_QUERY_CACHE_DISABLED",
  "ER_SAME_NAME_PARTITION_FIELD",
  "ER_PARTITION_COLUMN_LIST_ERROR",
  "ER_WRONG_TYPE_COLUMN_VALUE_ERROR",
  "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR",
  "ER_MAXVALUE_IN_VALUES_IN",
  "ER_TOO_MANY_VALUES_ERROR",
  "ER_ROW_SINGLE_PARTITION_FIELD_ERROR",
  "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD",
  "ER_PARTITION_FIELDS_TOO_LONG",
  "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE",
  "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE",
  "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE",
  "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE",
  "ER_BINLOG_UNSAFE_AND_STMT_ENGINE",
  "ER_BINLOG_UNSAFE_AND_STMT_ENGINE",
  "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE",
  "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE",
  "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE",
  "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE",
  "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE",
  "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE",
  "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE",
  "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE",
  "ER_BINLOG_UNSAFE_LIMIT",
  "ER_BINLOG_UNSAFE_LIMIT",
  "ER_BINLOG_UNSAFE_INSERT_DELAYED",
  "ER_BINLOG_UNSAFE_INSERT_DELAYED",
  "ER_BINLOG_UNSAFE_SYSTEM_TABLE",
  "ER_BINLOG_UNSAFE_SYSTEM_TABLE",
  "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS",
  "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS",
  "ER_BINLOG_UNSAFE_UDF",
  "ER_BINLOG_UNSAFE_UDF",
  "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE",
  "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE",
  "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION",
  "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION",
  "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS",
  "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS",
  "ER_MESSAGE_AND_STATEMENT",
  "ER_MESSAGE_AND_STATEMENT",
  "ER_SLAVE_CONVERSION_FAILED",
  "ER_SLAVE_CONVERSION_FAILED",
  "ER_SLAVE_CANT_CREATE_CONVERSION",
  "ER_SLAVE_CANT_CREATE_CONVERSION",
  "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT",
  "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT",
  "ER_PATH_LENGTH",
  "ER_PATH_LENGTH",
  "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT",
  "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT",
  "ER_WRONG_NATIVE_TABLE_STRUCTURE",
  "ER_WRONG_NATIVE_TABLE_STRUCTURE",
  "ER_WRONG_PERFSCHEMA_USAGE",
  "ER_WRONG_PERFSCHEMA_USAGE",
  "ER_WARN_I_S_SKIPPED_TABLE",
  "ER_WARN_I_S_SKIPPED_TABLE",
  "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT",
  "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT",
  "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT",
  "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT",
  "ER_SPATIAL_MUST_HAVE_GEOM_COL",
  "ER_SPATIAL_MUST_HAVE_GEOM_COL",
  "ER_TOO_LONG_INDEX_COMMENT",
  "ER_TOO_LONG_INDEX_COMMENT",
  "ER_LOCK_ABORTED",
  "ER_LOCK_ABORTED",
  "ER_DATA_OUT_OF_RANGE",
  "ER_DATA_OUT_OF_RANGE",
  "ER_WRONG_SPVAR_TYPE_IN_LIMIT",
  "ER_WRONG_SPVAR_TYPE_IN_LIMIT",
  "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE",
  "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE",
  "ER_BINLOG_UNSAFE_MIXED_STATEMENT",
  "ER_BINLOG_UNSAFE_MIXED_STATEMENT",
  "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN",
  "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN",
  "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN",
  "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN",
  "ER_FAILED_READ_FROM_PAR_FILE",
  "ER_FAILED_READ_FROM_PAR_FILE",
  "ER_VALUES_IS_NOT_INT_TYPE_ERROR",
  "ER_VALUES_IS_NOT_INT_TYPE_ERROR",
  "ER_ACCESS_DENIED_NO_PASSWORD_ERROR",
  "ER_ACCESS_DENIED_NO_PASSWORD_ERROR",
  "ER_SET_PASSWORD_AUTH_PLUGIN",
  "ER_SET_PASSWORD_AUTH_PLUGIN",
  "ER_GRANT_PLUGIN_USER_EXISTS",
  "ER_GRANT_PLUGIN_USER_EXISTS",
  "ER_TRUNCATE_ILLEGAL_FK",
  "ER_TRUNCATE_ILLEGAL_FK",
  "ER_PLUGIN_IS_PERMANENT",
  "ER_PLUGIN_IS_PERMANENT",
  "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN",
  "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN",
  "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX",
  "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX",
  "ER_STMT_CACHE_FULL",
  "ER_STMT_CACHE_FULL",
  "ER_MULTI_UPDATE_KEY_CONFLICT",
  "ER_MULTI_UPDATE_KEY_CONFLICT",
  "ER_TABLE_NEEDS_REBUILD",
  "ER_TABLE_NEEDS_REBUILD",
  "ER_INDEX_COLUMN_TOO_LONG",
  "ER_INDEX_COLUMN_TOO_LONG",
  "ER_ERROR_IN_TRIGGER_BODY",
  "ER_ERROR_IN_TRIGGER_BODY",
  "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY",
  "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY",
  "ER_INDEX_CORRUPT",
  "ER_INDEX_CORRUPT",
  "ER_UNDO_RECORD_TOO_BIG",
  "ER_UNDO_RECORD_TOO_BIG",
  "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT",
  "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT",
  "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE",
  "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE",
  "ER_BINLOG_UNSAFE_REPLACE_SELECT",
  "ER_BINLOG_UNSAFE_REPLACE_SELECT",
  "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT",
  "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT",
  "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT",
  "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT",
  "ER_BINLOG_UNSAFE_UPDATE_IGNORE",
  "ER_BINLOG_UNSAFE_UPDATE_IGNORE",
  "ER_PLUGIN_NO_UNINSTALL",
  "ER_PLUGIN_NO_UNINSTALL",
  "ER_PLUGIN_NO_INSTALL",
  "ER_PLUGIN_NO_INSTALL",
  "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT",
  "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT",
  "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC",
  "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC",
  "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS",
  "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS",
  "ER_TABLE_IN_FK_CHECK",
  "ER_TABLE_IN_FK_CHECK",
  "ER_UNSUPPORTED_ENGINE",
  "ER_UNSUPPORTED_ENGINE",
  "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST",
  "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST"
]);

/***/ }),

/***/ "./node_modules/db-errors/lib/errorCodes/postgres.js":
/***/ ((module) => {

"use strict";


module.exports = new Set([
  "000",
  "00000",
  "01000",
  "0100C",
  "01008",
  "01003",
  "01007",
  "01006",
  "01004",
  "01P01",
  "02000",
  "02001",
  "03000",
  "08000",
  "08003",
  "08006",
  "08001",
  "08004",
  "08007",
  "08P01",
  "09000",
  "0A000",
  "0B000",
  "0F000",
  "0F001",
  "0L000",
  "0LP01",
  "0P000",
  "0Z000",
  "0Z002",
  "20000",
  "21000",
  "22000",
  "2202E",
  "22021",
  "22008",
  "22012",
  "22005",
  "2200B",
  "22022",
  "22015",
  "2201E",
  "22014",
  "22016",
  "2201F",
  "2201G",
  "22018",
  "22007",
  "22019",
  "2200D",
  "22025",
  "22P06",
  "22010",
  "22023",
  "2201B",
  "2201W",
  "2201X",
  "2202H",
  "2202G",
  "22009",
  "2200C",
  "2200G",
  "22004",
  "22002",
  "22003",
  "22026",
  "22001",
  "22011",
  "22027",
  "22024",
  "2200F",
  "22P01",
  "22P02",
  "22P03",
  "22P04",
  "22P05",
  "2200L",
  "2200M",
  "2200N",
  "2200S",
  "2200T",
  "23000",
  "23001",
  "23502",
  "23503",
  "23505",
  "23514",
  "23P01",
  "24000",
  "25000",
  "25001",
  "25002",
  "25008",
  "25003",
  "25004",
  "25005",
  "25006",
  "25007",
  "25P01",
  "25P02",
  "25P03",
  "26000",
  "27000",
  "28000",
  "28P01",
  "2B000",
  "2BP01",
  "2D000",
  "2F000",
  "2F005",
  "2F002",
  "2F003",
  "2F004",
  "34000",
  "38000",
  "38001",
  "38002",
  "38003",
  "38004",
  "39000",
  "39001",
  "39004",
  "39P01",
  "39P02",
  "39P03",
  "3B000",
  "3B001",
  "3D000",
  "3F000",
  "40000",
  "40002",
  "40001",
  "40003",
  "40P01",
  "42000",
  "42601",
  "42501",
  "42846",
  "42803",
  "42P20",
  "42P19",
  "42830",
  "42602",
  "42622",
  "42939",
  "42804",
  "42P18",
  "42P21",
  "42P22",
  "42809",
  "42703",
  "42883",
  "42P01",
  "42P02",
  "42704",
  "42701",
  "42P03",
  "42P04",
  "42723",
  "42P05",
  "42P06",
  "42P07",
  "42712",
  "42710",
  "42702",
  "42725",
  "42P08",
  "42P09",
  "42P10",
  "42611",
  "42P11",
  "42P12",
  "42P13",
  "42P14",
  "42P15",
  "42P16",
  "42P17",
  "44000",
  "53000",
  "53100",
  "53200",
  "53300",
  "53400",
  "54000",
  "54001",
  "54011",
  "54023",
  "55000",
  "55006",
  "55P02",
  "55P03",
  "57000",
  "57014",
  "57P01",
  "57P02",
  "57P03",
  "57P04",
  "58000",
  "58030",
  "58P01",
  "58P02",
  "72000",
  "F0000",
  "F0001",
  "HV000",
  "HV005",
  "HV002",
  "HV010",
  "HV021",
  "HV024",
  "HV007",
  "HV008",
  "HV004",
  "HV006",
  "HV091",
  "HV00B",
  "HV00C",
  "HV00D",
  "HV090",
  "HV00A",
  "HV009",
  "HV014",
  "HV001",
  "HV00P",
  "HV00J",
  "HV00K",
  "HV00Q",
  "HV00R",
  "HV00L",
  "HV00M",
  "HV00N",
  "P0000",
  "P0001",
  "P0002",
  "P0003",
  "P0004",
  "XX000",
  "XX001",
  "XX002"
]);

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/CheckViolationError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");

class CheckViolationError extends ConstraintViolationError {

  constructor(args) {
    super(args);

    this.table = args.table;
    this.constraint = args.constraint;
  }
}

module.exports = CheckViolationError;

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/ConstraintViolationError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");

class ConstraintViolationError extends DBError {}

module.exports = ConstraintViolationError;

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/DBError.js":
/***/ ((module) => {

"use strict";


class DBError extends Error {

  constructor(args) {
    super(args.nativeError.message);

    this.name = this.constructor.name;
    this.nativeError = args.nativeError;
    this.client = args.client;
  }
}

module.exports = DBError;

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/DataError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");

class DataError extends DBError {}

module.exports = DataError;

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/ForeignKeyViolationError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");

class ForeignKeyViolationError extends ConstraintViolationError {

  constructor(args) {
    super(args);

    this.table = args.table;
    this.constraint = args.constraint;
    this.schema = args.schema;
  }
}

module.exports = ForeignKeyViolationError;

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/NotNullViolationError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");

class NotNullViolationError extends ConstraintViolationError {

  constructor(args) {
    super(args);

    this.table = args.table;
    this.column = args.column;
    this.schema = args.schema;
    this.database = args.database;
  }
}

module.exports = NotNullViolationError;

/***/ }),

/***/ "./node_modules/db-errors/lib/errors/UniqueViolationError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");

class UniqueViolationError extends ConstraintViolationError {

  constructor(args) {
    super(args);

    this.table = args.table;
    this.columns = args.columns;
    this.constraint = args.constraint;
    this.schema = args.schema;
  }
}

module.exports = UniqueViolationError;

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const postgres = __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/parser.js");
const sqlite = __webpack_require__("./node_modules/db-errors/lib/parsers/sqlite/DBError/parser.js");
const mysql = __webpack_require__("./node_modules/db-errors/lib/parsers/mysql/DBError/parser.js");
const mssql = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/parser.js");

module.exports = {
  postgres,
  sqlite,
  mysql,
  mssql,
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/CheckViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CheckViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/CheckViolationError.js");
const { isCode } = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/util.js");

const REGEX = /The (INSERT|UPDATE) statement conflicted with the CHECK constraint "(.+)". The conflict occurred in database "(.+)", table "(.+)", column '(.+)'./

module.exports = {
  error: CheckViolationError,

  parse: (err) => {
    if (isCode(err, 16, 547)) {
      const match = REGEX.exec(err.originalError.message);

      if (!match) {
        return null;
      }

      return {
        table: match[3],
        constraint: match[1]
      };
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/DataError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DataError = __webpack_require__("./node_modules/db-errors/lib/errors/DataError.js");
const { isCode } = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/util.js");

module.exports = {
  error: DataError,

  parse: (err) => {
    // 241 - Conversion failed when converting date and/or time from character string.
    // 242 - The conversion of a nvarchar data type to a datetime data type resulted in an out-of-range value.
    // 245 - Conversion failed when converting the nvarchar value 'lol' to data type int.
    // 8152 - String or binary data would be truncated.
    if (isCode(err, 16, 241) || isCode(err, 16, 242) || isCode(err, 16, 245) || isCode(err, 16, 8152)) {
      return {};
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/ForeignKeyViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ForeignKeyViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ForeignKeyViolationError.js");
const { isCode } = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/util.js");

const INSERT_UPDATE_REGEX = /The (?:INSERT|UPDATE) statement conflicted with the FOREIGN KEY constraint "(.+)". The conflict occurred in database "(.+)", table "(.+)\.(.+)", column '(.+)'./;
const DELETE_REGEX = /The DELETE statement conflicted with the REFERENCE constraint "(.+)". The conflict occurred in database "(.+)", table "(.+)\.(.+)", column '(.+)'./;

module.exports = {
  error: ForeignKeyViolationError,

  parse: (err) => {
    if (isCode(err, 16, 547)) {
      const insertUpdateMatch = INSERT_UPDATE_REGEX.exec(err.originalError.message);

      if (insertUpdateMatch) {
        return {
          table: insertUpdateMatch[4],
          schema: insertUpdateMatch[3],
          constraint: insertUpdateMatch[1],
        };
      }

      const deleteMatch = DELETE_REGEX.exec(err.originalError.message);

      if (deleteMatch) {
        return {
          table: deleteMatch[4],
          schema: deleteMatch[3],
          constraint: deleteMatch[1],
        };
      }
    }

    return null;
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/NotNullViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const NotNullViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/NotNullViolationError.js");
const { isCode } = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/util.js");

const REGEX = /Cannot insert the value NULL into column '(.+)', table '(.+)\.(.+)\.(.+)'; column does not allow nulls. (?:INSERT|UPDATE) fails./;

module.exports = {
  error: NotNullViolationError,

  parse: (err) => {
    if (isCode(err, 16, 515) || isCode(err, 16, 50000)) {
      const match = REGEX.exec(err.originalError.message);

      if (!match) {
        return null;
      }

      return {
        column: match[1],
        database: match[2],
        schema: match[3],
        table: match[4],
      };
    } else {
      return null;
    }
  },

  subclassParsers: []
};


/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/UniqueViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const UniqueViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/UniqueViolationError.js");
const { isCode } = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/util.js");

const UNIQUE_INDEX_REGEX = /Cannot insert duplicate key row in object '(.+)\.(.+)' with unique index '(.+)'. The duplicate key value is (.+)./;
const UNIQUE_CONSTRAINT_REGEX = /Violation of UNIQUE KEY constraint '(.+)'. Cannot insert duplicate key in object '(.+)\.(.+)'. The duplicate key value is \((.+)\)/;

// 2601 - Violation in unique index
// 2627 - Violation in unique constraint (although it is implemented using unique index)

module.exports = {
  error: UniqueViolationError,

  parse: (err) => {
    if (isCode(err, 14, 2627)) {
      const constraintMatch = UNIQUE_CONSTRAINT_REGEX.exec(err.originalError.message);

      if (!constraintMatch) {
        return null;
      }

      return {
        table: constraintMatch[3],
        schema: constraintMatch[2],
        constraint: constraintMatch[1]
      };
    }

    // TODO: this case is missing a test
    if (isCode(err, 14, 2601)) {
      const indexMatch = UNIQUE_INDEX_REGEX.exec(err.originalError.message);

      if (!indexMatch) {
        return null;
      }

      return {
        table: indexMatch[2],
        constraint: indexMatch[3],
        schema: indexMatch[1],
      };
    }

    return null;
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");
const errorCodes = (__webpack_require__("./node_modules/db-errors/lib/errorCodes/index.js").mssql);
const { getCode } = __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/util.js");

module.exports = {
  error: DBError,

  parse: (err) => {
    if (err.originalError && err.code === 'EREQUEST' && errorCodes.has(getCode(err))) {
      return {
        nativeError: err.originalError,
        client: 'mssql'
      };
    }

    return null;
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/CheckViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/DataError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/ForeignKeyViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/NotNullViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mssql/DBError/UniqueViolationError/parser.js"),
  ]
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mssql/DBError/util.js":
/***/ ((module) => {

function getCode(error) {
  return {
    errorCode: error.originalError.info.number,
    severity: error.originalError.info.class,
  };
}

function isCode(error, severity, errorCode) {
  const code = getCode(error);

  if (code) {
    return code.errorCode === errorCode && code.severity === severity;
  }

  return false;
}

module.exports = {
  getCode,
  isCode,
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/ForeignKeyViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ForeignKeyViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ForeignKeyViolationError.js");

const NO_REFERENCED_REGEX = /a foreign key constraint fails \(`(.+)`\.`(.+)`, CONSTRAINT `(.+)` FOREIGN KEY \(`(.+)`\) REFERENCES `(.+)` \(`(.+)`\)/;
const ROW_IS_REFERENCED_REGEX = /Cannot delete or update a parent row: a foreign key constraint fails \(`(.+)`\.`(.+)`, CONSTRAINT `(.+)` FOREIGN KEY \(`(.+)`\) REFERENCES `(.+)` \(`(.+)`\)/;

module.exports = {
  error: ForeignKeyViolationError,

  parse: (err) => {
    let match = null;

    if (
      err.code === 'ER_NO_REFERENCED_ROW' ||
      err.code === 'ER_ROW_IS_REFERENCED'
    ) {
      // For these variants, there is no table or constraint information available.
      // These seem to be mostly thrown on mysql 8 when the db user doesn't have
      // priviledges to the parent table. There seems to be a bug however that
      // causes these generic errors to be thrown even in some cases where the
      // user DOES have priviledges.
      return {
        table: null,
        constraint:null
      };
    }

    if (err.code === 'ER_NO_REFERENCED_ROW_2') {
      match = NO_REFERENCED_REGEX.exec(err.sqlMessage);
    } else if (err.code === 'ER_ROW_IS_REFERENCED_2') {
      match = ROW_IS_REFERENCED_REGEX.exec(err.sqlMessage);
    }

    if (!match) {
      return null;
    }

    return {
      table: match[2],
      constraint: match[3]
    };
  },

  subclassParsers: []
};


/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/NotNullViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const NotNullViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/NotNullViolationError.js");

const COLUMN_REGEX_BAD_NULL_ERROR = /Column '(.+)' cannot be null/;
const COLUMN_REGEX_NO_DEFAULT_FOR_FIELD = /Field '(.+)' doesn't have a default value/;

module.exports = {
  error: NotNullViolationError,

  parse: (err) => {
    let columnMatch = null;

    if (err.code === 'ER_BAD_NULL_ERROR') {
      columnMatch = COLUMN_REGEX_BAD_NULL_ERROR.exec(err.sqlMessage);
    } else if (err.code === 'ER_NO_DEFAULT_FOR_FIELD') {
      columnMatch = COLUMN_REGEX_NO_DEFAULT_FOR_FIELD.exec(err.sqlMessage);
    }

    if (!columnMatch) {
      return null;
    }

    // No way to reliably get `table` from mysql error.
    return {
      column: columnMatch[1]
    };
  },

  subclassParsers: []
};


/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/UniqueViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const UniqueViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/UniqueViolationError.js");

const CODES = ['ER_DUP_ENTRY', 'ER_DUP_ENTRY_WITH_KEY_NAME'];
const CONSTRAINT_REGEX = /Duplicate entry '(.+)' for key '(.+)'/;

module.exports = {
  error: UniqueViolationError,

  parse: (err) => {
    if (CODES.indexOf(err.code) === -1) {
      return null;
    }

    const constraintMatch = CONSTRAINT_REGEX.exec(err.sqlMessage);

    if (!constraintMatch) {
      return null;
    }

    // No way to reliably get `table` and `columns` from mysql error.
    return {
      constraint: constraintMatch[2]
    };
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");
const { getSqlStateClass } = __webpack_require__("./node_modules/db-errors/lib/utils/sqlState.js");

module.exports = {
  error: ConstraintViolationError,

  parse: (err) => {
    if (getSqlStateClass(err.sqlState) === '23' || err.code === 'ER_NO_DEFAULT_FOR_FIELD') {
      return {};
    } else {
      return null;
    }
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/UniqueViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/NotNullViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/ForeignKeyViolationError/parser.js")
  ]
};


/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mysql/DBError/DataError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DataError = __webpack_require__("./node_modules/db-errors/lib/errors/DataError.js");
const { getSqlStateClass } = __webpack_require__("./node_modules/db-errors/lib/utils/sqlState.js");

const ERROR_CODES = [
  'ER_DATA_TOO_LONG',
  'ER_TRUNCATED_WRONG_VALUE',
  'ER_TRUNCATED_WRONG_VALUE_FOR_FIELD'
];

module.exports = {
  error: DataError,

  parse: (err) => {
    // MySQL mainly uses the SQLSTATE codes, but some errors don't have
    // an SQLSTATE equivalent.
    if (getSqlStateClass(err.sqlState) === '22' || ERROR_CODES.includes(err.code)) {
      return {};
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/mysql/DBError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");
const errorCodes = (__webpack_require__("./node_modules/db-errors/lib/errorCodes/index.js").mysql);

module.exports = {
  error: DBError,

  parse: (err) => {
    if (typeof err.code === 'string'
      && 'sqlMessage' in err
      && 'sqlState' in err
      && err.sqlState.length === 5
      && errorCodes.has(err.code)
      && typeof err.errno === 'number') {

      return {
        nativeError: err,
        client: 'mysql'
      };
    }

    return null;
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/mysql/DBError/ConstraintViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/mysql/DBError/DataError/parser.js")
  ]
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/CheckViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CheckViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/CheckViolationError.js");

module.exports = {
  error: CheckViolationError,

  parse: (err) => {
    if (err.code === '23514') {
      return {
        table: err.table,
        constraint: err.constraint
      };
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/ForeignKeyViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ForeignKeyViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ForeignKeyViolationError.js");

module.exports = {
  error: ForeignKeyViolationError,

  parse: (err) => {
    if (err.code === '23503') {
      return {
        table: err.table,
        constraint: err.constraint
      };
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/NotNullViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const NotNullViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/NotNullViolationError.js");

module.exports = {
  error: NotNullViolationError,

  parse: (err) => {
    if (err.code === '23502') {
      return {
        table: err.table,
        column: err.column
      };
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/UniqueViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const UniqueViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/UniqueViolationError.js");

const UNIQUE_COLUMNS_REGEX = /Key \((.+)\)=\(.+\) already exists/;

module.exports = {
  error: UniqueViolationError,

  parse: (err) => {
    if (err.code !== '23505') {
      return null;
    }

    const colsMatch = UNIQUE_COLUMNS_REGEX.exec(err.detail);

    if (!colsMatch) {
      return null;
    }

    const cols = colsMatch[1]
      .split(',')
      .map(it => it.trim())
      .map(it => stripQuotes(it));

    return {
      table: err.table,
      columns: cols,
      constraint: err.constraint
    };
  },

  subclassParsers: []
};

function stripQuotes(it) {
  if (it[0] === '"' && it[it.length - 1] === '"') {
    return it.substr(1, it.length - 2);
  } else {
    return it;
  }
}

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");
const { getSqlStateClass } = __webpack_require__("./node_modules/db-errors/lib/utils/sqlState.js");

module.exports = {
  error: ConstraintViolationError,

  parse: (err) => {
    if (getSqlStateClass(err.code) === '23') {
      return {};
    } else {
      return null;
    }
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/UniqueViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/NotNullViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/ForeignKeyViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/CheckViolationError/parser.js")
  ]
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/DataError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DataError = __webpack_require__("./node_modules/db-errors/lib/errors/DataError.js");
const { getSqlStateClass } = __webpack_require__("./node_modules/db-errors/lib/utils/sqlState.js");

module.exports = {
  error: DataError,

  parse: (err) => {
    if (getSqlStateClass(err.code) === '22') {
      return {};
    } else {
      return null;
    }
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/postgres/DBError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");
const errorCodes = (__webpack_require__("./node_modules/db-errors/lib/errorCodes/index.js").postgres);

module.exports = {
  error: DBError,

  parse: (err) => {
    if (typeof err.code === 'string'
      && err.code.length === 5
      && errorCodes.has(err.code)
      && 'internalQuery' in err
      && 'table' in err) {

      return {
        nativeError: err,
        client: 'postgres'
      };
    }

    return null;
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/ConstraintViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/postgres/DBError/DataError/parser.js")
  ]
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/CheckViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CheckViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/CheckViolationError.js");

const REGEX = /SQLITE_CONSTRAINT: CHECK constraint failed/;

module.exports = {
  error: CheckViolationError,

  parse: (err) => {
    const match = REGEX.exec(err.message);

    if (!match) {
      return null;
    }

    // No way to extract anything reliably.
    return {};
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/ForeignKeyViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ForeignKeyViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ForeignKeyViolationError.js");

const REGEX = /SQLITE_CONSTRAINT: FOREIGN KEY constraint failed/;

module.exports = {
  error: ForeignKeyViolationError,

  parse: (err) => {
    const match = REGEX.exec(err.message);

    if (!match) {
      return null;
    }

    // No way to extract anything reliably.
    return {};
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/NotNullViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const NotNullViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/NotNullViolationError.js");

const NOT_COLUMN_REGEX = /SQLITE_CONSTRAINT: NOT NULL constraint failed: (.+)$/;

module.exports = {
  error: NotNullViolationError,

  parse: (err) => {
    const colMatch = NOT_COLUMN_REGEX.exec(err.message);

    if (!colMatch) {
      return null;
    }

    const parts = colMatch[1]
      .trim()
      .split('.')
      .map(it => it.trim());

    return {
      table: parts[0],
      column: parts[1]
    };
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/UniqueViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const UniqueViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/UniqueViolationError.js");

const UNIQUE_COLUMNS_REGEX = /SQLITE_CONSTRAINT: UNIQUE constraint failed: (.+)$/;

module.exports = {
  error: UniqueViolationError,

  parse: (err) => {
    const colsMatch = UNIQUE_COLUMNS_REGEX.exec(err.message);

    if (!colsMatch) {
      return null;
    }

    const cols = colsMatch[1]
      .split(',')
      .map(it => it.trim())
      .map(it => it.split('.'))
      .map(it => it.map(it => it.trim()))

    return {
      table: cols[0][0],
      columns: cols.map(it => it[1])
    };
  },

  subclassParsers: []
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ConstraintViolationError = __webpack_require__("./node_modules/db-errors/lib/errors/ConstraintViolationError.js");

module.exports = {
  error: ConstraintViolationError,

  parse: (err) => {
    if (err.code === 'SQLITE_CONSTRAINT') {
      return {};
    } else {
      return null;
    }
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/UniqueViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/NotNullViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/ForeignKeyViolationError/parser.js"),
    __webpack_require__("./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/CheckViolationError/parser.js")
  ]
};

/***/ }),

/***/ "./node_modules/db-errors/lib/parsers/sqlite/DBError/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DBError = __webpack_require__("./node_modules/db-errors/lib/errors/DBError.js");

module.exports = {
  error: DBError,

  parse: (err) => {
    if (typeof err.code === 'string'
      && err.code.startsWith('SQLITE_')
      && typeof err.errno === 'number') {

      return {
        nativeError: err,
        client: 'sqlite'
      };
    }

    return null;
  },

  subclassParsers: [
    __webpack_require__("./node_modules/db-errors/lib/parsers/sqlite/DBError/ConstraintViolationError/parser.js")
  ]
};

/***/ }),

/***/ "./node_modules/db-errors/lib/utils/sqlState.js":
/***/ ((module) => {

function getSqlStateClass(sqlState) {
  return sqlState.substr(0, 2);
}

module.exports = {
  getSqlStateClass
};

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__("./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/debug/src/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("./node_modules/debug/src/node.js");


/***/ }),

/***/ "./node_modules/debug/src/node.js":
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__("tty");
const util = __webpack_require__("util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = null;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__("./node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__("./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "./node_modules/dotenv/lib/main.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__("fs")
const path = __webpack_require__("path")
const os = __webpack_require__("os")
const crypto = __webpack_require__("crypto")
const packageJson = __webpack_require__("./node_modules/dotenv/package.json")

const version = packageJson.version

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
function parse (src) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n')
      value = value.replace(/\\r/g, '\r')
    }

    // Add to object
    obj[key] = value
  }

  return obj
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options)

  // Parse .env.vault
  const result = DotenvModule.configDotenv({ path: vaultPath })
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)
    err.code = 'MISSING_DATA'
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',')
  const length = keys.length

  let decrypted
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim()

      // Get instructions for decrypt
      const attrs = _instructions(result, key)

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _log (message) {
  console.log(`[dotenv@${version}][INFO] ${message}`)
}

function _warn (message) {
  console.log(`[dotenv@${version}][WARN] ${message}`)
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`)
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'
    throw err
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let possibleVaultPath = null

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  _log('Loading env from encrypted .env.vault')

  const parsed = DotenvModule._parseVault(options)

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding = 'utf8'
  const debug = Boolean(options && options.debug)

  if (options && options.encoding) {
    encoding = options.encoding
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default')
    }
  }

  let optionPaths = [dotenvPath] // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)]
    } else {
      optionPaths = [] // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath))
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError
  const parsedAll = {}
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))

      DotenvModule.populate(parsedAll, parsed, options)
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`)
      }
      lastError = e
    }
  }

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsedAll, options)

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options)

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')

  const nonce = ciphertext.subarray(0, 12)
  const authTag = ciphertext.subarray(-16)
  ciphertext = ciphertext.subarray(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError
    const invalidKeyLength = error.message === 'Invalid key length'
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')
      err.code = 'DECRYPTION_FAILED'
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug)
  const override = Boolean(options && options.override)

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')
    err.code = 'OBJECT_REQUIRED'
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key]
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`)
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`)
        }
      }
    } else {
      processEnv[key] = parsed[key]
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports.configDotenv = DotenvModule.configDotenv
module.exports._configVault = DotenvModule._configVault
module.exports._parseVault = DotenvModule._parseVault
module.exports.config = DotenvModule.config
module.exports.decrypt = DotenvModule.decrypt
module.exports.parse = DotenvModule.parse
module.exports.populate = DotenvModule.populate

module.exports = DotenvModule


/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/fast-uri/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = __webpack_require__("./node_modules/fast-uri/lib/utils.js")
const SCHEMES = __webpack_require__("./node_modules/fast-uri/lib/schemes.js")

function normalize (uri, options) {
  if (typeof uri === 'string') {
    uri = serialize(parse(uri, options), options)
  } else if (typeof uri === 'object') {
    uri = parse(serialize(uri, options), options)
  }
  return uri
}

function resolve (baseURI, relativeURI, options) {
  const schemelessOptions = Object.assign({ scheme: 'null' }, options)
  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)
  return serialize(resolved, { ...schemelessOptions, skipEscape: true })
}

function resolveComponents (base, relative, options, skipNormalization) {
  const target = {}
  if (!skipNormalization) {
    base = parse(serialize(base, options), options) // normalize base components
    relative = parse(serialize(relative, options), options) // normalize relative components
  }
  options = options || {}

  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme
    // target.authority = relative.authority;
    target.userinfo = relative.userinfo
    target.host = relative.host
    target.port = relative.port
    target.path = removeDotSegments(relative.path || '')
    target.query = relative.query
  } else {
    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
      // target.authority = relative.authority;
      target.userinfo = relative.userinfo
      target.host = relative.host
      target.port = relative.port
      target.path = removeDotSegments(relative.path || '')
      target.query = relative.query
    } else {
      if (!relative.path) {
        target.path = base.path
        if (relative.query !== undefined) {
          target.query = relative.query
        } else {
          target.query = base.query
        }
      } else {
        if (relative.path.charAt(0) === '/') {
          target.path = removeDotSegments(relative.path)
        } else {
          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
            target.path = '/' + relative.path
          } else if (!base.path) {
            target.path = relative.path
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path
          }
          target.path = removeDotSegments(target.path)
        }
        target.query = relative.query
      }
      // target.authority = base.authority;
      target.userinfo = base.userinfo
      target.host = base.host
      target.port = base.port
    }
    target.scheme = base.scheme
  }

  target.fragment = relative.fragment

  return target
}

function equal (uriA, uriB, options) {
  if (typeof uriA === 'string') {
    uriA = unescape(uriA)
    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })
  } else if (typeof uriA === 'object') {
    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })
  }

  if (typeof uriB === 'string') {
    uriB = unescape(uriB)
    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })
  } else if (typeof uriB === 'object') {
    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })
  }

  return uriA.toLowerCase() === uriB.toLowerCase()
}

function serialize (cmpts, opts) {
  const components = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ''
  }
  const options = Object.assign({}, opts)
  const uriTokens = []

  // find scheme handler
  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]

  // perform scheme specific serialization
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)

  if (components.path !== undefined) {
    if (!options.skipEscape) {
      components.path = escape(components.path)

      if (components.scheme !== undefined) {
        components.path = components.path.split('%3A').join(':')
      }
    } else {
      components.path = unescape(components.path)
    }
  }

  if (options.reference !== 'suffix' && components.scheme) {
    uriTokens.push(components.scheme, ':')
  }

  const authority = recomposeAuthority(components, options)
  if (authority !== undefined) {
    if (options.reference !== 'suffix') {
      uriTokens.push('//')
    }

    uriTokens.push(authority)

    if (components.path && components.path.charAt(0) !== '/') {
      uriTokens.push('/')
    }
  }
  if (components.path !== undefined) {
    let s = components.path

    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s = removeDotSegments(s)
    }

    if (authority === undefined) {
      s = s.replace(/^\/\//u, '/%2F') // don't allow the path to start with "//"
    }

    uriTokens.push(s)
  }

  if (components.query !== undefined) {
    uriTokens.push('?', components.query)
  }

  if (components.fragment !== undefined) {
    uriTokens.push('#', components.fragment)
  }
  return uriTokens.join('')
}

const hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))

function nonSimpleDomain (value) {
  let code = 0
  for (let i = 0, len = value.length; i < len; ++i) {
    code = value.charCodeAt(i)
    if (code > 126 || hexLookUp[code]) {
      return true
    }
  }
  return false
}

const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u

function parse (uri, opts) {
  const options = Object.assign({}, opts)
  const parsed = {
    scheme: undefined,
    userinfo: undefined,
    host: '',
    port: undefined,
    path: '',
    query: undefined,
    fragment: undefined
  }
  const gotEncoding = uri.indexOf('%') !== -1
  let isIP = false
  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri

  const matches = uri.match(URI_PARSE)

  if (matches) {
    // store each component
    parsed.scheme = matches[1]
    parsed.userinfo = matches[3]
    parsed.host = matches[4]
    parsed.port = parseInt(matches[5], 10)
    parsed.path = matches[6] || ''
    parsed.query = matches[7]
    parsed.fragment = matches[8]

    // fix port number
    if (isNaN(parsed.port)) {
      parsed.port = matches[5]
    }
    if (parsed.host) {
      const ipv4result = normalizeIPv4(parsed.host)
      if (ipv4result.isIPV4 === false) {
        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })
        parsed.host = ipv6result.host.toLowerCase()
        isIP = ipv6result.isIPV6
      } else {
        parsed.host = ipv4result.host
        isIP = true
      }
    }
    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {
      parsed.reference = 'same-document'
    } else if (parsed.scheme === undefined) {
      parsed.reference = 'relative'
    } else if (parsed.fragment === undefined) {
      parsed.reference = 'absolute'
    } else {
      parsed.reference = 'uri'
    }

    // check for reference errors
    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'
    }

    // find scheme handler
    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]

    // check if scheme can't handle IRIs
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      // if host component is a domain name
      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
        // convert Unicode IDN -> ASCII IDN
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())
        } catch (e) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e
        }
      }
      // convert IRI -> URI
    }

    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
      if (gotEncoding && parsed.scheme !== undefined) {
        parsed.scheme = unescape(parsed.scheme)
      }
      if (gotEncoding && parsed.host !== undefined) {
        parsed.host = unescape(parsed.host)
      }
      if (parsed.path !== undefined && parsed.path.length) {
        parsed.path = escape(unescape(parsed.path))
      }
      if (parsed.fragment !== undefined && parsed.fragment.length) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))
      }
    }

    // perform scheme specific parsing
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options)
    }
  } else {
    parsed.error = parsed.error || 'URI can not be parsed.'
  }
  return parsed
}

const fastUri = {
  SCHEMES,
  normalize,
  resolve,
  resolveComponents,
  equal,
  serialize,
  parse
}

module.exports = fastUri
module.exports["default"] = fastUri
module.exports.fastUri = fastUri


/***/ }),

/***/ "./node_modules/fast-uri/lib/schemes.js":
/***/ ((module) => {

"use strict";


const UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu

function isSecure (wsComponents) {
  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'
}

function httpParse (components) {
  if (!components.host) {
    components.error = components.error || 'HTTP URIs must have a host.'
  }

  return components
}

function httpSerialize (components) {
  const secure = String(components.scheme).toLowerCase() === 'https'

  // normalize the default port
  if (components.port === (secure ? 443 : 80) || components.port === '') {
    components.port = undefined
  }

  // normalize the empty path
  if (!components.path) {
    components.path = '/'
  }

  // NOTE: We do not parse query strings for HTTP URIs
  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
  // and not the HTTP spec.

  return components
}

function wsParse (wsComponents) {
// indicate if the secure flag is set
  wsComponents.secure = isSecure(wsComponents)

  // construct resouce name
  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')
  wsComponents.path = undefined
  wsComponents.query = undefined

  return wsComponents
}

function wsSerialize (wsComponents) {
// normalize the default port
  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {
    wsComponents.port = undefined
  }

  // ensure scheme matches secure flag
  if (typeof wsComponents.secure === 'boolean') {
    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')
    wsComponents.secure = undefined
  }

  // reconstruct path from resource name
  if (wsComponents.resourceName) {
    const [path, query] = wsComponents.resourceName.split('?')
    wsComponents.path = (path && path !== '/' ? path : undefined)
    wsComponents.query = query
    wsComponents.resourceName = undefined
  }

  // forbid fragment component
  wsComponents.fragment = undefined

  return wsComponents
}

function urnParse (urnComponents, options) {
  if (!urnComponents.path) {
    urnComponents.error = 'URN can not be parsed'
    return urnComponents
  }
  const matches = urnComponents.path.match(URN_REG)
  if (matches) {
    const scheme = options.scheme || urnComponents.scheme || 'urn'
    urnComponents.nid = matches[1].toLowerCase()
    urnComponents.nss = matches[2]
    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`
    const schemeHandler = SCHEMES[urnScheme]
    urnComponents.path = undefined

    if (schemeHandler) {
      urnComponents = schemeHandler.parse(urnComponents, options)
    }
  } else {
    urnComponents.error = urnComponents.error || 'URN can not be parsed.'
  }

  return urnComponents
}

function urnSerialize (urnComponents, options) {
  const scheme = options.scheme || urnComponents.scheme || 'urn'
  const nid = urnComponents.nid.toLowerCase()
  const urnScheme = `${scheme}:${options.nid || nid}`
  const schemeHandler = SCHEMES[urnScheme]

  if (schemeHandler) {
    urnComponents = schemeHandler.serialize(urnComponents, options)
  }

  const uriComponents = urnComponents
  const nss = urnComponents.nss
  uriComponents.path = `${nid || options.nid}:${nss}`

  options.skipEscape = true
  return uriComponents
}

function urnuuidParse (urnComponents, options) {
  const uuidComponents = urnComponents
  uuidComponents.uuid = uuidComponents.nss
  uuidComponents.nss = undefined

  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'
  }

  return uuidComponents
}

function urnuuidSerialize (uuidComponents) {
  const urnComponents = uuidComponents
  // normalize UUID
  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()
  return urnComponents
}

const http = {
  scheme: 'http',
  domainHost: true,
  parse: httpParse,
  serialize: httpSerialize
}

const https = {
  scheme: 'https',
  domainHost: http.domainHost,
  parse: httpParse,
  serialize: httpSerialize
}

const ws = {
  scheme: 'ws',
  domainHost: true,
  parse: wsParse,
  serialize: wsSerialize
}

const wss = {
  scheme: 'wss',
  domainHost: ws.domainHost,
  parse: ws.parse,
  serialize: ws.serialize
}

const urn = {
  scheme: 'urn',
  parse: urnParse,
  serialize: urnSerialize,
  skipNormalize: true
}

const urnuuid = {
  scheme: 'urn:uuid',
  parse: urnuuidParse,
  serialize: urnuuidSerialize,
  skipNormalize: true
}

const SCHEMES = {
  http,
  https,
  ws,
  wss,
  urn,
  'urn:uuid': urnuuid
}

module.exports = SCHEMES


/***/ }),

/***/ "./node_modules/fast-uri/lib/scopedChars.js":
/***/ ((module) => {

"use strict";


const HEX = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
}

module.exports = {
  HEX
}


/***/ }),

/***/ "./node_modules/fast-uri/lib/utils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { HEX } = __webpack_require__("./node_modules/fast-uri/lib/scopedChars.js")

function normalizeIPv4 (host) {
  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }
  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []
  const [address] = matches
  if (address) {
    return { host: stripLeadingZeros(address, '.'), isIPV4: true }
  } else {
    return { host, isIPV4: false }
  }
}

/**
 * @param {string[]} input
 * @param {boolean} [keepZero=false]
 * @returns {string|undefined}
 */
function stringArrayToHexStripped (input, keepZero = false) {
  let acc = ''
  let strip = true
  for (const c of input) {
    if (HEX[c] === undefined) return undefined
    if (c !== '0' && strip === true) strip = false
    if (!strip) acc += c
  }
  if (keepZero && acc.length === 0) acc = '0'
  return acc
}

function getIPV6 (input) {
  let tokenCount = 0
  const output = { error: false, address: '', zone: '' }
  const address = []
  const buffer = []
  let isZone = false
  let endipv6Encountered = false
  let endIpv6 = false

  function consume () {
    if (buffer.length) {
      if (isZone === false) {
        const hex = stringArrayToHexStripped(buffer)
        if (hex !== undefined) {
          address.push(hex)
        } else {
          output.error = true
          return false
        }
      }
      buffer.length = 0
    }
    return true
  }

  for (let i = 0; i < input.length; i++) {
    const cursor = input[i]
    if (cursor === '[' || cursor === ']') { continue }
    if (cursor === ':') {
      if (endipv6Encountered === true) {
        endIpv6 = true
      }
      if (!consume()) { break }
      tokenCount++
      address.push(':')
      if (tokenCount > 7) {
        // not valid
        output.error = true
        break
      }
      if (i - 1 >= 0 && input[i - 1] === ':') {
        endipv6Encountered = true
      }
      continue
    } else if (cursor === '%') {
      if (!consume()) { break }
      // switch to zone detection
      isZone = true
    } else {
      buffer.push(cursor)
      continue
    }
  }
  if (buffer.length) {
    if (isZone) {
      output.zone = buffer.join('')
    } else if (endIpv6) {
      address.push(buffer.join(''))
    } else {
      address.push(stringArrayToHexStripped(buffer))
    }
  }
  output.address = address.join('')
  return output
}

function normalizeIPv6 (host, opts = {}) {
  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
  const ipv6 = getIPV6(host)

  if (!ipv6.error) {
    let newHost = ipv6.address
    let escapedHost = ipv6.address
    if (ipv6.zone) {
      newHost += '%' + ipv6.zone
      escapedHost += '%25' + ipv6.zone
    }
    return { host: newHost, escapedHost, isIPV6: true }
  } else {
    return { host, isIPV6: false }
  }
}

function stripLeadingZeros (str, token) {
  let out = ''
  let skip = true
  const l = str.length
  for (let i = 0; i < l; i++) {
    const c = str[i]
    if (c === '0' && skip) {
      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {
        out += c
        skip = false
      }
    } else {
      if (c === token) {
        skip = true
      } else {
        skip = false
      }
      out += c
    }
  }
  return out
}

function findToken (str, token) {
  let ind = 0
  for (let i = 0; i < str.length; i++) {
    if (str[i] === token) ind++
  }
  return ind
}

const RDS1 = /^\.\.?\//u
const RDS2 = /^\/\.(?:\/|$)/u
const RDS3 = /^\/\.\.(?:\/|$)/u
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u

function removeDotSegments (input) {
  const output = []

  while (input.length) {
    if (input.match(RDS1)) {
      input = input.replace(RDS1, '')
    } else if (input.match(RDS2)) {
      input = input.replace(RDS2, '/')
    } else if (input.match(RDS3)) {
      input = input.replace(RDS3, '/')
      output.pop()
    } else if (input === '.' || input === '..') {
      input = ''
    } else {
      const im = input.match(RDS5)
      if (im) {
        const s = im[0]
        input = input.slice(s.length)
        output.push(s)
      } else {
        throw new Error('Unexpected dot segment condition')
      }
    }
  }
  return output.join('')
}

function normalizeComponentEncoding (components, esc) {
  const func = esc !== true ? escape : unescape
  if (components.scheme !== undefined) {
    components.scheme = func(components.scheme)
  }
  if (components.userinfo !== undefined) {
    components.userinfo = func(components.userinfo)
  }
  if (components.host !== undefined) {
    components.host = func(components.host)
  }
  if (components.path !== undefined) {
    components.path = func(components.path)
  }
  if (components.query !== undefined) {
    components.query = func(components.query)
  }
  if (components.fragment !== undefined) {
    components.fragment = func(components.fragment)
  }
  return components
}

function recomposeAuthority (components, options) {
  const uriTokens = []

  if (components.userinfo !== undefined) {
    uriTokens.push(components.userinfo)
    uriTokens.push('@')
  }

  if (components.host !== undefined) {
    let host = unescape(components.host)
    const ipV4res = normalizeIPv4(host)

    if (ipV4res.isIPV4) {
      host = ipV4res.host
    } else {
      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`
      } else {
        host = components.host
      }
    }
    uriTokens.push(host)
  }

  if (typeof components.port === 'number' || typeof components.port === 'string') {
    uriTokens.push(':')
    uriTokens.push(String(components.port))
  }

  return uriTokens.length ? uriTokens.join('') : undefined
};

module.exports = {
  recomposeAuthority,
  normalizeComponentEncoding,
  removeDotSegments,
  normalizeIPv4,
  normalizeIPv6,
  stringArrayToHexStripped
}


/***/ }),

/***/ "./node_modules/has-flag/index.js":
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reactIs = __webpack_require__("./node_modules/hoist-non-react-statics/node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "./node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),

/***/ "./node_modules/hoist-non-react-statics/node_modules/react-is/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__("./node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js");
} else {}


/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__("util");
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__("./node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/***/ ((module) => {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


/***/ }),

/***/ "./node_modules/knex/knex.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Knex.js
// --------------
//     (c) 2013-present Tim Griesser
//     Knex may be freely distributed under the MIT license.
//     For details and documentation:
//     http://knexjs.org

const knex = __webpack_require__("./node_modules/knex/lib/index.js");

/**
 * These export configurations enable JS and TS developers
 * to consume knex in whatever way best suits their needs.
 * Some examples of supported import syntax includes:
 * - `const knex = require('knex')`
 * - `const { knex } = require('knex')`
 * - `import * as knex from 'knex'`
 * - `import { knex } from 'knex'`
 * - `import knex from 'knex'`
 */
knex.knex = knex;
knex.default = knex;

module.exports = knex;


/***/ }),

/***/ "./node_modules/knex/lib/builder-interface-augmenter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const clone = __webpack_require__("./node_modules/lodash/clone.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");
const { callbackify } = __webpack_require__("util");
const finallyMixin = __webpack_require__("./node_modules/knex/lib/util/finally-mixin.js");
const { formatQuery } = __webpack_require__("./node_modules/knex/lib/execution/internal/query-executioner.js");

function augmentWithBuilderInterface(Target) {
  Target.prototype.toQuery = function (tz) {
    let data = this.toSQL(this._method, tz);
    if (!Array.isArray(data)) data = [data];
    if (!data.length) {
      return '';
    }

    return data
      .map((statement) => {
        return formatQuery(statement.sql, statement.bindings, tz, this.client);
      })
      .reduce((a, c) => a.concat(a.endsWith(';') ? '\n' : ';\n', c));
  };

  // Create a new instance of the `Runner`, passing in the current object.
  Target.prototype.then = function (/* onFulfilled, onRejected */) {
    let result = this.client.runner(this).run();

    if (this.client.config.asyncStackTraces) {
      result = result.catch((err) => {
        err.originalStack = err.stack;
        const firstLine = err.stack.split('\n')[0];

        // a hack to get a callstack into the client code despite this
        // node.js bug https://github.com/nodejs/node/issues/11865
        // see lib/util/save-async-stack.js for more details
        const { error, lines } = this._asyncStack;
        const stackByLines = error.stack.split('\n');
        const asyncStack = stackByLines.slice(lines);
        asyncStack.unshift(firstLine);

        // put the fake more helpful "async" stack on the thrown error
        err.stack = asyncStack.join('\n');
        throw err;
      });
    }

    return result.then.apply(result, arguments);
  };

  // Add additional "options" to the builder. Typically used for client specific
  // items, like the `mysql` and `sqlite3` drivers.
  Target.prototype.options = function (opts) {
    this._options = this._options || [];
    this._options.push(clone(opts) || {});
    return this;
  };

  // Sets an explicit "connection" we wish to use for this query.
  Target.prototype.connection = function (connection) {
    this._connection = connection;
    this.client.processPassedConnection(connection);
    return this;
  };

  // Set a debug flag for the current schema query stack.
  Target.prototype.debug = function (enabled) {
    this._debug = arguments.length ? enabled : true;
    return this;
  };

  // Set the transaction object for this query.
  Target.prototype.transacting = function (transaction) {
    if (transaction && transaction.client) {
      if (!transaction.client.transacting) {
        transaction.client.logger.warn(
          `Invalid transaction value: ${transaction.client}`
        );
      } else {
        this.client = transaction.client;
      }
    }
    if (isEmpty(transaction)) {
      this.client.logger.error(
        'Invalid value on transacting call, potential bug'
      );
      throw Error(
        'Invalid transacting value (null, undefined or empty object)'
      );
    }
    return this;
  };

  // Initializes a stream.
  Target.prototype.stream = function (options) {
    return this.client.runner(this).stream(options);
  };

  // Initialize a stream & pipe automatically.
  Target.prototype.pipe = function (writable, options) {
    return this.client.runner(this).pipe(writable, options);
  };

  Target.prototype.asCallback = function (cb) {
    const promise = this.then();
    callbackify(() => promise)(cb);
    return promise;
  };

  Target.prototype.catch = function (onReject) {
    return this.then().catch(onReject);
  };

  Object.defineProperty(Target.prototype, Symbol.toStringTag, {
    get: () => 'object',
  });

  finallyMixin(Target.prototype);
}

module.exports = {
  augmentWithBuilderInterface,
};


/***/ }),

/***/ "./node_modules/knex/lib/client.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Pool, TimeoutError } = __webpack_require__("./node_modules/tarn/dist/tarn.js");
const { EventEmitter } = __webpack_require__("events");
const { promisify } = __webpack_require__("util");
const { makeEscape } = __webpack_require__("./node_modules/knex/lib/util/string.js");
const cloneDeep = __webpack_require__("./node_modules/lodash/cloneDeep.js");
const defaults = __webpack_require__("./node_modules/lodash/defaults.js");
const uniqueId = __webpack_require__("./node_modules/lodash/uniqueId.js");

const Runner = __webpack_require__("./node_modules/knex/lib/execution/runner.js");
const Transaction = __webpack_require__("./node_modules/knex/lib/execution/transaction.js");
const {
  executeQuery,
  enrichQueryObject,
} = __webpack_require__("./node_modules/knex/lib/execution/internal/query-executioner.js");
const QueryBuilder = __webpack_require__("./node_modules/knex/lib/query/querybuilder.js");
const QueryCompiler = __webpack_require__("./node_modules/knex/lib/query/querycompiler.js");
const SchemaBuilder = __webpack_require__("./node_modules/knex/lib/schema/builder.js");
const SchemaCompiler = __webpack_require__("./node_modules/knex/lib/schema/compiler.js");
const TableBuilder = __webpack_require__("./node_modules/knex/lib/schema/tablebuilder.js");
const TableCompiler = __webpack_require__("./node_modules/knex/lib/schema/tablecompiler.js");
const ColumnBuilder = __webpack_require__("./node_modules/knex/lib/schema/columnbuilder.js");
const ColumnCompiler = __webpack_require__("./node_modules/knex/lib/schema/columncompiler.js");
const { KnexTimeoutError } = __webpack_require__("./node_modules/knex/lib/util/timeout.js");
const { outputQuery, unwrapRaw } = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");
const { compileCallback } = __webpack_require__("./node_modules/knex/lib/formatter/formatterUtils.js");
const Raw = __webpack_require__("./node_modules/knex/lib/raw.js");
const Ref = __webpack_require__("./node_modules/knex/lib/ref.js");
const Formatter = __webpack_require__("./node_modules/knex/lib/formatter.js");
const Logger = __webpack_require__("./node_modules/knex/lib/logger.js");
const { POOL_CONFIG_OPTIONS } = __webpack_require__("./node_modules/knex/lib/constants.js");
const ViewBuilder = __webpack_require__("./node_modules/knex/lib/schema/viewbuilder.js");
const ViewCompiler = __webpack_require__("./node_modules/knex/lib/schema/viewcompiler.js");
const isPlainObject = __webpack_require__("./node_modules/lodash/isPlainObject.js");
const { setHiddenProperty } = __webpack_require__("./node_modules/knex/lib/util/security.js");

const debug = __webpack_require__("./node_modules/debug/src/index.js")('knex:client');

// The base client provides the general structure
// for a dialect specific client object.

class Client extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
    this.logger = new Logger(config);

    if (this.config.connection && this.config.connection.password) {
      setHiddenProperty(this.config.connection);
    }

    //Client is a required field, so throw error if it's not supplied.
    //If 'this.dialect' is set, then this is a 'super()' call, in which case
    //'client' does not have to be set as it's already assigned on the client prototype.

    if (this.dialect && !this.config.client) {
      this.logger.warn(
        `Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.`
      );
    }

    const dbClient = this.config.client || this.dialect;
    if (!dbClient) {
      throw new Error(
        `knex: Required configuration option 'client' is missing.`
      );
    }

    if (config.version) {
      this.version = config.version;
    }

    if (config.connection && config.connection instanceof Function) {
      this.connectionConfigProvider = config.connection;
      this.connectionConfigExpirationChecker = () => true; // causes the provider to be called on first use
    } else {
      this.connectionSettings = cloneDeep(config.connection || {});
      if (config.connection && config.connection.password) {
        setHiddenProperty(this.connectionSettings, config.connection);
      }
      this.connectionConfigExpirationChecker = null;
    }
    if (this.driverName && config.connection) {
      this.initializeDriver();
      if (!config.pool || (config.pool && config.pool.max !== 0)) {
        this.initializePool(config);
      }
    }
    this.valueForUndefined = this.raw('DEFAULT');
    if (config.useNullAsDefault) {
      this.valueForUndefined = null;
    }
  }
  formatter(builder) {
    return new Formatter(this, builder);
  }

  queryBuilder() {
    return new QueryBuilder(this);
  }

  queryCompiler(builder, formatter) {
    return new QueryCompiler(this, builder, formatter);
  }

  schemaBuilder() {
    return new SchemaBuilder(this);
  }

  schemaCompiler(builder) {
    return new SchemaCompiler(this, builder);
  }

  tableBuilder(type, tableName, tableNameLike, fn) {
    return new TableBuilder(this, type, tableName, tableNameLike, fn);
  }

  viewBuilder(type, viewBuilder, fn) {
    return new ViewBuilder(this, type, viewBuilder, fn);
  }

  tableCompiler(tableBuilder) {
    return new TableCompiler(this, tableBuilder);
  }

  viewCompiler(viewCompiler) {
    return new ViewCompiler(this, viewCompiler);
  }

  columnBuilder(tableBuilder, type, args) {
    return new ColumnBuilder(this, tableBuilder, type, args);
  }

  columnCompiler(tableBuilder, columnBuilder) {
    return new ColumnCompiler(this, tableBuilder, columnBuilder);
  }

  runner(builder) {
    return new Runner(this, builder);
  }

  transaction(container, config, outerTx) {
    return new Transaction(this, container, config, outerTx);
  }

  raw() {
    return new Raw(this).set(...arguments);
  }

  ref() {
    return new Ref(this, ...arguments);
  }
  query(connection, queryParam) {
    const queryObject = enrichQueryObject(connection, queryParam, this);
    return executeQuery(connection, queryObject, this);
  }

  stream(connection, queryParam, stream, options) {
    const queryObject = enrichQueryObject(connection, queryParam, this);
    return this._stream(connection, queryObject, stream, options);
  }

  prepBindings(bindings) {
    return bindings;
  }

  positionBindings(sql) {
    return sql;
  }

  postProcessResponse(resp, queryContext) {
    if (this.config.postProcessResponse) {
      return this.config.postProcessResponse(resp, queryContext);
    }
    return resp;
  }

  wrapIdentifier(value, queryContext) {
    return this.customWrapIdentifier(
      value,
      this.wrapIdentifierImpl,
      queryContext
    );
  }

  customWrapIdentifier(value, origImpl, queryContext) {
    if (this.config.wrapIdentifier) {
      return this.config.wrapIdentifier(value, origImpl, queryContext);
    }
    return origImpl(value);
  }

  wrapIdentifierImpl(value) {
    return value !== '*' ? `"${value.replace(/"/g, '""')}"` : '*';
  }

  initializeDriver() {
    try {
      this.driver = this._driver();
    } catch (e) {
      const message = `Knex: run\n$ npm install ${this.driverName} --save`;
      this.logger.error(`${message}\n${e.message}\n${e.stack}`);
      throw new Error(`${message}\n${e.message}`);
    }
  }

  poolDefaults() {
    return { min: 2, max: 10, propagateCreateError: true };
  }

  getPoolSettings(poolConfig) {
    poolConfig = defaults({}, poolConfig, this.poolDefaults());

    POOL_CONFIG_OPTIONS.forEach((option) => {
      if (option in poolConfig) {
        this.logger.warn(
          [
            `Pool config option "${option}" is no longer supported.`,
            `See https://github.com/Vincit/tarn.js for possible pool config options.`,
          ].join(' ')
        );
      }
    });

    const DEFAULT_ACQUIRE_TIMEOUT = 60000;
    const timeouts = [
      this.config.acquireConnectionTimeout,
      poolConfig.acquireTimeoutMillis,
    ].filter((timeout) => timeout !== undefined);

    if (!timeouts.length) {
      timeouts.push(DEFAULT_ACQUIRE_TIMEOUT);
    }

    // acquire connection timeout can be set on config or config.pool
    // choose the smallest, positive timeout setting and set on poolConfig
    poolConfig.acquireTimeoutMillis = Math.min(...timeouts);

    const updatePoolConnectionSettingsFromProvider = async () => {
      if (!this.connectionConfigProvider) {
        return; // static configuration, nothing to update
      }
      if (
        !this.connectionConfigExpirationChecker ||
        !this.connectionConfigExpirationChecker()
      ) {
        return; // not expired, reuse existing connection
      }
      const providerResult = await this.connectionConfigProvider();
      if (providerResult.expirationChecker) {
        this.connectionConfigExpirationChecker =
          providerResult.expirationChecker;
        delete providerResult.expirationChecker; // MySQL2 driver warns on receiving extra properties
      } else {
        this.connectionConfigExpirationChecker = null;
      }
      this.connectionSettings = providerResult;
    };

    return Object.assign(poolConfig, {
      create: async () => {
        await updatePoolConnectionSettingsFromProvider();
        const connection = await this.acquireRawConnection();
        connection.__knexUid = uniqueId('__knexUid');
        if (poolConfig.afterCreate) {
          await promisify(poolConfig.afterCreate)(connection);
        }
        return connection;
      },

      destroy: (connection) => {
        if (connection !== void 0) {
          return this.destroyRawConnection(connection);
        }
      },

      validate: (connection) => {
        if (connection.__knex__disposed) {
          this.logger.warn(`Connection Error: ${connection.__knex__disposed}`);
          return false;
        }

        return this.validateConnection(connection);
      },
    });
  }

  initializePool(config = this.config) {
    if (this.pool) {
      this.logger.warn('The pool has already been initialized');
      return;
    }

    const tarnPoolConfig = {
      ...this.getPoolSettings(config.pool),
    };
    // afterCreate is an internal knex param, tarn.js does not support it
    if (tarnPoolConfig.afterCreate) {
      delete tarnPoolConfig.afterCreate;
    }

    this.pool = new Pool(tarnPoolConfig);
  }

  validateConnection(connection) {
    return true;
  }

  // Acquire a connection from the pool.
  async acquireConnection() {
    if (!this.pool) {
      throw new Error('Unable to acquire a connection');
    }
    try {
      const connection = await this.pool.acquire().promise;
      debug('acquired connection from pool: %s', connection.__knexUid);
      if (connection.config) {
        if (connection.config.password) {
          setHiddenProperty(connection.config);
        }
        if (
          connection.config.authentication &&
          connection.config.authentication.options &&
          connection.config.authentication.options.password
        ) {
          setHiddenProperty(connection.config.authentication.options);
        }
      }
      return connection;
    } catch (error) {
      let convertedError = error;
      if (error instanceof TimeoutError) {
        convertedError = new KnexTimeoutError(
          'Knex: Timeout acquiring a connection. The pool is probably full. ' +
            'Are you missing a .transacting(trx) call?'
        );
      }
      throw convertedError;
    }
  }

  // Releases a connection back to the connection pool,
  // returning a promise resolved when the connection is released.
  releaseConnection(connection) {
    debug('releasing connection to pool: %s', connection.__knexUid);
    const didRelease = this.pool.release(connection);

    if (!didRelease) {
      debug('pool refused connection: %s', connection.__knexUid);
    }

    return Promise.resolve();
  }

  // Destroy the current connection pool for the client.
  async destroy(callback) {
    try {
      if (this.pool && this.pool.destroy) {
        await this.pool.destroy();
      }
      this.pool = undefined;

      if (typeof callback === 'function') {
        callback();
      }
    } catch (err) {
      if (typeof callback === 'function') {
        return callback(err);
      }
      throw err;
    }
  }

  // Return the database being used by this client.
  database() {
    return this.connectionSettings.database;
  }

  toString() {
    return '[object KnexClient]';
  }

  assertCanCancelQuery() {
    if (!this.canCancelQuery) {
      throw new Error('Query cancelling not supported for this dialect');
    }
  }

  cancelQuery() {
    throw new Error('Query cancelling not supported for this dialect');
  }

  // Formatter part

  alias(first, second) {
    return first + ' as ' + second;
  }

  // Checks whether a value is a function... if it is, we compile it
  // otherwise we check whether it's a raw
  parameter(value, builder, bindingsHolder) {
    if (typeof value === 'function') {
      return outputQuery(
        compileCallback(value, undefined, this, bindingsHolder),
        true,
        builder,
        this
      );
    }
    return unwrapRaw(value, true, builder, this, bindingsHolder) || '?';
  }

  // Turns a list of values into a list of ?'s, joining them with commas unless
  // a "joining" value is specified (e.g. ' and ')
  parameterize(values, notSetValue, builder, bindingsHolder) {
    if (typeof values === 'function')
      return this.parameter(values, builder, bindingsHolder);
    values = Array.isArray(values) ? values : [values];
    let str = '',
      i = -1;
    while (++i < values.length) {
      if (i > 0) str += ', ';
      let value = values[i];
      // json columns can have object in values.
      if (isPlainObject(value)) {
        value = JSON.stringify(value);
      }
      str += this.parameter(
        value === undefined ? notSetValue : value,
        builder,
        bindingsHolder
      );
    }
    return str;
  }

  // Formats `values` into a parenthesized list of parameters for a `VALUES`
  // clause.
  //
  // [1, 2]                  -> '(?, ?)'
  // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'
  // knex('table')           -> '(select * from "table")'
  // knex.raw('select ?', 1) -> '(select ?)'
  //
  values(values, builder, bindingsHolder) {
    if (Array.isArray(values)) {
      if (Array.isArray(values[0])) {
        return `(${values
          .map(
            (value) =>
              `(${this.parameterize(
                value,
                undefined,
                builder,
                bindingsHolder
              )})`
          )
          .join(', ')})`;
      }
      return `(${this.parameterize(
        values,
        undefined,
        builder,
        bindingsHolder
      )})`;
    }

    if (values && values.isRawInstance) {
      return `(${this.parameter(values, builder, bindingsHolder)})`;
    }

    return this.parameter(values, builder, bindingsHolder);
  }

  processPassedConnection(connection) {
    // Default implementation is noop
  }

  toPathForJson(jsonPath) {
    // By default, we want a json path, so if this function is not overriden,
    // we return the path.
    return jsonPath;
  }
}

Object.assign(Client.prototype, {
  _escapeBinding: makeEscape({
    escapeString(str) {
      return `'${str.replace(/'/g, "''")}'`;
    },
  }),

  canCancelQuery: false,
});

module.exports = Client;


/***/ }),

/***/ "./node_modules/knex/lib/constants.js":
/***/ ((module) => {

// The client names we'll allow in the `{name: lib}` pairing.
const CLIENT_ALIASES = Object.freeze({
  pg: 'postgres',
  postgresql: 'postgres',
  sqlite: 'sqlite3',
});

const SUPPORTED_CLIENTS = Object.freeze(
  [
    'mssql',
    'mysql',
    'mysql2',
    'oracledb',
    'postgres',
    'pgnative',
    'redshift',
    'sqlite3',
    'cockroachdb',
    'better-sqlite3',
  ].concat(Object.keys(CLIENT_ALIASES))
);

const DRIVER_NAMES = Object.freeze({
  MsSQL: 'mssql',
  MySQL: 'mysql',
  MySQL2: 'mysql2',
  Oracle: 'oracledb',
  PostgreSQL: 'pg',
  PgNative: 'pgnative',
  Redshift: 'pg-redshift',
  SQLite: 'sqlite3',
  CockroachDB: 'cockroachdb',
  BetterSQLite3: 'better-sqlite3',
});

const POOL_CONFIG_OPTIONS = Object.freeze([
  'maxWaitingClients',
  'testOnBorrow',
  'fifo',
  'priorityRange',
  'autostart',
  'evictionRunIntervalMillis',
  'numTestsPerRun',
  'softIdleTimeoutMillis',
  'Promise',
]);

/**
 * Regex that only matches comma's in strings that aren't wrapped in parentheses. Can be used to
 * safely split strings like `id int, name string, body text, primary key (id, name)` into definition
 * rows
 */
const COMMA_NO_PAREN_REGEX = /,[\s](?![^(]*\))/g;

module.exports = {
  CLIENT_ALIASES,
  SUPPORTED_CLIENTS,
  POOL_CONFIG_OPTIONS,
  COMMA_NO_PAREN_REGEX,
  DRIVER_NAMES,
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/better-sqlite3/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// better-sqlite3 Client
// -------
const Client_SQLite3 = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/index.js");

class Client_BetterSQLite3 extends Client_SQLite3 {
  _driver() {
    return __webpack_require__("better-sqlite3");
  }

  // Get a raw connection from the database, returning a promise with the connection object.
  async acquireRawConnection() {
    const options = this.connectionSettings.options || {};

    return new this.driver(this.connectionSettings.filename, {
      nativeBinding: options.nativeBinding,
      readonly: !!options.readonly,
    });
  }

  // Used to explicitly close a connection, called internally by the pool when
  // a connection times out or the pool is shutdown.
  async destroyRawConnection(connection) {
    return connection.close();
  }

  // Runs the query on the specified connection, providing the bindings and any
  // other necessary prep work.
  async _query(connection, obj) {
    if (!obj.sql) throw new Error('The query is empty');

    if (!connection) {
      throw new Error('No connection provided');
    }

    const statement = connection.prepare(obj.sql);
    const bindings = this._formatBindings(obj.bindings);

    if (statement.reader) {
      const response = await statement.all(bindings);
      obj.response = response;
      return obj;
    }

    const response = await statement.run(bindings);
    obj.response = response;
    obj.context = {
      lastID: response.lastInsertRowid,
      changes: response.changes,
    };

    return obj;
  }

  _formatBindings(bindings) {
    if (!bindings) {
      return [];
    }
    return bindings.map((binding) => {
      if (binding instanceof Date) {
        return binding.valueOf();
      }

      if (typeof binding === 'boolean') {
        return Number(binding);
      }

      return binding;
    });
  }
}

Object.assign(Client_BetterSQLite3.prototype, {
  // The "dialect", for reference .
  driverName: 'better-sqlite3',
});

module.exports = Client_BetterSQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// MySQL Client
// -------
const defer = __webpack_require__("./node_modules/lodash/defer.js");
const map = __webpack_require__("./node_modules/lodash/map.js");
const { promisify } = __webpack_require__("util");
const Client = __webpack_require__("./node_modules/knex/lib/client.js");

const Transaction = __webpack_require__("./node_modules/knex/lib/dialects/mysql/transaction.js");
const QueryBuilder = __webpack_require__("./node_modules/knex/lib/dialects/mysql/query/mysql-querybuilder.js");
const QueryCompiler = __webpack_require__("./node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js");
const SchemaCompiler = __webpack_require__("./node_modules/knex/lib/dialects/mysql/schema/mysql-compiler.js");
const TableCompiler = __webpack_require__("./node_modules/knex/lib/dialects/mysql/schema/mysql-tablecompiler.js");
const ColumnCompiler = __webpack_require__("./node_modules/knex/lib/dialects/mysql/schema/mysql-columncompiler.js");

const { makeEscape } = __webpack_require__("./node_modules/knex/lib/util/string.js");
const ViewCompiler = __webpack_require__("./node_modules/knex/lib/dialects/mysql/schema/mysql-viewcompiler.js");
const ViewBuilder = __webpack_require__("./node_modules/knex/lib/dialects/mysql/schema/mysql-viewbuilder.js");

// Always initialize with the "QueryBuilder" and "QueryCompiler"
// objects, which extend the base 'lib/query/builder' and
// 'lib/query/compiler', respectively.
class Client_MySQL extends Client {
  _driver() {
    return __webpack_require__("./node_modules/mysql/index.js");
  }

  queryBuilder() {
    return new QueryBuilder(this);
  }

  queryCompiler(builder, formatter) {
    return new QueryCompiler(this, builder, formatter);
  }

  schemaCompiler() {
    return new SchemaCompiler(this, ...arguments);
  }

  tableCompiler() {
    return new TableCompiler(this, ...arguments);
  }

  viewCompiler() {
    return new ViewCompiler(this, ...arguments);
  }

  viewBuilder() {
    return new ViewBuilder(this, ...arguments);
  }

  columnCompiler() {
    return new ColumnCompiler(this, ...arguments);
  }

  transaction() {
    return new Transaction(this, ...arguments);
  }

  wrapIdentifierImpl(value) {
    return value !== '*' ? `\`${value.replace(/`/g, '``')}\`` : '*';
  }

  // Get a raw connection, called by the `pool` whenever a new
  // connection needs to be added to the pool.
  acquireRawConnection() {
    return new Promise((resolver, rejecter) => {
      const connection = this.driver.createConnection(this.connectionSettings);
      connection.on('error', (err) => {
        connection.__knex__disposed = err;
      });
      connection.connect((err) => {
        if (err) {
          // if connection is rejected, remove listener that was registered above...
          connection.removeAllListeners();
          return rejecter(err);
        }
        resolver(connection);
      });
    });
  }

  // Used to explicitly close a connection, called internally by the pool
  // when a connection times out or the pool is shutdown.
  async destroyRawConnection(connection) {
    try {
      const end = promisify((cb) => connection.end(cb));
      return await end();
    } catch (err) {
      connection.__knex__disposed = err;
    } finally {
      // see discussion https://github.com/knex/knex/pull/3483
      defer(() => connection.removeAllListeners());
    }
  }

  validateConnection(connection) {
    return (
      connection.state === 'connected' || connection.state === 'authenticated'
    );
  }

  // Grab a connection, run the query via the MySQL streaming interface,
  // and pass that through to the stream we've sent back to the client.
  _stream(connection, obj, stream, options) {
    if (!obj.sql) throw new Error('The query is empty');

    options = options || {};
    const queryOptions = Object.assign({ sql: obj.sql }, obj.options);
    return new Promise((resolver, rejecter) => {
      stream.on('error', rejecter);
      stream.on('end', resolver);
      const queryStream = connection
        .query(queryOptions, obj.bindings)
        .stream(options);

      queryStream.on('error', (err) => {
        rejecter(err);
        stream.emit('error', err);
      });

      queryStream.pipe(stream);
    });
  }

  // Runs the query on the specified connection, providing the bindings
  // and any other necessary prep work.
  _query(connection, obj) {
    if (!obj || typeof obj === 'string') obj = { sql: obj };
    if (!obj.sql) throw new Error('The query is empty');

    return new Promise(function (resolver, rejecter) {
      if (!obj.sql) {
        resolver();
        return;
      }
      const queryOptions = Object.assign({ sql: obj.sql }, obj.options);
      connection.query(
        queryOptions,
        obj.bindings,
        function (err, rows, fields) {
          if (err) return rejecter(err);
          obj.response = [rows, fields];
          resolver(obj);
        }
      );
    });
  }

  // Process the response as returned from the query.
  processResponse(obj, runner) {
    if (obj == null) return;
    const { response } = obj;
    const { method } = obj;
    const rows = response[0];
    const fields = response[1];
    if (obj.output) return obj.output.call(runner, rows, fields);
    switch (method) {
      case 'select':
        return rows;
      case 'first':
        return rows[0];
      case 'pluck':
        return map(rows, obj.pluck);
      case 'insert':
        return [rows.insertId];
      case 'del':
      case 'update':
      case 'counter':
        return rows.affectedRows;
      default:
        return response;
    }
  }

  async cancelQuery(connectionToKill) {
    const conn = await this.acquireRawConnection();
    try {
      return await this._wrappedCancelQueryCall(conn, connectionToKill);
    } finally {
      await this.destroyRawConnection(conn);
      if (conn.__knex__disposed) {
        this.logger.warn(`Connection Error: ${conn.__knex__disposed}`);
      }
    }
  }

  _wrappedCancelQueryCall(conn, connectionToKill) {
    return this._query(conn, {
      sql: 'KILL QUERY ?',
      bindings: [connectionToKill.threadId],
      options: {},
    });
  }
}

Object.assign(Client_MySQL.prototype, {
  dialect: 'mysql',

  driverName: 'mysql',

  _escapeBinding: makeEscape(),

  canCancelQuery: true,
});

module.exports = Client_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/query/mysql-querybuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const QueryBuilder = __webpack_require__("./node_modules/knex/lib/query/querybuilder.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");

module.exports = class QueryBuilder_MySQL extends QueryBuilder {
  upsert(values, returning, options) {
    this._method = 'upsert';
    if (!isEmpty(returning)) {
      this.returning(returning, options);
    }

    this._single.upsert = values;
    return this;
  }
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// MySQL Query Compiler
// ------
const assert = __webpack_require__("assert");
const identity = __webpack_require__("./node_modules/lodash/identity.js");
const isPlainObject = __webpack_require__("./node_modules/lodash/isPlainObject.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");
const QueryCompiler = __webpack_require__("./node_modules/knex/lib/query/querycompiler.js");
const { wrapAsIdentifier } = __webpack_require__("./node_modules/knex/lib/formatter/formatterUtils.js");
const {
  columnize: columnize_,
  wrap: wrap_,
} = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

const isPlainObjectOrArray = (value) =>
  isPlainObject(value) || Array.isArray(value);

class QueryCompiler_MySQL extends QueryCompiler {
  constructor(client, builder, formatter) {
    super(client, builder, formatter);

    const { returning } = this.single;
    if (returning) {
      this.client.logger.warn(
        '.returning() is not supported by mysql and will not have any effect.'
      );
    }

    this._emptyInsertValue = '() values ()';
  }
  // Compiles an `delete` allowing comments
  del() {
    const sql = super.del();
    if (sql === '') return sql;
    const comments = this.comments();
    return (comments === '' ? '' : comments + ' ') + sql;
  }

  // Compiles an `insert` query, allowing for multiple
  // inserts using a single query statement.
  insert() {
    let sql = super.insert();
    if (sql === '') return sql;
    const comments = this.comments();
    sql = (comments === '' ? '' : comments + ' ') + sql;

    const { ignore, merge, insert } = this.single;
    if (ignore) sql = sql.replace('insert into', 'insert ignore into');
    if (merge) {
      sql += this._merge(merge.updates, insert);
      const wheres = this.where();
      if (wheres) {
        throw new Error(
          '.onConflict().merge().where() is not supported for mysql'
        );
      }
    }

    return sql;
  }

  upsert() {
    const upsertValues = this.single.upsert || [];
    const sql = this.with() + `replace into ${this.tableName} `;
    const body = this._insertBody(upsertValues);
    return body === '' ? '' : sql + body;
  }

  // Compiles merge for onConflict, allowing for different merge strategies
  _merge(updates, insert) {
    const sql = ' on duplicate key update ';
    if (updates && Array.isArray(updates)) {
      // update subset of columns
      return (
        sql +
        updates
          .map((column) =>
            wrapAsIdentifier(column, this.formatter.builder, this.client)
          )
          .map((column) => `${column} = values(${column})`)
          .join(', ')
      );
    } else if (updates && typeof updates === 'object') {
      const updateData = this._prepUpdate(updates);
      return sql + updateData.join(',');
    } else {
      const insertData = this._prepInsert(insert);
      if (typeof insertData === 'string') {
        throw new Error(
          'If using merge with a raw insert query, then updates must be provided'
        );
      }

      return (
        sql +
        insertData.columns
          .map((column) => wrapAsIdentifier(column, this.builder, this.client))
          .map((column) => `${column} = values(${column})`)
          .join(', ')
      );
    }
  }

  // Update method, including joins, wheres, order & limits.
  update() {
    const comments = this.comments();
    const withSQL = this.with();
    const join = this.join();
    const updates = this._prepUpdate(this.single.update);
    const where = this.where();
    const order = this.order();
    const limit = this.limit();
    return (
      (comments === '' ? '' : comments + ' ') +
      withSQL +
      `update ${this.tableName}` +
      (join ? ` ${join}` : '') +
      ' set ' +
      updates.join(', ') +
      (where ? ` ${where}` : '') +
      (order ? ` ${order}` : '') +
      (limit ? ` ${limit}` : '')
    );
  }

  forUpdate() {
    return 'for update';
  }

  forShare() {
    return 'lock in share mode';
  }

  // Only supported on MySQL 8.0+
  skipLocked() {
    return 'skip locked';
  }

  // Supported on MySQL 8.0+ and MariaDB 10.3.0+
  noWait() {
    return 'nowait';
  }

  // Compiles a `columnInfo` query.
  columnInfo() {
    const column = this.single.columnInfo;

    // The user may have specified a custom wrapIdentifier function in the config. We
    // need to run the identifiers through that function, but not format them as
    // identifiers otherwise.
    const table = this.client.customWrapIdentifier(this.single.table, identity);

    return {
      sql: 'select * from information_schema.columns where table_name = ? and table_schema = ?',
      bindings: [table, this.client.database()],
      output(resp) {
        const out = resp.reduce(function (columns, val) {
          columns[val.COLUMN_NAME] = {
            defaultValue:
              val.COLUMN_DEFAULT === 'NULL' ? null : val.COLUMN_DEFAULT,
            type: val.DATA_TYPE,
            maxLength: val.CHARACTER_MAXIMUM_LENGTH,
            nullable: val.IS_NULLABLE === 'YES',
          };
          return columns;
        }, {});
        return (column && out[column]) || out;
      },
    };
  }

  limit() {
    const noLimit = !this.single.limit && this.single.limit !== 0;
    if (noLimit && !this.single.offset) return '';

    // Workaround for offset only.
    // see: http://stackoverflow.com/questions/255517/mysql-offset-infinite-rows
    const limit =
      this.single.offset && noLimit
        ? '18446744073709551615'
        : this._getValueOrParameterFromAttribute('limit');
    return `limit ${limit}`;
  }

  whereBasic(statement) {
    assert(
      !isPlainObjectOrArray(statement.value),
      'The values in where clause must not be object or array.'
    );

    return super.whereBasic(statement);
  }

  whereRaw(statement) {
    assert(
      isEmpty(statement.value.bindings) ||
        !Object.values(statement.value.bindings).some(isPlainObjectOrArray),
      'The values in where clause must not be object or array.'
    );

    return super.whereRaw(statement);
  }

  whereLike(statement) {
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'like '
    )}${this._valueClause(statement)} COLLATE utf8_bin`;
  }

  whereILike(statement) {
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'like '
    )}${this._valueClause(statement)}`;
  }

  // Json functions
  jsonExtract(params) {
    return this._jsonExtract(['json_extract', 'json_unquote'], params);
  }

  jsonSet(params) {
    return this._jsonSet('json_set', params);
  }

  jsonInsert(params) {
    return this._jsonSet('json_insert', params);
  }

  jsonRemove(params) {
    const jsonCol = `json_remove(${columnize_(
      params.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )},${this.client.parameter(
      params.path,
      this.builder,
      this.bindingsHolder
    )})`;
    return params.alias
      ? this.client.alias(jsonCol, this.formatter.wrap(params.alias))
      : jsonCol;
  }

  whereJsonObject(statement) {
    return this._not(
      statement,
      `json_contains(${this._columnClause(statement)}, ${this._jsonValueClause(
        statement
      )})`
    );
  }

  whereJsonPath(statement) {
    return this._whereJsonPath('json_extract', statement);
  }

  whereJsonSupersetOf(statement) {
    return this._not(
      statement,
      `json_contains(${wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )},${this._jsonValueClause(statement)})`
    );
  }

  whereJsonSubsetOf(statement) {
    return this._not(
      statement,
      `json_contains(${this._jsonValueClause(statement)},${wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )})`
    );
  }

  onJsonPathEquals(clause) {
    return this._onJsonPathEquals('json_extract', clause);
  }
}

// Set the QueryBuilder & QueryCompiler on the client object,
// in case anyone wants to modify things to suit their own purposes.
module.exports = QueryCompiler_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/schema/mysql-columncompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// MySQL Column Compiler
// -------
const ColumnCompiler = __webpack_require__("./node_modules/knex/lib/schema/columncompiler.js");
const { isObject } = __webpack_require__("./node_modules/knex/lib/util/is.js");
const { toNumber } = __webpack_require__("./node_modules/knex/lib/util/helpers.js");

const commentEscapeRegex = /(?<!\\)'/g;

class ColumnCompiler_MySQL extends ColumnCompiler {
  constructor(client, tableCompiler, columnBuilder) {
    super(client, tableCompiler, columnBuilder);
    this.modifiers = [
      'unsigned',
      'nullable',
      'defaultTo',
      'comment',
      'collate',
      'first',
      'after',
    ];
    this._addCheckModifiers();
  }

  // Types
  // ------

  double(precision, scale) {
    if (!precision) return 'double';
    return `double(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
  }

  integer(length) {
    length = length ? `(${toNumber(length, 11)})` : '';
    return `int${length}`;
  }

  tinyint(length) {
    length = length ? `(${toNumber(length, 1)})` : '';
    return `tinyint${length}`;
  }

  text(column) {
    switch (column) {
      case 'medium':
      case 'mediumtext':
        return 'mediumtext';
      case 'long':
      case 'longtext':
        return 'longtext';
      default:
        return 'text';
    }
  }

  mediumtext() {
    return this.text('medium');
  }

  longtext() {
    return this.text('long');
  }

  enu(allowed) {
    return `enum('${allowed.join("', '")}')`;
  }

  datetime(precision) {
    if (isObject(precision)) {
      ({ precision } = precision);
    }

    return typeof precision === 'number'
      ? `datetime(${precision})`
      : 'datetime';
  }

  timestamp(precision) {
    if (isObject(precision)) {
      ({ precision } = precision);
    }

    return typeof precision === 'number'
      ? `timestamp(${precision})`
      : 'timestamp';
  }

  time(precision) {
    if (isObject(precision)) {
      ({ precision } = precision);
    }

    return typeof precision === 'number' ? `time(${precision})` : 'time';
  }

  bit(length) {
    return length ? `bit(${toNumber(length)})` : 'bit';
  }

  binary(length) {
    return length ? `varbinary(${toNumber(length)})` : 'blob';
  }

  json() {
    return 'json';
  }

  jsonb() {
    return 'json';
  }

  // Modifiers
  // ------

  defaultTo(value) {
    // MySQL defaults to null by default, but breaks down if you pass it explicitly
    // Note that in MySQL versions up to 5.7, logic related to updating
    // timestamps when no explicit value is passed is quite insane - https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp
    if (value === null || value === undefined) {
      return;
    }
    if ((this.type === 'json' || this.type === 'jsonb') && isObject(value)) {
      // Default value for json will work only it is an expression
      return `default ('${JSON.stringify(value)}')`;
    }
    const defaultVal = super.defaultTo.apply(this, arguments);
    if (this.type !== 'blob' && this.type.indexOf('text') === -1) {
      return defaultVal;
    }
    return '';
  }

  unsigned() {
    return 'unsigned';
  }

  comment(comment) {
    if (comment && comment.length > 255) {
      this.client.logger.warn(
        'Your comment is longer than the max comment length for MySQL'
      );
    }
    return comment && `comment '${comment.replace(commentEscapeRegex, "\\'")}'`;
  }

  first() {
    return 'first';
  }

  after(column) {
    return `after ${this.formatter.wrap(column)}`;
  }

  collate(collation) {
    return collation && `collate '${collation}'`;
  }

  checkRegex(regex, constraintName) {
    return this._check(
      `${this.formatter.wrap(
        this.getColumnName()
      )} REGEXP ${this.client._escapeBinding(regex)}`,
      constraintName
    );
  }

  increments(options = { primaryKey: true }) {
    return (
      'int unsigned not null' +
      // In MySQL autoincrement are always a primary key. If you already have a primary key, we
      // initialize this column as classic int column then modify it later in table compiler
      (this.tableCompiler._canBeAddPrimaryKey(options)
        ? ' auto_increment primary key'
        : '')
    );
  }

  bigincrements(options = { primaryKey: true }) {
    return (
      'bigint unsigned not null' +
      // In MySQL autoincrement are always a primary key. If you already have a primary key, we
      // initialize this column as classic int column then modify it later in table compiler
      (this.tableCompiler._canBeAddPrimaryKey(options)
        ? ' auto_increment primary key'
        : '')
    );
  }
}

ColumnCompiler_MySQL.prototype.bigint = 'bigint';
ColumnCompiler_MySQL.prototype.mediumint = 'mediumint';
ColumnCompiler_MySQL.prototype.smallint = 'smallint';

module.exports = ColumnCompiler_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/schema/mysql-compiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// MySQL Schema Compiler
// -------
const SchemaCompiler = __webpack_require__("./node_modules/knex/lib/schema/compiler.js");

class SchemaCompiler_MySQL extends SchemaCompiler {
  constructor(client, builder) {
    super(client, builder);
  }

  // Rename a table on the schema.
  renameTable(tableName, to) {
    this.pushQuery(
      `rename table ${this.formatter.wrap(tableName)} to ${this.formatter.wrap(
        to
      )}`
    );
  }

  renameView(from, to) {
    this.renameTable(from, to);
  }

  // Check whether a table exists on the query.
  hasTable(tableName) {
    let sql = 'select * from information_schema.tables where table_name = ?';
    const bindings = [tableName];

    if (this.schema) {
      sql += ' and table_schema = ?';
      bindings.push(this.schema);
    } else {
      sql += ' and table_schema = database()';
    }

    this.pushQuery({
      sql,
      bindings,
      output: function output(resp) {
        return resp.length > 0;
      },
    });
  }

  // Check whether a column exists on the schema.
  hasColumn(tableName, column) {
    this.pushQuery({
      sql: `show columns from ${this.formatter.wrap(tableName)}`,
      output(resp) {
        return resp.some((row) => {
          return (
            this.client.wrapIdentifier(row.Field.toLowerCase()) ===
            this.client.wrapIdentifier(column.toLowerCase())
          );
        });
      },
    });
  }
}

module.exports = SchemaCompiler_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/schema/mysql-tablecompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint max-len:0*/

// MySQL Table Builder & Compiler
// -------
const TableCompiler = __webpack_require__("./node_modules/knex/lib/schema/tablecompiler.js");
const { isObject, isString } = __webpack_require__("./node_modules/knex/lib/util/is.js");

// Table Compiler
// ------

class TableCompiler_MySQL extends TableCompiler {
  constructor(client, tableBuilder) {
    super(client, tableBuilder);
  }

  createQuery(columns, ifNot, like) {
    const createStatement = ifNot
      ? 'create table if not exists '
      : 'create table ';
    const { client } = this;
    let conn = {};
    let columnsSql = ' (' + columns.sql.join(', ');

    columnsSql += this.primaryKeys() || '';
    columnsSql += this._addChecks();
    columnsSql += ')';

    let sql =
      createStatement +
      this.tableName() +
      (like && this.tableNameLike()
        ? ' like ' + this.tableNameLike()
        : columnsSql);

    // Check if the connection settings are set.
    if (client.connectionSettings) {
      conn = client.connectionSettings;
    }

    const charset = this.single.charset || conn.charset || '';
    const collation = this.single.collate || conn.collate || '';
    const engine = this.single.engine || '';

    if (charset && !like) sql += ` default character set ${charset}`;
    if (collation) sql += ` collate ${collation}`;
    if (engine) sql += ` engine = ${engine}`;

    if (this.single.comment) {
      const comment = this.single.comment || '';
      const MAX_COMMENT_LENGTH = 1024;
      if (comment.length > MAX_COMMENT_LENGTH)
        this.client.logger.warn(
          `The max length for a table comment is ${MAX_COMMENT_LENGTH} characters`
        );
      sql += ` comment = '${comment}'`;
    }

    this.pushQuery(sql);
    if (like) {
      this.addColumns(columns, this.addColumnsPrefix);
    }
  }

  // Compiles the comment on the table.
  comment(comment) {
    this.pushQuery(`alter table ${this.tableName()} comment = '${comment}'`);
  }

  changeType() {
    // alter table + table + ' modify ' + wrapped + '// type';
  }

  // Renames a column on the table.
  renameColumn(from, to) {
    const compiler = this;
    const table = this.tableName();
    const wrapped = this.formatter.wrap(from) + ' ' + this.formatter.wrap(to);

    this.pushQuery({
      sql:
        `show full fields from ${table} where field = ` +
        this.client.parameter(from, this.tableBuilder, this.bindingsHolder),
      output(resp) {
        const column = resp[0];
        const runner = this;
        return compiler.getFKRefs(runner).then(([refs]) =>
          new Promise((resolve, reject) => {
            try {
              if (!refs.length) {
                resolve();
              }
              resolve(compiler.dropFKRefs(runner, refs));
            } catch (e) {
              reject(e);
            }
          })
            .then(function () {
              let sql = `alter table ${table} change ${wrapped} ${column.Type}`;

              if (String(column.Null).toUpperCase() !== 'YES') {
                sql += ` NOT NULL`;
              } else {
                // This doesn't matter for most cases except Timestamp, where this is important
                sql += ` NULL`;
              }
              if (column.Default !== void 0 && column.Default !== null) {
                sql += ` DEFAULT '${column.Default}'`;
              }
              if (column.Collation !== void 0 && column.Collation !== null) {
                sql += ` COLLATE '${column.Collation}'`;
              }
              // Add back the auto increment if the column  it, fix issue #2767
              if (column.Extra == 'auto_increment') {
                sql += ` AUTO_INCREMENT`;
              }

              return runner.query({
                sql,
              });
            })
            .then(function () {
              if (!refs.length) {
                return;
              }
              return compiler.createFKRefs(
                runner,
                refs.map(function (ref) {
                  if (ref.REFERENCED_COLUMN_NAME === from) {
                    ref.REFERENCED_COLUMN_NAME = to;
                  }
                  if (ref.COLUMN_NAME === from) {
                    ref.COLUMN_NAME = to;
                  }
                  return ref;
                })
              );
            })
        );
      },
    });
  }

  primaryKeys() {
    const pks = (this.grouped.alterTable || []).filter(
      (k) => k.method === 'primary'
    );
    if (pks.length > 0 && pks[0].args.length > 0) {
      const columns = pks[0].args[0];
      let constraintName = pks[0].args[1] || '';
      if (constraintName) {
        constraintName = ' constraint ' + this.formatter.wrap(constraintName);
      }

      if (this.grouped.columns) {
        const incrementsCols = this._getIncrementsColumnNames();
        if (incrementsCols.length) {
          incrementsCols.forEach((c) => {
            if (!columns.includes(c)) {
              columns.unshift(c);
            }
          });
        }
        const bigIncrementsCols = this._getBigIncrementsColumnNames();
        if (bigIncrementsCols.length) {
          bigIncrementsCols.forEach((c) => {
            if (!columns.includes(c)) {
              columns.unshift(c);
            }
          });
        }
      }

      return `,${constraintName} primary key (${this.formatter.columnize(
        columns
      )})`;
    }
  }

  getFKRefs(runner) {
    const bindingsHolder = {
      bindings: [],
    };

    const sql =
      'SELECT KCU.CONSTRAINT_NAME, KCU.TABLE_NAME, KCU.COLUMN_NAME, ' +
      '       KCU.REFERENCED_TABLE_NAME, KCU.REFERENCED_COLUMN_NAME, ' +
      '       RC.UPDATE_RULE, RC.DELETE_RULE ' +
      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ' +
      'JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ' +
      '       USING(CONSTRAINT_NAME)' +
      'WHERE KCU.REFERENCED_TABLE_NAME = ' +
      this.client.parameter(
        this.tableNameRaw,
        this.tableBuilder,
        bindingsHolder
      ) +
      ' ' +
      '  AND KCU.CONSTRAINT_SCHEMA = ' +
      this.client.parameter(
        this.client.database(),
        this.tableBuilder,
        bindingsHolder
      ) +
      ' ' +
      '  AND RC.CONSTRAINT_SCHEMA = ' +
      this.client.parameter(
        this.client.database(),
        this.tableBuilder,
        bindingsHolder
      );

    return runner.query({
      sql,
      bindings: bindingsHolder.bindings,
    });
  }

  dropFKRefs(runner, refs) {
    const formatter = this.client.formatter(this.tableBuilder);

    return Promise.all(
      refs.map(function (ref) {
        const constraintName = formatter.wrap(ref.CONSTRAINT_NAME);
        const tableName = formatter.wrap(ref.TABLE_NAME);
        return runner.query({
          sql: `alter table ${tableName} drop foreign key ${constraintName}`,
        });
      })
    );
  }

  createFKRefs(runner, refs) {
    const formatter = this.client.formatter(this.tableBuilder);

    return Promise.all(
      refs.map(function (ref) {
        const tableName = formatter.wrap(ref.TABLE_NAME);
        const keyName = formatter.wrap(ref.CONSTRAINT_NAME);
        const column = formatter.columnize(ref.COLUMN_NAME);
        const references = formatter.columnize(ref.REFERENCED_COLUMN_NAME);
        const inTable = formatter.wrap(ref.REFERENCED_TABLE_NAME);
        const onUpdate = ` ON UPDATE ${ref.UPDATE_RULE}`;
        const onDelete = ` ON DELETE ${ref.DELETE_RULE}`;

        return runner.query({
          sql:
            `alter table ${tableName} add constraint ${keyName} ` +
            'foreign key (' +
            column +
            ') references ' +
            inTable +
            ' (' +
            references +
            ')' +
            onUpdate +
            onDelete,
        });
      })
    );
  }

  index(columns, indexName, options) {
    let storageEngineIndexType;
    let indexType;

    if (isString(options)) {
      indexType = options;
    } else if (isObject(options)) {
      ({ indexType, storageEngineIndexType } = options);
    }

    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('index', this.tableNameRaw, columns);
    storageEngineIndexType = storageEngineIndexType
      ? ` using ${storageEngineIndexType}`
      : '';
    this.pushQuery(
      `alter table ${this.tableName()} add${
        indexType ? ` ${indexType}` : ''
      } index ${indexName}(${this.formatter.columnize(
        columns
      )})${storageEngineIndexType}`
    );
  }

  primary(columns, constraintName) {
    let deferrable;
    if (isObject(constraintName)) {
      ({ constraintName, deferrable } = constraintName);
    }
    if (deferrable && deferrable !== 'not deferrable') {
      this.client.logger.warn(
        `mysql: primary key constraint \`${constraintName}\` will not be deferrable ${deferrable} because mysql does not support deferred constraints.`
      );
    }
    constraintName = constraintName
      ? this.formatter.wrap(constraintName)
      : this.formatter.wrap(`${this.tableNameRaw}_pkey`);

    const primaryCols = columns;
    let incrementsCols = [];
    let bigIncrementsCols = [];
    if (this.grouped.columns) {
      incrementsCols = this._getIncrementsColumnNames();
      if (incrementsCols) {
        incrementsCols.forEach((c) => {
          if (!primaryCols.includes(c)) {
            primaryCols.unshift(c);
          }
        });
      }
      bigIncrementsCols = this._getBigIncrementsColumnNames();
      if (bigIncrementsCols) {
        bigIncrementsCols.forEach((c) => {
          if (!primaryCols.includes(c)) {
            primaryCols.unshift(c);
          }
        });
      }
    }
    if (this.method !== 'create' && this.method !== 'createIfNot') {
      this.pushQuery(
        `alter table ${this.tableName()} add primary key ${constraintName}(${this.formatter.columnize(
          primaryCols
        )})`
      );
    }
    if (incrementsCols.length) {
      this.pushQuery(
        `alter table ${this.tableName()} modify column ${this.formatter.columnize(
          incrementsCols
        )} int unsigned not null auto_increment`
      );
    }
    if (bigIncrementsCols.length) {
      this.pushQuery(
        `alter table ${this.tableName()} modify column ${this.formatter.columnize(
          bigIncrementsCols
        )} bigint unsigned not null auto_increment`
      );
    }
  }

  unique(columns, indexName) {
    let storageEngineIndexType;
    let deferrable;
    if (isObject(indexName)) {
      ({ indexName, deferrable, storageEngineIndexType } = indexName);
    }
    if (deferrable && deferrable !== 'not deferrable') {
      this.client.logger.warn(
        `mysql: unique index \`${indexName}\` will not be deferrable ${deferrable} because mysql does not support deferred constraints.`
      );
    }
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('unique', this.tableNameRaw, columns);
    storageEngineIndexType = storageEngineIndexType
      ? ` using ${storageEngineIndexType}`
      : '';
    this.pushQuery(
      `alter table ${this.tableName()} add unique ${indexName}(${this.formatter.columnize(
        columns
      )})${storageEngineIndexType}`
    );
  }

  // Compile a drop index command.
  dropIndex(columns, indexName) {
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('index', this.tableNameRaw, columns);
    this.pushQuery(`alter table ${this.tableName()} drop index ${indexName}`);
  }

  // Compile a drop foreign key command.
  dropForeign(columns, indexName) {
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('foreign', this.tableNameRaw, columns);
    this.pushQuery(
      `alter table ${this.tableName()} drop foreign key ${indexName}`
    );
  }

  // Compile a drop primary key command.
  dropPrimary() {
    this.pushQuery(`alter table ${this.tableName()} drop primary key`);
  }

  // Compile a drop unique key command.
  dropUnique(column, indexName) {
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('unique', this.tableNameRaw, column);
    this.pushQuery(`alter table ${this.tableName()} drop index ${indexName}`);
  }
}

TableCompiler_MySQL.prototype.addColumnsPrefix = 'add ';
TableCompiler_MySQL.prototype.alterColumnsPrefix = 'modify ';
TableCompiler_MySQL.prototype.dropColumnPrefix = 'drop ';

module.exports = TableCompiler_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/schema/mysql-viewbuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ViewBuilder = __webpack_require__("./node_modules/knex/lib/schema/viewbuilder.js");

class ViewBuilder_MySQL extends ViewBuilder {
  constructor() {
    super(...arguments);
  }

  checkOption() {
    this._single.checkOption = 'default_option';
  }

  localCheckOption() {
    this._single.checkOption = 'local';
  }

  cascadedCheckOption() {
    this._single.checkOption = 'cascaded';
  }
}

module.exports = ViewBuilder_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/schema/mysql-viewcompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint max-len: 0 */

const ViewCompiler = __webpack_require__("./node_modules/knex/lib/schema/viewcompiler.js");

class ViewCompiler_MySQL extends ViewCompiler {
  constructor(client, viewCompiler) {
    super(client, viewCompiler);
  }

  createOrReplace() {
    this.createQuery(this.columns, this.selectQuery, false, true);
  }
}

module.exports = ViewCompiler_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/mysql/transaction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Transaction = __webpack_require__("./node_modules/knex/lib/execution/transaction.js");
const Debug = __webpack_require__("./node_modules/debug/src/index.js");

const debug = Debug('knex:tx');

class Transaction_MySQL extends Transaction {
  query(conn, sql, status, value) {
    const t = this;
    const q = this.trxClient
      .query(conn, sql)
      .catch((err) => {
        if (err.errno === 1305) {
          this.trxClient.logger.warn(
            'Transaction was implicitly committed, do not mix transactions and ' +
              'DDL with MySQL (#805)'
          );
          return;
        }

        status = 2;
        value = err;
        t._completed = true;
        debug('%s error running transaction query', t.txid);
      })
      .then(function (res) {
        if (status === 1) t._resolver(value);
        if (status === 2) {
          if (value === undefined) {
            if (t.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
              t._resolver();
              return;
            }
            value = new Error(`Transaction rejected with non-error: ${value}`);
          }
          t._rejecter(value);
        }
        return res;
      });
    if (status === 1 || status === 2) {
      t._completed = true;
    }
    return q;
  }
}

module.exports = Transaction_MySQL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/execution/sqlite-transaction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Transaction = __webpack_require__("./node_modules/knex/lib/execution/transaction.js");

class Transaction_Sqlite extends Transaction {
  begin(conn) {
    // SQLite doesn't really support isolation levels, it is serializable by
    // default and so we override it to ignore isolation level.
    // There is a `PRAGMA read_uncommitted = true;`, but that's probably not
    // what the user wants
    if (this.isolationLevel) {
      this.client.logger.warn(
        'sqlite3 only supports serializable transactions, ignoring the isolation level param'
      );
    }
    // SQLite infers read vs write transactions from the statement operation
    // https://www.sqlite.org/lang_transaction.html#read_transactions_versus_write_transactions
    if (this.readOnly) {
      this.client.logger.warn(
        'sqlite3 implicitly handles read vs write transactions'
      );
    }
    return this.query(conn, 'BEGIN;');
  }
}

module.exports = Transaction_Sqlite;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// SQLite3
// -------
const defaults = __webpack_require__("./node_modules/lodash/defaults.js");
const map = __webpack_require__("./node_modules/lodash/map.js");
const { promisify } = __webpack_require__("util");

const Client = __webpack_require__("./node_modules/knex/lib/client.js");

const Raw = __webpack_require__("./node_modules/knex/lib/raw.js");
const Transaction = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/execution/sqlite-transaction.js");
const SqliteQueryCompiler = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js");
const SchemaCompiler = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js");
const ColumnCompiler = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-columncompiler.js");
const TableCompiler = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js");
const ViewCompiler = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-viewcompiler.js");
const SQLite3_DDL = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/ddl.js");
const Formatter = __webpack_require__("./node_modules/knex/lib/formatter.js");
const QueryBuilder = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/query/sqlite-querybuilder.js");

class Client_SQLite3 extends Client {
  constructor(config) {
    super(config);

    if (config.connection && config.connection.filename === undefined) {
      this.logger.warn(
        'Could not find `connection.filename` in config. Please specify ' +
          'the database path and name to avoid errors. ' +
          '(see docs https://knexjs.org/guide/#configuration-options)'
      );
    }

    if (config.useNullAsDefault === undefined) {
      this.logger.warn(
        'sqlite does not support inserting default values. Set the ' +
          '`useNullAsDefault` flag to hide this warning. ' +
          '(see docs https://knexjs.org/guide/query-builder.html#insert).'
      );
    }
  }

  _driver() {
    return __webpack_require__("sqlite3");
  }

  schemaCompiler() {
    return new SchemaCompiler(this, ...arguments);
  }

  transaction() {
    return new Transaction(this, ...arguments);
  }

  queryCompiler(builder, formatter) {
    return new SqliteQueryCompiler(this, builder, formatter);
  }

  queryBuilder() {
    return new QueryBuilder(this);
  }

  viewCompiler(builder, formatter) {
    return new ViewCompiler(this, builder, formatter);
  }

  columnCompiler() {
    return new ColumnCompiler(this, ...arguments);
  }

  tableCompiler() {
    return new TableCompiler(this, ...arguments);
  }

  ddl(compiler, pragma, connection) {
    return new SQLite3_DDL(this, compiler, pragma, connection);
  }

  wrapIdentifierImpl(value) {
    return value !== '*' ? `\`${value.replace(/`/g, '``')}\`` : '*';
  }

  // Get a raw connection from the database, returning a promise with the connection object.
  acquireRawConnection() {
    return new Promise((resolve, reject) => {
      // the default mode for sqlite3
      let flags = this.driver.OPEN_READWRITE | this.driver.OPEN_CREATE;

      if (this.connectionSettings.flags) {
        if (!Array.isArray(this.connectionSettings.flags)) {
          throw new Error(`flags must be an array of strings`);
        }
        this.connectionSettings.flags.forEach((_flag) => {
          if (!_flag.startsWith('OPEN_') || !this.driver[_flag]) {
            throw new Error(`flag ${_flag} not supported by node-sqlite3`);
          }
          flags = flags | this.driver[_flag];
        });
      }

      const db = new this.driver.Database(
        this.connectionSettings.filename,
        flags,
        (err) => {
          if (err) {
            return reject(err);
          }
          resolve(db);
        }
      );
    });
  }

  // Used to explicitly close a connection, called internally by the pool when
  // a connection times out or the pool is shutdown.
  async destroyRawConnection(connection) {
    const close = promisify((cb) => connection.close(cb));
    return close();
  }

  // Runs the query on the specified connection, providing the bindings and any
  // other necessary prep work.
  _query(connection, obj) {
    if (!obj.sql) throw new Error('The query is empty');

    const { method } = obj;
    let callMethod;
    switch (method) {
      case 'insert':
      case 'update':
        callMethod = obj.returning ? 'all' : 'run';
        break;
      case 'counter':
      case 'del':
        callMethod = 'run';
        break;
      default:
        callMethod = 'all';
    }
    return new Promise(function (resolver, rejecter) {
      if (!connection || !connection[callMethod]) {
        return rejecter(
          new Error(`Error calling ${callMethod} on connection.`)
        );
      }
      connection[callMethod](obj.sql, obj.bindings, function (err, response) {
        if (err) return rejecter(err);
        obj.response = response;

        // We need the context here, as it contains
        // the "this.lastID" or "this.changes"
        obj.context = this;

        return resolver(obj);
      });
    });
  }

  _stream(connection, obj, stream) {
    if (!obj.sql) throw new Error('The query is empty');

    const client = this;
    return new Promise(function (resolver, rejecter) {
      stream.on('error', rejecter);
      stream.on('end', resolver);

      return client
        ._query(connection, obj)
        .then((obj) => obj.response)
        .then((rows) => rows.forEach((row) => stream.write(row)))
        .catch(function (err) {
          stream.emit('error', err);
        })
        .then(function () {
          stream.end();
        });
    });
  }

  // Ensures the response is returned in the same format as other clients.
  processResponse(obj, runner) {
    const ctx = obj.context;
    const { response, returning } = obj;
    if (obj.output) return obj.output.call(runner, response);
    switch (obj.method) {
      case 'select':
        return response;
      case 'first':
        return response[0];
      case 'pluck':
        return map(response, obj.pluck);
      case 'insert': {
        if (returning) {
          if (response) {
            return response;
          }
        }
        return [ctx.lastID];
      }
      case 'update': {
        if (returning) {
          if (response) {
            return response;
          }
        }
        return ctx.changes;
      }
      case 'del':
      case 'counter':
        return ctx.changes;
      default: {
        return response;
      }
    }
  }

  poolDefaults() {
    return defaults({ min: 1, max: 1 }, super.poolDefaults());
  }

  formatter(builder) {
    return new Formatter(this, builder);
  }

  values(values, builder, formatter) {
    if (Array.isArray(values)) {
      if (Array.isArray(values[0])) {
        return `( values ${values
          .map(
            (value) =>
              `(${this.parameterize(value, undefined, builder, formatter)})`
          )
          .join(', ')})`;
      }
      return `(${this.parameterize(values, undefined, builder, formatter)})`;
    }

    if (values instanceof Raw) {
      return `(${this.parameter(values, builder, formatter)})`;
    }

    return this.parameter(values, builder, formatter);
  }
}

Object.assign(Client_SQLite3.prototype, {
  dialect: 'sqlite3',

  driverName: 'sqlite3',
});

module.exports = Client_SQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/query/sqlite-querybuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const QueryBuilder = __webpack_require__("./node_modules/knex/lib/query/querybuilder.js");

module.exports = class QueryBuilder_SQLite3 extends QueryBuilder {
  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
    this._validateWithArgs(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      'with'
    );
    return this.withWrapped(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      true
    );
  }

  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
    this._validateWithArgs(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      'with'
    );
    return this.withWrapped(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      false
    );
  }
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// SQLite3 Query Builder & Compiler

const constant = __webpack_require__("./node_modules/lodash/constant.js");
const each = __webpack_require__("./node_modules/lodash/each.js");
const identity = __webpack_require__("./node_modules/lodash/identity.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");
const reduce = __webpack_require__("./node_modules/lodash/reduce.js");

const QueryCompiler = __webpack_require__("./node_modules/knex/lib/query/querycompiler.js");
const noop = __webpack_require__("./node_modules/knex/lib/util/noop.js");
const { isString } = __webpack_require__("./node_modules/knex/lib/util/is.js");
const {
  wrapString,
  columnize: columnize_,
} = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

const emptyStr = constant('');

class QueryCompiler_SQLite3 extends QueryCompiler {
  constructor(client, builder, formatter) {
    super(client, builder, formatter);

    // The locks are not applicable in SQLite3
    this.forShare = emptyStr;
    this.forKeyShare = emptyStr;
    this.forUpdate = emptyStr;
    this.forNoKeyUpdate = emptyStr;
  }

  // SQLite requires us to build the multi-row insert as a listing of select with
  // unions joining them together. So we'll build out this list of columns and
  // then join them all together with select unions to complete the queries.
  insert() {
    const insertValues = this.single.insert || [];
    let sql = this.with() + `insert into ${this.tableName} `;

    if (Array.isArray(insertValues)) {
      if (insertValues.length === 0) {
        return '';
      } else if (
        insertValues.length === 1 &&
        insertValues[0] &&
        isEmpty(insertValues[0])
      ) {
        return {
          sql: sql + this._emptyInsertValue,
        };
      }
    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {
      return {
        sql: sql + this._emptyInsertValue,
      };
    }

    const insertData = this._prepInsert(insertValues);

    if (isString(insertData)) {
      return {
        sql: sql + insertData,
      };
    }

    if (insertData.columns.length === 0) {
      return {
        sql: '',
      };
    }

    sql += `(${this.formatter.columnize(insertData.columns)})`;

    // backwards compatible error
    if (this.client.valueForUndefined !== null) {
      insertData.values.forEach((bindings) => {
        each(bindings, (binding) => {
          if (binding === undefined)
            throw new TypeError(
              '`sqlite` does not support inserting default values. Specify ' +
                'values explicitly or use the `useNullAsDefault` config flag. ' +
                '(see docs https://knexjs.org/guide/query-builder.html#insert).'
            );
        });
      });
    }

    if (insertData.values.length === 1) {
      const parameters = this.client.parameterize(
        insertData.values[0],
        this.client.valueForUndefined,
        this.builder,
        this.bindingsHolder
      );
      sql += ` values (${parameters})`;

      const { onConflict, ignore, merge } = this.single;
      if (onConflict && ignore) sql += this._ignore(onConflict);
      else if (onConflict && merge) {
        sql += this._merge(merge.updates, onConflict, insertValues);
        const wheres = this.where();
        if (wheres) sql += ` ${wheres}`;
      }

      const { returning } = this.single;
      if (returning) {
        sql += this._returning(returning);
      }

      return {
        sql,
        returning,
      };
    }

    const blocks = [];
    let i = -1;
    while (++i < insertData.values.length) {
      let i2 = -1;
      const block = (blocks[i] = []);
      let current = insertData.values[i];
      current = current === undefined ? this.client.valueForUndefined : current;
      while (++i2 < insertData.columns.length) {
        block.push(
          this.client.alias(
            this.client.parameter(
              current[i2],
              this.builder,
              this.bindingsHolder
            ),
            this.formatter.wrap(insertData.columns[i2])
          )
        );
      }
      blocks[i] = block.join(', ');
    }
    sql += ' select ' + blocks.join(' union all select ');

    const { onConflict, ignore, merge } = this.single;
    if (onConflict && ignore) sql += ' where true' + this._ignore(onConflict);
    else if (onConflict && merge) {
      sql +=
        ' where true' + this._merge(merge.updates, onConflict, insertValues);
    }

    const { returning } = this.single;
    if (returning) sql += this._returning(returning);

    return {
      sql,
      returning,
    };
  }

  // Compiles an `update` query, allowing for a return value.
  update() {
    const withSQL = this.with();
    const updateData = this._prepUpdate(this.single.update);
    const wheres = this.where();
    const { returning } = this.single;
    return {
      sql:
        withSQL +
        `update ${this.single.only ? 'only ' : ''}${this.tableName} ` +
        `set ${updateData.join(', ')}` +
        (wheres ? ` ${wheres}` : '') +
        this._returning(returning),
      returning,
    };
  }

  _ignore(columns) {
    if (columns === true) {
      return ' on conflict do nothing';
    }
    return ` on conflict ${this._onConflictClause(columns)} do nothing`;
  }

  _merge(updates, columns, insert) {
    let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;
    if (updates && Array.isArray(updates)) {
      sql += updates
        .map((column) =>
          wrapString(
            column.split('.').pop(),
            this.formatter.builder,
            this.client,
            this.formatter
          )
        )
        .map((column) => `${column} = excluded.${column}`)
        .join(', ');

      return sql;
    } else if (updates && typeof updates === 'object') {
      const updateData = this._prepUpdate(updates);
      if (typeof updateData === 'string') {
        sql += updateData;
      } else {
        sql += updateData.join(',');
      }

      return sql;
    } else {
      const insertData = this._prepInsert(insert);
      if (typeof insertData === 'string') {
        throw new Error(
          'If using merge with a raw insert query, then updates must be provided'
        );
      }

      sql += insertData.columns
        .map((column) =>
          wrapString(column.split('.').pop(), this.builder, this.client)
        )
        .map((column) => `${column} = excluded.${column}`)
        .join(', ');

      return sql;
    }
  }

  _returning(value) {
    return value ? ` returning ${this.formatter.columnize(value)}` : '';
  }

  // Compile a truncate table statement into SQL.
  truncate() {
    const { table } = this.single;
    return {
      sql: `delete from ${this.tableName}`,
      output() {
        return this.query({
          sql: `delete from sqlite_sequence where name = '${table}'`,
        }).catch(noop);
      },
    };
  }

  // Compiles a `columnInfo` query
  columnInfo() {
    const column = this.single.columnInfo;

    // The user may have specified a custom wrapIdentifier function in the config. We
    // need to run the identifiers through that function, but not format them as
    // identifiers otherwise.
    const table = this.client.customWrapIdentifier(this.single.table, identity);

    return {
      sql: `PRAGMA table_info(\`${table}\`)`,
      output(resp) {
        const maxLengthRegex = /.*\((\d+)\)/;
        const out = reduce(
          resp,
          function (columns, val) {
            let { type } = val;
            let maxLength = type.match(maxLengthRegex);
            if (maxLength) {
              maxLength = maxLength[1];
            }
            type = maxLength ? type.split('(')[0] : type;
            columns[val.name] = {
              type: type.toLowerCase(),
              maxLength,
              nullable: !val.notnull,
              defaultValue: val.dflt_value,
            };
            return columns;
          },
          {}
        );
        return (column && out[column]) || out;
      },
    };
  }

  limit() {
    const noLimit = !this.single.limit && this.single.limit !== 0;
    if (noLimit && !this.single.offset) return '';

    // Workaround for offset only,
    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit
    this.single.limit = noLimit ? -1 : this.single.limit;
    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;
  }

  // Json functions
  jsonExtract(params) {
    return this._jsonExtract('json_extract', params);
  }

  jsonSet(params) {
    return this._jsonSet('json_set', params);
  }

  jsonInsert(params) {
    return this._jsonSet('json_insert', params);
  }

  jsonRemove(params) {
    const jsonCol = `json_remove(${columnize_(
      params.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )},${this.client.parameter(
      params.path,
      this.builder,
      this.bindingsHolder
    )})`;
    return params.alias
      ? this.client.alias(jsonCol, this.formatter.wrap(params.alias))
      : jsonCol;
  }

  whereJsonPath(statement) {
    return this._whereJsonPath('json_extract', statement);
  }

  whereJsonSupersetOf(statement) {
    throw new Error(
      'Json superset where clause not actually supported by SQLite'
    );
  }

  whereJsonSubsetOf(statement) {
    throw new Error(
      'Json subset where clause not actually supported by SQLite'
    );
  }

  onJsonPathEquals(clause) {
    return this._onJsonPathEquals('json_extract', clause);
  }
}

module.exports = QueryCompiler_SQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/ddl.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// SQLite3_DDL
//
// All of the SQLite3 specific DDL helpers for renaming/dropping
// columns and changing datatypes.
// -------

const identity = __webpack_require__("./node_modules/lodash/identity.js");
const { nanonum } = __webpack_require__("./node_modules/knex/lib/util/nanoid.js");
const {
  copyData,
  dropOriginal,
  renameTable,
  getTableSql,
  isForeignCheckEnabled,
  setForeignCheck,
  executeForeignCheck,
} = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js");
const { parseCreateTable, parseCreateIndex } = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/internal/parser.js");
const {
  compileCreateTable,
  compileCreateIndex,
} = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/internal/compiler.js");
const { isEqualId, includesId } = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/internal/utils.js");

// So altering the schema in SQLite3 is a major pain.
// We have our own object to deal with the renaming and altering the types
// for sqlite3 things.
class SQLite3_DDL {
  constructor(client, tableCompiler, pragma, connection) {
    this.client = client;
    this.tableCompiler = tableCompiler;
    this.pragma = pragma;
    this.tableNameRaw = this.tableCompiler.tableNameRaw;
    this.alteredName = `_knex_temp_alter${nanonum(3)}`;
    this.connection = connection;
    this.formatter = (value) =>
      this.client.customWrapIdentifier(value, identity);
    this.wrap = (value) => this.client.wrapIdentifierImpl(value);
  }

  tableName() {
    return this.formatter(this.tableNameRaw);
  }

  getTableSql() {
    const tableName = this.tableName();

    return this.client.transaction(
      async (trx) => {
        trx.disableProcessing();
        const result = await trx.raw(getTableSql(tableName));
        trx.enableProcessing();

        return {
          createTable: result.filter((create) => create.type === 'table')[0]
            .sql,
          createIndices: result
            .filter((create) => create.type === 'index')
            .map((create) => create.sql),
        };
      },
      { connection: this.connection }
    );
  }

  async isForeignCheckEnabled() {
    const result = await this.client
      .raw(isForeignCheckEnabled())
      .connection(this.connection);

    return result[0].foreign_keys === 1;
  }

  async setForeignCheck(enable) {
    await this.client.raw(setForeignCheck(enable)).connection(this.connection);
  }

  renameTable(trx) {
    return trx.raw(renameTable(this.alteredName, this.tableName()));
  }

  dropOriginal(trx) {
    return trx.raw(dropOriginal(this.tableName()));
  }

  copyData(trx, columns) {
    return trx.raw(copyData(this.tableName(), this.alteredName, columns));
  }

  async alterColumn(columns) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    parsedTable.columns = parsedTable.columns.map((column) => {
      const newColumnInfo = columns.find((c) => isEqualId(c.name, column.name));

      if (newColumnInfo) {
        column.type = newColumnInfo.type;

        column.constraints.default =
          newColumnInfo.defaultTo !== null
            ? {
                name: null,
                value: newColumnInfo.defaultTo,
                expression: false,
              }
            : null;

        column.constraints.notnull = newColumnInfo.notNull
          ? { name: null, conflict: null }
          : null;

        column.constraints.null = newColumnInfo.notNull
          ? null
          : column.constraints.null;
      }

      return column;
    });

    const newTable = compileCreateTable(parsedTable, this.wrap);

    return this.generateAlterCommands(newTable, createIndices);
  }

  async dropColumn(columns) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    parsedTable.columns = parsedTable.columns.filter(
      (parsedColumn) =>
        parsedColumn.expression || !includesId(columns, parsedColumn.name)
    );

    if (parsedTable.columns.length === 0) {
      throw new Error('Unable to drop last column from table');
    }

    parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
      if (constraint.type === 'PRIMARY KEY' || constraint.type === 'UNIQUE') {
        return constraint.columns.every(
          (constraintColumn) =>
            constraintColumn.expression ||
            !includesId(columns, constraintColumn.name)
        );
      } else if (constraint.type === 'FOREIGN KEY') {
        return (
          constraint.columns.every(
            (constraintColumnName) => !includesId(columns, constraintColumnName)
          ) &&
          (constraint.references.table !== parsedTable.table ||
            constraint.references.columns.every(
              (referenceColumnName) => !includesId(columns, referenceColumnName)
            ))
        );
      } else {
        return true;
      }
    });

    const newColumns = parsedTable.columns.map((column) => column.name);

    const newTable = compileCreateTable(parsedTable, this.wrap);

    const newIndices = [];
    for (const createIndex of createIndices) {
      const parsedIndex = parseCreateIndex(createIndex);

      parsedIndex.columns = parsedIndex.columns.filter(
        (parsedColumn) =>
          parsedColumn.expression || !includesId(columns, parsedColumn.name)
      );

      if (parsedIndex.columns.length > 0) {
        newIndices.push(compileCreateIndex(parsedIndex, this.wrap));
      }
    }

    return this.alter(newTable, newIndices, newColumns);
  }

  async dropForeign(columns, foreignKeyName) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    if (!foreignKeyName) {
      parsedTable.columns = parsedTable.columns.map((column) => ({
        ...column,
        references: includesId(columns, column.name) ? null : column.references,
      }));
    }

    parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
      if (constraint.type === 'FOREIGN KEY') {
        if (foreignKeyName) {
          return (
            !constraint.name || !isEqualId(constraint.name, foreignKeyName)
          );
        }

        return constraint.columns.every(
          (constraintColumnName) => !includesId(columns, constraintColumnName)
        );
      } else {
        return true;
      }
    });

    const newTable = compileCreateTable(parsedTable, this.wrap);

    return this.alter(newTable, createIndices);
  }

  async dropPrimary(constraintName) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    parsedTable.columns = parsedTable.columns.map((column) => ({
      ...column,
      primary: null,
    }));

    parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
      if (constraint.type === 'PRIMARY KEY') {
        if (constraintName) {
          return (
            !constraint.name || !isEqualId(constraint.name, constraintName)
          );
        } else {
          return false;
        }
      } else {
        return true;
      }
    });

    const newTable = compileCreateTable(parsedTable, this.wrap);

    return this.alter(newTable, createIndices);
  }

  async primary(columns, constraintName) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    parsedTable.columns = parsedTable.columns.map((column) => ({
      ...column,
      primary: null,
    }));

    parsedTable.constraints = parsedTable.constraints.filter(
      (constraint) => constraint.type !== 'PRIMARY KEY'
    );

    parsedTable.constraints.push({
      type: 'PRIMARY KEY',
      name: constraintName || null,
      columns: columns.map((column) => ({
        name: column,
        expression: false,
        collation: null,
        order: null,
      })),
      conflict: null,
    });

    const newTable = compileCreateTable(parsedTable, this.wrap);

    return this.alter(newTable, createIndices);
  }

  async foreign(foreignInfo) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    parsedTable.constraints.push({
      type: 'FOREIGN KEY',
      name: foreignInfo.keyName || null,
      columns: foreignInfo.column,
      references: {
        table: foreignInfo.inTable,
        columns: foreignInfo.references,
        delete: foreignInfo.onDelete || null,
        update: foreignInfo.onUpdate || null,
        match: null,
        deferrable: null,
      },
    });

    const newTable = compileCreateTable(parsedTable, this.wrap);

    return this.generateAlterCommands(newTable, createIndices);
  }

  async setNullable(column, isNullable) {
    const { createTable, createIndices } = await this.getTableSql();

    const parsedTable = parseCreateTable(createTable);
    parsedTable.table = this.alteredName;

    const parsedColumn = parsedTable.columns.find((c) =>
      isEqualId(column, c.name)
    );

    if (!parsedColumn) {
      throw new Error(
        `.setNullable: Column ${column} does not exist in table ${this.tableName()}.`
      );
    }

    parsedColumn.constraints.notnull = isNullable
      ? null
      : { name: null, conflict: null };

    parsedColumn.constraints.null = isNullable
      ? parsedColumn.constraints.null
      : null;

    const newTable = compileCreateTable(parsedTable, this.wrap);

    return this.generateAlterCommands(newTable, createIndices);
  }

  async alter(newSql, createIndices, columns) {
    const wasForeignCheckEnabled = await this.isForeignCheckEnabled();

    if (wasForeignCheckEnabled) {
      await this.setForeignCheck(false);
    }

    try {
      await this.client.transaction(
        async (trx) => {
          await trx.raw(newSql);
          await this.copyData(trx, columns);
          await this.dropOriginal(trx);
          await this.renameTable(trx);

          for (const createIndex of createIndices) {
            await trx.raw(createIndex);
          }

          if (wasForeignCheckEnabled) {
            const foreignViolations = await trx.raw(executeForeignCheck());

            if (foreignViolations.length > 0) {
              throw new Error('FOREIGN KEY constraint failed');
            }
          }
        },
        { connection: this.connection }
      );
    } finally {
      if (wasForeignCheckEnabled) {
        await this.setForeignCheck(true);
      }
    }
  }

  async generateAlterCommands(newSql, createIndices, columns) {
    const sql = [];
    const pre = [];
    const post = [];
    let check = null;

    sql.push(newSql);
    sql.push(copyData(this.tableName(), this.alteredName, columns));
    sql.push(dropOriginal(this.tableName()));
    sql.push(renameTable(this.alteredName, this.tableName()));

    for (const createIndex of createIndices) {
      sql.push(createIndex);
    }

    const isForeignCheckEnabled = await this.isForeignCheckEnabled();

    if (isForeignCheckEnabled) {
      pre.push(setForeignCheck(false));
      post.push(setForeignCheck(true));

      check = executeForeignCheck();
    }

    return { pre, sql, check, post };
  }
}

module.exports = SQLite3_DDL;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/internal/compiler.js":
/***/ ((module) => {

function compileCreateTable(ast, wrap = (v) => v) {
  return createTable(ast, wrap);
}

function compileCreateIndex(ast, wrap = (v) => v) {
  return createIndex(ast, wrap);
}

function createTable(ast, wrap) {
  return `CREATE${temporary(ast, wrap)} TABLE${exists(ast, wrap)} ${schema(
    ast,
    wrap
  )}${table(ast, wrap)} (${columnDefinitionList(
    ast,
    wrap
  )}${tableConstraintList(ast, wrap)})${rowid(ast, wrap)}`;
}

function temporary(ast, wrap) {
  return ast.temporary ? ' TEMP' : '';
}

function rowid(ast, wrap) {
  return ast.rowid ? ' WITHOUT ROWID' : '';
}

function columnDefinitionList(ast, wrap) {
  return ast.columns.map((column) => columnDefinition(column, wrap)).join(', ');
}

function columnDefinition(ast, wrap) {
  return `${identifier(ast.name, wrap)}${typeName(
    ast,
    wrap
  )}${columnConstraintList(ast.constraints, wrap)}`;
}

function typeName(ast, wrap) {
  return ast.type !== null ? ` ${ast.type}` : '';
}

function columnConstraintList(ast, wrap) {
  return `${primaryColumnConstraint(ast, wrap)}${notnullColumnConstraint(
    ast,
    wrap
  )}${nullColumnConstraint(ast, wrap)}${uniqueColumnConstraint(
    ast,
    wrap
  )}${checkColumnConstraint(ast, wrap)}${defaultColumnConstraint(
    ast,
    wrap
  )}${collateColumnConstraint(ast, wrap)}${referencesColumnConstraint(
    ast,
    wrap
  )}${asColumnConstraint(ast, wrap)}`;
}

function primaryColumnConstraint(ast, wrap) {
  return ast.primary !== null
    ? ` ${constraintName(ast.primary, wrap)}PRIMARY KEY${order(
        ast.primary,
        wrap
      )}${conflictClause(ast.primary, wrap)}${autoincrement(ast.primary, wrap)}`
    : '';
}

function autoincrement(ast, wrap) {
  return ast.autoincrement ? ' AUTOINCREMENT' : '';
}

function notnullColumnConstraint(ast, wrap) {
  return ast.notnull !== null
    ? ` ${constraintName(ast.notnull, wrap)}NOT NULL${conflictClause(
        ast.notnull,
        wrap
      )}`
    : '';
}

function nullColumnConstraint(ast, wrap) {
  return ast.null !== null
    ? ` ${constraintName(ast.null, wrap)}NULL${conflictClause(ast.null, wrap)}`
    : '';
}

function uniqueColumnConstraint(ast, wrap) {
  return ast.unique !== null
    ? ` ${constraintName(ast.unique, wrap)}UNIQUE${conflictClause(
        ast.unique,
        wrap
      )}`
    : '';
}

function checkColumnConstraint(ast, wrap) {
  return ast.check !== null
    ? ` ${constraintName(ast.check, wrap)}CHECK (${expression(
        ast.check.expression,
        wrap
      )})`
    : '';
}

function defaultColumnConstraint(ast, wrap) {
  return ast.default !== null
    ? ` ${constraintName(ast.default, wrap)}DEFAULT ${
        !ast.default.expression
          ? ast.default.value
          : `(${expression(ast.default.value, wrap)})`
      }`
    : '';
}

function collateColumnConstraint(ast, wrap) {
  return ast.collate !== null
    ? ` ${constraintName(ast.collate, wrap)}COLLATE ${ast.collate.collation}`
    : '';
}

function referencesColumnConstraint(ast, wrap) {
  return ast.references !== null
    ? ` ${constraintName(ast.references, wrap)}${foreignKeyClause(
        ast.references,
        wrap
      )}`
    : '';
}

function asColumnConstraint(ast, wrap) {
  return ast.as !== null
    ? ` ${constraintName(ast.as, wrap)}${
        ast.as.generated ? 'GENERATED ALWAYS ' : ''
      }AS (${expression(ast.as.expression, wrap)})${
        ast.as.mode !== null ? ` ${ast.as.mode}` : ''
      }`
    : '';
}

function tableConstraintList(ast, wrap) {
  return ast.constraints.reduce(
    (constraintList, constraint) =>
      `${constraintList}, ${tableConstraint(constraint, wrap)}`,
    ''
  );
}

function tableConstraint(ast, wrap) {
  switch (ast.type) {
    case 'PRIMARY KEY':
      return primaryTableConstraint(ast, wrap);
    case 'UNIQUE':
      return uniqueTableConstraint(ast, wrap);
    case 'CHECK':
      return checkTableConstraint(ast, wrap);
    case 'FOREIGN KEY':
      return foreignTableConstraint(ast, wrap);
  }
}

function primaryTableConstraint(ast, wrap) {
  return `${constraintName(ast, wrap)}PRIMARY KEY (${indexedColumnList(
    ast,
    wrap
  )})${conflictClause(ast, wrap)}`;
}

function uniqueTableConstraint(ast, wrap) {
  return `${constraintName(ast, wrap)}UNIQUE (${indexedColumnList(
    ast,
    wrap
  )})${conflictClause(ast, wrap)}`;
}

function conflictClause(ast, wrap) {
  return ast.conflict !== null ? ` ON CONFLICT ${ast.conflict}` : '';
}

function checkTableConstraint(ast, wrap) {
  return `${constraintName(ast, wrap)}CHECK (${expression(
    ast.expression,
    wrap
  )})`;
}

function foreignTableConstraint(ast, wrap) {
  return `${constraintName(ast, wrap)}FOREIGN KEY (${columnNameList(
    ast,
    wrap
  )}) ${foreignKeyClause(ast.references, wrap)}`;
}

function foreignKeyClause(ast, wrap) {
  return `REFERENCES ${table(ast, wrap)}${columnNameListOptional(
    ast,
    wrap
  )}${deleteUpdateMatchList(ast, wrap)}${deferrable(ast.deferrable, wrap)}`;
}

function columnNameListOptional(ast, wrap) {
  return ast.columns.length > 0 ? ` (${columnNameList(ast, wrap)})` : '';
}

function columnNameList(ast, wrap) {
  return ast.columns.map((column) => identifier(column, wrap)).join(', ');
}

function deleteUpdateMatchList(ast, wrap) {
  return `${deleteReference(ast, wrap)}${updateReference(
    ast,
    wrap
  )}${matchReference(ast, wrap)}`;
}

function deleteReference(ast, wrap) {
  return ast.delete !== null ? ` ON DELETE ${ast.delete}` : '';
}

function updateReference(ast, wrap) {
  return ast.update !== null ? ` ON UPDATE ${ast.update}` : '';
}

function matchReference(ast, wrap) {
  return ast.match !== null ? ` MATCH ${ast.match}` : '';
}

function deferrable(ast, wrap) {
  return ast !== null
    ? ` ${ast.not ? 'NOT ' : ''}DEFERRABLE${
        ast.initially !== null ? ` INITIALLY ${ast.initially}` : ''
      }`
    : '';
}

function constraintName(ast, wrap) {
  return ast.name !== null ? `CONSTRAINT ${identifier(ast.name, wrap)} ` : '';
}

function createIndex(ast, wrap) {
  return `CREATE${unique(ast, wrap)} INDEX${exists(ast, wrap)} ${schema(
    ast,
    wrap
  )}${index(ast, wrap)} on ${table(ast, wrap)} (${indexedColumnList(
    ast,
    wrap
  )})${where(ast, wrap)}`;
}

function unique(ast, wrap) {
  return ast.unique ? ' UNIQUE' : '';
}

function exists(ast, wrap) {
  return ast.exists ? ' IF NOT EXISTS' : '';
}

function schema(ast, wrap) {
  return ast.schema !== null ? `${identifier(ast.schema, wrap)}.` : '';
}

function index(ast, wrap) {
  return identifier(ast.index, wrap);
}

function table(ast, wrap) {
  return identifier(ast.table, wrap);
}

function where(ast, wrap) {
  return ast.where !== null ? ` where ${expression(ast.where)}` : '';
}

function indexedColumnList(ast, wrap) {
  return ast.columns
    .map((column) =>
      !column.expression
        ? indexedColumn(column, wrap)
        : indexedColumnExpression(column, wrap)
    )
    .join(', ');
}

function indexedColumn(ast, wrap) {
  return `${identifier(ast.name, wrap)}${collation(ast, wrap)}${order(
    ast,
    wrap
  )}`;
}

function indexedColumnExpression(ast, wrap) {
  return `${indexedExpression(ast.name, wrap)}${collation(ast, wrap)}${order(
    ast,
    wrap
  )}`;
}

function collation(ast, wrap) {
  return ast.collation !== null ? ` COLLATE ${ast.collation}` : '';
}

function order(ast, wrap) {
  return ast.order !== null ? ` ${ast.order}` : '';
}

function indexedExpression(ast, wrap) {
  return expression(ast, wrap);
}

function expression(ast, wrap) {
  return ast.reduce(
    (expr, e) =>
      Array.isArray(e)
        ? `${expr}(${expression(e)})`
        : !expr
        ? e
        : `${expr} ${e}`,
    ''
  );
}

function identifier(ast, wrap) {
  return wrap(ast);
}

module.exports = {
  compileCreateTable,
  compileCreateIndex,
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js":
/***/ ((module) => {

// Sequence parser combinator
function s(sequence, post = (v) => v) {
  return function ({ index = 0, input }) {
    let position = index;
    const ast = [];

    for (const parser of sequence) {
      const result = parser({ index: position, input });

      if (result.success) {
        position = result.index;
        ast.push(result.ast);
      } else {
        return result;
      }
    }

    return { success: true, ast: post(ast), index: position, input };
  };
}

// Alternative parser combinator
function a(alternative, post = (v) => v) {
  return function ({ index = 0, input }) {
    for (const parser of alternative) {
      const result = parser({ index, input });

      if (result.success) {
        return {
          success: true,
          ast: post(result.ast),
          index: result.index,
          input,
        };
      }
    }

    return { success: false, ast: null, index, input };
  };
}

// Many parser combinator
function m(many, post = (v) => v) {
  return function ({ index = 0, input }) {
    let result = {};
    let position = index;
    const ast = [];

    do {
      result = many({ index: position, input });

      if (result.success) {
        position = result.index;
        ast.push(result.ast);
      }
    } while (result.success);

    if (ast.length > 0) {
      return { success: true, ast: post(ast), index: position, input };
    } else {
      return { success: false, ast: null, index: position, input };
    }
  };
}

// Optional parser combinator
function o(optional, post = (v) => v) {
  return function ({ index = 0, input }) {
    const result = optional({ index, input });

    if (result.success) {
      return {
        success: true,
        ast: post(result.ast),
        index: result.index,
        input,
      };
    } else {
      return { success: true, ast: post(null), index, input };
    }
  };
}

// Lookahead parser combinator
function l(lookahead, post = (v) => v) {
  return function ({ index = 0, input }) {
    const result = lookahead.do({ index, input });

    if (result.success) {
      const resultNext = lookahead.next({ index: result.index, input });

      if (resultNext.success) {
        return {
          success: true,
          ast: post(result.ast),
          index: result.index,
          input,
        };
      }
    }

    return { success: false, ast: null, index, input };
  };
}

// Negative parser combinator
function n(negative, post = (v) => v) {
  return function ({ index = 0, input }) {
    const result = negative.do({ index, input });

    if (result.success) {
      const resultNot = negative.not({ index, input });

      if (!resultNot.success) {
        return {
          success: true,
          ast: post(result.ast),
          index: result.index,
          input,
        };
      }
    }

    return { success: false, ast: null, index, input };
  };
}

// Token parser combinator
function t(token, post = (v) => v.text) {
  return function ({ index = 0, input }) {
    const result = input[index];

    if (
      result !== undefined &&
      (token.type === undefined || token.type === result.type) &&
      (token.text === undefined ||
        token.text.toUpperCase() === result.text.toUpperCase())
    ) {
      return {
        success: true,
        ast: post(result),
        index: index + 1,
        input,
      };
    } else {
      return { success: false, ast: null, index, input };
    }
  };
}

// Empty parser constant
const e = function ({ index = 0, input }) {
  return { success: true, ast: null, index, input };
};

// Finish parser constant
const f = function ({ index = 0, input }) {
  return { success: index === input.length, ast: null, index, input };
};

module.exports = { s, a, m, o, l, n, t, e, f };


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/internal/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { tokenize } = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/internal/tokenizer.js");
const { s, a, m, o, l, n, t, e, f } = __webpack_require__("./node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js");

const TOKENS = {
  keyword:
    /(?:ABORT|ACTION|ADD|AFTER|ALL|ALTER|ALWAYS|ANALYZE|AND|AS|ASC|ATTACH|AUTOINCREMENT|BEFORE|BEGIN|BETWEEN|BY|CASCADE|CASE|CAST|CHECK|COLLATE|COLUMN|COMMIT|CONFLICT|CONSTRAINT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|DATABASE|DEFAULT|DEFERRED|DEFERRABLE|DELETE|DESC|DETACH|DISTINCT|DO|DROP|END|EACH|ELSE|ESCAPE|EXCEPT|EXCLUSIVE|EXCLUDE|EXISTS|EXPLAIN|FAIL|FILTER|FIRST|FOLLOWING|FOR|FOREIGN|FROM|FULL|GENERATED|GLOB|GROUP|GROUPS|HAVING|IF|IGNORE|IMMEDIATE|IN|INDEX|INDEXED|INITIALLY|INNER|INSERT|INSTEAD|INTERSECT|INTO|IS|ISNULL|JOIN|KEY|LAST|LEFT|LIKE|LIMIT|MATCH|MATERIALIZED|NATURAL|NO|NOT|NOTHING|NOTNULL|NULL|NULLS|OF|OFFSET|ON|OR|ORDER|OTHERS|OUTER|OVER|PARTITION|PLAN|PRAGMA|PRECEDING|PRIMARY|QUERY|RAISE|RANGE|RECURSIVE|REFERENCES|REGEXP|REINDEX|RELEASE|RENAME|REPLACE|RESTRICT|RETURNING|RIGHT|ROLLBACK|ROW|ROWS|SAVEPOINT|SELECT|SET|TABLE|TEMP|TEMPORARY|THEN|TIES|TO|TRANSACTION|TRIGGER|UNBOUNDED|UNION|UNIQUE|UPDATE|USING|VACUUM|VALUES|VIEW|VIRTUAL|WHEN|WHERE|WINDOW|WITH|WITHOUT)(?=\s+|-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\.)/,
  id: /"[^"]*(?:""[^"]*)*"|`[^`]*(?:``[^`]*)*`|\[[^[\]]*\]|[a-z_][a-z0-9_$]*/,
  string: /'[^']*(?:''[^']*)*'/,
  blob: /x'(?:[0-9a-f][0-9a-f])+'/,
  numeric: /(?:\d+(?:\.\d*)?|\.\d+)(?:e(?:\+|-)?\d+)?|0x[0-9a-f]+/,
  variable: /\?\d*|[@$:][a-z0-9_$]+/,
  operator: /-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\./,
  _ws: /\s+/,
};

function parseCreateTable(sql) {
  const result = createTable({ input: tokenize(sql, TOKENS) });

  if (!result.success) {
    throw new Error(
      `Parsing CREATE TABLE failed at [${result.input
        .slice(result.index)
        .map((t) => t.text)
        .join(' ')}] of "${sql}"`
    );
  }

  return result.ast;
}

function parseCreateIndex(sql) {
  const result = createIndex({ input: tokenize(sql, TOKENS) });

  if (!result.success) {
    throw new Error(
      `Parsing CREATE INDEX failed at [${result.input
        .slice(result.index)
        .map((t) => t.text)
        .join(' ')}] of "${sql}"`
    );
  }

  return result.ast;
}

function createTable(ctx) {
  return s(
    [
      t({ text: 'CREATE' }, (v) => null),
      temporary,
      t({ text: 'TABLE' }, (v) => null),
      exists,
      schema,
      table,
      t({ text: '(' }, (v) => null),
      columnDefinitionList,
      tableConstraintList,
      t({ text: ')' }, (v) => null),
      rowid,
      f,
    ],
    (v) => Object.assign({}, ...v.filter((x) => x !== null))
  )(ctx);
}

function temporary(ctx) {
  return a([t({ text: 'TEMP' }), t({ text: 'TEMPORARY' }), e], (v) => ({
    temporary: v !== null,
  }))(ctx);
}

function rowid(ctx) {
  return o(s([t({ text: 'WITHOUT' }), t({ text: 'ROWID' })]), (v) => ({
    rowid: v !== null,
  }))(ctx);
}

function columnDefinitionList(ctx) {
  return a([
    s([columnDefinition, t({ text: ',' }), columnDefinitionList], (v) => ({
      columns: [v[0]].concat(v[2].columns),
    })),
    s([columnDefinition], (v) => ({ columns: [v[0]] })),
  ])(ctx);
}

function columnDefinition(ctx) {
  return s(
    [s([identifier], (v) => ({ name: v[0] })), typeName, columnConstraintList],
    (v) => Object.assign({}, ...v)
  )(ctx);
}

function typeName(ctx) {
  return o(
    s(
      [
        m(t({ type: 'id' })),
        a([
          s(
            [
              t({ text: '(' }),
              signedNumber,
              t({ text: ',' }),
              signedNumber,
              t({ text: ')' }),
            ],
            (v) => `(${v[1]}, ${v[3]})`
          ),
          s(
            [t({ text: '(' }), signedNumber, t({ text: ')' })],
            (v) => `(${v[1]})`
          ),
          e,
        ]),
      ],
      (v) => `${v[0].join(' ')}${v[1] || ''}`
    ),
    (v) => ({ type: v })
  )(ctx);
}

function columnConstraintList(ctx) {
  return o(m(columnConstraint), (v) => ({
    constraints: Object.assign(
      {
        primary: null,
        notnull: null,
        null: null,
        unique: null,
        check: null,
        default: null,
        collate: null,
        references: null,
        as: null,
      },
      ...(v || [])
    ),
  }))(ctx);
}

function columnConstraint(ctx) {
  return a([
    primaryColumnConstraint,
    notnullColumnConstraint,
    nullColumnConstraint,
    uniqueColumnConstraint,
    checkColumnConstraint,
    defaultColumnConstraint,
    collateColumnConstraint,
    referencesColumnConstraint,
    asColumnConstraint,
  ])(ctx);
}

function primaryColumnConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'PRIMARY' }, (v) => null),
      t({ text: 'KEY' }, (v) => null),
      order,
      conflictClause,
      autoincrement,
    ],
    (v) => ({ primary: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function autoincrement(ctx) {
  return o(t({ text: 'AUTOINCREMENT' }), (v) => ({
    autoincrement: v !== null,
  }))(ctx);
}

function notnullColumnConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'NOT' }, (v) => null),
      t({ text: 'NULL' }, (v) => null),
      conflictClause,
    ],
    (v) => ({ notnull: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function nullColumnConstraint(ctx) {
  return s(
    [constraintName, t({ text: 'NULL' }, (v) => null), conflictClause],
    (v) => ({ null: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function uniqueColumnConstraint(ctx) {
  return s(
    [constraintName, t({ text: 'UNIQUE' }, (v) => null), conflictClause],
    (v) => ({ unique: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function checkColumnConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'CHECK' }, (v) => null),
      t({ text: '(' }, (v) => null),
      s([expression], (v) => ({ expression: v[0] })),
      t({ text: ')' }, (v) => null),
    ],
    (v) => ({ check: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function defaultColumnConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'DEFAULT' }, (v) => null),
      a([
        s([t({ text: '(' }), expression, t({ text: ')' })], (v) => ({
          value: v[1],
          expression: true,
        })),
        s([literalValue], (v) => ({ value: v[0], expression: false })),
        s([signedNumber], (v) => ({ value: v[0], expression: false })),
      ]),
    ],
    (v) => ({ default: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function collateColumnConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'COLLATE' }, (v) => null),
      t({ type: 'id' }, (v) => ({ collation: v.text })),
    ],
    (v) => ({ collate: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function referencesColumnConstraint(ctx) {
  return s(
    [constraintName, s([foreignKeyClause], (v) => v[0].references)],
    (v) => ({
      references: Object.assign({}, ...v.filter((x) => x !== null)),
    })
  )(ctx);
}

function asColumnConstraint(ctx) {
  return s(
    [
      constraintName,
      o(s([t({ text: 'GENERATED' }), t({ text: 'ALWAYS' })]), (v) => ({
        generated: v !== null,
      })),
      t({ text: 'AS' }, (v) => null),
      t({ text: '(' }, (v) => null),
      s([expression], (v) => ({ expression: v[0] })),
      t({ text: ')' }, (v) => null),
      a([t({ text: 'STORED' }), t({ text: 'VIRTUAL' }), e], (v) => ({
        mode: v ? v.toUpperCase() : null,
      })),
    ],
    (v) => ({ as: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function tableConstraintList(ctx) {
  return o(m(s([t({ text: ',' }), tableConstraint], (v) => v[1])), (v) => ({
    constraints: v || [],
  }))(ctx);
}

function tableConstraint(ctx) {
  return a([
    primaryTableConstraint,
    uniqueTableConstraint,
    checkTableConstraint,
    foreignTableConstraint,
  ])(ctx);
}

function primaryTableConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'PRIMARY' }, (v) => null),
      t({ text: 'KEY' }, (v) => null),
      t({ text: '(' }, (v) => null),
      indexedColumnList,
      t({ text: ')' }, (v) => null),
      conflictClause,
    ],
    (v) =>
      Object.assign({ type: 'PRIMARY KEY' }, ...v.filter((x) => x !== null))
  )(ctx);
}

function uniqueTableConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'UNIQUE' }, (v) => null),
      t({ text: '(' }, (v) => null),
      indexedColumnList,
      t({ text: ')' }, (v) => null),
      conflictClause,
    ],
    (v) => Object.assign({ type: 'UNIQUE' }, ...v.filter((x) => x !== null))
  )(ctx);
}

function conflictClause(ctx) {
  return o(
    s(
      [
        t({ text: 'ON' }),
        t({ text: 'CONFLICT' }),
        a([
          t({ text: 'ROLLBACK' }),
          t({ text: 'ABORT' }),
          t({ text: 'FAIL' }),
          t({ text: 'IGNORE' }),
          t({ text: 'REPLACE' }),
        ]),
      ],
      (v) => v[2]
    ),
    (v) => ({ conflict: v ? v.toUpperCase() : null })
  )(ctx);
}

function checkTableConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'CHECK' }, (v) => null),
      t({ text: '(' }, (v) => null),
      s([expression], (v) => ({ expression: v[0] })),
      t({ text: ')' }, (v) => null),
    ],
    (v) => Object.assign({ type: 'CHECK' }, ...v.filter((x) => x !== null))
  )(ctx);
}

function foreignTableConstraint(ctx) {
  return s(
    [
      constraintName,
      t({ text: 'FOREIGN' }, (v) => null),
      t({ text: 'KEY' }, (v) => null),
      t({ text: '(' }, (v) => null),
      columnNameList,
      t({ text: ')' }, (v) => null),
      foreignKeyClause,
    ],
    (v) =>
      Object.assign({ type: 'FOREIGN KEY' }, ...v.filter((x) => x !== null))
  )(ctx);
}

function foreignKeyClause(ctx) {
  return s(
    [
      t({ text: 'REFERENCES' }, (v) => null),
      table,
      columnNameListOptional,
      o(m(a([deleteReference, updateReference, matchReference])), (v) =>
        Object.assign({ delete: null, update: null, match: null }, ...(v || []))
      ),
      deferrable,
    ],
    (v) => ({ references: Object.assign({}, ...v.filter((x) => x !== null)) })
  )(ctx);
}

function columnNameListOptional(ctx) {
  return o(
    s([t({ text: '(' }), columnNameList, t({ text: ')' })], (v) => v[1]),
    (v) => ({ columns: v ? v.columns : [] })
  )(ctx);
}

function columnNameList(ctx) {
  return s(
    [
      o(m(s([identifier, t({ text: ',' })], (v) => v[0])), (v) =>
        v !== null ? v : []
      ),
      identifier,
    ],
    (v) => ({ columns: v[0].concat([v[1]]) })
  )(ctx);
}

function deleteReference(ctx) {
  return s([t({ text: 'ON' }), t({ text: 'DELETE' }), onAction], (v) => ({
    delete: v[2],
  }))(ctx);
}

function updateReference(ctx) {
  return s([t({ text: 'ON' }), t({ text: 'UPDATE' }), onAction], (v) => ({
    update: v[2],
  }))(ctx);
}

function matchReference(ctx) {
  return s(
    [t({ text: 'MATCH' }), a([t({ type: 'keyword' }), t({ type: 'id' })])],
    (v) => ({ match: v[1] })
  )(ctx);
}

function deferrable(ctx) {
  return o(
    s([
      o(t({ text: 'NOT' })),
      t({ text: 'DEFERRABLE' }),
      o(
        s(
          [
            t({ text: 'INITIALLY' }),
            a([t({ text: 'DEFERRED' }), t({ text: 'IMMEDIATE' })]),
          ],
          (v) => v[1].toUpperCase()
        )
      ),
    ]),
    (v) => ({ deferrable: v ? { not: v[0] !== null, initially: v[2] } : null })
  )(ctx);
}

function constraintName(ctx) {
  return o(
    s([t({ text: 'CONSTRAINT' }), identifier], (v) => v[1]),
    (v) => ({ name: v })
  )(ctx);
}

function createIndex(ctx) {
  return s(
    [
      t({ text: 'CREATE' }, (v) => null),
      unique,
      t({ text: 'INDEX' }, (v) => null),
      exists,
      schema,
      index,
      t({ text: 'ON' }, (v) => null),
      table,
      t({ text: '(' }, (v) => null),
      indexedColumnList,
      t({ text: ')' }, (v) => null),
      where,
      f,
    ],
    (v) => Object.assign({}, ...v.filter((x) => x !== null))
  )(ctx);
}

function unique(ctx) {
  return o(t({ text: 'UNIQUE' }), (v) => ({ unique: v !== null }))(ctx);
}

function exists(ctx) {
  return o(
    s([t({ text: 'IF' }), t({ text: 'NOT' }), t({ text: 'EXISTS' })]),
    (v) => ({ exists: v !== null })
  )(ctx);
}

function schema(ctx) {
  return o(
    s([identifier, t({ text: '.' })], (v) => v[0]),
    (v) => ({ schema: v })
  )(ctx);
}

function index(ctx) {
  return s([identifier], (v) => ({ index: v[0] }))(ctx);
}

function table(ctx) {
  return s([identifier], (v) => ({ table: v[0] }))(ctx);
}

function where(ctx) {
  return o(
    s([t({ text: 'WHERE' }), expression], (v) => v[1]),
    (v) => ({ where: v })
  )(ctx);
}

function indexedColumnList(ctx) {
  return a([
    s([indexedColumn, t({ text: ',' }), indexedColumnList], (v) => ({
      columns: [v[0]].concat(v[2].columns),
    })),
    s([indexedColumnExpression, t({ text: ',' }), indexedColumnList], (v) => ({
      columns: [v[0]].concat(v[2].columns),
    })),
    l({ do: indexedColumn, next: t({ text: ')' }) }, (v) => ({
      columns: [v],
    })),
    l({ do: indexedColumnExpression, next: t({ text: ')' }) }, (v) => ({
      columns: [v],
    })),
  ])(ctx);
}

function indexedColumn(ctx) {
  return s(
    [
      s([identifier], (v) => ({ name: v[0], expression: false })),
      collation,
      order,
    ],
    (v) => Object.assign({}, ...v.filter((x) => x !== null))
  )(ctx);
}

function indexedColumnExpression(ctx) {
  return s(
    [
      s([indexedExpression], (v) => ({ name: v[0], expression: true })),
      collation,
      order,
    ],
    (v) => Object.assign({}, ...v.filter((x) => x !== null))
  )(ctx);
}

function collation(ctx) {
  return o(
    s([t({ text: 'COLLATE' }), t({ type: 'id' })], (v) => v[1]),
    (v) => ({ collation: v })
  )(ctx);
}

function order(ctx) {
  return a([t({ text: 'ASC' }), t({ text: 'DESC' }), e], (v) => ({
    order: v ? v.toUpperCase() : null,
  }))(ctx);
}

function indexedExpression(ctx) {
  return m(
    a([
      n({
        do: t({ type: 'keyword' }),
        not: a([
          t({ text: 'COLLATE' }),
          t({ text: 'ASC' }),
          t({ text: 'DESC' }),
        ]),
      }),
      t({ type: 'id' }),
      t({ type: 'string' }),
      t({ type: 'blob' }),
      t({ type: 'numeric' }),
      t({ type: 'variable' }),
      n({
        do: t({ type: 'operator' }),
        not: a([t({ text: '(' }), t({ text: ')' }), t({ text: ',' })]),
      }),
      s([t({ text: '(' }), o(expression), t({ text: ')' })], (v) => v[1] || []),
    ])
  )(ctx);
}

function expression(ctx) {
  return m(
    a([
      t({ type: 'keyword' }),
      t({ type: 'id' }),
      t({ type: 'string' }),
      t({ type: 'blob' }),
      t({ type: 'numeric' }),
      t({ type: 'variable' }),
      n({
        do: t({ type: 'operator' }),
        not: a([t({ text: '(' }), t({ text: ')' })]),
      }),
      s([t({ text: '(' }), o(expression), t({ text: ')' })], (v) => v[1] || []),
    ])
  )(ctx);
}

function identifier(ctx) {
  return a([t({ type: 'id' }), t({ type: 'string' })], (v) =>
    /^["`['][^]*["`\]']$/.test(v) ? v.substring(1, v.length - 1) : v
  )(ctx);
}

function onAction(ctx) {
  return a(
    [
      s([t({ text: 'SET' }), t({ text: 'NULL' })], (v) => `${v[0]} ${v[1]}`),
      s([t({ text: 'SET' }), t({ text: 'DEFAULT' })], (v) => `${v[0]} ${v[1]}`),
      t({ text: 'CASCADE' }),
      t({ text: 'RESTRICT' }),
      s([t({ text: 'NO' }), t({ text: 'ACTION' })], (v) => `${v[0]} ${v[1]}`),
    ],
    (v) => v.toUpperCase()
  )(ctx);
}

function literalValue(ctx) {
  return a([
    t({ type: 'numeric' }),
    t({ type: 'string' }),
    t({ type: 'id' }),
    t({ type: 'blob' }),
    t({ text: 'NULL' }),
    t({ text: 'TRUE' }),
    t({ text: 'FALSE' }),
    t({ text: 'CURRENT_TIME' }),
    t({ text: 'CURRENT_DATE' }),
    t({ text: 'CURRENT_TIMESTAMP' }),
  ])(ctx);
}

function signedNumber(ctx) {
  return s(
    [a([t({ text: '+' }), t({ text: '-' }), e]), t({ type: 'numeric' })],
    (v) => `${v[0] || ''}${v[1]}`
  )(ctx);
}

module.exports = {
  parseCreateTable,
  parseCreateIndex,
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js":
/***/ ((module) => {

function copyData(sourceTable, targetTable, columns) {
  return `INSERT INTO "${targetTable}" SELECT ${
    columns === undefined
      ? '*'
      : columns.map((column) => `"${column}"`).join(', ')
  } FROM "${sourceTable}";`;
}

function dropOriginal(tableName) {
  return `DROP TABLE "${tableName}"`;
}

function renameTable(tableName, alteredName) {
  return `ALTER TABLE "${tableName}" RENAME TO "${alteredName}"`;
}

function getTableSql(tableName) {
  return `SELECT type, sql FROM sqlite_master WHERE (type='table' OR (type='index' AND sql IS NOT NULL)) AND lower(tbl_name)='${tableName.toLowerCase()}'`;
}

function isForeignCheckEnabled() {
  return `PRAGMA foreign_keys`;
}

function setForeignCheck(enable) {
  return `PRAGMA foreign_keys = ${enable ? 'ON' : 'OFF'}`;
}

function executeForeignCheck() {
  return `PRAGMA foreign_key_check`;
}

module.exports = {
  copyData,
  dropOriginal,
  renameTable,
  getTableSql,
  isForeignCheckEnabled,
  setForeignCheck,
  executeForeignCheck,
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/internal/tokenizer.js":
/***/ ((module) => {

function tokenize(text, tokens) {
  const compiledRegex = new RegExp(
    Object.entries(tokens)
      .map(([type, regex]) => `(?<${type}>${regex.source})`)
      .join('|'),
    'yi'
  );

  let index = 0;
  const ast = [];

  while (index < text.length) {
    compiledRegex.lastIndex = index;
    const result = text.match(compiledRegex);

    if (result !== null) {
      const [type, text] = Object.entries(result.groups).find(
        ([name, group]) => group !== undefined
      );

      index += text.length;

      if (!type.startsWith('_')) {
        ast.push({ type, text });
      }
    } else {
      throw new Error(
        `No matching tokenizer rule found at: [${text.substring(index)}]`
      );
    }
  }

  return ast;
}

module.exports = {
  tokenize,
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/internal/utils.js":
/***/ ((module) => {

function isEqualId(first, second) {
  return first.toLowerCase() === second.toLowerCase();
}

function includesId(list, id) {
  return list.some((item) => isEqualId(item, id));
}

module.exports = {
  isEqualId,
  includesId,
};


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-columncompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ColumnCompiler = __webpack_require__("./node_modules/knex/lib/schema/columncompiler.js");

// Column Compiler
// -------

class ColumnCompiler_SQLite3 extends ColumnCompiler {
  constructor() {
    super(...arguments);
    this.modifiers = ['nullable', 'defaultTo'];
    this._addCheckModifiers();
  }

  // Types
  // -------

  enu(allowed) {
    return `text check (${this.formatter.wrap(
      this.args[0]
    )} in ('${allowed.join("', '")}'))`;
  }

  _pushAlterCheckQuery(checkPredicate, constraintName) {
    throw new Error(
      `Alter table with to add constraints is not permitted in SQLite`
    );
  }

  checkRegex(regexes, constraintName) {
    return this._check(
      `${this.formatter.wrap(
        this.getColumnName()
      )} REGEXP ${this.client._escapeBinding(regexes)}`,
      constraintName
    );
  }
}

ColumnCompiler_SQLite3.prototype.json = 'json';
ColumnCompiler_SQLite3.prototype.jsonb = 'json';
ColumnCompiler_SQLite3.prototype.double =
  ColumnCompiler_SQLite3.prototype.decimal =
  ColumnCompiler_SQLite3.prototype.floating =
    'float';
ColumnCompiler_SQLite3.prototype.timestamp = 'datetime';
// autoincrement without primary key is a syntax error in SQLite, so it's necessary
ColumnCompiler_SQLite3.prototype.increments =
  ColumnCompiler_SQLite3.prototype.bigincrements =
    'integer not null primary key autoincrement';

module.exports = ColumnCompiler_SQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// SQLite3: Column Builder & Compiler
// -------
const SchemaCompiler = __webpack_require__("./node_modules/knex/lib/schema/compiler.js");

const some = __webpack_require__("./node_modules/lodash/some.js");

// Schema Compiler
// -------

class SchemaCompiler_SQLite3 extends SchemaCompiler {
  constructor(client, builder) {
    super(client, builder);
  }

  // Compile the query to determine if a table exists.
  hasTable(tableName) {
    const sql =
      `select * from sqlite_master ` +
      `where type = 'table' and name = ${this.client.parameter(
        this.formatter.wrap(tableName).replace(/`/g, ''),
        this.builder,
        this.bindingsHolder
      )}`;
    this.pushQuery({ sql, output: (resp) => resp.length > 0 });
  }

  // Compile the query to determine if a column exists.
  hasColumn(tableName, column) {
    this.pushQuery({
      sql: `PRAGMA table_info(${this.formatter.wrap(tableName)})`,
      output(resp) {
        return some(resp, (col) => {
          return (
            this.client.wrapIdentifier(col.name.toLowerCase()) ===
            this.client.wrapIdentifier(column.toLowerCase())
          );
        });
      },
    });
  }

  // Compile a rename table command.
  renameTable(from, to) {
    this.pushQuery(
      `alter table ${this.formatter.wrap(from)} rename to ${this.formatter.wrap(
        to
      )}`
    );
  }

  async generateDdlCommands() {
    const sequence = this.builder._sequence;
    for (let i = 0, l = sequence.length; i < l; i++) {
      const query = sequence[i];
      this[query.method].apply(this, query.args);
    }

    const commandSources = this.sequence;

    if (commandSources.length === 1 && commandSources[0].statementsProducer) {
      return commandSources[0].statementsProducer();
    } else {
      const result = [];

      for (const commandSource of commandSources) {
        const command = commandSource.sql;

        if (Array.isArray(command)) {
          result.push(...command);
        } else {
          result.push(command);
        }
      }

      return { pre: [], sql: result, check: null, post: [] };
    }
  }
}

module.exports = SchemaCompiler_SQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const filter = __webpack_require__("./node_modules/lodash/filter.js");
const values = __webpack_require__("./node_modules/lodash/values.js");
const identity = __webpack_require__("./node_modules/lodash/identity.js");
const { isObject } = __webpack_require__("./node_modules/knex/lib/util/is.js");

const TableCompiler = __webpack_require__("./node_modules/knex/lib/schema/tablecompiler.js");
const { formatDefault } = __webpack_require__("./node_modules/knex/lib/formatter/formatterUtils.js");

class TableCompiler_SQLite3 extends TableCompiler {
  constructor() {
    super(...arguments);
  }

  // Create a new table.
  createQuery(columns, ifNot, like) {
    const createStatement = ifNot
      ? 'create table if not exists '
      : 'create table ';

    let sql = createStatement + this.tableName();

    if (like && this.tableNameLike()) {
      sql += ' as select * from ' + this.tableNameLike() + ' where 0=1';
    } else {
      // so we will need to check for a primary key commands and add the columns
      // to the table's declaration here so they can be created on the tables.
      sql += ' (' + columns.sql.join(', ');
      sql += this.foreignKeys() || '';
      sql += this.primaryKeys() || '';
      sql += this._addChecks();
      sql += ')';
    }
    this.pushQuery(sql);

    if (like) {
      this.addColumns(columns, this.addColumnsPrefix);
    }
  }

  addColumns(columns, prefix, colCompilers) {
    if (prefix === this.alterColumnsPrefix) {
      const compiler = this;

      const columnsInfo = colCompilers.map((col) => {
        const name = this.client.customWrapIdentifier(
          col.getColumnName(),
          identity,
          col.columnBuilder.queryContext()
        );

        const type = col.getColumnType();

        const defaultTo = col.modified['defaultTo']
          ? formatDefault(col.modified['defaultTo'][0], col.type, this.client)
          : null;

        const notNull =
          col.modified['nullable'] && col.modified['nullable'][0] === false;

        return { name, type, defaultTo, notNull };
      });

      this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        statementsProducer(pragma, connection) {
          return compiler.client
            .ddl(compiler, pragma, connection)
            .alterColumn(columnsInfo);
        },
      });
    } else {
      for (let i = 0, l = columns.sql.length; i < l; i++) {
        this.pushQuery({
          sql: `alter table ${this.tableName()} add column ${columns.sql[i]}`,
          bindings: columns.bindings[i],
        });
      }
    }
  }

  // Compile a drop unique key command.
  dropUnique(columns, indexName) {
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('unique', this.tableNameRaw, columns);
    this.pushQuery(`drop index ${indexName}`);
  }

  // Compile a drop foreign key command.
  dropForeign(columns, indexName) {
    const compiler = this;

    columns = Array.isArray(columns) ? columns : [columns];
    columns = columns.map((column) =>
      this.client.customWrapIdentifier(column, identity)
    );
    indexName = this.client.customWrapIdentifier(indexName, identity);

    this.pushQuery({
      sql: `PRAGMA table_info(${this.tableName()})`,
      output(pragma) {
        return compiler.client
          .ddl(compiler, pragma, this.connection)
          .dropForeign(columns, indexName);
      },
    });
  }

  // Compile a drop primary key command.
  dropPrimary(constraintName) {
    const compiler = this;

    constraintName = this.client.customWrapIdentifier(constraintName, identity);

    this.pushQuery({
      sql: `PRAGMA table_info(${this.tableName()})`,
      output(pragma) {
        return compiler.client
          .ddl(compiler, pragma, this.connection)
          .dropPrimary(constraintName);
      },
    });
  }

  dropIndex(columns, indexName) {
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('index', this.tableNameRaw, columns);
    this.pushQuery(`drop index ${indexName}`);
  }

  // Compile a unique key command.
  unique(columns, indexName) {
    let deferrable;
    let predicate;
    if (isObject(indexName)) {
      ({ indexName, deferrable, predicate } = indexName);
    }
    if (deferrable && deferrable !== 'not deferrable') {
      this.client.logger.warn(
        `sqlite3: unique index \`${indexName}\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`
      );
    }
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('unique', this.tableNameRaw, columns);
    columns = this.formatter.columnize(columns);

    const predicateQuery = predicate
      ? ' ' + this.client.queryCompiler(predicate).where()
      : '';

    this.pushQuery(
      `create unique index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`
    );
  }

  // Compile a plain index key command.
  index(columns, indexName, options) {
    indexName = indexName
      ? this.formatter.wrap(indexName)
      : this._indexCommand('index', this.tableNameRaw, columns);
    columns = this.formatter.columnize(columns);

    let predicate;
    if (isObject(options)) {
      ({ predicate } = options);
    }
    const predicateQuery = predicate
      ? ' ' + this.client.queryCompiler(predicate).where()
      : '';
    this.pushQuery(
      `create index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`
    );
  }

  /**
   * Add a primary key to an existing table.
   *
   * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table
   *       creation in this method
   *
   * @param {string | string[]} columns - Column name(s) to assign as primary keys
   * @param {string} [constraintName] - Custom name for the PK constraint
   */
  primary(columns, constraintName) {
    const compiler = this;

    columns = Array.isArray(columns) ? columns : [columns];
    columns = columns.map((column) =>
      this.client.customWrapIdentifier(column, identity)
    );

    let deferrable;
    if (isObject(constraintName)) {
      ({ constraintName, deferrable } = constraintName);
    }
    if (deferrable && deferrable !== 'not deferrable') {
      this.client.logger.warn(
        `sqlite3: primary key constraint \`${constraintName}\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`
      );
    }
    constraintName = this.client.customWrapIdentifier(constraintName, identity);

    if (this.method !== 'create' && this.method !== 'createIfNot') {
      this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        output(pragma) {
          return compiler.client
            .ddl(compiler, pragma, this.connection)
            .primary(columns, constraintName);
        },
      });
    }
  }

  /**
   * Add a foreign key constraint to an existing table
   *
   * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do
   *       anything regarding table creation in this method
   *
   * @param {object} foreignInfo - Information about the current column foreign setup
   * @param {string | string[]} [foreignInfo.column] - Column in the current constraint
   * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint
   * @param {string | string[]} foreignInfo.references - What column it references in the other table
   * @param {string} foreignInfo.inTable - What table is referenced in this constraint
   * @param {string} [foreignInfo.onUpdate] - What to do on updates
   * @param {string} [foreignInfo.onDelete] - What to do on deletions
   */
  foreign(foreignInfo) {
    const compiler = this;

    if (this.method !== 'create' && this.method !== 'createIfNot') {
      foreignInfo.column = Array.isArray(foreignInfo.column)
        ? foreignInfo.column
        : [foreignInfo.column];
      foreignInfo.column = foreignInfo.column.map((column) =>
        this.client.customWrapIdentifier(column, identity)
      );
      foreignInfo.inTable = this.client.customWrapIdentifier(
        foreignInfo.inTable,
        identity
      );
      foreignInfo.references = Array.isArray(foreignInfo.references)
        ? foreignInfo.references
        : [foreignInfo.references];
      foreignInfo.references = foreignInfo.references.map((column) =>
        this.client.customWrapIdentifier(column, identity)
      );

      this.pushQuery({
        sql: `PRAGMA table_info(${this.tableName()})`,
        statementsProducer(pragma, connection) {
          return compiler.client
            .ddl(compiler, pragma, connection)
            .foreign(foreignInfo);
        },
      });
    }
  }

  primaryKeys() {
    const pks = filter(this.grouped.alterTable || [], { method: 'primary' });
    if (pks.length > 0 && pks[0].args.length > 0) {
      const columns = pks[0].args[0];
      let constraintName = pks[0].args[1] || '';
      if (constraintName) {
        constraintName = ' constraint ' + this.formatter.wrap(constraintName);
      }
      const needUniqueCols =
        this.grouped.columns.filter((t) => t.builder._type === 'increments')
          .length > 0;
      // SQLite dont support autoincrement columns and composite primary keys (autoincrement is always primary key).
      // You need to add unique index instead when you have autoincrement columns (https://stackoverflow.com/a/6154876/1535159)
      return `,${constraintName} ${
        needUniqueCols ? 'unique' : 'primary key'
      } (${this.formatter.columnize(columns)})`;
    }
  }

  foreignKeys() {
    let sql = '';
    const foreignKeys = filter(this.grouped.alterTable || [], {
      method: 'foreign',
    });
    for (let i = 0, l = foreignKeys.length; i < l; i++) {
      const foreign = foreignKeys[i].args[0];
      const column = this.formatter.columnize(foreign.column);
      const references = this.formatter.columnize(foreign.references);
      const foreignTable = this.formatter.wrap(foreign.inTable);
      let constraintName = foreign.keyName || '';
      if (constraintName) {
        constraintName = ' constraint ' + this.formatter.wrap(constraintName);
      }
      sql += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;
      if (foreign.onDelete) sql += ` on delete ${foreign.onDelete}`;
      if (foreign.onUpdate) sql += ` on update ${foreign.onUpdate}`;
    }
    return sql;
  }

  createTableBlock() {
    return this.getColumns().concat().join(',');
  }

  renameColumn(from, to) {
    this.pushQuery({
      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
        from
      )} to ${this.formatter.wrap(to)}`,
    });
  }

  _setNullableState(column, isNullable) {
    const compiler = this;

    this.pushQuery({
      sql: `PRAGMA table_info(${this.tableName()})`,
      statementsProducer(pragma, connection) {
        return compiler.client
          .ddl(compiler, pragma, connection)
          .setNullable(column, isNullable);
      },
    });
  }

  dropColumn() {
    const compiler = this;
    const columns = values(arguments);

    const columnsWrapped = columns.map((column) =>
      this.client.customWrapIdentifier(column, identity)
    );

    this.pushQuery({
      sql: `PRAGMA table_info(${this.tableName()})`,
      output(pragma) {
        return compiler.client
          .ddl(compiler, pragma, this.connection)
          .dropColumn(columnsWrapped);
      },
    });
  }
}

module.exports = TableCompiler_SQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/dialects/sqlite3/schema/sqlite-viewcompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint max-len: 0 */

const ViewCompiler = __webpack_require__("./node_modules/knex/lib/schema/viewcompiler.js");
const {
  columnize: columnize_,
} = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

class ViewCompiler_SQLite3 extends ViewCompiler {
  constructor(client, viewCompiler) {
    super(client, viewCompiler);
  }
  createOrReplace() {
    const columns = this.columns;
    const selectQuery = this.selectQuery.toString();
    const viewName = this.viewName();

    const columnList = columns
      ? ' (' +
        columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) +
        ')'
      : '';

    const dropSql = `drop view if exists ${viewName}`;
    const createSql = `create view ${viewName}${columnList} as ${selectQuery}`;

    this.pushQuery({
      sql: dropSql,
    });
    this.pushQuery({
      sql: createSql,
    });
  }
}

module.exports = ViewCompiler_SQLite3;


/***/ }),

/***/ "./node_modules/knex/lib/execution/batch-insert.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const chunk = __webpack_require__("./node_modules/lodash/chunk.js");
const flatten = __webpack_require__("./node_modules/lodash/flatten.js");
const delay = __webpack_require__("./node_modules/knex/lib/execution/internal/delay.js");
const { isNumber } = __webpack_require__("./node_modules/knex/lib/util/is.js");

function batchInsert(client, tableName, batch, chunkSize = 1000) {
  let returning = undefined;
  let transaction = null;
  if (!isNumber(chunkSize) || chunkSize < 1) {
    throw new TypeError(`Invalid chunkSize: ${chunkSize}`);
  }
  if (!Array.isArray(batch)) {
    throw new TypeError(`Invalid batch: Expected array, got ${typeof batch}`);
  }
  const chunks = chunk(batch, chunkSize);

  const runInTransaction = (cb) => {
    if (transaction) {
      return cb(transaction);
    }
    return client.transaction(cb);
  };

  return Object.assign(
    Promise.resolve().then(async () => {
      //Next tick to ensure wrapper functions are called if needed
      await delay(1);
      return runInTransaction(async (tr) => {
        const chunksResults = [];
        for (const items of chunks) {
          chunksResults.push(await tr(tableName).insert(items, returning));
        }
        return flatten(chunksResults);
      });
    }),
    {
      returning(columns) {
        returning = columns;

        return this;
      },
      transacting(tr) {
        transaction = tr;

        return this;
      },
    }
  );
}

module.exports = batchInsert;


/***/ }),

/***/ "./node_modules/knex/lib/execution/internal/delay.js":
/***/ ((module) => {

/**
 * @param {number} delay
 * @returns {Promise<void>}
 */
module.exports = (delay) =>
  new Promise((resolve) => setTimeout(resolve, delay));


/***/ }),

/***/ "./node_modules/knex/lib/execution/internal/ensure-connection-callback.js":
/***/ ((module) => {

function ensureConnectionCallback(runner) {
  runner.client.emit('start', runner.builder);
  runner.builder.emit('start', runner.builder);
  const sql = runner.builder.toSQL();

  if (runner.builder._debug) {
    runner.client.logger.debug(sql);
  }

  if (Array.isArray(sql)) {
    return runner.queryArray(sql);
  }
  return runner.query(sql);
}

function ensureConnectionStreamCallback(runner, params) {
  try {
    const sql = runner.builder.toSQL();

    if (Array.isArray(sql) && params.hasHandler) {
      throw new Error(
        'The stream may only be used with a single query statement.'
      );
    }

    return runner.client.stream(
      runner.connection,
      sql,
      params.stream,
      params.options
    );
  } catch (e) {
    params.stream.emit('error', e);
    throw e;
  }
}

module.exports = {
  ensureConnectionCallback,
  ensureConnectionStreamCallback,
};


/***/ }),

/***/ "./node_modules/knex/lib/execution/internal/query-executioner.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _debugQuery = __webpack_require__("./node_modules/debug/src/index.js")('knex:query');
const debugBindings = __webpack_require__("./node_modules/debug/src/index.js")('knex:bindings');
const debugQuery = (sql, txId) => _debugQuery(sql.replace(/%/g, '%%'), txId);
const { isString } = __webpack_require__("./node_modules/knex/lib/util/is.js");

function formatQuery(sql, bindings, timeZone, client) {
  bindings = bindings == null ? [] : [].concat(bindings);
  let index = 0;
  return sql.replace(/\\?\?/g, (match) => {
    if (match === '\\?') {
      return '?';
    }
    if (index === bindings.length) {
      return match;
    }
    const value = bindings[index++];
    return client._escapeBinding(value, { timeZone });
  });
}

function enrichQueryObject(connection, queryParam, client) {
  const queryObject = isString(queryParam) ? { sql: queryParam } : queryParam;

  queryObject.bindings = client.prepBindings(queryObject.bindings);
  queryObject.sql = client.positionBindings(queryObject.sql);

  const { __knexUid, __knexTxId } = connection;

  client.emit('query', Object.assign({ __knexUid, __knexTxId }, queryObject));
  debugQuery(queryObject.sql, __knexTxId);
  debugBindings(queryObject.bindings, __knexTxId);

  return queryObject;
}

function executeQuery(connection, queryObject, client) {
  return client._query(connection, queryObject).catch((err) => {
    if (client.config && client.config.compileSqlOnError === false) {
      err.message = queryObject.sql + ' - ' + err.message;
    } else {
      err.message =
        formatQuery(queryObject.sql, queryObject.bindings, undefined, client) +
        ' - ' +
        err.message;
    }
    client.emit(
      'query-error',
      err,
      Object.assign(
        { __knexUid: connection.__knexUid, __knexTxId: connection.__knexUid },
        queryObject
      )
    );
    throw err;
  });
}

module.exports = {
  enrichQueryObject,
  executeQuery,
  formatQuery,
};


/***/ }),

/***/ "./node_modules/knex/lib/execution/runner.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { KnexTimeoutError } = __webpack_require__("./node_modules/knex/lib/util/timeout.js");
const { timeout } = __webpack_require__("./node_modules/knex/lib/util/timeout.js");
const {
  ensureConnectionCallback,
  ensureConnectionStreamCallback,
} = __webpack_require__("./node_modules/knex/lib/execution/internal/ensure-connection-callback.js");

let Transform;

// The "Runner" constructor takes a "builder" (query, schema, or raw)
// and runs through each of the query statements, calling any additional
// "output" method provided alongside the query and bindings.
class Runner {
  constructor(client, builder) {
    this.client = client;
    this.builder = builder;
    this.queries = [];

    // The "connection" object is set on the runner when
    // "run" is called.
    this.connection = undefined;
  }

  // "Run" the target, calling "toSQL" on the builder, returning
  // an object or array of queries to run, each of which are run on
  // a single connection.
  async run() {
    const runner = this;
    try {
      const res = await this.ensureConnection(ensureConnectionCallback);

      // Fire a single "end" event on the builder when
      // all queries have successfully completed.
      runner.builder.emit('end');
      return res;

      // If there are any "error" listeners, we fire an error event
      // and then re-throw the error to be eventually handled by
      // the promise chain. Useful if you're wrapping in a custom `Promise`.
    } catch (err) {
      if (runner.builder._events && runner.builder._events.error) {
        runner.builder.emit('error', err);
      }
      throw err;
    }
  }

  // Stream the result set, by passing through to the dialect's streaming
  // capabilities. If the options are
  stream(optionsOrHandler, handlerOrNil) {
    const firstOptionIsHandler =
      typeof optionsOrHandler === 'function' && arguments.length === 1;

    const options = firstOptionIsHandler ? {} : optionsOrHandler;
    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;

    // Determines whether we emit an error or throw here.
    const hasHandler = typeof handler === 'function';

    // Lazy-load the "Transform" dependency.
    Transform = Transform || (__webpack_require__("stream").Transform);

    const queryContext = this.builder.queryContext();

    const stream = new Transform({
      objectMode: true,
      transform: (chunk, _, callback) => {
        callback(null, this.client.postProcessResponse(chunk, queryContext));
      },
    });
    stream.on('close', () => {
      this.client.releaseConnection(this.connection);
    });

    // If the stream is manually destroyed, the close event is not
    // propagated to the top of the pipe chain. We need to manually verify
    // that the source stream is closed and if not, manually destroy it.
    stream.on('pipe', (sourceStream) => {
      const cleanSourceStream = () => {
        if (!sourceStream.closed) {
          sourceStream.destroy();
        }
      };

      // Stream already closed, cleanup immediately
      if (stream.closed) {
        cleanSourceStream();
      } else {
        stream.on('close', cleanSourceStream);
      }
    });

    const connectionAcquirePromise = this.ensureConnection(
      ensureConnectionStreamCallback,
      {
        options,
        hasHandler,
        stream,
      }
    )
      // Emit errors on the stream if the error occurred before a connection
      // could be acquired.
      // If the connection was acquired, assume the error occurred in the client
      // code and has already been emitted on the stream. Don't emit it twice.
      .catch((err) => {
        if (!this.connection) {
          stream.emit('error', err);
        }
      });

    // If a function is passed to handle the stream, send the stream
    // there and return the promise, otherwise just return the stream
    // and the promise will take care of itself.
    if (hasHandler) {
      handler(stream);
      return connectionAcquirePromise;
    }
    return stream;
  }

  // Allow you to pipe the stream to a writable stream.
  pipe(writable, options) {
    return this.stream(options).pipe(writable);
  }

  // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
  // to run in sequence, and on the same connection, especially helpful when schema building
  // and dealing with foreign key constraints, etc.
  async query(obj) {
    const { __knexUid, __knexTxId } = this.connection;

    this.builder.emit('query', Object.assign({ __knexUid, __knexTxId }, obj));

    const runner = this;
    const queryContext = this.builder.queryContext();
    // query-error events are emitted before the queryPromise continuations.
    // pass queryContext into client.query so it can be raised properly.
    if (obj !== null && typeof obj === 'object') {
      obj.queryContext = queryContext;
    }
    let queryPromise = this.client.query(this.connection, obj);

    if (obj.timeout) {
      queryPromise = timeout(queryPromise, obj.timeout);
    }

    // Await the return value of client.processResponse; in the case of sqlite3's
    // dropColumn()/renameColumn(), it will be a Promise for the transaction
    // containing the complete rename procedure.
    return queryPromise
      .then((resp) => this.client.processResponse(resp, runner))
      .then((processedResponse) => {
        const postProcessedResponse = this.client.postProcessResponse(
          processedResponse,
          queryContext
        );

        this.builder.emit(
          'query-response',
          postProcessedResponse,
          Object.assign({ __knexUid, __knexTxId }, obj),
          this.builder
        );

        this.client.emit(
          'query-response',
          postProcessedResponse,
          Object.assign({ __knexUid, __knexTxId }, obj),
          this.builder
        );

        return postProcessedResponse;
      })
      .catch((error) => {
        if (!(error instanceof KnexTimeoutError)) {
          return Promise.reject(error);
        }
        const { timeout, sql, bindings } = obj;

        let cancelQuery;
        if (obj.cancelOnTimeout) {
          cancelQuery = this.client.cancelQuery(this.connection);
        } else {
          // If we don't cancel the query, we need to mark the connection as disposed so that
          // it gets destroyed by the pool and is never used again. If we don't do this and
          // return the connection to the pool, it will be useless until the current operation
          // that timed out, finally finishes.
          this.connection.__knex__disposed = error;
          cancelQuery = Promise.resolve();
        }

        return cancelQuery
          .catch((cancelError) => {
            // If the cancellation failed, we need to mark the connection as disposed so that
            // it gets destroyed by the pool and is never used again. If we don't do this and
            // return the connection to the pool, it will be useless until the current operation
            // that timed out, finally finishes.
            this.connection.__knex__disposed = error;

            // cancellation failed
            throw Object.assign(cancelError, {
              message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,
              sql,
              bindings,
              timeout,
            });
          })
          .then(() => {
            // cancellation succeeded, rethrow timeout error
            throw Object.assign(error, {
              message: `Defined query timeout of ${timeout}ms exceeded when running query.`,
              sql,
              bindings,
              timeout,
            });
          });
      })
      .catch((error) => {
        this.builder.emit(
          'query-error',
          error,
          Object.assign({ __knexUid, __knexTxId, queryContext }, obj)
        );
        throw error;
      });
  }

  // In the case of the "schema builder" we call `queryArray`, which runs each
  // of the queries in sequence.
  async queryArray(queries) {
    if (queries.length === 1) {
      const query = queries[0];

      if (!query.statementsProducer) {
        return this.query(query);
      }

      const statements = await query.statementsProducer(
        undefined,
        this.connection
      );

      const sqlQueryObjects = statements.sql.map((statement) => ({
        sql: statement,
        bindings: query.bindings,
      }));
      const preQueryObjects = statements.pre.map((statement) => ({
        sql: statement,
        bindings: query.bindings,
      }));
      const postQueryObjects = statements.post.map((statement) => ({
        sql: statement,
        bindings: query.bindings,
      }));

      let results = [];

      await this.queryArray(preQueryObjects);

      try {
        await this.client.transaction(
          async (trx) => {
            const transactionRunner = new Runner(trx.client, this.builder);
            transactionRunner.connection = this.connection;

            results = await transactionRunner.queryArray(sqlQueryObjects);

            if (statements.check) {
              const foreignViolations = await trx.raw(statements.check);

              if (foreignViolations.length > 0) {
                throw new Error('FOREIGN KEY constraint failed');
              }
            }
          },
          { connection: this.connection }
        );
      } finally {
        await this.queryArray(postQueryObjects);
      }

      return results;
    }

    const results = [];
    for (const query of queries) {
      results.push(await this.queryArray([query]));
    }
    return results;
  }

  // Check whether there's a transaction flag, and that it has a connection.
  async ensureConnection(cb, cbParams) {
    // Use override from a builder if passed
    if (this.builder._connection) {
      this.connection = this.builder._connection;
    }

    if (this.connection) {
      return cb(this, cbParams);
    }

    let acquiredConnection;
    try {
      acquiredConnection = await this.client.acquireConnection();
    } catch (error) {
      if (!(error instanceof KnexTimeoutError)) {
        return Promise.reject(error);
      }
      if (this.builder) {
        error.sql = this.builder.sql;
        error.bindings = this.builder.bindings;
      }
      throw error;
    }
    try {
      this.connection = acquiredConnection;
      return await cb(this, cbParams);
    } finally {
      await this.client.releaseConnection(acquiredConnection);
    }
  }
}

module.exports = Runner;


/***/ }),

/***/ "./node_modules/knex/lib/execution/transaction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Transaction
// -------
const { EventEmitter } = __webpack_require__("events");
const Debug = __webpack_require__("./node_modules/debug/src/index.js");
const uniqueId = __webpack_require__("./node_modules/lodash/uniqueId.js");
const { callbackify } = __webpack_require__("util");

const makeKnex = __webpack_require__("./node_modules/knex/lib/knex-builder/make-knex.js");
const { timeout, KnexTimeoutError } = __webpack_require__("./node_modules/knex/lib/util/timeout.js");
const finallyMixin = __webpack_require__("./node_modules/knex/lib/util/finally-mixin.js");

const debug = Debug('knex:tx');

// FYI: This is defined as a function instead of a constant so that
//      each Transactor can have its own copy of the default config.
//      This will minimize the impact of bugs that might be introduced
//      if a Transactor ever mutates its config.
function DEFAULT_CONFIG() {
  return {
    userParams: {},
    doNotRejectOnRollback: true,
  };
}
// These aren't supported in sqlite3 which is serialized already so it's as
// safe as reasonable, except for a special read_uncommitted pragma
const validIsolationLevels = [
  // Doesn't really work in postgres, it treats it as read committed
  'read uncommitted',
  'read committed',
  'snapshot',
  // snapshot and repeatable read are basically the same, most "repeatable
  // read" implementations are actually "snapshot" also known as Multi Version
  // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop
  // repeated reads for inserts as it uses a pessimistic locking system so
  // you should probably use 'snapshot' to stop read skew.
  'repeatable read',
  // mysql pretends to have serializable, but it is not
  'serializable',
];

// Acts as a facade for a Promise, keeping the internal state
// and managing any child transactions.
class Transaction extends EventEmitter {
  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {
    super();
    this.userParams = config.userParams;
    this.doNotRejectOnRollback = config.doNotRejectOnRollback;

    const txid = (this.txid = uniqueId('trx'));

    this.client = client;
    this.logger = client.logger;
    this.outerTx = outerTx;
    this.trxClient = undefined;
    this._completed = false;
    this._debug = client.config && client.config.debug;

    this.readOnly = config.readOnly;
    if (config.isolationLevel) {
      this.setIsolationLevel(config.isolationLevel);
    }

    debug(
      '%s: Starting %s transaction',
      txid,
      outerTx ? 'nested' : 'top level'
    );

    // `this` can potentially serve as an `outerTx` for another
    // Transaction.  So, go ahead and establish `_lastChild` now.
    this._lastChild = Promise.resolve();

    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();

    // FYI: As you will see in a moment, this Promise will be used to construct
    //      2 separate Promise Chains.  This ensures that each Promise Chain
    //      can establish its error-handling semantics without interfering
    //      with the other Promise Chain.
    const basePromise = _previousSibling.then(() =>
      this._evaluateContainer(config, container)
    );

    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the
    //      caller must handle any exceptions that result from `basePromise`.
    this._promise = basePromise.then((x) => x);

    if (outerTx) {
      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal
      //      for when the next sibling should begin its execution.  Therefore,
      //      exceptions are caught and ignored.
      outerTx._lastChild = basePromise.catch(() => {});
    }
  }

  isCompleted() {
    return (
      this._completed || (this.outerTx && this.outerTx.isCompleted()) || false
    );
  }

  begin(conn) {
    const trxMode = [
      this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : '',
      this.readOnly ? 'READ ONLY' : '',
    ]
      .join(' ')
      .trim();

    if (trxMode.length === 0) {
      return this.query(conn, 'BEGIN;');
    }

    return this.query(conn, `SET TRANSACTION ${trxMode};`).then(() =>
      this.query(conn, 'BEGIN;')
    );
  }

  savepoint(conn) {
    return this.query(conn, `SAVEPOINT ${this.txid};`);
  }

  commit(conn, value) {
    return this.query(conn, 'COMMIT;', 1, value);
  }

  release(conn, value) {
    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);
  }

  setIsolationLevel(isolationLevel) {
    if (!validIsolationLevels.includes(isolationLevel)) {
      throw new Error(
        `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(
          validIsolationLevels
        )}`
      );
    }
    this.isolationLevel = isolationLevel;
    return this;
  }

  rollback(conn, error) {
    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(
      (err) => {
        if (!(err instanceof KnexTimeoutError)) {
          return Promise.reject(err);
        }
        this._rejecter(error);
      }
    );
  }

  rollbackTo(conn, error) {
    return timeout(
      this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),
      5000
    ).catch((err) => {
      if (!(err instanceof KnexTimeoutError)) {
        return Promise.reject(err);
      }
      this._rejecter(error);
    });
  }

  query(conn, sql, status, value) {
    const q = this.trxClient
      .query(conn, sql)
      .catch((err) => {
        status = 2;
        value = err;
        this._completed = true;
        debug('%s error running transaction query', this.txid);
      })
      .then((res) => {
        if (status === 1) {
          this._resolver(value);
        }
        if (status === 2) {
          if (value === undefined) {
            if (this.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
              this._resolver();
              return;
            }

            value = new Error(`Transaction rejected with non-error: ${value}`);
          }
          this._rejecter(value);
        }
        return res;
      });
    if (status === 1 || status === 2) {
      this._completed = true;
    }
    return q;
  }

  debug(enabled) {
    this._debug = arguments.length ? enabled : true;
    return this;
  }

  async _evaluateContainer(config, container) {
    return this.acquireConnection(config, (connection) => {
      const trxClient = (this.trxClient = makeTxClient(
        this,
        this.client,
        connection
      ));
      const init = this.client.transacting
        ? this.savepoint(connection)
        : this.begin(connection);
      const executionPromise = new Promise((resolver, rejecter) => {
        this._resolver = resolver;
        this._rejecter = rejecter;
      });

      init
        .then(() => {
          return makeTransactor(this, connection, trxClient);
        })
        .then((transactor) => {
          this.transactor = transactor;
          if (this.outerTx) {
            transactor.parentTransaction = this.outerTx.transactor;
          }
          transactor.executionPromise = executionPromise;

          // If we've returned a "thenable" from the transaction container, assume
          // the rollback and commit are chained to this object's success / failure.
          // Directly thrown errors are treated as automatic rollbacks.
          let result;
          try {
            result = container(transactor);
          } catch (err) {
            result = Promise.reject(err);
          }
          if (result && result.then && typeof result.then === 'function') {
            result
              .then((val) => {
                return transactor.commit(val);
              })
              .catch((err) => {
                return transactor.rollback(err);
              });
          }
          return null;
        })
        .catch((e) => {
          return this._rejecter(e);
        });

      return executionPromise;
    });
  }

  // Acquire a connection and create a disposer - either using the one passed
  // via config or getting one off the client. The disposer will be called once
  // the original promise is marked completed.
  async acquireConnection(config, cb) {
    const configConnection = config && config.connection;
    const connection =
      configConnection || (await this.client.acquireConnection());

    try {
      connection.__knexTxId = this.txid;
      return await cb(connection);
    } finally {
      if (!configConnection) {
        debug('%s: releasing connection', this.txid);
        this.client.releaseConnection(connection);
      } else {
        debug('%s: not releasing external connection', this.txid);
      }
    }
  }

  then(onResolve, onReject) {
    return this._promise.then(onResolve, onReject);
  }

  catch(...args) {
    return this._promise.catch(...args);
  }

  asCallback(cb) {
    callbackify(() => this._promise)(cb);
    return this._promise;
  }
}
finallyMixin(Transaction.prototype);

// The transactor is a full featured knex object, with a "commit", a "rollback"
// and a "savepoint" function. The "savepoint" is just sugar for creating a new
// transaction. If the rollback is run inside a savepoint, it rolls back to the
// last savepoint - otherwise it rolls back the transaction.
function makeTransactor(trx, connection, trxClient) {
  const transactor = makeKnex(trxClient);

  transactor.context.withUserParams = () => {
    throw new Error(
      'Cannot set user params on a transaction - it can only inherit params from main knex instance'
    );
  };

  transactor.isTransaction = true;
  transactor.userParams = trx.userParams || {};

  transactor.context.transaction = function (container, options) {
    if (!options) {
      options = { doNotRejectOnRollback: true };
    } else if (options.doNotRejectOnRollback === undefined) {
      options.doNotRejectOnRollback = true;
    }

    return this._transaction(container, options, trx);
  };

  transactor.savepoint = function (container, options) {
    return transactor.transaction(container, options);
  };

  if (trx.client.transacting) {
    transactor.commit = (value) => trx.release(connection, value);
    transactor.rollback = (error) => trx.rollbackTo(connection, error);
  } else {
    transactor.commit = (value) => trx.commit(connection, value);
    transactor.rollback = (error) => trx.rollback(connection, error);
  }

  transactor.isCompleted = () => trx.isCompleted();

  return transactor;
}

// We need to make a client object which always acquires the same
// connection and does not release back into the pool.
function makeTxClient(trx, client, connection) {
  const trxClient = Object.create(client.constructor.prototype);
  trxClient.version = client.version;
  trxClient.config = client.config;
  trxClient.driver = client.driver;
  trxClient.connectionSettings = client.connectionSettings;
  trxClient.transacting = true;
  trxClient.valueForUndefined = client.valueForUndefined;
  trxClient.logger = client.logger;

  trxClient.on('start', function (arg) {
    trx.emit('start', arg);
    client.emit('start', arg);
  });

  trxClient.on('query', function (arg) {
    trx.emit('query', arg);
    client.emit('query', arg);
  });

  trxClient.on('query-error', function (err, obj) {
    trx.emit('query-error', err, obj);
    client.emit('query-error', err, obj);
  });

  trxClient.on('query-response', function (response, obj, builder) {
    trx.emit('query-response', response, obj, builder);
    client.emit('query-response', response, obj, builder);
  });

  const _query = trxClient.query;
  trxClient.query = function (conn, obj) {
    const completed = trx.isCompleted();
    return new Promise(function (resolve, reject) {
      try {
        if (conn !== connection)
          throw new Error('Invalid connection for transaction query.');
        if (completed) completedError(trx, obj);
        resolve(_query.call(trxClient, conn, obj));
      } catch (e) {
        reject(e);
      }
    });
  };
  const _stream = trxClient.stream;
  trxClient.stream = function (conn, obj, stream, options) {
    const completed = trx.isCompleted();
    return new Promise(function (resolve, reject) {
      try {
        if (conn !== connection)
          throw new Error('Invalid connection for transaction query.');
        if (completed) completedError(trx, obj);
        resolve(_stream.call(trxClient, conn, obj, stream, options));
      } catch (e) {
        reject(e);
      }
    });
  };
  trxClient.acquireConnection = function () {
    return Promise.resolve(connection);
  };
  trxClient.releaseConnection = function () {
    return Promise.resolve();
  };

  return trxClient;
}

function completedError(trx, obj) {
  const sql = typeof obj === 'string' ? obj : obj && obj.sql;
  debug('%s: Transaction completed: %s', trx.txid, sql);
  throw new Error(
    'Transaction query already complete, run with DEBUG=knex:tx for more info'
  );
}

module.exports = Transaction;


/***/ }),

/***/ "./node_modules/knex/lib/formatter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  columnize: columnize_,
  wrap: wrap_,
} = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

class Formatter {
  constructor(client, builder) {
    this.client = client;
    this.builder = builder;
    this.bindings = [];
  }

  // Accepts a string or array of columns to wrap as appropriate.
  columnize(target) {
    return columnize_(target, this.builder, this.client, this);
  }

  // Puts the appropriate wrapper around a value depending on the database
  // engine, unless it's a knex.raw value, in which case it's left alone.
  wrap(value, isParameter) {
    return wrap_(value, isParameter, this.builder, this.client, this);
  }
}

module.exports = Formatter;


/***/ }),

/***/ "./node_modules/knex/lib/formatter/formatterUtils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { isObject } = __webpack_require__("./node_modules/knex/lib/util/is.js");

// Compiles a callback using the query builder.
function compileCallback(callback, method, client, bindingsHolder) {
  // Build the callback
  const builder = client.queryBuilder();
  callback.call(builder, builder);

  // Compile the callback, using the current formatter (to track all bindings).
  const compiler = client.queryCompiler(builder, bindingsHolder.bindings);

  // Return the compiled & parameterized sql.
  return compiler.toSQL(method || builder._method || 'select');
}

function wrapAsIdentifier(value, builder, client) {
  const queryContext = builder.queryContext();
  return client.wrapIdentifier((value || '').trim(), queryContext);
}

function formatDefault(value, type, client) {
  if (value === void 0) {
    return '';
  } else if (value === null) {
    return 'null';
  } else if (value && value.isRawInstance) {
    return value.toQuery();
  } else if (type === 'bool') {
    if (value === 'false') value = 0;
    return `'${value ? 1 : 0}'`;
  } else if ((type === 'json' || type === 'jsonb') && isObject(value)) {
    return `'${JSON.stringify(value)}'`;
  } else {
    return client._escapeBinding(value.toString());
  }
}

module.exports = {
  compileCallback,
  wrapAsIdentifier,
  formatDefault,
};


/***/ }),

/***/ "./node_modules/knex/lib/formatter/rawFormatter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { columnize } = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

function replaceRawArrBindings(raw, client) {
  const bindingsHolder = {
    bindings: [],
  };
  const builder = raw;

  const expectedBindings = raw.bindings.length;
  const values = raw.bindings;
  let index = 0;

  const sql = raw.sql.replace(/\\?\?\??/g, function (match) {
    if (match === '\\?') {
      return match;
    }

    const value = values[index++];

    if (match === '??') {
      return columnize(value, builder, client, bindingsHolder);
    }
    return client.parameter(value, builder, bindingsHolder);
  });

  if (expectedBindings !== index) {
    throw new Error(`Expected ${expectedBindings} bindings, saw ${index}`);
  }

  return {
    method: 'raw',
    sql,
    bindings: bindingsHolder.bindings,
  };
}

function replaceKeyBindings(raw, client) {
  const bindingsHolder = {
    bindings: [],
  };
  const builder = raw;

  const values = raw.bindings;
  const regex = /\\?(:(\w+):(?=::)|:(\w+):(?!:)|:(\w+))/g;

  const sql = raw.sql.replace(regex, function (match, p1, p2, p3, p4) {
    if (match !== p1) {
      return p1;
    }

    const part = p2 || p3 || p4;
    const key = match.trim();
    const isIdentifier = key[key.length - 1] === ':';
    const value = values[part];

    if (value === undefined) {
      if (Object.prototype.hasOwnProperty.call(values, part)) {
        bindingsHolder.bindings.push(value);
      }

      return match;
    }

    if (isIdentifier) {
      return match.replace(
        p1,
        columnize(value, builder, client, bindingsHolder)
      );
    }

    return match.replace(p1, client.parameter(value, builder, bindingsHolder));
  });

  return {
    method: 'raw',
    sql,
    bindings: bindingsHolder.bindings,
  };
}

module.exports = {
  replaceKeyBindings,
  replaceRawArrBindings,
};


/***/ }),

/***/ "./node_modules/knex/lib/formatter/wrappingFormatter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const transform = __webpack_require__("./node_modules/lodash/transform.js");
const QueryBuilder = __webpack_require__("./node_modules/knex/lib/query/querybuilder.js");
const { compileCallback, wrapAsIdentifier } = __webpack_require__("./node_modules/knex/lib/formatter/formatterUtils.js");

// Valid values for the `order by` clause generation.
const orderBys = ['asc', 'desc'];

// Turn this into a lookup map
const operators = transform(
  [
    '=',
    '<',
    '>',
    '<=',
    '>=',
    '<>',
    '!=',
    'like',
    'not like',
    'between',
    'not between',
    'ilike',
    'not ilike',
    'exists',
    'not exist',
    'rlike',
    'not rlike',
    'regexp',
    'not regexp',
    'match',
    '&',
    '|',
    '^',
    '<<',
    '>>',
    '~',
    '~=',
    '~*',
    '!~',
    '!~*',
    '#',
    '&&',
    '@>',
    '<@',
    '||',
    '&<',
    '&>',
    '-|-',
    '@@',
    '!!',
    ['?', '\\?'],
    ['?|', '\\?|'],
    ['?&', '\\?&'],
  ],
  (result, key) => {
    if (Array.isArray(key)) {
      result[key[0]] = key[1];
    } else {
      result[key] = key;
    }
  },
  {}
);

// Accepts a string or array of columns to wrap as appropriate. Column can be raw
function columnize(target, builder, client, bindingHolder) {
  const columns = Array.isArray(target) ? target : [target];
  let str = '',
    i = -1;
  while (++i < columns.length) {
    if (i > 0) str += ', ';
    str += wrap(columns[i], undefined, builder, client, bindingHolder);
  }
  return str;
}

// Puts the appropriate wrapper around a value depending on the database
// engine, unless it's a knex.raw value, in which case it's left alone.
function wrap(value, isParameter, builder, client, bindingHolder) {
  const raw = unwrapRaw(value, isParameter, builder, client, bindingHolder);
  if (raw) return raw;
  switch (typeof value) {
    case 'function':
      return outputQuery(
        compileCallback(value, undefined, client, bindingHolder),
        true,
        builder,
        client
      );
    case 'object':
      return parseObject(value, builder, client, bindingHolder);
    case 'number':
      return value;
    default:
      return wrapString(value + '', builder, client);
  }
}

function unwrapRaw(value, isParameter, builder, client, bindingsHolder) {
  let query;
  if (value instanceof QueryBuilder) {
    query = client.queryCompiler(value).toSQL();
    if (query.bindings) {
      bindingsHolder.bindings.push(...query.bindings);
    }
    return outputQuery(query, isParameter, builder, client);
  }
  if (value && value.isRawInstance) {
    value.client = client;
    if (builder._queryContext) {
      value.queryContext = () => {
        return builder._queryContext;
      };
    }

    query = value.toSQL();
    if (query.bindings) {
      bindingsHolder.bindings.push(...query.bindings);
    }
    return query.sql;
  }
  if (isParameter) {
    bindingsHolder.bindings.push(value);
  }
}

function operator(value, builder, client, bindingsHolder) {
  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);
  if (raw) return raw;
  const operator = operators[(value || '').toLowerCase()];
  if (!operator) {
    throw new TypeError(`The operator "${value}" is not permitted`);
  }
  return operator;
}

// Coerce to string to prevent strange errors when it's not a string.
function wrapString(value, builder, client) {
  const asIndex = value.toLowerCase().indexOf(' as ');
  if (asIndex !== -1) {
    const first = value.slice(0, asIndex);
    const second = value.slice(asIndex + 4);
    return client.alias(
      wrapString(first, builder, client),
      wrapAsIdentifier(second, builder, client)
    );
  }
  const wrapped = [];
  let i = -1;
  const segments = value.split('.');
  while (++i < segments.length) {
    value = segments[i];
    if (i === 0 && segments.length > 1) {
      wrapped.push(wrapString((value || '').trim(), builder, client));
    } else {
      wrapped.push(wrapAsIdentifier(value, builder, client));
    }
  }
  return wrapped.join('.');
}

// Key-value notation for alias
function parseObject(obj, builder, client, formatter) {
  const ret = [];
  for (const alias in obj) {
    const queryOrIdentifier = obj[alias];
    // Avoids double aliasing for subqueries
    if (typeof queryOrIdentifier === 'function') {
      const compiled = compileCallback(
        queryOrIdentifier,
        undefined,
        client,
        formatter
      );
      compiled.as = alias; // enforces the object's alias
      ret.push(outputQuery(compiled, true, builder, client));
    } else if (queryOrIdentifier instanceof QueryBuilder) {
      ret.push(
        client.alias(
          `(${wrap(queryOrIdentifier, undefined, builder, client, formatter)})`,
          wrapAsIdentifier(alias, builder, client)
        )
      );
    } else {
      ret.push(
        client.alias(
          wrap(queryOrIdentifier, undefined, builder, client, formatter),
          wrapAsIdentifier(alias, builder, client)
        )
      );
    }
  }
  return ret.join(', ');
}

// Ensures the query is aliased if necessary.
function outputQuery(compiled, isParameter, builder, client) {
  let sql = compiled.sql || '';
  if (sql) {
    if (
      (compiled.method === 'select' || compiled.method === 'first') &&
      (isParameter || compiled.as)
    ) {
      sql = `(${sql})`;
      if (compiled.as)
        return client.alias(sql, wrapString(compiled.as, builder, client));
    }
  }
  return sql;
}

/**
 * Creates SQL for a parameter, which might be passed to where() or .with() or
 * pretty much anywhere in API.
 *
 * @param value
 * @param method Optional at least 'select' or 'update' are valid
 * @param builder
 * @param client
 * @param bindingHolder
 */
function rawOrFn(value, method, builder, client, bindingHolder) {
  if (typeof value === 'function') {
    return outputQuery(
      compileCallback(value, method, client, bindingHolder),
      undefined,
      builder,
      client
    );
  }
  return unwrapRaw(value, undefined, builder, client, bindingHolder) || '';
}

// Specify the direction of the ordering.
function direction(value, builder, client, bindingsHolder) {
  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);
  if (raw) return raw;
  return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';
}

module.exports = {
  columnize,
  direction,
  operator,
  outputQuery,
  rawOrFn,
  unwrapRaw,
  wrap,
  wrapString,
};


/***/ }),

/***/ "./node_modules/knex/lib/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Knex = __webpack_require__("./node_modules/knex/lib/knex-builder/Knex.js");

module.exports = Knex;


/***/ }),

/***/ "./node_modules/knex/lib/knex-builder/FunctionHelper.js":
/***/ ((module) => {

// FunctionHelper
// -------
// Used for adding functions from the builder
// Example usage: table.dateTime('datetime_to_date').notNull().defaultTo(knex.fn.now());
class FunctionHelper {
  constructor(client) {
    this.client = client;
  }

  now(precision) {
    if (typeof precision === 'number') {
      return this.client.raw(`CURRENT_TIMESTAMP(${precision})`);
    }
    return this.client.raw('CURRENT_TIMESTAMP');
  }

  uuid() {
    switch (this.client.driverName) {
      case 'sqlite3':
      case 'better-sqlite3':
        return this.client.raw(
          "(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))"
        );
      case 'mssql':
        return this.client.raw('(NEWID())');
      case 'pg':
      case 'pgnative':
      case 'cockroachdb':
        return this.client.raw('(gen_random_uuid())');
      case 'oracle':
      case 'oracledb':
        return this.client.raw('(random_uuid())');
      case 'mysql':
      case 'mysql2':
        return this.client.raw('(UUID())');
      default:
        throw new Error(
          `${this.client.driverName} does not have a uuid function`
        );
    }
  }

  uuidToBin(uuid, ordered = true) {
    const buf = Buffer.from(uuid.replace(/-/g, ''), 'hex');
    return ordered
      ? Buffer.concat([
          buf.slice(6, 8),
          buf.slice(4, 6),
          buf.slice(0, 4),
          buf.slice(8, 16),
        ])
      : Buffer.concat([
          buf.slice(0, 4),
          buf.slice(4, 6),
          buf.slice(6, 8),
          buf.slice(8, 16),
        ]);
  }

  binToUuid(bin, ordered = true) {
    const buf = Buffer.from(bin, 'hex');
    return ordered
      ? [
          buf.toString('hex', 4, 8),
          buf.toString('hex', 2, 4),
          buf.toString('hex', 0, 2),
          buf.toString('hex', 8, 10),
          buf.toString('hex', 10, 16),
        ].join('-')
      : [
          buf.toString('hex', 0, 4),
          buf.toString('hex', 4, 6),
          buf.toString('hex', 6, 8),
          buf.toString('hex', 8, 10),
          buf.toString('hex', 10, 16),
        ].join('-');
  }
}

module.exports = FunctionHelper;


/***/ }),

/***/ "./node_modules/knex/lib/knex-builder/Knex.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Client = __webpack_require__("./node_modules/knex/lib/client.js");
const QueryBuilder = __webpack_require__("./node_modules/knex/lib/query/querybuilder.js");
const QueryInterface = __webpack_require__("./node_modules/knex/lib/query/method-constants.js");

const makeKnex = __webpack_require__("./node_modules/knex/lib/knex-builder/make-knex.js");
const { KnexTimeoutError } = __webpack_require__("./node_modules/knex/lib/util/timeout.js");
const { resolveConfig } = __webpack_require__("./node_modules/knex/lib/knex-builder/internal/config-resolver.js");
const SchemaBuilder = __webpack_require__("./node_modules/knex/lib/schema/builder.js");
const ViewBuilder = __webpack_require__("./node_modules/knex/lib/schema/viewbuilder.js");
const ColumnBuilder = __webpack_require__("./node_modules/knex/lib/schema/columnbuilder.js");
const TableBuilder = __webpack_require__("./node_modules/knex/lib/schema/tablebuilder.js");

function knex(config) {
  const { resolvedConfig, Dialect } = resolveConfig(...arguments);

  const newKnex = makeKnex(new Dialect(resolvedConfig));
  if (resolvedConfig.userParams) {
    newKnex.userParams = resolvedConfig.userParams;
  }
  return newKnex;
}

// Expose Client on the main Knex namespace.
knex.Client = Client;

knex.KnexTimeoutError = KnexTimeoutError;

knex.QueryBuilder = {
  extend: function (methodName, fn) {
    QueryBuilder.extend(methodName, fn);
    QueryInterface.push(methodName);
  },
};

knex.SchemaBuilder = {
  extend: function (methodName, fn) {
    SchemaBuilder.extend(methodName, fn);
  },
};

knex.ViewBuilder = {
  extend: function (methodName, fn) {
    ViewBuilder.extend(methodName, fn);
  },
};

knex.ColumnBuilder = {
  extend: function (methodName, fn) {
    ColumnBuilder.extend(methodName, fn);
  },
};

knex.TableBuilder = {
  extend: function (methodName, fn) {
    TableBuilder.extend(methodName, fn);
  },
};

module.exports = knex;


/***/ }),

/***/ "./node_modules/knex/lib/knex-builder/internal/config-resolver.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Client = __webpack_require__("./node_modules/knex/lib/client.js");
const { SUPPORTED_CLIENTS } = __webpack_require__("./node_modules/knex/lib/constants.js");

const parseConnection = __webpack_require__("./node_modules/knex/lib/knex-builder/internal/parse-connection.js");
const { getDialectByNameOrAlias } = __webpack_require__("./node_modules/knex/lib/dialects/index.js");

function resolveConfig(config) {
  let Dialect;
  let resolvedConfig;

  // If config is a string, try to parse it
  const parsedConfig =
    typeof config === 'string'
      ? Object.assign(parseConnection(config), arguments[2])
      : config;

  // If user provided no relevant parameters, use generic client
  if (
    arguments.length === 0 ||
    (!parsedConfig.client && !parsedConfig.dialect)
  ) {
    Dialect = Client;
  }
  // If user provided Client constructor as a parameter, use it
  else if (typeof parsedConfig.client === 'function') {
    Dialect = parsedConfig.client;
  }
  // If neither applies, let's assume user specified name of a client or dialect as a string
  else {
    const clientName = parsedConfig.client || parsedConfig.dialect;
    if (!SUPPORTED_CLIENTS.includes(clientName)) {
      throw new Error(
        `knex: Unknown configuration option 'client' value ${clientName}. Note that it is case-sensitive, check documentation for supported values.`
      );
    }

    Dialect = getDialectByNameOrAlias(clientName);
  }

  // If config connection parameter is passed as string, try to parse it
  if (typeof parsedConfig.connection === 'string') {
    resolvedConfig = Object.assign({}, parsedConfig, {
      connection: parseConnection(parsedConfig.connection).connection,
    });
  } else {
    resolvedConfig = Object.assign({}, parsedConfig);
  }

  return {
    resolvedConfig,
    Dialect,
  };
}

module.exports = {
  resolveConfig,
};


/***/ }),

/***/ "./node_modules/knex/lib/knex-builder/internal/parse-connection.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { parse } = __webpack_require__("./node_modules/pg-connection-string/index.js");
const parsePG = parse;
const isWindows = process && process.platform && process.platform === 'win32';

/**
 * @param str
 * @returns {URL}
 */
function tryParse(str) {
  try {
    return new URL(str);
  } catch (e) {
    return null;
  }
}

module.exports = function parseConnectionString(str) {
  const parsed = tryParse(str);
  const isDriveLetter = isWindows && parsed && parsed.protocol.length === 2;
  if (!parsed || isDriveLetter) {
    return {
      client: 'sqlite3',
      connection: {
        filename: str,
      },
    };
  }
  let { protocol } = parsed;
  if (protocol.slice(-1) === ':') {
    protocol = protocol.slice(0, -1);
  }

  const isPG = ['postgresql', 'postgres'].includes(protocol);

  return {
    client: protocol,
    connection: isPG ? parsePG(str) : connectionObject(parsed),
  };
};

/**
 * @param {URL} parsed
 * @returns {{}}
 */
function connectionObject(parsed) {
  const connection = {};
  let db = parsed.pathname;
  if (db[0] === '/') {
    db = db.slice(1);
  }

  connection.database = db;

  if (parsed.hostname) {
    if (parsed.protocol.indexOf('mssql') === 0) {
      connection.server = parsed.hostname;
    } else {
      connection.host = parsed.hostname;
    }
  }
  if (parsed.port) {
    connection.port = parsed.port;
  }
  if (parsed.username || parsed.password) {
    connection.user = decodeURIComponent(parsed.username);
  }
  if (parsed.password) {
    connection.password = decodeURIComponent(parsed.password);
  }
  if (parsed.searchParams) {
    for (const [key, value] of parsed.searchParams.entries()) {
      const isNestedConfigSupported = ['mysql:', 'mariadb:', 'mssql:'].includes(
        parsed.protocol
      );
      if (isNestedConfigSupported) {
        try {
          connection[key] = JSON.parse(value);
        } catch (err) {
          connection[key] = value;
        }
      } else {
        connection[key] = value;
      }
    }
  }
  return connection;
}


/***/ }),

/***/ "./node_modules/knex/lib/knex-builder/make-knex.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { EventEmitter } = __webpack_require__("events");

const { Migrator } = __webpack_require__("./node_modules/knex/lib/migrations/migrate/Migrator.js");
const Seeder = __webpack_require__("./node_modules/knex/lib/migrations/seed/Seeder.js");
const FunctionHelper = __webpack_require__("./node_modules/knex/lib/knex-builder/FunctionHelper.js");
const QueryInterface = __webpack_require__("./node_modules/knex/lib/query/method-constants.js");
const merge = __webpack_require__("./node_modules/lodash/merge.js");
const batchInsert = __webpack_require__("./node_modules/knex/lib/execution/batch-insert.js");
const { isObject } = __webpack_require__("./node_modules/knex/lib/util/is.js");
const { setHiddenProperty } = __webpack_require__("./node_modules/knex/lib/util/security.js");

// Javascript does not officially support "callable objects".  Instead,
// you must create a regular Function and inject properties/methods
// into it.  In other words: you can't leverage Prototype Inheritance
// to share the property/method definitions.
//
// To work around this, we're creating an Object Property Definition.
// This allow us to quickly inject everything into the `knex` function
// via the `Object.defineProperties(..)` function.  More importantly,
// it allows the same definitions to be shared across `knex` instances.
const KNEX_PROPERTY_DEFINITIONS = {
  client: {
    get() {
      return this.context.client;
    },
    set(client) {
      this.context.client = client;
    },
    configurable: true,
  },

  userParams: {
    get() {
      return this.context.userParams;
    },
    set(userParams) {
      this.context.userParams = userParams;
    },
    configurable: true,
  },

  schema: {
    get() {
      return this.client.schemaBuilder();
    },
    configurable: true,
  },

  migrate: {
    get() {
      return new Migrator(this);
    },
    configurable: true,
  },

  seed: {
    get() {
      return new Seeder(this);
    },
    configurable: true,
  },

  fn: {
    get() {
      return new FunctionHelper(this.client);
    },
    configurable: true,
  },
};

// `knex` instances serve as proxies around `context` objects.  So, calling
// any of these methods on the `knex` instance will forward the call to
// the `knex.context` object. This ensures that `this` will correctly refer
// to `context` within each of these methods.
const CONTEXT_METHODS = [
  'raw',
  'batchInsert',
  'transaction',
  'transactionProvider',
  'initialize',
  'destroy',
  'ref',
  'withUserParams',
  'queryBuilder',
  'disableProcessing',
  'enableProcessing',
];

for (const m of CONTEXT_METHODS) {
  KNEX_PROPERTY_DEFINITIONS[m] = {
    value: function (...args) {
      return this.context[m](...args);
    },
    configurable: true,
  };
}

function makeKnex(client) {
  // The object we're potentially using to kick off an initial chain.
  function knex(tableName, options) {
    return createQueryBuilder(knex.context, tableName, options);
  }

  redefineProperties(knex, client);
  return knex;
}

function initContext(knexFn) {
  const knexContext = knexFn.context || {};
  Object.assign(knexContext, {
    queryBuilder() {
      return this.client.queryBuilder();
    },

    raw() {
      return this.client.raw.apply(this.client, arguments);
    },

    batchInsert(table, batch, chunkSize = 1000) {
      return batchInsert(this, table, batch, chunkSize);
    },

    // Creates a new transaction.
    // If container is provided, returns a promise for when the transaction is resolved.
    // If container is not provided, returns a promise with a transaction that is resolved
    // when transaction is ready to be used.
    transaction(container, _config) {
      // Overload support of `transaction(config)`
      if (!_config && isObject(container)) {
        _config = container;
        container = null;
      }

      const config = Object.assign({}, _config);
      config.userParams = this.userParams || {};
      if (config.doNotRejectOnRollback === undefined) {
        config.doNotRejectOnRollback = true;
      }

      return this._transaction(container, config);
    },

    // Internal method that actually establishes the Transaction.  It makes no assumptions
    // about the `config` or `outerTx`, and expects the caller to handle these details.
    _transaction(container, config, outerTx = null) {
      if (container) {
        const trx = this.client.transaction(container, config, outerTx);
        return trx;
      } else {
        return new Promise((resolve, reject) => {
          this.client.transaction(resolve, config, outerTx).catch(reject);
        });
      }
    },

    transactionProvider(config) {
      let trx;
      return () => {
        if (!trx) {
          trx = this.transaction(undefined, config);
        }
        return trx;
      };
    },

    // Typically never needed, initializes the pool for a knex client.
    initialize(config) {
      return this.client.initializePool(config);
    },

    // Convenience method for tearing down the pool.
    destroy(callback) {
      return this.client.destroy(callback);
    },

    ref(ref) {
      return this.client.ref(ref);
    },

    // Do not document this as public API until naming and API is improved for general consumption
    // This method exists to disable processing of internal queries in migrations
    disableProcessing() {
      if (this.userParams.isProcessingDisabled) {
        return;
      }
      this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;
      this.userParams.postProcessResponse =
        this.client.config.postProcessResponse;
      this.client.config.wrapIdentifier = null;
      this.client.config.postProcessResponse = null;
      this.userParams.isProcessingDisabled = true;
    },

    // Do not document this as public API until naming and API is improved for general consumption
    // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations
    enableProcessing() {
      if (!this.userParams.isProcessingDisabled) {
        return;
      }
      this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;
      this.client.config.postProcessResponse =
        this.userParams.postProcessResponse;
      this.userParams.isProcessingDisabled = false;
    },

    withUserParams(params) {
      const knexClone = shallowCloneFunction(knexFn); // We need to include getters in our clone
      if (this.client) {
        knexClone.client = Object.create(this.client.constructor.prototype); // Clone client to avoid leaking listeners that are set on it
        merge(knexClone.client, this.client);
        knexClone.client.config = Object.assign({}, this.client.config); // Clone client config to make sure they can be modified independently

        if (this.client.config.password) {
          setHiddenProperty(knexClone.client.config, this.client.config);
        }
      }

      redefineProperties(knexClone, knexClone.client);
      _copyEventListeners('query', knexFn, knexClone);
      _copyEventListeners('query-error', knexFn, knexClone);
      _copyEventListeners('query-response', knexFn, knexClone);
      _copyEventListeners('start', knexFn, knexClone);
      knexClone.userParams = params;
      return knexClone;
    },
  });

  if (!knexFn.context) {
    knexFn.context = knexContext;
  }
}

function _copyEventListeners(eventName, sourceKnex, targetKnex) {
  const listeners = sourceKnex.listeners(eventName);
  listeners.forEach((listener) => {
    targetKnex.on(eventName, listener);
  });
}

function redefineProperties(knex, client) {
  // Allow chaining methods from the root object, before
  // any other information is specified.
  //
  // TODO: `QueryBuilder.extend(..)` allows new QueryBuilder
  //       methods to be introduced via external components.
  //       As a side-effect, it also pushes the new method names
  //       into the `QueryInterface` array.
  //
  //       The Problem: due to the way the code is currently
  //       structured, these new methods cannot be retroactively
  //       injected into existing `knex` instances!  As a result,
  //       some `knex` instances will support the methods, and
  //       others will not.
  //
  //       We should revisit this once we figure out the desired
  //       behavior / usage.  For instance: do we really want to
  //       allow external components to directly manipulate `knex`
  //       data structures?  Or, should we come up w/ a different
  //       approach that avoids side-effects / mutation?
  //
  //      (FYI: I noticed this issue because I attempted to integrate
  //       this logic directly into the `KNEX_PROPERTY_DEFINITIONS`
  //       construction.  However, `KNEX_PROPERTY_DEFINITIONS` is
  //       constructed before any `knex` instances are created.
  //       As a result, the method extensions were missing from all
  //       `knex` instances.)
  for (let i = 0; i < QueryInterface.length; i++) {
    const method = QueryInterface[i];
    knex[method] = function () {
      const builder = this.queryBuilder();
      return builder[method].apply(builder, arguments);
    };
  }

  Object.defineProperties(knex, KNEX_PROPERTY_DEFINITIONS);

  initContext(knex);
  knex.client = client;
  knex.userParams = {};

  // Hook up the "knex" object as an EventEmitter.
  const ee = new EventEmitter();
  for (const key in ee) {
    knex[key] = ee[key];
  }

  // Unfortunately, something seems to be broken in Node 6 and removing events from a clone also mutates original Knex,
  // which is highly undesirable
  if (knex._internalListeners) {
    knex._internalListeners.forEach(({ eventName, listener }) => {
      knex.client.removeListener(eventName, listener); // Remove duplicates for copies
    });
  }
  knex._internalListeners = [];

  // Passthrough all "start" and "query" events to the knex object.
  _addInternalListener(knex, 'start', (obj) => {
    knex.emit('start', obj);
  });
  _addInternalListener(knex, 'query', (obj) => {
    knex.emit('query', obj);
  });
  _addInternalListener(knex, 'query-error', (err, obj) => {
    knex.emit('query-error', err, obj);
  });
  _addInternalListener(knex, 'query-response', (response, obj, builder) => {
    knex.emit('query-response', response, obj, builder);
  });
}

function _addInternalListener(knex, eventName, listener) {
  knex.client.on(eventName, listener);
  knex._internalListeners.push({
    eventName,
    listener,
  });
}

function createQueryBuilder(knexContext, tableName, options) {
  const qb = knexContext.queryBuilder();
  if (!tableName)
    knexContext.client.logger.warn(
      'calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.'
    );
  return tableName ? qb.table(tableName, options) : qb;
}

function shallowCloneFunction(originalFunction) {
  const fnContext = Object.create(
    Object.getPrototypeOf(originalFunction),
    Object.getOwnPropertyDescriptors(originalFunction)
  );

  const knexContext = {};
  const knexFnWrapper = (tableName, options) => {
    return createQueryBuilder(knexContext, tableName, options);
  };

  const clonedFunction = knexFnWrapper.bind(fnContext);
  Object.assign(clonedFunction, originalFunction);
  clonedFunction.context = knexContext;
  return clonedFunction;
}

module.exports = makeKnex;


/***/ }),

/***/ "./node_modules/knex/lib/logger.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const color = __webpack_require__("./node_modules/colorette/index.cjs");
const { inspect } = __webpack_require__("util");
const { isString, isFunction } = __webpack_require__("./node_modules/knex/lib/util/is.js");

class Logger {
  constructor(config = {}) {
    const {
      log: {
        debug,
        warn,
        error,
        deprecate,
        inspectionDepth,
        enableColors,
      } = {},
    } = config;
    this._inspectionDepth = inspectionDepth || 5;
    this._enableColors = resolveIsEnabledColors(enableColors);
    this._debug = debug;
    this._warn = warn;
    this._error = error;
    this._deprecate = deprecate;
  }

  _log(message, userFn, colorFn) {
    if (userFn != null && !isFunction(userFn)) {
      throw new TypeError('Extensions to knex logger must be functions!');
    }

    if (isFunction(userFn)) {
      userFn(message);
      return;
    }

    if (!isString(message)) {
      message = inspect(message, {
        depth: this._inspectionDepth,
        colors: this._enableColors,
      });
    }

    console.log(colorFn ? colorFn(message) : message);
  }

  debug(message) {
    this._log(message, this._debug);
  }

  warn(message) {
    this._log(message, this._warn, color.yellow);
  }

  error(message) {
    this._log(message, this._error, color.red);
  }

  deprecate(method, alternative) {
    const message = `${method} is deprecated, please use ${alternative}`;

    this._log(message, this._deprecate, color.yellow);
  }
}

function resolveIsEnabledColors(enableColorsParam) {
  if (enableColorsParam != null) {
    return enableColorsParam;
  }

  if (process && process.stdout) {
    return process.stdout.isTTY;
  }

  return false;
}

module.exports = Logger;


/***/ }),

/***/ "./node_modules/knex/lib/query/analytic.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const assert = __webpack_require__("assert");

// Analytic
// -------

// The "Analytic" is an object holding any necessary info about a analytic function
// e.g row_number, rank, dense_rank,
class Analytic {
  constructor(method, schema, alias, orderBy, partitions) {
    this.schema = schema;
    this.type = 'analytic';
    this.method = method;
    this.order = orderBy || [];
    this.partitions = partitions || [];
    this.alias = alias;
    this.and = this;

    this.grouping = 'columns';
  }

  partitionBy(column, direction) {
    assert(
      Array.isArray(column) || typeof column === 'string',
      `The argument to an analytic partitionBy function must be either a string
            or an array of string.`
    );

    if (Array.isArray(column)) {
      this.partitions = this.partitions.concat(column);
    } else {
      this.partitions.push({ column: column, order: direction });
    }
    return this;
  }

  orderBy(column, direction) {
    assert(
      Array.isArray(column) || typeof column === 'string',
      `The argument to an analytic orderBy function must be either a string
            or an array of string.`
    );

    if (Array.isArray(column)) {
      this.order = this.order.concat(column);
    } else {
      this.order.push({ column: column, order: direction });
    }
    return this;
  }
}

module.exports = Analytic;


/***/ }),

/***/ "./node_modules/knex/lib/query/constants.js":
/***/ ((module) => {

/**
 * internal constants, do not use in application code
 */
module.exports = {
  lockMode: {
    forShare: 'forShare',
    forUpdate: 'forUpdate',
    forNoKeyUpdate: 'forNoKeyUpdate',
    forKeyShare: 'forKeyShare',
  },
  waitMode: {
    skipLocked: 'skipLocked',
    noWait: 'noWait',
  },
};


/***/ }),

/***/ "./node_modules/knex/lib/query/joinclause.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const assert = __webpack_require__("assert");

// JoinClause
// -------

function getClauseFromArguments(compilerType, bool, first, operator, second) {
  if (typeof first === 'function') {
    return {
      type: 'onWrapped',
      value: first,
      bool: bool,
    };
  }

  switch (arguments.length) {
    case 3:
      return { type: 'onRaw', value: first, bool };
    case 4:
      return {
        type: compilerType,
        column: first,
        operator: '=',
        value: operator,
        bool,
      };
    default:
      return {
        type: compilerType,
        column: first,
        operator,
        value: second,
        bool,
      };
  }
}

// The "JoinClause" is an object holding any necessary info about a join,
// including the type, and any associated tables & columns being joined.
class JoinClause {
  constructor(table, type, schema) {
    this.schema = schema;
    this.table = table;
    this.joinType = type;
    this.and = this;
    this.clauses = [];
  }

  get or() {
    return this._bool('or');
  }

  // Adds an "on" clause to the current join object.
  on(first) {
    if (typeof first === 'object' && typeof first.toSQL !== 'function') {
      const keys = Object.keys(first);
      let i = -1;
      const method = this._bool() === 'or' ? 'orOn' : 'on';
      while (++i < keys.length) {
        this[method](keys[i], first[keys[i]]);
      }
      return this;
    }

    const data = getClauseFromArguments('onBasic', this._bool(), ...arguments);

    if (data) {
      this.clauses.push(data);
    }

    return this;
  }

  // Adds an "or on" clause to the current join object.
  orOn(first, operator, second) {
    return this._bool('or').on.apply(this, arguments);
  }

  onJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
    this.clauses.push({
      type: 'onJsonPathEquals',
      columnFirst: columnFirst,
      jsonPathFirst: jsonPathFirst,
      columnSecond: columnSecond,
      jsonPathSecond: jsonPathSecond,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  orOnJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
    return this._bool('or').onJsonPathEquals.apply(this, arguments);
  }

  // Adds a "using" clause to the current join.
  using(column) {
    return this.clauses.push({ type: 'onUsing', column, bool: this._bool() });
  }

  onVal(first) {
    if (typeof first === 'object' && typeof first.toSQL !== 'function') {
      const keys = Object.keys(first);
      let i = -1;
      const method = this._bool() === 'or' ? 'orOnVal' : 'onVal';
      while (++i < keys.length) {
        this[method](keys[i], first[keys[i]]);
      }
      return this;
    }

    const data = getClauseFromArguments('onVal', this._bool(), ...arguments);

    if (data) {
      this.clauses.push(data);
    }

    return this;
  }

  andOnVal() {
    return this.onVal(...arguments);
  }

  orOnVal() {
    return this._bool('or').onVal(...arguments);
  }

  onBetween(column, values) {
    assert(
      Array.isArray(values),
      'The second argument to onBetween must be an array.'
    );
    assert(
      values.length === 2,
      'You must specify 2 values for the onBetween clause'
    );
    this.clauses.push({
      type: 'onBetween',
      column,
      value: values,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  onNotBetween(column, values) {
    return this._not(true).onBetween(column, values);
  }

  orOnBetween(column, values) {
    return this._bool('or').onBetween(column, values);
  }

  orOnNotBetween(column, values) {
    return this._bool('or')._not(true).onBetween(column, values);
  }

  onIn(column, values) {
    if (Array.isArray(values) && values.length === 0) return this.on(1, '=', 0);
    this.clauses.push({
      type: 'onIn',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  onNotIn(column, values) {
    return this._not(true).onIn(column, values);
  }

  orOnIn(column, values) {
    return this._bool('or').onIn(column, values);
  }

  orOnNotIn(column, values) {
    return this._bool('or')._not(true).onIn(column, values);
  }

  onNull(column) {
    this.clauses.push({
      type: 'onNull',
      column,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orOnNull(callback) {
    return this._bool('or').onNull(callback);
  }

  onNotNull(callback) {
    return this._not(true).onNull(callback);
  }

  orOnNotNull(callback) {
    return this._not(true)._bool('or').onNull(callback);
  }

  onExists(callback) {
    this.clauses.push({
      type: 'onExists',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orOnExists(callback) {
    return this._bool('or').onExists(callback);
  }

  onNotExists(callback) {
    return this._not(true).onExists(callback);
  }

  orOnNotExists(callback) {
    return this._not(true)._bool('or').onExists(callback);
  }

  // Explicitly set the type of join, useful within a function when creating a grouped join.
  type(type) {
    this.joinType = type;
    return this;
  }

  _bool(bool) {
    if (arguments.length === 1) {
      this._boolFlag = bool;
      return this;
    }
    const ret = this._boolFlag || 'and';
    this._boolFlag = 'and';
    return ret;
  }

  _not(val) {
    if (arguments.length === 1) {
      this._notFlag = val;
      return this;
    }
    const ret = this._notFlag;
    this._notFlag = false;
    return ret;
  }
}

Object.assign(JoinClause.prototype, {
  grouping: 'join',
});

JoinClause.prototype.andOn = JoinClause.prototype.on;
JoinClause.prototype.andOnIn = JoinClause.prototype.onIn;
JoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;
JoinClause.prototype.andOnNull = JoinClause.prototype.onNull;
JoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;
JoinClause.prototype.andOnExists = JoinClause.prototype.onExists;
JoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;
JoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;
JoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;
JoinClause.prototype.andOnJsonPathEquals =
  JoinClause.prototype.onJsonPathEquals;

module.exports = JoinClause;


/***/ }),

/***/ "./node_modules/knex/lib/query/method-constants.js":
/***/ ((module) => {

// All properties we can use to start a query chain
// from the `knex` object, e.g. `knex.select('*').from(...`
module.exports = [
  'with',
  'withRecursive',
  'withMaterialized',
  'withNotMaterialized',
  'select',
  'as',
  'columns',
  'column',
  'from',
  'fromJS',
  'fromRaw',
  'into',
  'withSchema',
  'table',
  'distinct',
  'join',
  'joinRaw',
  'innerJoin',
  'leftJoin',
  'leftOuterJoin',
  'rightJoin',
  'rightOuterJoin',
  'outerJoin',
  'fullOuterJoin',
  'crossJoin',
  'where',
  'andWhere',
  'orWhere',
  'whereNot',
  'orWhereNot',
  'whereLike',
  'andWhereLike',
  'orWhereLike',
  'whereILike',
  'andWhereILike',
  'orWhereILike',
  'whereRaw',
  'whereWrapped',
  'havingWrapped',
  'orWhereRaw',
  'whereExists',
  'orWhereExists',
  'whereNotExists',
  'orWhereNotExists',
  'whereIn',
  'orWhereIn',
  'whereNotIn',
  'orWhereNotIn',
  'whereNull',
  'orWhereNull',
  'whereNotNull',
  'orWhereNotNull',
  'whereBetween',
  'whereNotBetween',
  'andWhereBetween',
  'andWhereNotBetween',
  'orWhereBetween',
  'orWhereNotBetween',
  'groupBy',
  'groupByRaw',
  'orderBy',
  'orderByRaw',
  'union',
  'unionAll',
  'intersect',
  'except',
  'having',
  'havingRaw',
  'orHaving',
  'orHavingRaw',
  'offset',
  'limit',
  'count',
  'countDistinct',
  'min',
  'max',
  'sum',
  'sumDistinct',
  'avg',
  'avgDistinct',
  'increment',
  'decrement',
  'first',
  'debug',
  'pluck',
  'clearSelect',
  'clearWhere',
  'clearGroup',
  'clearOrder',
  'clearHaving',
  'insert',
  'update',
  'returning',
  'del',
  'delete',
  'truncate',
  'transacting',
  'connection',

  // JSON methods

  // Json manipulation functions
  'jsonExtract',
  'jsonSet',
  'jsonInsert',
  'jsonRemove',

  // Wheres Json
  'whereJsonObject',
  'orWhereJsonObject',
  'andWhereJsonObject',
  'whereNotJsonObject',
  'orWhereNotJsonObject',
  'andWhereNotJsonObject',

  'whereJsonPath',
  'orWhereJsonPath',
  'andWhereJsonPath',

  'whereJsonSupersetOf',
  'orWhereJsonSupersetOf',
  'andWhereJsonSupersetOf',
  'whereJsonNotSupersetOf',
  'orWhereJsonNotSupersetOf',
  'andWhereJsonNotSupersetOf',

  'whereJsonSubsetOf',
  'orWhereJsonSubsetOf',
  'andWhereJsonSubsetOf',
  'whereJsonNotSubsetOf',
  'orWhereJsonNotSubsetOf',
  'andWhereJsonNotSubsetOf',
];


/***/ }),

/***/ "./node_modules/knex/lib/query/querybuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Builder
// -------
const assert = __webpack_require__("assert");
const { EventEmitter } = __webpack_require__("events");
const assign = __webpack_require__("./node_modules/lodash/assign.js");
const clone = __webpack_require__("./node_modules/lodash/clone.js");
const each = __webpack_require__("./node_modules/lodash/each.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");
const isPlainObject = __webpack_require__("./node_modules/lodash/isPlainObject.js");
const last = __webpack_require__("./node_modules/lodash/last.js");
const reject = __webpack_require__("./node_modules/lodash/reject.js");
const tail = __webpack_require__("./node_modules/lodash/tail.js");
const toArray = __webpack_require__("./node_modules/lodash/toArray.js");

const { addQueryContext, normalizeArr } = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const JoinClause = __webpack_require__("./node_modules/knex/lib/query/joinclause.js");
const Analytic = __webpack_require__("./node_modules/knex/lib/query/analytic.js");
const saveAsyncStack = __webpack_require__("./node_modules/knex/lib/util/save-async-stack.js");
const {
  isBoolean,
  isNumber,
  isObject,
  isString,
  isFunction,
} = __webpack_require__("./node_modules/knex/lib/util/is.js");

const { lockMode, waitMode } = __webpack_require__("./node_modules/knex/lib/query/constants.js");
const {
  augmentWithBuilderInterface,
} = __webpack_require__("./node_modules/knex/lib/builder-interface-augmenter.js");

const SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);
const CLEARABLE_STATEMENTS = new Set([
  'with',
  'select',
  'columns',
  'hintComments',
  'where',
  'union',
  'join',
  'group',
  'order',
  'having',
  'limit',
  'offset',
  'counter',
  'counters',
]);
const LOCK_MODES = new Set([
  lockMode.forShare,
  lockMode.forUpdate,
  lockMode.forNoKeyUpdate,
  lockMode.forKeyShare,
]);

// Typically called from `knex.builder`,
// start a new query building chain.
class Builder extends EventEmitter {
  constructor(client) {
    super();
    this.client = client;
    this.and = this;
    this._single = {};
    this._comments = [];
    this._statements = [];
    this._method = 'select';
    if (client.config) {
      saveAsyncStack(this, 5);
      this._debug = client.config.debug;
    }
    // Internal flags used in the builder.
    this._joinFlag = 'inner';
    this._boolFlag = 'and';
    this._notFlag = false;
    this._asColumnFlag = false;
  }

  toString() {
    return this.toQuery();
  }

  // Convert the current query "toSQL"
  toSQL(method, tz) {
    return this.client.queryCompiler(this).toSQL(method || this._method, tz);
  }

  // Create a shallow clone of the current query builder.
  clone() {
    const cloned = new this.constructor(this.client);
    cloned._method = this._method;
    cloned._single = clone(this._single);
    cloned._comments = clone(this._comments);
    cloned._statements = clone(this._statements);
    cloned._debug = this._debug;

    // `_option` is assigned by the `Interface` mixin.
    if (this._options !== undefined) {
      cloned._options = clone(this._options);
    }
    if (this._queryContext !== undefined) {
      cloned._queryContext = clone(this._queryContext);
    }
    if (this._connection !== undefined) {
      cloned._connection = this._connection;
    }

    return cloned;
  }

  timeout(ms, { cancel } = {}) {
    if (isNumber(ms) && ms > 0) {
      this._timeout = ms;
      if (cancel) {
        this.client.assertCanCancelQuery();
        this._cancelOnTimeout = true;
      }
    }
    return this;
  }

  // With
  // ------
  isValidStatementArg(statement) {
    return (
      typeof statement === 'function' ||
      statement instanceof Builder ||
      (statement && statement.isRawInstance)
    );
  }

  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {
    const [query, columnList] =
      typeof nothingOrStatement === 'undefined'
        ? [statementOrColumnList, undefined]
        : [nothingOrStatement, statementOrColumnList];
    if (typeof alias !== 'string') {
      throw new Error(`${method}() first argument must be a string`);
    }

    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {
      // Validated as two-arg variant (alias, statement).
      return;
    }

    // Attempt to interpret as three-arg variant (alias, columnList, statement).
    const isNonEmptyNameList =
      Array.isArray(columnList) &&
      columnList.length > 0 &&
      columnList.every((it) => typeof it === 'string');
    if (!isNonEmptyNameList) {
      throw new Error(
        `${method}() second argument must be a statement or non-empty column name list.`
      );
    }

    if (this.isValidStatementArg(query)) {
      return;
    }
    throw new Error(
      `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`
    );
  }

  with(alias, statementOrColumnList, nothingOrStatement) {
    this._validateWithArgs(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      'with'
    );
    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
  }

  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
    throw new Error('With materialized is not supported by this dialect');
  }

  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
    throw new Error('With materialized is not supported by this dialect');
  }

  // Helper for compiling any advanced `with` queries.
  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {
    const [query, columnList] =
      typeof nothingOrStatement === 'undefined'
        ? [statementOrColumnList, undefined]
        : [nothingOrStatement, statementOrColumnList];
    const statement = {
      grouping: 'with',
      type: 'withWrapped',
      alias: alias,
      columnList,
      value: query,
    };
    if (materialized !== undefined) {
      statement.materialized = materialized;
    }
    this._statements.push(statement);
    return this;
  }

  // With Recursive
  // ------

  withRecursive(alias, statementOrColumnList, nothingOrStatement) {
    this._validateWithArgs(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      'withRecursive'
    );
    return this.withRecursiveWrapped(
      alias,
      statementOrColumnList,
      nothingOrStatement
    );
  }

  // Helper for compiling any advanced `withRecursive` queries.
  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {
    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
    this._statements[this._statements.length - 1].recursive = true;
    return this;
  }

  // Select
  // ------

  // Adds a column or columns to the list of "columns"
  // being selected on the query.
  columns(column) {
    if (!column && column !== 0) return this;
    this._statements.push({
      grouping: 'columns',
      value: normalizeArr(...arguments),
    });
    return this;
  }

  // Adds a comment to the query
  comment(txt) {
    if (!isString(txt)) {
      throw new Error('Comment must be a string');
    }
    const forbiddenChars = ['/*', '*/', '?'];
    if (forbiddenChars.some((chars) => txt.includes(chars))) {
      throw new Error(`Cannot include ${forbiddenChars.join(', ')} in comment`);
    }
    this._comments.push({
      comment: txt,
    });
    return this;
  }

  // Allow for a sub-select to be explicitly aliased as a column,
  // without needing to compile the query in a where.
  as(column) {
    this._single.as = column;
    return this;
  }

  // Adds a single hint or an array of hits to the list of "hintComments" on the query.
  hintComment(hints) {
    hints = Array.isArray(hints) ? hints : [hints];
    if (hints.some((hint) => !isString(hint))) {
      throw new Error('Hint comment must be a string');
    }
    if (hints.some((hint) => hint.includes('/*') || hint.includes('*/'))) {
      throw new Error('Hint comment cannot include "/*" or "*/"');
    }
    if (hints.some((hint) => hint.includes('?'))) {
      throw new Error('Hint comment cannot include "?"');
    }
    this._statements.push({
      grouping: 'hintComments',
      value: hints,
    });
    return this;
  }

  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
  withSchema(schemaName) {
    this._single.schema = schemaName;
    return this;
  }

  // Sets the `tableName` on the query.
  // Alias to "from" for select and "into" for insert statements
  // e.g. builder.insert({a: value}).into('tableName')
  // `options`: options object containing keys:
  //   - `only`: whether the query should use SQL's ONLY to not return
  //           inheriting table data. Defaults to false.
  table(tableName, options = {}) {
    this._single.table = tableName;
    this._single.only = options.only === true;
    return this;
  }

  // Adds a `distinct` clause to the query.
  distinct(...args) {
    this._statements.push({
      grouping: 'columns',
      value: normalizeArr(...args),
      distinct: true,
    });
    return this;
  }

  distinctOn(...args) {
    if (isEmpty(args)) {
      throw new Error('distinctOn requires at least on argument');
    }
    this._statements.push({
      grouping: 'columns',
      value: normalizeArr(...args),
      distinctOn: true,
    });
    return this;
  }

  // Adds a join clause to the query, allowing for advanced joins
  // with an anonymous function as the second argument.
  join(table, first, ...args) {
    let join;
    const schema =
      table instanceof Builder || typeof table === 'function'
        ? undefined
        : this._single.schema;
    const joinType = this._joinType();
    if (typeof first === 'function') {
      join = new JoinClause(table, joinType, schema);
      first.call(join, join);
    } else if (joinType === 'raw') {
      join = new JoinClause(this.client.raw(table, first), 'raw');
    } else {
      join = new JoinClause(table, joinType, schema);
      if (first) {
        join.on(first, ...args);
      }
    }
    this._statements.push(join);
    return this;
  }

  using(tables) {
    throw new Error(
      "'using' function is only available in PostgreSQL dialect with Delete statements."
    );
  }

  // JOIN blocks:
  innerJoin(...args) {
    return this._joinType('inner').join(...args);
  }

  leftJoin(...args) {
    return this._joinType('left').join(...args);
  }

  leftOuterJoin(...args) {
    return this._joinType('left outer').join(...args);
  }

  rightJoin(...args) {
    return this._joinType('right').join(...args);
  }

  rightOuterJoin(...args) {
    return this._joinType('right outer').join(...args);
  }

  outerJoin(...args) {
    return this._joinType('outer').join(...args);
  }

  fullOuterJoin(...args) {
    return this._joinType('full outer').join(...args);
  }

  crossJoin(...args) {
    return this._joinType('cross').join(...args);
  }

  joinRaw(...args) {
    return this._joinType('raw').join(...args);
  }

  // Where modifiers:
  get or() {
    return this._bool('or');
  }

  get not() {
    return this._not(true);
  }

  // The where function can be used in several ways:
  // The most basic is `where(key, value)`, which expands to
  // where key = value.
  where(column, operator, value) {
    const argsLength = arguments.length;

    // Support "where true || where false"
    if (column === false || column === true) {
      return this.where(1, '=', column ? 1 : 0);
    }

    // Check if the column is a function, in which case it's
    // a where statement wrapped in parens.
    if (typeof column === 'function') {
      return this.whereWrapped(column);
    }

    // Allows `where({id: 2})` syntax.
    if (isObject(column) && !column.isRawInstance)
      return this._objectWhere(column);

    // Allow a raw statement to be passed along to the query.
    if (column && column.isRawInstance && argsLength === 1)
      return this.whereRaw(column);

    // Enable the where('key', value) syntax, only when there
    // are explicitly two arguments passed, so it's not possible to
    // do where('key', '!=') and have that turn into where key != null
    if (argsLength === 2) {
      value = operator;
      operator = '=';

      // If the value is null, and it's a two argument query,
      // we assume we're going for a `whereNull`.
      if (value === null) {
        return this.whereNull(column);
      }
    }

    // lower case the operator for comparison purposes
    const checkOperator = `${operator}`.toLowerCase().trim();

    // If there are 3 arguments, check whether 'in' is one of them.
    if (argsLength === 3) {
      if (checkOperator === 'in' || checkOperator === 'not in') {
        return this._not(checkOperator === 'not in').whereIn(column, value);
      }
      if (checkOperator === 'between' || checkOperator === 'not between') {
        return this._not(checkOperator === 'not between').whereBetween(
          column,
          value
        );
      }
    }

    // If the value is still null, check whether they're meaning
    // where value is null
    if (value === null) {
      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');
      if (checkOperator === 'is' || checkOperator === 'is not') {
        return this._not(checkOperator === 'is not').whereNull(column);
      }
    }

    // Push onto the where statement stack.
    this._statements.push({
      grouping: 'where',
      type: 'whereBasic',
      column,
      operator,
      value,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag,
    });
    return this;
  }

  whereColumn(...args) {
    this._asColumnFlag = true;
    this.where(...args);
    this._asColumnFlag = false;
    return this;
  }

  // Adds an `or where` clause to the query.
  orWhere(column, ...args) {
    this._bool('or');
    const obj = column;
    if (isObject(obj) && !obj.isRawInstance) {
      return this.whereWrapped(function () {
        for (const key in obj) {
          this.andWhere(key, obj[key]);
        }
      });
    }
    return this.where(column, ...args);
  }

  orWhereColumn(column, ...args) {
    this._bool('or');
    const obj = column;
    if (isObject(obj) && !obj.isRawInstance) {
      return this.whereWrapped(function () {
        for (const key in obj) {
          this.andWhereColumn(key, '=', obj[key]);
        }
      });
    }
    return this.whereColumn(column, ...args);
  }

  // Adds an `not where` clause to the query.
  whereNot(column, ...args) {
    if (args.length >= 2) {
      if (args[0] === 'in' || args[0] === 'between') {
        this.client.logger.warn(
          'whereNot is not suitable for "in" and "between" type subqueries. You should use "not in" and "not between" instead.'
        );
      }
    }
    return this._not(true).where(column, ...args);
  }

  whereNotColumn(...args) {
    return this._not(true).whereColumn(...args);
  }

  // Adds an `or not where` clause to the query.
  orWhereNot(...args) {
    return this._bool('or').whereNot(...args);
  }

  orWhereNotColumn(...args) {
    return this._bool('or').whereNotColumn(...args);
  }

  // Processes an object literal provided in a "where" clause.
  _objectWhere(obj) {
    const boolVal = this._bool();
    const notVal = this._not() ? 'Not' : '';
    for (const key in obj) {
      this[boolVal + 'Where' + notVal](key, obj[key]);
    }
    return this;
  }

  // Adds a raw `where` clause to the query.
  whereRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);

    this._statements.push({
      grouping: 'where',
      type: 'whereRaw',
      value: raw,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orWhereRaw(sql, bindings) {
    return this._bool('or').whereRaw(sql, bindings);
  }

  // Helper for compiling any advanced `where` queries.
  whereWrapped(callback) {
    this._statements.push({
      grouping: 'where',
      type: 'whereWrapped',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `where exists` clause to the query.
  whereExists(callback) {
    this._statements.push({
      grouping: 'where',
      type: 'whereExists',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds an `or where exists` clause to the query.
  orWhereExists(callback) {
    return this._bool('or').whereExists(callback);
  }

  // Adds a `where not exists` clause to the query.
  whereNotExists(callback) {
    return this._not(true).whereExists(callback);
  }

  // Adds a `or where not exists` clause to the query.
  orWhereNotExists(callback) {
    return this._bool('or').whereNotExists(callback);
  }

  // Adds a `where in` clause to the query.
  whereIn(column, values) {
    if (Array.isArray(values) && isEmpty(values))
      return this.where(this._not());
    this._statements.push({
      grouping: 'where',
      type: 'whereIn',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `or where in` clause to the query.
  orWhereIn(column, values) {
    return this._bool('or').whereIn(column, values);
  }

  // Adds a `where not in` clause to the query.
  whereNotIn(column, values) {
    return this._not(true).whereIn(column, values);
  }

  // Adds a `or where not in` clause to the query.
  orWhereNotIn(column, values) {
    return this._bool('or')._not(true).whereIn(column, values);
  }

  // Adds a `where null` clause to the query.
  whereNull(column) {
    this._statements.push({
      grouping: 'where',
      type: 'whereNull',
      column,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `or where null` clause to the query.
  orWhereNull(column) {
    return this._bool('or').whereNull(column);
  }

  // Adds a `where not null` clause to the query.
  whereNotNull(column) {
    return this._not(true).whereNull(column);
  }

  // Adds a `or where not null` clause to the query.
  orWhereNotNull(column) {
    return this._bool('or').whereNotNull(column);
  }

  // Adds a `where between` clause to the query.
  whereBetween(column, values) {
    assert(
      Array.isArray(values),
      'The second argument to whereBetween must be an array.'
    );
    assert(
      values.length === 2,
      'You must specify 2 values for the whereBetween clause'
    );
    this._statements.push({
      grouping: 'where',
      type: 'whereBetween',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `where not between` clause to the query.
  whereNotBetween(column, values) {
    return this._not(true).whereBetween(column, values);
  }

  // Adds a `or where between` clause to the query.
  orWhereBetween(column, values) {
    return this._bool('or').whereBetween(column, values);
  }

  // Adds a `or where not between` clause to the query.
  orWhereNotBetween(column, values) {
    return this._bool('or').whereNotBetween(column, values);
  }

  _whereLike(type, column, value) {
    this._statements.push({
      grouping: 'where',
      type: type,
      column,
      value: value,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag,
    });
    return this;
  }

  // Adds a `where like` clause to the query.
  whereLike(column, value) {
    return this._whereLike('whereLike', column, value);
  }

  // Adds a `or where like` clause to the query.
  orWhereLike(column, value) {
    return this._bool('or')._whereLike('whereLike', column, value);
  }

  // Adds a `where ilike` clause to the query.
  whereILike(column, value) {
    return this._whereLike('whereILike', column, value);
  }

  // Adds a `or where ilike` clause to the query.
  orWhereILike(column, value) {
    return this._bool('or')._whereLike('whereILike', column, value);
  }

  // Adds a `group by` clause to the query.
  groupBy(item) {
    if (item && item.isRawInstance) {
      return this.groupByRaw.apply(this, arguments);
    }
    this._statements.push({
      grouping: 'group',
      type: 'groupByBasic',
      value: normalizeArr(...arguments),
    });
    return this;
  }

  // Adds a raw `group by` clause to the query.
  groupByRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    this._statements.push({
      grouping: 'group',
      type: 'groupByRaw',
      value: raw,
    });
    return this;
  }

  // Adds a `order by` clause to the query.
  orderBy(column, direction, nulls = '') {
    if (Array.isArray(column)) {
      return this._orderByArray(column);
    }
    this._statements.push({
      grouping: 'order',
      type: 'orderByBasic',
      value: column,
      direction,
      nulls,
    });
    return this;
  }

  // Adds a `order by` with multiple columns to the query.
  _orderByArray(columnDefs) {
    for (let i = 0; i < columnDefs.length; i++) {
      const columnInfo = columnDefs[i];
      if (isObject(columnInfo)) {
        this._statements.push({
          grouping: 'order',
          type: 'orderByBasic',
          value: columnInfo['column'],
          direction: columnInfo['order'],
          nulls: columnInfo['nulls'],
        });
      } else if (isString(columnInfo) || isNumber(columnInfo)) {
        this._statements.push({
          grouping: 'order',
          type: 'orderByBasic',
          value: columnInfo,
        });
      }
    }
    return this;
  }

  // Add a raw `order by` clause to the query.
  orderByRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    this._statements.push({
      grouping: 'order',
      type: 'orderByRaw',
      value: raw,
    });
    return this;
  }

  _union(clause, args) {
    let callbacks = args[0];
    let wrap = args[1];
    if (args.length === 1 || (args.length === 2 && isBoolean(wrap))) {
      if (!Array.isArray(callbacks)) {
        callbacks = [callbacks];
      }
      for (let i = 0, l = callbacks.length; i < l; i++) {
        this._statements.push({
          grouping: 'union',
          clause: clause,
          value: callbacks[i],
          wrap: wrap || false,
        });
      }
    } else {
      callbacks = toArray(args).slice(0, args.length - 1);
      wrap = args[args.length - 1];
      if (!isBoolean(wrap)) {
        callbacks.push(wrap);
        wrap = false;
      }
      this._union(clause, [callbacks, wrap]);
    }
    return this;
  }

  // Add a union statement to the query.
  union(...args) {
    return this._union('union', args);
  }

  // Adds a union all statement to the query.
  unionAll(...args) {
    return this._union('union all', args);
  }

  intersect(...args) {
    return this._union('intersect', args);
  }

  except(...args) {
    return this._union('except', args);
  }

  // Adds a `having` clause to the query.
  having(column, operator, value) {
    if (column.isRawInstance && arguments.length === 1) {
      return this.havingRaw(column);
    }

    // Check if the column is a function, in which case it's
    // a having statement wrapped in parens.
    if (typeof column === 'function') {
      return this.havingWrapped(column);
    }

    this._statements.push({
      grouping: 'having',
      type: 'havingBasic',
      column,
      operator,
      value,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  orHaving(column, ...args) {
    this._bool('or');
    const obj = column;
    if (isObject(obj) && !obj.isRawInstance) {
      return this.havingWrapped(function () {
        for (const key in obj) {
          this.andHaving(key, obj[key]);
        }
      });
    }
    return this.having(column, ...args);
  }

  // Helper for compiling any advanced `having` queries.
  havingWrapped(callback) {
    this._statements.push({
      grouping: 'having',
      type: 'havingWrapped',
      value: callback,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  havingNull(column) {
    this._statements.push({
      grouping: 'having',
      type: 'havingNull',
      column,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orHavingNull(callback) {
    return this._bool('or').havingNull(callback);
  }

  havingNotNull(callback) {
    return this._not(true).havingNull(callback);
  }

  orHavingNotNull(callback) {
    return this._not(true)._bool('or').havingNull(callback);
  }

  havingExists(callback) {
    this._statements.push({
      grouping: 'having',
      type: 'havingExists',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orHavingExists(callback) {
    return this._bool('or').havingExists(callback);
  }

  havingNotExists(callback) {
    return this._not(true).havingExists(callback);
  }

  orHavingNotExists(callback) {
    return this._not(true)._bool('or').havingExists(callback);
  }

  havingBetween(column, values) {
    assert(
      Array.isArray(values),
      'The second argument to havingBetween must be an array.'
    );
    assert(
      values.length === 2,
      'You must specify 2 values for the havingBetween clause'
    );
    this._statements.push({
      grouping: 'having',
      type: 'havingBetween',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orHavingBetween(column, values) {
    return this._bool('or').havingBetween(column, values);
  }

  havingNotBetween(column, values) {
    return this._not(true).havingBetween(column, values);
  }

  orHavingNotBetween(column, values) {
    return this._not(true)._bool('or').havingBetween(column, values);
  }

  havingIn(column, values) {
    if (Array.isArray(values) && isEmpty(values))
      return this.where(this._not());
    this._statements.push({
      grouping: 'having',
      type: 'havingIn',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `or where in` clause to the query.
  orHavingIn(column, values) {
    return this._bool('or').havingIn(column, values);
  }

  // Adds a `where not in` clause to the query.
  havingNotIn(column, values) {
    return this._not(true).havingIn(column, values);
  }

  // Adds a `or where not in` clause to the query.
  orHavingNotIn(column, values) {
    return this._bool('or')._not(true).havingIn(column, values);
  }

  // Adds a raw `having` clause to the query.
  havingRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    this._statements.push({
      grouping: 'having',
      type: 'havingRaw',
      value: raw,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  orHavingRaw(sql, bindings) {
    return this._bool('or').havingRaw(sql, bindings);
  }

  // set the skip binding parameter (= insert the raw value in the query) for an attribute.
  _setSkipBinding(attribute, options) {
    let skipBinding = options;
    if (isObject(options)) {
      skipBinding = options.skipBinding;
    }
    this._single.skipBinding = this._single.skipBinding || {};
    this._single.skipBinding[attribute] = skipBinding;
  }

  // Only allow a single "offset" to be set for the current query.
  offset(value, options) {
    if (value == null || value.isRawInstance || value instanceof Builder) {
      // Builder for backward compatibility
      this._single.offset = value;
    } else {
      const val = parseInt(value, 10);
      if (isNaN(val)) {
        this.client.logger.warn('A valid integer must be provided to offset');
      } else if (val < 0) {
        throw new Error(`A non-negative integer must be provided to offset.`);
      } else {
        this._single.offset = val;
      }
    }
    this._setSkipBinding('offset', options);
    return this;
  }

  // Only allow a single "limit" to be set for the current query.
  limit(value, options) {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      this.client.logger.warn('A valid integer must be provided to limit');
    } else {
      this._single.limit = val;
      this._setSkipBinding('limit', options);
    }
    return this;
  }

  // Retrieve the "count" result of the query.
  count(column, options) {
    return this._aggregate('count', column || '*', options);
  }

  // Retrieve the minimum value of a given column.
  min(column, options) {
    return this._aggregate('min', column, options);
  }

  // Retrieve the maximum value of a given column.
  max(column, options) {
    return this._aggregate('max', column, options);
  }

  // Retrieve the sum of the values of a given column.
  sum(column, options) {
    return this._aggregate('sum', column, options);
  }

  // Retrieve the average of the values of a given column.
  avg(column, options) {
    return this._aggregate('avg', column, options);
  }

  // Retrieve the "count" of the distinct results of the query.
  countDistinct(...columns) {
    let options;
    if (columns.length > 1 && isPlainObject(last(columns))) {
      [options] = columns.splice(columns.length - 1, 1);
    }

    if (!columns.length) {
      columns = '*';
    } else if (columns.length === 1) {
      columns = columns[0];
    }

    return this._aggregate('count', columns, { ...options, distinct: true });
  }

  // Retrieve the sum of the distinct values of a given column.
  sumDistinct(column, options) {
    return this._aggregate('sum', column, { ...options, distinct: true });
  }

  // Retrieve the vg of the distinct results of the query.
  avgDistinct(column, options) {
    return this._aggregate('avg', column, { ...options, distinct: true });
  }

  // Increments a column's value by the specified amount.
  increment(column, amount = 1) {
    if (isObject(column)) {
      for (const key in column) {
        this._counter(key, column[key]);
      }

      return this;
    }

    return this._counter(column, amount);
  }

  // Decrements a column's value by the specified amount.
  decrement(column, amount = 1) {
    if (isObject(column)) {
      for (const key in column) {
        this._counter(key, -column[key]);
      }

      return this;
    }

    return this._counter(column, -amount);
  }

  // Clears increments/decrements
  clearCounters() {
    this._single.counter = {};
    return this;
  }

  // Sets the values for a `select` query, informing that only the first
  // row should be returned (limit 1).
  first(...args) {
    if (this._method && this._method !== 'select') {
      throw new Error(`Cannot chain .first() on "${this._method}" query`);
    }

    this.select(normalizeArr(...args));
    this._method = 'first';
    this.limit(1);
    return this;
  }

  // Use existing connection to execute the query
  // Same value that client.acquireConnection() for an according client returns should be passed
  connection(_connection) {
    this._connection = _connection;
    this.client.processPassedConnection(_connection);
    return this;
  }

  // Pluck a column from a query.
  pluck(column) {
    if (this._method && this._method !== 'select') {
      throw new Error(`Cannot chain .pluck() on "${this._method}" query`);
    }

    this._method = 'pluck';
    this._single.pluck = column;
    this._statements.push({
      grouping: 'columns',
      type: 'pluck',
      value: column,
    });
    return this;
  }

  // Deprecated. Remove everything from select clause
  clearSelect() {
    this._clearGrouping('columns');
    return this;
  }

  // Deprecated. Remove everything from where clause
  clearWhere() {
    this._clearGrouping('where');
    return this;
  }

  // Deprecated. Remove everything from group clause
  clearGroup() {
    this._clearGrouping('group');
    return this;
  }

  // Deprecated. Remove everything from order clause
  clearOrder() {
    this._clearGrouping('order');
    return this;
  }

  // Deprecated. Remove everything from having clause
  clearHaving() {
    this._clearGrouping('having');
    return this;
  }

  // Remove everything from statement clause
  clear(statement) {
    if (!CLEARABLE_STATEMENTS.has(statement))
      throw new Error(`Knex Error: unknown statement '${statement}'`);
    if (statement.startsWith('counter')) return this.clearCounters();
    if (statement === 'select') {
      statement = 'columns';
    }
    this._clearGrouping(statement);
    return this;
  }

  // Insert & Update
  // ------

  // Sets the values for an `insert` query.
  insert(values, returning, options) {
    this._method = 'insert';
    if (!isEmpty(returning)) this.returning(returning, options);
    this._single.insert = values;
    return this;
  }

  // Sets the values for an `update`, allowing for both
  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
  update(values, returning, options) {
    let ret;
    const obj = this._single.update || {};
    this._method = 'update';
    if (isString(values)) {
      if (isPlainObject(returning)) {
        obj[values] = JSON.stringify(returning);
      } else {
        obj[values] = returning;
      }
      if (arguments.length > 2) {
        ret = arguments[2];
      }
    } else {
      const keys = Object.keys(values);
      if (this._single.update) {
        this.client.logger.warn('Update called multiple times with objects.');
      }
      let i = -1;
      while (++i < keys.length) {
        obj[keys[i]] = values[keys[i]];
      }
      ret = arguments[1];
    }
    if (!isEmpty(ret)) this.returning(ret, options);
    this._single.update = obj;
    return this;
  }

  // Sets the returning value for the query.
  returning(returning, options) {
    this._single.returning = returning;
    this._single.options = options;
    return this;
  }

  onConflict(columns) {
    if (typeof columns === 'string') {
      columns = [columns];
    }
    return new OnConflictBuilder(this, columns || true);
  }

  // Delete
  // ------

  // Executes a delete statement on the query;
  delete(ret, options) {
    this._method = 'del';
    if (!isEmpty(ret)) this.returning(ret, options);
    return this;
  }

  // Truncates a table, ends the query chain.
  truncate(tableName) {
    this._method = 'truncate';
    if (tableName) {
      this._single.table = tableName;
    }
    return this;
  }

  // Retrieves columns for the table specified by `knex(tableName)`
  columnInfo(column) {
    this._method = 'columnInfo';
    this._single.columnInfo = column;
    return this;
  }

  // Set a lock for update constraint.
  forUpdate(...tables) {
    this._single.lock = lockMode.forUpdate;
    if (tables.length === 1 && Array.isArray(tables[0])) {
      this._single.lockTables = tables[0];
    } else {
      this._single.lockTables = tables;
    }
    return this;
  }

  // Set a lock for share constraint.
  forShare(...tables) {
    this._single.lock = lockMode.forShare;
    this._single.lockTables = tables;
    return this;
  }

  // Set a lock for no key update constraint.
  forNoKeyUpdate(...tables) {
    this._single.lock = lockMode.forNoKeyUpdate;
    this._single.lockTables = tables;
    return this;
  }

  // Set a lock for key share constraint.
  forKeyShare(...tables) {
    this._single.lock = lockMode.forKeyShare;
    this._single.lockTables = tables;
    return this;
  }

  // Skips locked rows when using a lock constraint.
  skipLocked() {
    if (!this._isSelectQuery()) {
      throw new Error(`Cannot chain .skipLocked() on "${this._method}" query!`);
    }
    if (!this._hasLockMode()) {
      throw new Error(
        '.skipLocked() can only be used after a call to .forShare() or .forUpdate()!'
      );
    }
    if (this._single.waitMode === waitMode.noWait) {
      throw new Error('.skipLocked() cannot be used together with .noWait()!');
    }
    this._single.waitMode = waitMode.skipLocked;
    return this;
  }

  // Causes error when acessing a locked row instead of waiting for it to be released.
  noWait() {
    if (!this._isSelectQuery()) {
      throw new Error(`Cannot chain .noWait() on "${this._method}" query!`);
    }
    if (!this._hasLockMode()) {
      throw new Error(
        '.noWait() can only be used after a call to .forShare() or .forUpdate()!'
      );
    }
    if (this._single.waitMode === waitMode.skipLocked) {
      throw new Error('.noWait() cannot be used together with .skipLocked()!');
    }
    this._single.waitMode = waitMode.noWait;
    return this;
  }

  // Takes a JS object of methods to call and calls them
  fromJS(obj) {
    each(obj, (val, key) => {
      if (typeof this[key] !== 'function') {
        this.client.logger.warn(`Knex Error: unknown key ${key}`);
      }
      if (Array.isArray(val)) {
        this[key].apply(this, val);
      } else {
        this[key](val);
      }
    });
    return this;
  }

  fromRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    return this.from(raw);
  }

  // Passes query to provided callback function, useful for e.g. composing
  // domain-specific helpers
  modify(callback) {
    callback.apply(this, [this].concat(tail(arguments)));
    return this;
  }

  upsert(values, returning, options) {
    throw new Error(
      `Upsert is not yet supported for dialect ${this.client.dialect}`
    );
  }

  // JSON support functions
  _json(nameFunction, params) {
    this._statements.push({
      grouping: 'columns',
      type: 'json',
      method: nameFunction,
      params: params,
    });
    return this;
  }

  jsonExtract() {
    const column = arguments[0];
    let path;
    let alias;
    let singleValue = true;

    // We use arguments to have the signatures :
    // - column (string or array)
    // - column + path
    // - column + path + alias
    // - column + path + alias + singleValue
    // - column array + singleValue
    if (arguments.length >= 2) {
      path = arguments[1];
    }
    if (arguments.length >= 3) {
      alias = arguments[2];
    }
    if (arguments.length === 4) {
      singleValue = arguments[3];
    }
    if (
      arguments.length === 2 &&
      Array.isArray(arguments[0]) &&
      isBoolean(arguments[1])
    ) {
      singleValue = arguments[1];
    }
    return this._json('jsonExtract', {
      column: column,
      path: path,
      alias: alias,
      singleValue, // boolean used only in MSSQL to use function for extract value instead of object/array.
    });
  }

  jsonSet(column, path, value, alias) {
    return this._json('jsonSet', {
      column: column,
      path: path,
      value: value,
      alias: alias,
    });
  }

  jsonInsert(column, path, value, alias) {
    return this._json('jsonInsert', {
      column: column,
      path: path,
      value: value,
      alias: alias,
    });
  }

  jsonRemove(column, path, alias) {
    return this._json('jsonRemove', {
      column: column,
      path: path,
      alias: alias,
    });
  }

  // Wheres for JSON
  _isJsonObject(jsonValue) {
    return isObject(jsonValue) && !(jsonValue instanceof Builder);
  }

  _whereJsonWrappedValue(type, column, value) {
    const whereJsonClause = {
      grouping: 'where',
      type: type,
      column,
      value: value,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag,
    };
    if (arguments[3]) {
      whereJsonClause.operator = arguments[3];
    }
    if (arguments[4]) {
      whereJsonClause.jsonPath = arguments[4];
    }
    this._statements.push(whereJsonClause);
  }

  whereJsonObject(column, value) {
    this._whereJsonWrappedValue('whereJsonObject', column, value);
    return this;
  }

  orWhereJsonObject(column, value) {
    return this._bool('or').whereJsonObject(column, value);
  }

  whereNotJsonObject(column, value) {
    return this._not(true).whereJsonObject(column, value);
  }

  orWhereNotJsonObject(column, value) {
    return this._bool('or').whereNotJsonObject(column, value);
  }

  whereJsonPath(column, path, operator, value) {
    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);
    return this;
  }

  orWhereJsonPath(column, path, operator, value) {
    return this._bool('or').whereJsonPath(column, path, operator, value);
  }

  // Json superset wheres
  whereJsonSupersetOf(column, value) {
    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);
    return this;
  }

  whereJsonNotSupersetOf(column, value) {
    return this._not(true).whereJsonSupersetOf(column, value);
  }

  orWhereJsonSupersetOf(column, value) {
    return this._bool('or').whereJsonSupersetOf(column, value);
  }

  orWhereJsonNotSupersetOf(column, value) {
    return this._bool('or').whereJsonNotSupersetOf(column, value);
  }

  // Json subset wheres
  whereJsonSubsetOf(column, value) {
    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);
    return this;
  }

  whereJsonNotSubsetOf(column, value) {
    return this._not(true).whereJsonSubsetOf(column, value);
  }

  orWhereJsonSubsetOf(column, value) {
    return this._bool('or').whereJsonSubsetOf(column, value);
  }

  orWhereJsonNotSubsetOf(column, value) {
    return this._bool('or').whereJsonNotSubsetOf(column, value);
  }

  whereJsonHasNone(column, values) {
    this._not(true).whereJsonHasAll(column, values);
    return this;
  }

  // end of wheres for JSON

  _analytic(alias, second, third) {
    let analytic;
    const { schema } = this._single;
    const method = this._analyticMethod();
    alias = typeof alias === 'string' ? alias : null;

    assert(
      typeof second === 'function' ||
        second.isRawInstance ||
        Array.isArray(second) ||
        typeof second === 'string' ||
        typeof second === 'object',
      `The second argument to an analytic function must be either a function, a raw,
       an array of string or object, an object or a single string.`
    );

    if (third) {
      assert(
        Array.isArray(third) ||
          typeof third === 'string' ||
          typeof third === 'object',
        'The third argument to an analytic function must be either a string, an array of string or object or an object.'
      );
    }

    if (isFunction(second)) {
      analytic = new Analytic(method, schema, alias);
      second.call(analytic, analytic);
    } else if (second.isRawInstance) {
      const raw = second;
      analytic = {
        grouping: 'columns',
        type: 'analytic',
        method: method,
        raw: raw,
        alias: alias,
      };
    } else {
      const order = !Array.isArray(second) ? [second] : second;
      let partitions = third || [];
      partitions = !Array.isArray(partitions) ? [partitions] : partitions;
      analytic = {
        grouping: 'columns',
        type: 'analytic',
        method: method,
        order: order,
        alias: alias,
        partitions: partitions,
      };
    }
    this._statements.push(analytic);
    return this;
  }

  rank(...args) {
    return this._analyticMethod('rank')._analytic(...args);
  }

  denseRank(...args) {
    return this._analyticMethod('dense_rank')._analytic(...args);
  }

  rowNumber(...args) {
    return this._analyticMethod('row_number')._analytic(...args);
  }

  // ----------------------------------------------------------------------

  // Helper for the incrementing/decrementing queries.
  _counter(column, amount) {
    amount = parseFloat(amount);

    this._method = 'update';

    this._single.counter = this._single.counter || {};

    this._single.counter[column] = amount;

    return this;
  }

  // Helper to get or set the "boolFlag" value.
  _bool(val) {
    if (arguments.length === 1) {
      this._boolFlag = val;
      return this;
    }
    const ret = this._boolFlag;
    this._boolFlag = 'and';
    return ret;
  }

  // Helper to get or set the "notFlag" value.
  _not(val) {
    if (arguments.length === 1) {
      this._notFlag = val;
      return this;
    }
    const ret = this._notFlag;
    this._notFlag = false;
    return ret;
  }

  // Helper to get or set the "joinFlag" value.
  _joinType(val) {
    if (arguments.length === 1) {
      this._joinFlag = val;
      return this;
    }
    const ret = this._joinFlag || 'inner';
    this._joinFlag = 'inner';
    return ret;
  }

  _analyticMethod(val) {
    if (arguments.length === 1) {
      this._analyticFlag = val;
      return this;
    }
    return this._analyticFlag || 'row_number';
  }

  // Helper for compiling any aggregate queries.
  _aggregate(method, column, options = {}) {
    this._statements.push({
      grouping: 'columns',
      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',
      method,
      value: column,
      aggregateDistinct: options.distinct || false,
      alias: options.as,
    });
    return this;
  }

  // Helper function for clearing or reseting a grouping type from the builder
  _clearGrouping(grouping) {
    if (grouping in this._single) {
      this._single[grouping] = undefined;
    } else {
      this._statements = reject(this._statements, { grouping });
    }
  }

  // Helper function that checks if the builder will emit a select query
  _isSelectQuery() {
    return SELECT_COMMANDS.has(this._method);
  }

  // Helper function that checks if the query has a lock mode set
  _hasLockMode() {
    return LOCK_MODES.has(this._single.lock);
  }
}

Builder.prototype.select = Builder.prototype.columns;
Builder.prototype.column = Builder.prototype.columns;
Builder.prototype.andWhereNot = Builder.prototype.whereNot;
Builder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;
Builder.prototype.andWhere = Builder.prototype.where;
Builder.prototype.andWhereColumn = Builder.prototype.whereColumn;
Builder.prototype.andWhereRaw = Builder.prototype.whereRaw;
Builder.prototype.andWhereBetween = Builder.prototype.whereBetween;
Builder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;
Builder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;
Builder.prototype.andWhereNotJsonObject = Builder.prototype.whereNotJsonObject;
Builder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;
Builder.prototype.andWhereLike = Builder.prototype.whereLike;
Builder.prototype.andWhereILike = Builder.prototype.whereILike;
Builder.prototype.andHaving = Builder.prototype.having;
Builder.prototype.andHavingIn = Builder.prototype.havingIn;
Builder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;
Builder.prototype.andHavingNull = Builder.prototype.havingNull;
Builder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;
Builder.prototype.andHavingExists = Builder.prototype.havingExists;
Builder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;
Builder.prototype.andHavingBetween = Builder.prototype.havingBetween;
Builder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;
Builder.prototype.from = Builder.prototype.table;
Builder.prototype.into = Builder.prototype.table;
Builder.prototype.del = Builder.prototype.delete;

// Attach all of the top level promise methods that should be chainable.
augmentWithBuilderInterface(Builder);
addQueryContext(Builder);

Builder.extend = (methodName, fn) => {
  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {
    throw new Error(
      `Can't extend QueryBuilder with existing method ('${methodName}').`
    );
  }

  assign(Builder.prototype, { [methodName]: fn });
};

// Sub-builder for onConflict clauses
class OnConflictBuilder {
  constructor(builder, columns) {
    this.builder = builder;
    this._columns = columns;
  }

  // Sets insert query to ignore conflicts
  ignore() {
    this.builder._single.onConflict = this._columns;
    this.builder._single.ignore = true;
    return this.builder;
  }

  // Sets insert query to update on conflict
  merge(updates) {
    this.builder._single.onConflict = this._columns;
    this.builder._single.merge = { updates };
    return this.builder;
  }

  // Prevent
  then() {
    throw new Error(
      'Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()'
    );
  }
}

module.exports = Builder;


/***/ }),

/***/ "./node_modules/knex/lib/query/querycompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Query Compiler
// -------
const helpers = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const Raw = __webpack_require__("./node_modules/knex/lib/raw.js");
const QueryBuilder = __webpack_require__("./node_modules/knex/lib/query/querybuilder.js");
const JoinClause = __webpack_require__("./node_modules/knex/lib/query/joinclause.js");
const debug = __webpack_require__("./node_modules/debug/src/index.js");

const assign = __webpack_require__("./node_modules/lodash/assign.js");
const compact = __webpack_require__("./node_modules/lodash/compact.js");
const groupBy = __webpack_require__("./node_modules/lodash/groupBy.js");
const has = __webpack_require__("./node_modules/lodash/has.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");
const map = __webpack_require__("./node_modules/lodash/map.js");
const omitBy = __webpack_require__("./node_modules/lodash/omitBy.js");
const reduce = __webpack_require__("./node_modules/lodash/reduce.js");
const { nanoid } = __webpack_require__("./node_modules/knex/lib/util/nanoid.js");
const { isString, isUndefined } = __webpack_require__("./node_modules/knex/lib/util/is.js");
const {
  columnize: columnize_,
  direction: direction_,
  operator: operator_,
  wrap: wrap_,
  unwrapRaw: unwrapRaw_,
  rawOrFn: rawOrFn_,
} = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

const debugBindings = debug('knex:bindings');

const components = [
  'comments',
  'columns',
  'join',
  'where',
  'union',
  'group',
  'having',
  'order',
  'limit',
  'offset',
  'lock',
  'waitMode',
];

// The "QueryCompiler" takes all of the query statements which
// have been gathered in the "QueryBuilder" and turns them into a
// properly formatted / bound query string.
class QueryCompiler {
  constructor(client, builder, bindings) {
    this.client = client;
    this.method = builder._method || 'select';
    this.options = builder._options;
    this.single = builder._single;
    this.queryComments = builder._comments;
    this.timeout = builder._timeout || false;
    this.cancelOnTimeout = builder._cancelOnTimeout || false;
    this.grouped = groupBy(builder._statements, 'grouping');
    this.formatter = client.formatter(builder);
    // Used when the insert call is empty.
    this._emptyInsertValue = 'default values';
    this.first = this.select;

    this.bindings = bindings || [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;
    this.builder = this.formatter.builder;
  }

  // Collapse the builder into a single object
  toSQL(method, tz) {
    this._undefinedInWhereClause = false;
    this.undefinedBindingsInfo = [];

    method = method || this.method;
    const val = this[method]() || '';

    const query = {
      method,
      options: reduce(this.options, assign, {}),
      timeout: this.timeout,
      cancelOnTimeout: this.cancelOnTimeout,
      bindings: this.bindingsHolder.bindings || [],
      __knexQueryUid: nanoid(),
    };

    Object.defineProperties(query, {
      toNative: {
        value: () => {
          return {
            sql: this.client.positionBindings(query.sql),
            bindings: this.client.prepBindings(query.bindings),
          };
        },
        enumerable: false,
      },
    });

    if (isString(val)) {
      query.sql = val;
    } else {
      assign(query, val);
    }

    if (method === 'select' || method === 'first') {
      if (this.single.as) {
        query.as = this.single.as;
      }
    }

    if (this._undefinedInWhereClause) {
      debugBindings(query.bindings);
      throw new Error(
        `Undefined binding(s) detected when compiling ` +
          `${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(
            ', '
          )}] query: ${query.sql}`
      );
    }

    return query;
  }

  // Compiles the `select` statement, or nested sub-selects by calling each of
  // the component compilers, trimming out the empties, and returning a
  // generated query string.
  select() {
    let sql = this.with();

    let unionStatement = '';

    const firstStatements = [];
    const endStatements = [];

    components.forEach((component) => {
      const statement = this[component](this);
      // We store the 'union' statement to append it at the end.
      // We still need to call the component sequentially because of
      // order of bindings.
      switch (component) {
        case 'union':
          unionStatement = statement;
          break;
        case 'comments':
        case 'columns':
        case 'join':
        case 'where':
          firstStatements.push(statement);
          break;
        default:
          endStatements.push(statement);
          break;
      }
    });

    // Check if we need to wrap the main query.
    // We need to wrap main query if one of union have wrap options to true
    // to avoid error syntax (in PostgreSQL for example).
    const wrapMainQuery =
      this.grouped.union &&
      this.grouped.union.map((u) => u.wrap).some((u) => u);

    if (this.onlyUnions()) {
      const statements = compact(firstStatements.concat(endStatements)).join(
        ' '
      );
      sql += unionStatement + (statements ? ' ' + statements : '');
    } else {
      const allStatements =
        (wrapMainQuery ? '(' : '') +
        compact(firstStatements).join(' ') +
        (wrapMainQuery ? ')' : '');
      const endStat = compact(endStatements).join(' ');
      sql +=
        allStatements +
        (unionStatement ? ' ' + unionStatement : '') +
        (endStat ? ' ' + endStat : endStat);
    }
    return sql;
  }

  pluck() {
    let toPluck = this.single.pluck;
    if (toPluck.indexOf('.') !== -1) {
      toPluck = toPluck.split('.').slice(-1)[0];
    }
    return {
      sql: this.select(),
      pluck: toPluck,
    };
  }

  // Compiles an "insert" query, allowing for multiple
  // inserts using a single query statement.
  insert() {
    const insertValues = this.single.insert || [];
    const sql = this.with() + `insert into ${this.tableName} `;
    const body = this._insertBody(insertValues);
    return body === '' ? '' : sql + body;
  }

  _onConflictClause(columns) {
    return columns instanceof Raw
      ? this.formatter.wrap(columns)
      : `(${this.formatter.columnize(columns)})`;
  }

  _buildInsertValues(insertData) {
    let sql = '';
    let i = -1;
    while (++i < insertData.values.length) {
      if (i !== 0) sql += '), (';
      sql += this.client.parameterize(
        insertData.values[i],
        this.client.valueForUndefined,
        this.builder,
        this.bindingsHolder
      );
    }
    return sql;
  }

  _insertBody(insertValues) {
    let sql = '';
    if (Array.isArray(insertValues)) {
      if (insertValues.length === 0) {
        return '';
      }
    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {
      return sql + this._emptyInsertValue;
    }

    const insertData = this._prepInsert(insertValues);
    if (typeof insertData === 'string') {
      sql += insertData;
    } else {
      if (insertData.columns.length) {
        sql += `(${columnize_(
          insertData.columns,
          this.builder,
          this.client,
          this.bindingsHolder
        )}`;
        sql += ') values (' + this._buildInsertValues(insertData) + ')';
      } else if (insertValues.length === 1 && insertValues[0]) {
        sql += this._emptyInsertValue;
      } else {
        sql = '';
      }
    }
    return sql;
  }

  // Compiles the "update" query.
  update() {
    // Make sure tableName is processed by the formatter first.
    const withSQL = this.with();
    const { tableName } = this;
    const updateData = this._prepUpdate(this.single.update);
    const wheres = this.where();
    return (
      withSQL +
      `update ${this.single.only ? 'only ' : ''}${tableName}` +
      ' set ' +
      updateData.join(', ') +
      (wheres ? ` ${wheres}` : '')
    );
  }

  _hintComments() {
    let hints = this.grouped.hintComments || [];
    hints = hints.map((hint) => compact(hint.value).join(' '));
    hints = compact(hints).join(' ');
    return hints ? `/*+ ${hints} */ ` : '';
  }

  // Compiles the columns in the query, specifying if an item was distinct.
  columns() {
    let distinctClause = '';
    if (this.onlyUnions()) return '';
    const hints = this._hintComments();
    const columns = this.grouped.columns || [];
    let i = -1,
      sql = [];
    if (columns) {
      while (++i < columns.length) {
        const stmt = columns[i];
        if (stmt.distinct) distinctClause = 'distinct ';
        if (stmt.distinctOn) {
          distinctClause = this.distinctOn(stmt.value);
          continue;
        }
        if (stmt.type === 'aggregate') {
          sql.push(...this.aggregate(stmt));
        } else if (stmt.type === 'aggregateRaw') {
          sql.push(this.aggregateRaw(stmt));
        } else if (stmt.type === 'analytic') {
          sql.push(this.analytic(stmt));
        } else if (stmt.type === 'json') {
          sql.push(this.json(stmt));
        } else if (stmt.value && stmt.value.length > 0) {
          sql.push(
            columnize_(
              stmt.value,
              this.builder,
              this.client,
              this.bindingsHolder
            )
          );
        }
      }
    }
    if (sql.length === 0) sql = ['*'];
    const select = this.onlyJson() ? '' : 'select ';
    return (
      `${select}${hints}${distinctClause}` +
      sql.join(', ') +
      (this.tableName
        ? ` from ${this.single.only ? 'only ' : ''}${this.tableName}`
        : '')
    );
  }

  // Add comments to the query
  comments() {
    if (!this.queryComments.length) return '';
    return this.queryComments
      .map((comment) => `/* ${comment.comment} */`)
      .join(' ');
  }

  _aggregate(stmt, { aliasSeparator = ' as ', distinctParentheses } = {}) {
    const value = stmt.value;
    const method = stmt.method;
    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';
    const wrap = (identifier) =>
      wrap_(
        identifier,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
    const addAlias = (value, alias) => {
      if (alias) {
        return value + aliasSeparator + wrap(alias);
      }
      return value;
    };
    const aggregateArray = (value, alias) => {
      let columns = value.map(wrap).join(', ');
      if (distinct) {
        const openParen = distinctParentheses ? '(' : ' ';
        const closeParen = distinctParentheses ? ')' : '';
        columns = distinct.trim() + openParen + columns + closeParen;
      }
      const aggregated = `${method}(${columns})`;
      return addAlias(aggregated, alias);
    };
    const aggregateString = (value, alias) => {
      const aggregated = `${method}(${distinct + wrap(value)})`;
      return addAlias(aggregated, alias);
    };

    if (Array.isArray(value)) {
      return [aggregateArray(value)];
    }

    if (typeof value === 'object') {
      if (stmt.alias) {
        throw new Error('When using an object explicit alias can not be used');
      }
      return Object.entries(value).map(([alias, column]) => {
        if (Array.isArray(column)) {
          return aggregateArray(column, alias);
        }
        return aggregateString(column, alias);
      });
    }

    // Allows us to speciy an alias for the aggregate types.
    const splitOn = value.toLowerCase().indexOf(' as ');
    let column = value;
    let { alias } = stmt;
    if (splitOn !== -1) {
      column = value.slice(0, splitOn);
      if (alias) {
        throw new Error(`Found multiple aliases for same column: ${column}`);
      }
      alias = value.slice(splitOn + 4);
    }
    return [aggregateString(column, alias)];
  }

  aggregate(stmt) {
    return this._aggregate(stmt);
  }

  aggregateRaw(stmt) {
    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';
    return `${stmt.method}(${
      distinct +
      unwrapRaw_(
        stmt.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )
    })`;
  }

  _joinTable(join) {
    return join.schema && !(join.table instanceof Raw)
      ? `${join.schema}.${join.table}`
      : join.table;
  }

  // Compiles all each of the `join` clauses on the query,
  // including any nested join queries.
  join() {
    let sql = '';
    let i = -1;
    const joins = this.grouped.join;
    if (!joins) return '';
    while (++i < joins.length) {
      const join = joins[i];
      const table = this._joinTable(join);
      if (i > 0) sql += ' ';
      if (join.joinType === 'raw') {
        sql += unwrapRaw_(
          join.table,
          undefined,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      } else {
        sql +=
          join.joinType +
          ' join ' +
          wrap_(
            table,
            undefined,
            this.builder,
            this.client,
            this.bindingsHolder
          );
        let ii = -1;
        while (++ii < join.clauses.length) {
          const clause = join.clauses[ii];
          if (ii > 0) {
            sql += ` ${clause.bool} `;
          } else {
            sql += ` ${clause.type === 'onUsing' ? 'using' : 'on'} `;
          }
          const val = this[clause.type](clause);
          if (val) {
            sql += val;
          }
        }
      }
    }
    return sql;
  }

  onBetween(statement) {
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'between') +
      ' ' +
      statement.value
        .map((value) =>
          this.client.parameter(value, this.builder, this.bindingsHolder)
        )
        .join(' and ')
    );
  }

  onNull(statement) {
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' is ' +
      this._not(statement, 'null')
    );
  }

  onExists(statement) {
    return (
      this._not(statement, 'exists') +
      ' (' +
      rawOrFn_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  onIn(statement) {
    if (Array.isArray(statement.column)) return this.multiOnIn(statement);

    let values;
    if (statement.value instanceof Raw) {
      values = this.client.parameter(
        statement.value,
        this.builder,
        this.formatter
      );
    } else {
      values = this.client.parameterize(
        statement.value,
        undefined,
        this.builder,
        this.bindingsHolder
      );
    }

    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'in ') +
      this.wrap(values)
    );
  }

  multiOnIn(statement) {
    let i = -1,
      sql = `(${columnize_(
        statement.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )}) `;
    sql += this._not(statement, 'in ') + '((';
    while (++i < statement.value.length) {
      if (i !== 0) sql += '),(';
      sql += this.client.parameterize(
        statement.value[i],
        undefined,
        this.builder,
        this.bindingsHolder
      );
    }
    return sql + '))';
  }

  // Compiles all `where` statements on the query.
  where() {
    const wheres = this.grouped.where;
    if (!wheres) return;
    const sql = [];
    let i = -1;
    while (++i < wheres.length) {
      const stmt = wheres[i];
      if (
        Object.prototype.hasOwnProperty.call(stmt, 'value') &&
        helpers.containsUndefined(stmt.value)
      ) {
        this.undefinedBindingsInfo.push(stmt.column);
        this._undefinedInWhereClause = true;
      }
      const val = this[stmt.type](stmt);
      if (val) {
        if (sql.length === 0) {
          sql[0] = 'where';
        } else {
          sql.push(stmt.bool);
        }
        sql.push(val);
      }
    }
    return sql.length > 1 ? sql.join(' ') : '';
  }

  group() {
    return this._groupsOrders('group');
  }

  order() {
    return this._groupsOrders('order');
  }

  // Compiles the `having` statements.
  having() {
    const havings = this.grouped.having;
    if (!havings) return '';
    const sql = ['having'];
    for (let i = 0, l = havings.length; i < l; i++) {
      const s = havings[i];
      const val = this[s.type](s);
      if (val) {
        if (sql.length === 0) {
          sql[0] = 'where';
        }
        if (sql.length > 1 || (sql.length === 1 && sql[0] !== 'having')) {
          sql.push(s.bool);
        }
        sql.push(val);
      }
    }
    return sql.length > 1 ? sql.join(' ') : '';
  }

  havingRaw(statement) {
    return (
      this._not(statement, '') +
      unwrapRaw_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )
    );
  }

  havingWrapped(statement) {
    const val = rawOrFn_(
      statement.value,
      'where',
      this.builder,
      this.client,
      this.bindingsHolder
    );
    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';
  }

  havingBasic(statement) {
    return (
      this._not(statement, '') +
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_(
        statement.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this.client.parameter(statement.value, this.builder, this.bindingsHolder)
    );
  }

  havingNull(statement) {
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' is ' +
      this._not(statement, 'null')
    );
  }

  havingExists(statement) {
    return (
      this._not(statement, 'exists') +
      ' (' +
      rawOrFn_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  havingBetween(statement) {
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'between') +
      ' ' +
      statement.value
        .map((value) =>
          this.client.parameter(value, this.builder, this.bindingsHolder)
        )
        .join(' and ')
    );
  }

  havingIn(statement) {
    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'in ') +
      this.wrap(
        this.client.parameterize(
          statement.value,
          undefined,
          this.builder,
          this.bindingsHolder
        )
      )
    );
  }

  multiHavingIn(statement) {
    return this.multiOnIn(statement);
  }

  // Compile the "union" queries attached to the main query.
  union() {
    const onlyUnions = this.onlyUnions();
    const unions = this.grouped.union;
    if (!unions) return '';
    let sql = '';
    for (let i = 0, l = unions.length; i < l; i++) {
      const union = unions[i];
      if (i > 0) sql += ' ';
      if (i > 0 || !onlyUnions) sql += union.clause + ' ';
      const statement = rawOrFn_(
        union.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
      if (statement) {
        const wrap = union.wrap;
        if (wrap) sql += '(';
        sql += statement;
        if (wrap) sql += ')';
      }
    }
    return sql;
  }

  // If we haven't specified any columns or a `tableName`, we're assuming this
  // is only being used for unions.
  onlyUnions() {
    return (
      (!this.grouped.columns || !!this.grouped.columns[0].value) &&
      this.grouped.union &&
      !this.tableName
    );
  }

  _getValueOrParameterFromAttribute(attribute, rawValue) {
    if (this.single.skipBinding[attribute] === true) {
      return rawValue !== undefined && rawValue !== null
        ? rawValue
        : this.single[attribute];
    }
    return this.client.parameter(
      this.single[attribute],
      this.builder,
      this.bindingsHolder
    );
  }

  onlyJson() {
    return (
      !this.tableName &&
      this.grouped.columns &&
      this.grouped.columns.length === 1 &&
      this.grouped.columns[0].type === 'json'
    );
  }

  limit() {
    const noLimit = !this.single.limit && this.single.limit !== 0;
    if (noLimit) return '';
    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;
  }

  offset() {
    if (!this.single.offset) return '';
    return `offset ${this._getValueOrParameterFromAttribute('offset')}`;
  }

  // Compiles a `delete` query.
  del() {
    // Make sure tableName is processed by the formatter first.
    const { tableName } = this;
    const withSQL = this.with();
    const wheres = this.where();
    const joins = this.join();
    // When using joins, delete the "from" table values as a default
    const deleteSelector = joins ? tableName + ' ' : '';
    return (
      withSQL +
      `delete ${deleteSelector}from ${
        this.single.only ? 'only ' : ''
      }${tableName}` +
      (joins ? ` ${joins}` : '') +
      (wheres ? ` ${wheres}` : '')
    );
  }

  // Compiles a `truncate` query.
  truncate() {
    return `truncate ${this.tableName}`;
  }

  // Compiles the "locks".
  lock() {
    if (this.single.lock) {
      return this[this.single.lock]();
    }
  }

  // Compiles the wait mode on the locks.
  waitMode() {
    if (this.single.waitMode) {
      return this[this.single.waitMode]();
    }
  }

  // Fail on unsupported databases
  skipLocked() {
    throw new Error(
      '.skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+'
    );
  }

  // Fail on unsupported databases
  noWait() {
    throw new Error(
      '.noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+'
    );
  }

  distinctOn(value) {
    throw new Error('.distinctOn() is currently only supported on PostgreSQL');
  }

  // On Clause
  // ------

  onWrapped(clause) {
    const self = this;

    const wrapJoin = new JoinClause();
    clause.value.call(wrapJoin, wrapJoin);

    let sql = '';

    for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {
      const wrapClause = wrapJoin.clauses[ii];
      if (ii > 0) {
        sql += ` ${wrapClause.bool} `;
      }
      const val = self[wrapClause.type](wrapClause);
      if (val) {
        sql += val;
      }
    }

    if (sql.length) {
      return `(${sql})`;
    }
    return '';
  }

  onBasic(clause) {
    const toWrap = clause.value instanceof QueryBuilder;
    return (
      wrap_(
        clause.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_(
        clause.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      (toWrap ? '(' : '') +
      wrap_(
        clause.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      (toWrap ? ')' : '')
    );
  }

  onVal(clause) {
    return (
      wrap_(
        clause.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_(
        clause.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this.client.parameter(clause.value, this.builder, this.bindingsHolder)
    );
  }

  onRaw(clause) {
    return unwrapRaw_(
      clause.value,
      undefined,
      this.builder,
      this.client,
      this.bindingsHolder
    );
  }

  onUsing(clause) {
    return (
      '(' +
      columnize_(
        clause.column,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  // Where Clause
  // ------

  _valueClause(statement) {
    return statement.asColumn
      ? wrap_(
          statement.value,
          undefined,
          this.builder,
          this.client,
          this.bindingsHolder
        )
      : this.client.parameter(
          statement.value,
          this.builder,
          this.bindingsHolder
        );
  }

  _columnClause(statement) {
    let columns;
    if (Array.isArray(statement.column)) {
      columns = `(${columnize_(
        statement.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )})`;
    } else {
      columns = wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
    }
    return columns;
  }

  whereIn(statement) {
    const values = this.client.values(
      statement.value,
      this.builder,
      this.bindingsHolder
    );
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'in '
    )}${values}`;
  }

  whereLike(statement) {
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'like '
    )}${this._valueClause(statement)}`;
  }

  whereILike(statement) {
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'ilike '
    )}${this._valueClause(statement)}`;
  }

  whereNull(statement) {
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' is ' +
      this._not(statement, 'null')
    );
  }

  // Compiles a basic "where" clause.
  whereBasic(statement) {
    return (
      this._not(statement, '') +
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_(
        statement.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._valueClause(statement)
    );
  }

  whereExists(statement) {
    return (
      this._not(statement, 'exists') +
      ' (' +
      rawOrFn_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  whereWrapped(statement) {
    const val = rawOrFn_(
      statement.value,
      'where',
      this.builder,
      this.client,
      this.bindingsHolder
    );
    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';
  }

  whereBetween(statement) {
    return (
      wrap_(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'between') +
      ' ' +
      statement.value
        .map((value) =>
          this.client.parameter(value, this.builder, this.bindingsHolder)
        )
        .join(' and ')
    );
  }

  // Compiles a "whereRaw" query.
  whereRaw(statement) {
    return (
      this._not(statement, '') +
      unwrapRaw_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )
    );
  }

  _jsonWrapValue(jsonValue) {
    if (!this.builder._isJsonObject(jsonValue)) {
      try {
        return JSON.stringify(JSON.parse(jsonValue.replace(/\n|\t/g, '')));
      } catch (e) {
        return jsonValue;
      }
    }
    return JSON.stringify(jsonValue);
  }

  _jsonValueClause(statement) {
    statement.value = this._jsonWrapValue(statement.value);
    return this._valueClause(statement);
  }

  whereJsonObject(statement) {
    return `${this._columnClause(statement)} ${
      statement.not ? '!=' : '='
    } ${this._jsonValueClause(statement)}`;
  }

  wrap(str) {
    if (str.charAt(0) !== '(') return `(${str})`;
    return str;
  }

  json(stmt) {
    return this[stmt.method](stmt.params);
  }

  analytic(stmt) {
    let sql = '';
    const self = this;
    sql += stmt.method + '() over (';

    if (stmt.raw) {
      sql += stmt.raw;
    } else {
      if (stmt.partitions.length) {
        sql += 'partition by ';
        sql +=
          map(stmt.partitions, function (partition) {
            if (isString(partition)) {
              return self.formatter.columnize(partition);
            } else return self.formatter.columnize(partition.column) + (partition.order ? ' ' + partition.order : '');
          }).join(', ') + ' ';
      }

      sql += 'order by ';
      sql += map(stmt.order, function (order) {
        if (isString(order)) {
          return self.formatter.columnize(order);
        } else return self.formatter.columnize(order.column) + (order.order ? ' ' + order.order : '');
      }).join(', ');
    }

    sql += ')';

    if (stmt.alias) {
      sql += ' as ' + stmt.alias;
    }

    return sql;
  }

  // Compiles all `with` statements on the query.
  with() {
    if (!this.grouped.with || !this.grouped.with.length) {
      return '';
    }
    const withs = this.grouped.with;
    if (!withs) return;
    const sql = [];
    let i = -1;
    let isRecursive = false;
    while (++i < withs.length) {
      const stmt = withs[i];
      if (stmt.recursive) {
        isRecursive = true;
      }
      const val = this[stmt.type](stmt);
      sql.push(val);
    }
    return `with ${isRecursive ? 'recursive ' : ''}${sql.join(', ')} `;
  }

  withWrapped(statement) {
    const val = rawOrFn_(
      statement.value,
      undefined,
      this.builder,
      this.client,
      this.bindingsHolder
    );
    const columnList = statement.columnList
      ? '(' +
        columnize_(
          statement.columnList,
          this.builder,
          this.client,
          this.bindingsHolder
        ) +
        ')'
      : '';
    const materialized =
      statement.materialized === undefined
        ? ''
        : statement.materialized
        ? 'materialized '
        : 'not materialized ';
    return (
      (val &&
        columnize_(
          statement.alias,
          this.builder,
          this.client,
          this.bindingsHolder
        ) +
          columnList +
          ' as ' +
          materialized +
          '(' +
          val +
          ')') ||
      ''
    );
  }

  // Determines whether to add a "not" prefix to the where clause.
  _not(statement, str) {
    if (statement.not) return `not ${str}`;
    return str;
  }

  _prepInsert(data) {
    const isRaw = rawOrFn_(
      data,
      undefined,
      this.builder,
      this.client,
      this.bindingsHolder
    );
    if (isRaw) return isRaw;
    let columns = [];
    const values = [];
    if (!Array.isArray(data)) data = data ? [data] : [];
    let i = -1;
    while (++i < data.length) {
      if (data[i] == null) break;
      if (i === 0) columns = Object.keys(data[i]).sort();
      const row = new Array(columns.length);
      const keys = Object.keys(data[i]);
      let j = -1;
      while (++j < keys.length) {
        const key = keys[j];
        let idx = columns.indexOf(key);
        if (idx === -1) {
          columns = columns.concat(key).sort();
          idx = columns.indexOf(key);
          let k = -1;
          while (++k < values.length) {
            values[k].splice(idx, 0, undefined);
          }
          row.splice(idx, 0, undefined);
        }
        row[idx] = data[i][key];
      }
      values.push(row);
    }
    return {
      columns,
      values,
    };
  }

  // "Preps" the update.
  _prepUpdate(data = {}) {
    const { counter = {} } = this.single;

    for (const column of Object.keys(counter)) {
      //Skip?
      if (has(data, column)) {
        //Needed?
        this.client.logger.warn(
          `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`
        );
        continue;
      }

      let value = counter[column];

      const symbol = value < 0 ? '-' : '+';

      if (symbol === '-') {
        value = -value;
      }

      data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);
    }

    data = omitBy(data, isUndefined);

    const vals = [];
    const columns = Object.keys(data);
    let i = -1;

    while (++i < columns.length) {
      vals.push(
        wrap_(
          columns[i],
          undefined,
          this.builder,
          this.client,
          this.bindingsHolder
        ) +
          ' = ' +
          this.client.parameter(
            data[columns[i]],
            this.builder,
            this.bindingsHolder
          )
      );
    }

    if (isEmpty(vals)) {
      throw new Error(
        [
          'Empty .update() call detected!',
          'Update data does not contain any values to update.',
          'This will result in a faulty query.',
          this.single.table ? `Table: ${this.single.table}.` : '',
          this.single.update
            ? `Columns: ${Object.keys(this.single.update)}.`
            : '',
        ].join(' ')
      );
    }

    return vals;
  }

  _formatGroupsItemValue(value, nulls) {
    const { formatter } = this;
    let nullOrder = '';
    if (nulls === 'last') {
      nullOrder = ' is null';
    } else if (nulls === 'first') {
      nullOrder = ' is not null';
    }

    let groupOrder;
    if (value instanceof Raw) {
      groupOrder = unwrapRaw_(
        value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
    } else if (value instanceof QueryBuilder || nulls) {
      groupOrder = '(' + formatter.columnize(value) + nullOrder + ')';
    } else {
      groupOrder = formatter.columnize(value);
    }
    return groupOrder;
  }

  _basicGroupOrder(item, type) {
    const column = this._formatGroupsItemValue(item.value, item.nulls);
    const direction =
      type === 'order' && item.type !== 'orderByRaw'
        ? ` ${direction_(
            item.direction,
            this.builder,
            this.client,
            this.bindingsHolder
          )}`
        : '';
    return column + direction;
  }

  _groupOrder(item, type) {
    return this._basicGroupOrder(item, type);
  }

  _groupOrderNulls(item, type) {
    const column = this._formatGroupsItemValue(item.value);
    const direction =
      type === 'order' && item.type !== 'orderByRaw'
        ? ` ${direction_(
            item.direction,
            this.builder,
            this.client,
            this.bindingsHolder
          )}`
        : '';
    if (item.nulls && !(item.value instanceof Raw)) {
      return `${column}${direction ? direction : ''} nulls ${item.nulls}`;
    }
    return column + direction;
  }

  // Compiles the `order by` statements.
  _groupsOrders(type) {
    const items = this.grouped[type];
    if (!items) return '';
    const sql = items.map((item) => {
      return this._groupOrder(item, type);
    });
    return sql.length ? type + ' by ' + sql.join(', ') : '';
  }

  // Get the table name, wrapping it if necessary.
  // Implemented as a property to prevent ordering issues as described in #704.
  get tableName() {
    if (!this._tableName) {
      // Only call this.formatter.wrap() the first time this property is accessed.
      let tableName = this.single.table;
      const schemaName = this.single.schema;

      if (tableName && schemaName) {
        const isQueryBuilder = tableName instanceof QueryBuilder;
        const isRawQuery = tableName instanceof Raw;
        const isFunction = typeof tableName === 'function';

        if (!isQueryBuilder && !isRawQuery && !isFunction) {
          tableName = `${schemaName}.${tableName}`;
        }
      }

      this._tableName = tableName
        ? // Wrap subQuery with parenthesis, #3485
          wrap_(
            tableName,
            tableName instanceof QueryBuilder,
            this.builder,
            this.client,
            this.bindingsHolder
          )
        : '';
    }
    return this._tableName;
  }

  _jsonPathWrap(extraction) {
    return this.client.parameter(
      extraction.path || extraction[1],
      this.builder,
      this.bindingsHolder
    );
  }

  // Json common functions
  _jsonExtract(nameFunction, params) {
    let extractions;
    if (Array.isArray(params.column)) {
      extractions = params.column;
    } else {
      extractions = [params];
    }
    if (!Array.isArray(nameFunction)) {
      nameFunction = [nameFunction];
    }
    return extractions
      .map((extraction) => {
        let jsonCol = `${columnize_(
          extraction.column || extraction[0],
          this.builder,
          this.client,
          this.bindingsHolder
        )}, ${this._jsonPathWrap(extraction)}`;
        nameFunction.forEach((f) => {
          jsonCol = f + '(' + jsonCol + ')';
        });
        const alias = extraction.alias || extraction[2];
        return alias
          ? this.client.alias(jsonCol, this.formatter.wrap(alias))
          : jsonCol;
      })
      .join(', ');
  }

  _jsonSet(nameFunction, params) {
    const jsonSet = `${nameFunction}(${columnize_(
      params.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )}, ${this.client.parameter(
      params.path,
      this.builder,
      this.bindingsHolder
    )}, ${this.client.parameter(
      params.value,
      this.builder,
      this.bindingsHolder
    )})`;
    return params.alias
      ? this.client.alias(jsonSet, this.formatter.wrap(params.alias))
      : jsonSet;
  }

  _whereJsonPath(nameFunction, statement) {
    return `${nameFunction}(${this._columnClause(
      statement
    )}, ${this._jsonPathWrap({ path: statement.jsonPath })}) ${operator_(
      statement.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    )} ${this._jsonValueClause(statement)}`;
  }

  _onJsonPathEquals(nameJoinFunction, clause) {
    return (
      nameJoinFunction +
      '(' +
      wrap_(
        clause.columnFirst,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ', ' +
      this.client.parameter(
        clause.jsonPathFirst,
        this.builder,
        this.bindingsHolder
      ) +
      ') = ' +
      nameJoinFunction +
      '(' +
      wrap_(
        clause.columnSecond,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ', ' +
      this.client.parameter(
        clause.jsonPathSecond,
        this.builder,
        this.bindingsHolder
      ) +
      ')'
    );
  }
}

module.exports = QueryCompiler;


/***/ }),

/***/ "./node_modules/knex/lib/raw.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Raw
// -------
const { EventEmitter } = __webpack_require__("events");
const debug = __webpack_require__("./node_modules/debug/src/index.js");
const assign = __webpack_require__("./node_modules/lodash/assign.js");
const isPlainObject = __webpack_require__("./node_modules/lodash/isPlainObject.js");
const reduce = __webpack_require__("./node_modules/lodash/reduce.js");

const {
  replaceRawArrBindings,
  replaceKeyBindings,
} = __webpack_require__("./node_modules/knex/lib/formatter/rawFormatter.js");
const helpers = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const saveAsyncStack = __webpack_require__("./node_modules/knex/lib/util/save-async-stack.js");
const { nanoid } = __webpack_require__("./node_modules/knex/lib/util/nanoid.js");
const { isNumber, isObject } = __webpack_require__("./node_modules/knex/lib/util/is.js");
const {
  augmentWithBuilderInterface,
} = __webpack_require__("./node_modules/knex/lib/builder-interface-augmenter.js");

const debugBindings = debug('knex:bindings');

class Raw extends EventEmitter {
  constructor(client) {
    super();

    this.client = client;

    this.sql = '';
    this.bindings = [];

    // Todo: Deprecate
    this._wrappedBefore = undefined;
    this._wrappedAfter = undefined;
    if (client && client.config) {
      this._debug = client.config.debug;
      saveAsyncStack(this, 4);
    }
  }
  set(sql, bindings) {
    this.sql = sql;
    this.bindings =
      (isObject(bindings) && !bindings.toSQL) || bindings === undefined
        ? bindings
        : [bindings];

    return this;
  }

  timeout(ms, { cancel } = {}) {
    if (isNumber(ms) && ms > 0) {
      this._timeout = ms;
      if (cancel) {
        this.client.assertCanCancelQuery();
        this._cancelOnTimeout = true;
      }
    }
    return this;
  }

  // Wraps the current sql with `before` and `after`.
  wrap(before, after) {
    this._wrappedBefore = before;
    this._wrappedAfter = after;
    return this;
  }

  // Calls `toString` on the Knex object.
  toString() {
    return this.toQuery();
  }

  // Returns the raw sql for the query.
  toSQL(method, tz) {
    let obj;
    if (Array.isArray(this.bindings)) {
      obj = replaceRawArrBindings(this, this.client);
    } else if (this.bindings && isPlainObject(this.bindings)) {
      obj = replaceKeyBindings(this, this.client);
    } else {
      obj = {
        method: 'raw',
        sql: this.sql,
        bindings: this.bindings === undefined ? [] : [this.bindings],
      };
    }

    if (this._wrappedBefore) {
      obj.sql = this._wrappedBefore + obj.sql;
    }
    if (this._wrappedAfter) {
      obj.sql = obj.sql + this._wrappedAfter;
    }

    obj.options = reduce(this._options, assign, {});

    if (this._timeout) {
      obj.timeout = this._timeout;
      if (this._cancelOnTimeout) {
        obj.cancelOnTimeout = this._cancelOnTimeout;
      }
    }

    obj.bindings = obj.bindings || [];
    if (helpers.containsUndefined(obj.bindings)) {
      const undefinedBindingIndices = helpers.getUndefinedIndices(
        this.bindings
      );
      debugBindings(obj.bindings);
      throw new Error(
        `Undefined binding(s) detected for keys [${undefinedBindingIndices}] when compiling RAW query: ${obj.sql}`
      );
    }

    obj.__knexQueryUid = nanoid();

    Object.defineProperties(obj, {
      toNative: {
        value: () => ({
          sql: this.client.positionBindings(obj.sql),
          bindings: this.client.prepBindings(obj.bindings),
        }),
        enumerable: false,
      },
    });

    return obj;
  }
}

// Workaround to avoid circular dependency between wrappingFormatter.unwrapRaw and rawFormatter
Raw.prototype.isRawInstance = true;

// Allow the `Raw` object to be utilized with full access to the relevant
// promise API.
augmentWithBuilderInterface(Raw);
helpers.addQueryContext(Raw);

module.exports = Raw;


/***/ }),

/***/ "./node_modules/knex/lib/ref.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Raw = __webpack_require__("./node_modules/knex/lib/raw.js");

class Ref extends Raw {
  constructor(client, ref) {
    super(client);

    this.ref = ref;
    this._schema = null;
    this._alias = null;
  }

  withSchema(schema) {
    this._schema = schema;

    return this;
  }

  as(alias) {
    this._alias = alias;

    return this;
  }

  toSQL() {
    const string = this._schema ? `${this._schema}.${this.ref}` : this.ref;

    const formatter = this.client.formatter(this);

    const ref = formatter.columnize(string);

    const sql = this._alias ? `${ref} as ${formatter.wrap(this._alias)}` : ref;

    this.set(sql, []);

    return super.toSQL(...arguments);
  }
}

module.exports = Ref;


/***/ }),

/***/ "./node_modules/knex/lib/schema/builder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { EventEmitter } = __webpack_require__("events");
const toArray = __webpack_require__("./node_modules/lodash/toArray.js");
const assign = __webpack_require__("./node_modules/lodash/assign.js");
const { addQueryContext } = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const saveAsyncStack = __webpack_require__("./node_modules/knex/lib/util/save-async-stack.js");
const {
  augmentWithBuilderInterface,
} = __webpack_require__("./node_modules/knex/lib/builder-interface-augmenter.js");

// Constructor for the builder instance, typically called from
// `knex.builder`, accepting the current `knex` instance,
// and pulling out the `client` and `grammar` from the current
// knex instance.
class SchemaBuilder extends EventEmitter {
  constructor(client) {
    super();
    this.client = client;
    this._sequence = [];

    if (client.config) {
      this._debug = client.config.debug;
      saveAsyncStack(this, 4);
    }
  }

  withSchema(schemaName) {
    this._schema = schemaName;
    return this;
  }

  toString() {
    return this.toQuery();
  }

  toSQL() {
    return this.client.schemaCompiler(this).toSQL();
  }

  async generateDdlCommands() {
    return await this.client.schemaCompiler(this).generateDdlCommands();
  }
}

// Each of the schema builder methods just add to the
// "_sequence" array for consistency.
[
  'createTable',
  'createTableIfNotExists',
  'createTableLike',
  'createView',
  'createViewOrReplace',
  'createMaterializedView',
  'refreshMaterializedView',
  'dropView',
  'dropViewIfExists',
  'dropMaterializedView',
  'dropMaterializedViewIfExists',
  'createSchema',
  'createSchemaIfNotExists',
  'dropSchema',
  'dropSchemaIfExists',
  'createExtension',
  'createExtensionIfNotExists',
  'dropExtension',
  'dropExtensionIfExists',
  'table',
  'alterTable',
  'view',
  'alterView',
  'hasTable',
  'hasColumn',
  'dropTable',
  'renameTable',
  'renameView',
  'dropTableIfExists',
  'raw',
].forEach(function (method) {
  SchemaBuilder.prototype[method] = function () {
    if (method === 'createTableIfNotExists') {
      this.client.logger.warn(
        [
          'Use async .hasTable to check if table exists and then use plain .createTable. Since ',
          '.createTableIfNotExists actually just generates plain "CREATE TABLE IF NOT EXIST..." ',
          'query it will not work correctly if there are any alter table queries generated for ',
          'columns afterwards. To not break old migrations this function is left untouched for now',
          ', but it should not be used when writing new code and it is removed from documentation.',
        ].join('')
      );
    }
    if (method === 'table') method = 'alterTable';
    if (method === 'view') method = 'alterView';
    this._sequence.push({
      method,
      args: toArray(arguments),
    });
    return this;
  };
});

SchemaBuilder.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(SchemaBuilder.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend SchemaBuilder with existing method ('${methodName}').`
    );
  }

  assign(SchemaBuilder.prototype, { [methodName]: fn });
};

augmentWithBuilderInterface(SchemaBuilder);
addQueryContext(SchemaBuilder);

module.exports = SchemaBuilder;


/***/ }),

/***/ "./node_modules/knex/lib/schema/columnbuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const extend = __webpack_require__("./node_modules/lodash/extend.js");
const assign = __webpack_require__("./node_modules/lodash/assign.js");
const toArray = __webpack_require__("./node_modules/lodash/toArray.js");
const { addQueryContext } = __webpack_require__("./node_modules/knex/lib/util/helpers.js");

// The chainable interface off the original "column" method.
class ColumnBuilder {
  constructor(client, tableBuilder, type, args) {
    this.client = client;
    this._method = 'add';
    this._single = {};
    this._modifiers = {};
    this._statements = [];
    this._type = columnAlias[type] || type;
    this._args = args;
    this._tableBuilder = tableBuilder;

    // If we're altering the table, extend the object
    // with the available "alter" methods.
    if (tableBuilder._method === 'alter') {
      extend(this, AlterMethods);
    }
  }

  // Specify that the current column "references" a column,
  // which may be tableName.column or just "column"
  references(value) {
    return this._tableBuilder.foreign
      .call(this._tableBuilder, this._args[0], undefined, this)
      ._columnBuilder(this)
      .references(value);
  }
}

// All of the modifier methods that can be used to modify the current query.
const modifiers = [
  'default',
  'defaultsTo',
  'defaultTo',
  'unsigned',
  'nullable',
  'first',
  'after',
  'comment',
  'collate',
  'check',
  'checkPositive',
  'checkNegative',
  'checkIn',
  'checkNotIn',
  'checkBetween',
  'checkLength',
  'checkRegex',
];

// Aliases for convenience.
const aliasMethod = {
  default: 'defaultTo',
  defaultsTo: 'defaultTo',
};

// If we call any of the modifiers (index or otherwise) on the chainable, we pretend
// as though we're calling `table.method(column)` directly.
modifiers.forEach(function (method) {
  const key = aliasMethod[method] || method;
  ColumnBuilder.prototype[method] = function () {
    this._modifiers[key] = toArray(arguments);
    return this;
  };
});

addQueryContext(ColumnBuilder);

ColumnBuilder.prototype.notNull = ColumnBuilder.prototype.notNullable =
  function notNullable() {
    return this.nullable(false);
  };

['index', 'primary', 'unique'].forEach(function (method) {
  ColumnBuilder.prototype[method] = function () {
    if (this._type.toLowerCase().indexOf('increments') === -1) {
      this._tableBuilder[method].apply(
        this._tableBuilder,
        [this._args[0]].concat(toArray(arguments))
      );
    }
    return this;
  };
});

ColumnBuilder.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(ColumnBuilder.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend ColumnBuilder with existing method ('${methodName}').`
    );
  }

  assign(ColumnBuilder.prototype, { [methodName]: fn });
};

const AlterMethods = {};

// Specify that the column is to be dropped. This takes precedence
// over all other rules for the column.
AlterMethods.drop = function () {
  this._single.drop = true;

  return this;
};

// Specify the "type" that we're looking to set the
// Knex takes no responsibility for any data-loss that may
// occur when changing data types.
AlterMethods.alterType = function (type) {
  this._statements.push({
    grouping: 'alterType',
    value: type,
  });

  return this;
};

// Set column method to alter (default is add).
AlterMethods.alter = function ({
  alterNullable = true,
  alterType = true,
} = {}) {
  this._method = 'alter';
  this.alterNullable = alterNullable;
  this.alterType = alterType;

  return this;
};

// Alias a few methods for clarity when processing.
const columnAlias = {
  float: 'floating',
  enum: 'enu',
  boolean: 'bool',
  string: 'varchar',
  bigint: 'bigInteger',
};

module.exports = ColumnBuilder;


/***/ }),

/***/ "./node_modules/knex/lib/schema/columncompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Column Compiler
// Used for designating column definitions
// during the table "create" / "alter" statements.
// -------
const helpers = __webpack_require__("./node_modules/knex/lib/schema/internal/helpers.js");
const groupBy = __webpack_require__("./node_modules/lodash/groupBy.js");
const first = __webpack_require__("./node_modules/lodash/first.js");
const has = __webpack_require__("./node_modules/lodash/has.js");
const tail = __webpack_require__("./node_modules/lodash/tail.js");
const { toNumber } = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const { formatDefault } = __webpack_require__("./node_modules/knex/lib/formatter/formatterUtils.js");
const { operator: operator_ } = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

class ColumnCompiler {
  constructor(client, tableCompiler, columnBuilder) {
    this.client = client;
    this.tableCompiler = tableCompiler;
    this.columnBuilder = columnBuilder;
    this._commonBuilder = this.columnBuilder;
    this.args = columnBuilder._args;
    this.type = columnBuilder._type.toLowerCase();
    this.grouped = groupBy(columnBuilder._statements, 'grouping');
    this.modified = columnBuilder._modifiers;
    this.isIncrements = this.type.indexOf('increments') !== -1;

    this.formatter = client.formatter(columnBuilder);
    this.bindings = [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;

    this.sequence = [];
    this.modifiers = [];

    this.checksCount = 0;
  }

  _addCheckModifiers() {
    this.modifiers.push(
      'check',
      'checkPositive',
      'checkNegative',
      'checkIn',
      'checkNotIn',
      'checkBetween',
      'checkLength',
      'checkRegex'
    );
  }

  defaults(label) {
    if (Object.prototype.hasOwnProperty.call(this._defaultMap, label)) {
      return this._defaultMap[label].bind(this)();
    } else {
      throw new Error(
        `There is no default for the specified identifier ${label}`
      );
    }
  }

  // To convert to sql, we first go through and build the
  // column as it would be in the insert statement
  toSQL() {
    this.pushQuery(this.compileColumn());
    if (this.sequence.additional) {
      this.sequence = this.sequence.concat(this.sequence.additional);
    }
    return this.sequence;
  }

  // Compiles a column.
  compileColumn() {
    return (
      this.formatter.wrap(this.getColumnName()) +
      ' ' +
      this.getColumnType() +
      this.getModifiers()
    );
  }

  // Assumes the autoincrementing key is named `id` if not otherwise specified.
  getColumnName() {
    const value = first(this.args);
    return value || this.defaults('columnName');
  }

  getColumnType() {
    // Column type is cached so side effects (such as in pg native enums) are only run once
    if (!this._columnType) {
      const type = this[this.type];
      this._columnType =
        typeof type === 'function' ? type.apply(this, tail(this.args)) : type;
    }

    return this._columnType;
  }

  getModifiers() {
    const modifiers = [];

    for (let i = 0, l = this.modifiers.length; i < l; i++) {
      const modifier = this.modifiers[i];

      //Cannot allow 'nullable' modifiers on increments types
      if (!this.isIncrements || (this.isIncrements && modifier === 'comment')) {
        if (has(this.modified, modifier)) {
          const val = this[modifier].apply(this, this.modified[modifier]);
          if (val) modifiers.push(val);
        }
      }
    }

    return modifiers.length > 0 ? ` ${modifiers.join(' ')}` : '';
  }

  // Types
  // ------
  varchar(length) {
    return `varchar(${toNumber(length, 255)})`;
  }

  floating(precision, scale) {
    return `float(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
  }

  decimal(precision, scale) {
    if (precision === null) {
      throw new Error(
        'Specifying no precision on decimal columns is not supported for that SQL dialect.'
      );
    }
    return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
  }

  // Used to support custom types
  specifictype(type) {
    return type;
  }

  // Modifiers
  // -------

  nullable(nullable) {
    return nullable === false ? 'not null' : 'null';
  }

  notNullable() {
    return this.nullable(false);
  }

  defaultTo(value) {
    return `default ${formatDefault(value, this.type, this.client)}`;
  }

  increments(options = { primaryKey: true }) {
    return (
      'integer not null' +
      (this.tableCompiler._canBeAddPrimaryKey(options) ? ' primary key' : '') +
      ' autoincrement'
    );
  }

  bigincrements(options = { primaryKey: true }) {
    return this.increments(options);
  }

  _pushAlterCheckQuery(checkPredicate, constraintName) {
    let checkName = constraintName;
    if (!checkName) {
      this.checksCount++;
      checkName =
        this.tableCompiler.tableNameRaw +
        '_' +
        this.getColumnName() +
        '_' +
        this.checksCount;
    }
    this.pushAdditional(function () {
      this.pushQuery(
        `alter table ${this.tableCompiler.tableName()} add constraint ${checkName} check(${checkPredicate})`
      );
    });
  }

  _checkConstraintName(constraintName) {
    return constraintName ? `constraint ${constraintName} ` : '';
  }

  _check(checkPredicate, constraintName) {
    if (this.columnBuilder._method === 'alter') {
      this._pushAlterCheckQuery(checkPredicate, constraintName);
      return '';
    }
    return `${this._checkConstraintName(
      constraintName
    )}check (${checkPredicate})`;
  }

  checkPositive(constraintName) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${operator_(
        '>',
        this.columnBuilder,
        this.bindingsHolder
      )} 0`,
      constraintName
    );
  }

  checkNegative(constraintName) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${operator_(
        '<',
        this.columnBuilder,
        this.bindingsHolder
      )} 0`,
      constraintName
    );
  }

  _checkIn(values, constraintName, not) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${
        not ? 'not ' : ''
      }in (${values.map((v) => this.client._escapeBinding(v)).join(',')})`,
      constraintName
    );
  }

  checkIn(values, constraintName) {
    return this._checkIn(values, constraintName);
  }

  checkNotIn(values, constraintName) {
    return this._checkIn(values, constraintName, true);
  }

  checkBetween(intervals, constraintName) {
    if (
      intervals.length === 2 &&
      !Array.isArray(intervals[0]) &&
      !Array.isArray(intervals[1])
    ) {
      intervals = [intervals];
    }
    const intervalChecks = intervals
      .map((interval) => {
        return `${this.formatter.wrap(
          this.getColumnName()
        )} between ${this.client._escapeBinding(
          interval[0]
        )} and ${this.client._escapeBinding(interval[1])}`;
      })
      .join(' or ');
    return this._check(intervalChecks, constraintName);
  }

  checkLength(operator, length, constraintName) {
    return this._check(
      `length(${this.formatter.wrap(this.getColumnName())}) ${operator_(
        operator,
        this.columnBuilder,
        this.bindingsHolder
      )} ${toNumber(length)}`,
      constraintName
    );
  }
}

ColumnCompiler.prototype.binary = 'blob';
ColumnCompiler.prototype.bool = 'boolean';
ColumnCompiler.prototype.date = 'date';
ColumnCompiler.prototype.datetime = 'datetime';
ColumnCompiler.prototype.time = 'time';
ColumnCompiler.prototype.timestamp = 'timestamp';
ColumnCompiler.prototype.geometry = 'geometry';
ColumnCompiler.prototype.geography = 'geography';
ColumnCompiler.prototype.point = 'point';
ColumnCompiler.prototype.enu = 'varchar';
ColumnCompiler.prototype.bit = ColumnCompiler.prototype.json = 'text';
ColumnCompiler.prototype.uuid = ({
  useBinaryUuid = false,
  primaryKey = false,
} = {}) => (useBinaryUuid ? 'binary(16)' : 'char(36)');
ColumnCompiler.prototype.integer =
  ColumnCompiler.prototype.smallint =
  ColumnCompiler.prototype.mediumint =
    'integer';
ColumnCompiler.prototype.biginteger = 'bigint';
ColumnCompiler.prototype.text = 'text';
ColumnCompiler.prototype.tinyint = 'tinyint';

ColumnCompiler.prototype.pushQuery = helpers.pushQuery;
ColumnCompiler.prototype.pushAdditional = helpers.pushAdditional;
ColumnCompiler.prototype.unshiftQuery = helpers.unshiftQuery;

ColumnCompiler.prototype._defaultMap = {
  columnName: function () {
    if (!this.isIncrements) {
      throw new Error(
        `You did not specify a column name for the ${this.type} column.`
      );
    }
    return 'id';
  },
};

module.exports = ColumnCompiler;


/***/ }),

/***/ "./node_modules/knex/lib/schema/compiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  pushQuery,
  pushAdditional,
  unshiftQuery,
} = __webpack_require__("./node_modules/knex/lib/schema/internal/helpers.js");

// The "SchemaCompiler" takes all of the query statements which have been
// gathered in the "SchemaBuilder" and turns them into an array of
// properly formatted / bound query strings.
class SchemaCompiler {
  constructor(client, builder) {
    this.builder = builder;
    this._commonBuilder = this.builder;
    this.client = client;
    this.schema = builder._schema;

    this.bindings = [];
    this.bindingsHolder = this;
    this.formatter = client.formatter(builder);
    this.formatter.bindings = this.bindings;
    this.sequence = [];
  }

  createSchema() {
    throwOnlyPGError('createSchema');
  }

  createSchemaIfNotExists() {
    throwOnlyPGError('createSchemaIfNotExists');
  }

  dropSchema() {
    throwOnlyPGError('dropSchema');
  }

  dropSchemaIfExists() {
    throwOnlyPGError('dropSchemaIfExists');
  }

  dropTable(tableName) {
    this.pushQuery(
      this.dropTablePrefix +
        this.formatter.wrap(prefixedTableName(this.schema, tableName))
    );
  }

  dropTableIfExists(tableName) {
    this.pushQuery(
      this.dropTablePrefix +
        'if exists ' +
        this.formatter.wrap(prefixedTableName(this.schema, tableName))
    );
  }

  dropView(viewName) {
    this._dropView(viewName, false, false);
  }

  dropViewIfExists(viewName) {
    this._dropView(viewName, true, false);
  }

  dropMaterializedView(viewName) {
    throw new Error('materialized views are not supported by this dialect.');
  }

  dropMaterializedViewIfExists(viewName) {
    throw new Error('materialized views are not supported by this dialect.');
  }

  renameView(from, to) {
    throw new Error(
      'rename view is not supported by this dialect (instead drop then create another view).'
    );
  }

  refreshMaterializedView() {
    throw new Error('materialized views are not supported by this dialect.');
  }

  _dropView(viewName, ifExists, materialized) {
    this.pushQuery(
      (materialized ? this.dropMaterializedViewPrefix : this.dropViewPrefix) +
        (ifExists ? 'if exists ' : '') +
        this.formatter.wrap(prefixedTableName(this.schema, viewName))
    );
  }

  raw(sql, bindings) {
    this.sequence.push(this.client.raw(sql, bindings).toSQL());
  }

  toSQL() {
    const sequence = this.builder._sequence;
    for (let i = 0, l = sequence.length; i < l; i++) {
      const query = sequence[i];
      this[query.method].apply(this, query.args);
    }
    return this.sequence;
  }

  async generateDdlCommands() {
    const generatedCommands = this.toSQL();
    return {
      pre: [],
      sql: Array.isArray(generatedCommands)
        ? generatedCommands
        : [generatedCommands],
      check: null,
      post: [],
    };
  }
}

SchemaCompiler.prototype.dropTablePrefix = 'drop table ';
SchemaCompiler.prototype.dropViewPrefix = 'drop view ';
SchemaCompiler.prototype.dropMaterializedViewPrefix = 'drop materialized view ';
SchemaCompiler.prototype.alterViewPrefix = 'alter view ';

SchemaCompiler.prototype.alterTable = buildTable('alter');
SchemaCompiler.prototype.createTable = buildTable('create');
SchemaCompiler.prototype.createTableIfNotExists = buildTable('createIfNot');
SchemaCompiler.prototype.createTableLike = buildTable('createLike');

SchemaCompiler.prototype.createView = buildView('create');
SchemaCompiler.prototype.createViewOrReplace = buildView('createOrReplace');
SchemaCompiler.prototype.createMaterializedView = buildView(
  'createMaterializedView'
);
SchemaCompiler.prototype.alterView = buildView('alter');

SchemaCompiler.prototype.pushQuery = pushQuery;
SchemaCompiler.prototype.pushAdditional = pushAdditional;
SchemaCompiler.prototype.unshiftQuery = unshiftQuery;

function build(builder) {
  // pass queryContext down to tableBuilder but do not overwrite it if already set
  const queryContext = this.builder.queryContext();
  if (queryContext !== undefined && builder.queryContext() === undefined) {
    builder.queryContext(queryContext);
  }

  builder.setSchema(this.schema);
  const sql = builder.toSQL();

  for (let i = 0, l = sql.length; i < l; i++) {
    this.sequence.push(sql[i]);
  }
}

function buildTable(type) {
  if (type === 'createLike') {
    return function (tableName, tableNameLike, fn) {
      const builder = this.client.tableBuilder(
        type,
        tableName,
        tableNameLike,
        fn
      );
      build.call(this, builder);
    };
  } else {
    return function (tableName, fn) {
      const builder = this.client.tableBuilder(type, tableName, null, fn);
      build.call(this, builder);
    };
  }
}

function buildView(type) {
  return function (viewName, fn) {
    const builder = this.client.viewBuilder(type, viewName, fn);
    build.call(this, builder);
  };
}

function prefixedTableName(prefix, table) {
  return prefix ? `${prefix}.${table}` : table;
}

function throwOnlyPGError(operationName) {
  throw new Error(
    `${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`
  );
}

module.exports = SchemaCompiler;


/***/ }),

/***/ "./node_modules/knex/lib/schema/internal/helpers.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const tail = __webpack_require__("./node_modules/lodash/tail.js");
const { isString } = __webpack_require__("./node_modules/knex/lib/util/is.js");

// Push a new query onto the compiled "sequence" stack,
// creating a new formatter, returning the compiler.
function pushQuery(query) {
  if (!query) return;
  if (isString(query)) {
    query = { sql: query };
  }
  if (!query.bindings) {
    query.bindings = this.bindingsHolder.bindings;
  }
  this.sequence.push(query);

  this.formatter = this.client.formatter(this._commonBuilder);
  this.bindings = [];
  this.formatter.bindings = this.bindings;
}

// Used in cases where we need to push some additional column specific statements.
function pushAdditional(fn) {
  const child = new this.constructor(
    this.client,
    this.tableCompiler,
    this.columnBuilder
  );
  fn.call(child, tail(arguments));
  this.sequence.additional = (this.sequence.additional || []).concat(
    child.sequence
  );
}

// Unshift a new query onto the compiled "sequence" stack,
// creating a new formatter, returning the compiler.
function unshiftQuery(query) {
  if (!query) return;
  if (isString(query)) {
    query = { sql: query };
  }
  if (!query.bindings) {
    query.bindings = this.bindingsHolder.bindings;
  }
  this.sequence.unshift(query);

  this.formatter = this.client.formatter(this._commonBuilder);
  this.bindings = [];
  this.formatter.bindings = this.bindings;
}

module.exports = {
  pushAdditional,
  pushQuery,
  unshiftQuery,
};


/***/ }),

/***/ "./node_modules/knex/lib/schema/tablebuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TableBuilder

// Takes the function passed to the "createTable" or "table/editTable"
// functions and calls it with the "TableBuilder" as both the context and
// the first argument. Inside this function we can specify what happens to the
// method, pushing everything we want to do onto the "allStatements" array,
// which is then compiled into sql.
// ------
const each = __webpack_require__("./node_modules/lodash/each.js");
const extend = __webpack_require__("./node_modules/lodash/extend.js");
const assign = __webpack_require__("./node_modules/lodash/assign.js");
const toArray = __webpack_require__("./node_modules/lodash/toArray.js");
const helpers = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const { isString, isFunction, isObject } = __webpack_require__("./node_modules/knex/lib/util/is.js");

class TableBuilder {
  constructor(client, method, tableName, tableNameLike, fn) {
    this.client = client;
    this._fn = fn;
    this._method = method;
    this._schemaName = undefined;
    this._tableName = tableName;
    this._tableNameLike = tableNameLike;
    this._statements = [];
    this._single = {};

    if (!tableNameLike && !isFunction(this._fn)) {
      throw new TypeError(
        'A callback function must be supplied to calls against `.createTable` ' +
          'and `.table`'
      );
    }
  }

  setSchema(schemaName) {
    this._schemaName = schemaName;
  }

  // Convert the current tableBuilder object "toSQL"
  // giving us additional methods if we're altering
  // rather than creating the table.
  toSQL() {
    if (this._method === 'alter') {
      extend(this, AlterMethods);
    }
    // With 'create table ... like' callback function is useless.
    if (this._fn) {
      this._fn.call(this, this);
    }
    return this.client.tableCompiler(this).toSQL();
  }

  // The "timestamps" call is really just sets the `created_at` and `updated_at` columns.

  timestamps(useTimestamps, defaultToNow, useCamelCase) {
    if (isObject(useTimestamps)) {
      ({ useTimestamps, defaultToNow, useCamelCase } = useTimestamps);
    }
    const method = useTimestamps === true ? 'timestamp' : 'datetime';
    const createdAt = this[method](useCamelCase ? 'createdAt' : 'created_at');
    const updatedAt = this[method](useCamelCase ? 'updatedAt' : 'updated_at');

    if (defaultToNow === true) {
      const now = this.client.raw('CURRENT_TIMESTAMP');
      createdAt.notNullable().defaultTo(now);
      updatedAt.notNullable().defaultTo(now);
    }
  }

  // Set the comment value for a table, they're only allowed to be called
  // once per table.
  comment(value) {
    if (typeof value !== 'string') {
      throw new TypeError('Table comment must be string');
    }
    this._single.comment = value;
  }

  // Set a foreign key on the table, calling
  // `table.foreign('column_name').references('column').on('table').onDelete()...
  // Also called from the ColumnBuilder context when chaining.
  foreign(column, keyName) {
    const foreignData = { column: column, keyName: keyName };
    this._statements.push({
      grouping: 'alterTable',
      method: 'foreign',
      args: [foreignData],
    });
    let returnObj = {
      references(tableColumn) {
        let pieces;
        if (isString(tableColumn)) {
          pieces = tableColumn.split('.');
        }
        if (!pieces || pieces.length === 1) {
          foreignData.references = pieces ? pieces[0] : tableColumn;
          return {
            on(tableName) {
              if (typeof tableName !== 'string') {
                throw new TypeError(
                  `Expected tableName to be a string, got: ${typeof tableName}`
                );
              }
              foreignData.inTable = tableName;
              return returnObj;
            },
            inTable() {
              return this.on.apply(this, arguments);
            },
          };
        }
        foreignData.inTable = pieces[0];
        foreignData.references = pieces[1];
        return returnObj;
      },
      withKeyName(keyName) {
        foreignData.keyName = keyName;
        return returnObj;
      },
      onUpdate(statement) {
        foreignData.onUpdate = statement;
        return returnObj;
      },
      onDelete(statement) {
        foreignData.onDelete = statement;
        return returnObj;
      },
      deferrable: (type) => {
        const unSupported = [
          'mysql',
          'mssql',
          'redshift',
          'mysql2',
          'oracledb',
        ];
        if (unSupported.indexOf(this.client.dialect) !== -1) {
          throw new Error(`${this.client.dialect} does not support deferrable`);
        }
        foreignData.deferrable = type;
        return returnObj;
      },
      _columnBuilder(builder) {
        extend(builder, returnObj);
        returnObj = builder;
        return builder;
      },
    };
    return returnObj;
  }

  check(checkPredicate, bindings, constraintName) {
    this._statements.push({
      grouping: 'checks',
      args: [checkPredicate, bindings, constraintName],
    });
    return this;
  }
}

[
  // Each of the index methods can be called individually, with the
  // column name to be used, e.g. table.unique('column').
  'index',
  'primary',
  'unique',

  // Key specific
  'dropPrimary',
  'dropUnique',
  'dropIndex',
  'dropForeign',
].forEach((method) => {
  TableBuilder.prototype[method] = function () {
    this._statements.push({
      grouping: 'alterTable',
      method,
      args: toArray(arguments),
    });
    return this;
  };
});

// Warn for dialect-specific table methods, since that's the
// only time these are supported.
const specialMethods = {
  mysql: ['engine', 'charset', 'collate'],
  postgresql: ['inherits'],
};
each(specialMethods, function (methods, dialect) {
  methods.forEach(function (method) {
    TableBuilder.prototype[method] = function (value) {
      if (this.client.dialect !== dialect) {
        throw new Error(
          `Knex only supports ${method} statement with ${dialect}.`
        );
      }
      if (this._method === 'alter') {
        throw new Error(
          `Knex does not support altering the ${method} outside of create ` +
            `table, please use knex.raw statement.`
        );
      }
      this._single[method] = value;
    };
  });
});

helpers.addQueryContext(TableBuilder);

// Each of the column types that we can add, we create a new ColumnBuilder
// instance and push it onto the statements array.
const columnTypes = [
  // Numeric
  'tinyint',
  'smallint',
  'mediumint',
  'int',
  'bigint',
  'decimal',
  'float',
  'double',
  'real',
  'bit',
  'boolean',
  'serial',

  // Date / Time
  'date',
  'datetime',
  'timestamp',
  'time',
  'year',

  // Geometry
  'geometry',
  'geography',
  'point',

  // String
  'char',
  'varchar',
  'tinytext',
  'tinyText',
  'text',
  'mediumtext',
  'mediumText',
  'longtext',
  'longText',
  'binary',
  'varbinary',
  'tinyblob',
  'tinyBlob',
  'mediumblob',
  'mediumBlob',
  'blob',
  'longblob',
  'longBlob',
  'enum',
  'set',

  // Increments, Aliases, and Additional
  'bool',
  'dateTime',
  'increments',
  'bigincrements',
  'bigIncrements',
  'integer',
  'biginteger',
  'bigInteger',
  'string',
  'json',
  'jsonb',
  'uuid',
  'enu',
  'specificType',
];

// For each of the column methods, create a new "ColumnBuilder" interface,
// push it onto the "allStatements" stack, and then return the interface,
// with which we can add indexes, etc.
columnTypes.forEach((type) => {
  TableBuilder.prototype[type] = function () {
    const args = toArray(arguments);
    const builder = this.client.columnBuilder(this, type, args);
    this._statements.push({
      grouping: 'columns',
      builder,
    });
    return builder;
  };
});

const AlterMethods = {
  // Renames the current column `from` the current
  // TODO: this.column(from).rename(to)
  renameColumn(from, to) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'renameColumn',
      args: [from, to],
    });
    return this;
  },

  dropTimestamps() {
    // arguments[0] = useCamelCase
    return this.dropColumns(
      arguments[0] === true
        ? ['createdAt', 'updatedAt']
        : ['created_at', 'updated_at']
    );
  },

  setNullable(column) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'setNullable',
      args: [column],
    });

    return this;
  },

  check(checkPredicate, bindings, constraintName) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'check',
      args: [checkPredicate, bindings, constraintName],
    });
  },

  dropChecks() {
    this._statements.push({
      grouping: 'alterTable',
      method: 'dropChecks',
      args: toArray(arguments),
    });
  },

  dropNullable(column) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'dropNullable',
      args: [column],
    });

    return this;
  },

  // TODO: changeType
};

// Drop a column from the current table.
// TODO: Enable this.column(columnName).drop();
AlterMethods.dropColumn = AlterMethods.dropColumns = function () {
  this._statements.push({
    grouping: 'alterTable',
    method: 'dropColumn',
    args: toArray(arguments),
  });
  return this;
};

TableBuilder.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(TableBuilder.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend TableBuilder with existing method ('${methodName}').`
    );
  }

  assign(TableBuilder.prototype, { [methodName]: fn });
};

module.exports = TableBuilder;


/***/ }),

/***/ "./node_modules/knex/lib/schema/tablecompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint max-len:0 */

// Table Compiler
// -------
const {
  pushAdditional,
  pushQuery,
  unshiftQuery,
} = __webpack_require__("./node_modules/knex/lib/schema/internal/helpers.js");
const helpers = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const groupBy = __webpack_require__("./node_modules/lodash/groupBy.js");
const indexOf = __webpack_require__("./node_modules/lodash/indexOf.js");
const isEmpty = __webpack_require__("./node_modules/lodash/isEmpty.js");
const tail = __webpack_require__("./node_modules/lodash/tail.js");
const { normalizeArr } = __webpack_require__("./node_modules/knex/lib/util/helpers.js");

class TableCompiler {
  constructor(client, tableBuilder) {
    this.client = client;
    this.tableBuilder = tableBuilder;
    this._commonBuilder = this.tableBuilder;
    this.method = tableBuilder._method;
    this.schemaNameRaw = tableBuilder._schemaName;
    this.tableNameRaw = tableBuilder._tableName;
    this.tableNameLikeRaw = tableBuilder._tableNameLike;
    this.single = tableBuilder._single;
    this.grouped = groupBy(tableBuilder._statements, 'grouping');

    this.formatter = client.formatter(tableBuilder);
    this.bindings = [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;

    this.sequence = [];
    this._formatting = client.config && client.config.formatting;

    this.checksCount = 0;
  }

  // Convert the tableCompiler toSQL
  toSQL() {
    this[this.method]();
    return this.sequence;
  }

  // Column Compilation
  // -------

  // If this is a table "creation", we need to first run through all
  // of the columns to build them into a single string,
  // and then run through anything else and push it to the query sequence.
  create(ifNot, like) {
    const columnBuilders = this.getColumns();
    const columns = columnBuilders.map((col) => col.toSQL());
    const columnTypes = this.getColumnTypes(columns);
    if (this.createAlterTableMethods) {
      this.alterTableForCreate(columnTypes);
    }
    this.createQuery(columnTypes, ifNot, like);
    this.columnQueries(columns);
    delete this.single.comment;
    this.alterTable();
  }

  // Only create the table if it doesn't exist.
  createIfNot() {
    this.create(true);
  }

  createLike() {
    this.create(false, true);
  }

  createLikeIfNot() {
    this.create(true, true);
  }

  // If we're altering the table, we need to one-by-one
  // go through and handle each of the queries associated
  // with altering the table's schema.
  alter() {
    const addColBuilders = this.getColumns();
    const addColumns = addColBuilders.map((col) => col.toSQL());
    const alterColBuilders = this.getColumns('alter');
    const alterColumns = alterColBuilders.map((col) => col.toSQL());
    const addColumnTypes = this.getColumnTypes(addColumns);
    const alterColumnTypes = this.getColumnTypes(alterColumns);

    this.addColumns(addColumnTypes);
    this.alterColumns(alterColumnTypes, alterColBuilders);
    this.columnQueries(addColumns);
    this.columnQueries(alterColumns);
    this.alterTable();
  }

  foreign(foreignData) {
    if (foreignData.inTable && foreignData.references) {
      const keyName = foreignData.keyName
        ? this.formatter.wrap(foreignData.keyName)
        : this._indexCommand('foreign', this.tableNameRaw, foreignData.column);
      const column = this.formatter.columnize(foreignData.column);
      const references = this.formatter.columnize(foreignData.references);
      const inTable = this.formatter.wrap(foreignData.inTable);
      const onUpdate = foreignData.onUpdate
        ? (this.lowerCase ? ' on update ' : ' ON UPDATE ') +
          foreignData.onUpdate
        : '';
      const onDelete = foreignData.onDelete
        ? (this.lowerCase ? ' on delete ' : ' ON DELETE ') +
          foreignData.onDelete
        : '';
      const deferrable = foreignData.deferrable
        ? this.lowerCase
          ? ` deferrable initially ${foreignData.deferrable.toLowerCase()} `
          : ` DEFERRABLE INITIALLY ${foreignData.deferrable.toUpperCase()} `
        : '';
      if (this.lowerCase) {
        this.pushQuery(
          (!this.forCreate ? `alter table ${this.tableName()} add ` : '') +
            'constraint ' +
            keyName +
            ' ' +
            'foreign key (' +
            column +
            ') references ' +
            inTable +
            ' (' +
            references +
            ')' +
            onUpdate +
            onDelete +
            deferrable
        );
      } else {
        this.pushQuery(
          (!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : '') +
            'CONSTRAINT ' +
            keyName +
            ' ' +
            'FOREIGN KEY (' +
            column +
            ') REFERENCES ' +
            inTable +
            ' (' +
            references +
            ')' +
            onUpdate +
            onDelete +
            deferrable
        );
      }
    }
  }

  // Get all of the column sql & bindings individually for building the table queries.
  getColumnTypes(columns) {
    return columns.reduce(
      function (memo, columnSQL) {
        const column = columnSQL[0];
        memo.sql.push(column.sql);
        memo.bindings.concat(column.bindings);
        return memo;
      },
      { sql: [], bindings: [] }
    );
  }

  // Adds all of the additional queries from the "column"
  columnQueries(columns) {
    const queries = columns.reduce(function (memo, columnSQL) {
      const column = tail(columnSQL);
      if (!isEmpty(column)) return memo.concat(column);
      return memo;
    }, []);
    for (const q of queries) {
      this.pushQuery(q);
    }
  }

  // All of the columns to "add" for the query
  addColumns(columns, prefix) {
    prefix = prefix || this.addColumnsPrefix;

    if (columns.sql.length > 0) {
      const columnSql = columns.sql.map((column) => {
        return prefix + column;
      });
      this.pushQuery({
        sql:
          (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') +
          this.tableName() +
          ' ' +
          columnSql.join(', '),
        bindings: columns.bindings,
      });
    }
  }

  alterColumns(columns, colBuilders) {
    if (columns.sql.length > 0) {
      this.addColumns(columns, this.alterColumnsPrefix, colBuilders);
    }
  }

  // Compile the columns as needed for the current create or alter table
  getColumns(method) {
    const columns = this.grouped.columns || [];
    method = method || 'add';

    const queryContext = this.tableBuilder.queryContext();

    return columns
      .filter((column) => column.builder._method === method)
      .map((column) => {
        // pass queryContext down to columnBuilder but do not overwrite it if already set
        if (
          queryContext !== undefined &&
          column.builder.queryContext() === undefined
        ) {
          column.builder.queryContext(queryContext);
        }
        return this.client.columnCompiler(this, column.builder);
      });
  }

  tableName() {
    const name = this.schemaNameRaw
      ? `${this.schemaNameRaw}.${this.tableNameRaw}`
      : this.tableNameRaw;

    return this.formatter.wrap(name);
  }

  tableNameLike() {
    const name = this.schemaNameRaw
      ? `${this.schemaNameRaw}.${this.tableNameLikeRaw}`
      : this.tableNameLikeRaw;

    return this.formatter.wrap(name);
  }

  // Generate all of the alter column statements necessary for the query.
  alterTable() {
    const alterTable = this.grouped.alterTable || [];
    for (let i = 0, l = alterTable.length; i < l; i++) {
      const statement = alterTable[i];
      if (this[statement.method]) {
        this[statement.method].apply(this, statement.args);
      } else {
        this.client.logger.error(`Debug: ${statement.method} does not exist`);
      }
    }
    for (const item in this.single) {
      if (typeof this[item] === 'function') this[item](this.single[item]);
    }
  }

  alterTableForCreate(columnTypes) {
    this.forCreate = true;
    const savedSequence = this.sequence;
    const alterTable = this.grouped.alterTable || [];
    this.grouped.alterTable = [];
    for (let i = 0, l = alterTable.length; i < l; i++) {
      const statement = alterTable[i];
      if (indexOf(this.createAlterTableMethods, statement.method) < 0) {
        this.grouped.alterTable.push(statement);
        continue;
      }
      if (this[statement.method]) {
        this.sequence = [];
        this[statement.method].apply(this, statement.args);
        columnTypes.sql.push(this.sequence[0].sql);
      } else {
        this.client.logger.error(`Debug: ${statement.method} does not exist`);
      }
    }
    this.sequence = savedSequence;
    this.forCreate = false;
  }

  // Drop the index on the current table.
  dropIndex(value) {
    this.pushQuery(`drop index${value}`);
  }

  dropUnique() {
    throw new Error('Method implemented in the dialect driver');
  }

  dropForeign() {
    throw new Error('Method implemented in the dialect driver');
  }

  dropColumn() {
    const columns = helpers.normalizeArr.apply(null, arguments);
    const drops = (Array.isArray(columns) ? columns : [columns]).map(
      (column) => {
        return this.dropColumnPrefix + this.formatter.wrap(column);
      }
    );
    this.pushQuery(
      (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') +
        this.tableName() +
        ' ' +
        drops.join(', ')
    );
  }

  //Default implementation of setNullable. Overwrite on dialect-specific tablecompiler when needed
  //(See postgres/mssql for reference)
  _setNullableState(column, nullable) {
    const tableName = this.tableName();
    const columnName = this.formatter.columnize(column);
    const alterColumnPrefix = this.alterColumnsPrefix;
    return this.pushQuery({
      sql: 'SELECT 1',
      output: () => {
        return this.client
          .queryBuilder()
          .from(this.tableNameRaw)
          .columnInfo(column)
          .then((columnInfo) => {
            if (isEmpty(columnInfo)) {
              throw new Error(
                `.setNullable: Column ${columnName} does not exist in table ${tableName}.`
              );
            }
            const nullableType = nullable ? 'null' : 'not null';
            const columnType =
              columnInfo.type +
              (columnInfo.maxLength ? `(${columnInfo.maxLength})` : '');
            const defaultValue =
              columnInfo.defaultValue !== null &&
              columnInfo.defaultValue !== void 0
                ? `default '${columnInfo.defaultValue}'`
                : '';
            const sql = `alter table ${tableName} ${alterColumnPrefix} ${columnName} ${columnType} ${nullableType} ${defaultValue}`;
            return this.client.raw(sql);
          });
      },
    });
  }

  setNullable(column) {
    return this._setNullableState(column, true);
  }

  dropNullable(column) {
    return this._setNullableState(column, false);
  }

  dropChecks(checkConstraintNames) {
    if (checkConstraintNames === undefined) return '';
    checkConstraintNames = normalizeArr(checkConstraintNames);
    const tableName = this.tableName();
    const sql = `alter table ${tableName} ${checkConstraintNames
      .map((constraint) => `drop constraint ${constraint}`)
      .join(', ')}`;
    this.pushQuery(sql);
  }

  check(checkPredicate, bindings, constraintName) {
    const tableName = this.tableName();
    let checkConstraint = constraintName;
    if (!checkConstraint) {
      this.checksCount++;
      checkConstraint = tableName + '_' + this.checksCount;
    }
    const sql = `alter table ${tableName} add constraint ${checkConstraint} check(${checkPredicate})`;
    this.pushQuery(sql);
  }

  _addChecks() {
    if (this.grouped.checks) {
      return (
        ', ' +
        this.grouped.checks
          .map((c) => {
            return `${
              c.args[2] ? 'constraint ' + c.args[2] + ' ' : ''
            }check (${this.client.raw(c.args[0], c.args[1])})`;
          })
          .join(', ')
      );
    }
    return '';
  }

  // If no name was specified for this index, we will create one using a basic
  // convention of the table name, followed by the columns, followed by an
  // index type, such as primary or index, which makes the index unique.
  _indexCommand(type, tableName, columns) {
    if (!Array.isArray(columns)) columns = columns ? [columns] : [];
    const table = tableName.replace(/\.|-/g, '_');
    const indexName = (
      table +
      '_' +
      columns.join('_') +
      '_' +
      type
    ).toLowerCase();
    return this.formatter.wrap(indexName);
  }

  _getPrimaryKeys() {
    return (this.grouped.alterTable || [])
      .filter((a) => a.method === 'primary')
      .flatMap((a) => a.args)
      .flat();
  }

  _canBeAddPrimaryKey(options) {
    return options.primaryKey && this._getPrimaryKeys().length === 0;
  }

  _getIncrementsColumnNames() {
    return this.grouped.columns
      .filter((c) => c.builder._type === 'increments')
      .map((c) => c.builder._args[0]);
  }

  _getBigIncrementsColumnNames() {
    return this.grouped.columns
      .filter((c) => c.builder._type === 'bigincrements')
      .map((c) => c.builder._args[0]);
  }
}

TableCompiler.prototype.pushQuery = pushQuery;
TableCompiler.prototype.pushAdditional = pushAdditional;
TableCompiler.prototype.unshiftQuery = unshiftQuery;
TableCompiler.prototype.lowerCase = true;
TableCompiler.prototype.createAlterTableMethods = null;
TableCompiler.prototype.addColumnsPrefix = 'add column ';
TableCompiler.prototype.alterColumnsPrefix = 'alter column ';
TableCompiler.prototype.modifyColumnPrefix = 'modify column ';
TableCompiler.prototype.dropColumnPrefix = 'drop column ';

module.exports = TableCompiler;


/***/ }),

/***/ "./node_modules/knex/lib/schema/viewbuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const helpers = __webpack_require__("./node_modules/knex/lib/util/helpers.js");
const extend = __webpack_require__("./node_modules/lodash/extend.js");
const assign = __webpack_require__("./node_modules/lodash/assign.js");

class ViewBuilder {
  constructor(client, method, viewName, fn) {
    this.client = client;
    this._method = method;
    this._schemaName = undefined;
    this._columns = undefined;
    this._fn = fn;
    this._viewName = viewName;
    this._statements = [];
    this._single = {};
  }

  setSchema(schemaName) {
    this._schemaName = schemaName;
  }

  columns(columns) {
    this._columns = columns;
  }

  as(selectQuery) {
    this._selectQuery = selectQuery;
  }

  checkOption() {
    throw new Error(
      'check option definition is not supported by this dialect.'
    );
  }

  localCheckOption() {
    throw new Error(
      'check option definition is not supported by this dialect.'
    );
  }

  cascadedCheckOption() {
    throw new Error(
      'check option definition is not supported by this dialect.'
    );
  }

  toSQL() {
    if (this._method === 'alter') {
      extend(this, AlterMethods);
    }
    this._fn.call(this, this);
    return this.client.viewCompiler(this).toSQL();
  }
}

const AlterMethods = {
  column(column) {
    const self = this;
    return {
      rename: function (newName) {
        self._statements.push({
          grouping: 'alterView',
          method: 'renameColumn',
          args: [column, newName],
        });
        return this;
      },
      defaultTo: function (defaultValue) {
        self._statements.push({
          grouping: 'alterView',
          method: 'defaultTo',
          args: [column, defaultValue],
        });
        return this;
      },
    };
  },
};

helpers.addQueryContext(ViewBuilder);

ViewBuilder.extend = (methodName, fn) => {
  if (Object.prototype.hasOwnProperty.call(ViewBuilder.prototype, methodName)) {
    throw new Error(
      `Can't extend ViewBuilder with existing method ('${methodName}').`
    );
  }

  assign(ViewBuilder.prototype, { [methodName]: fn });
};

module.exports = ViewBuilder;


/***/ }),

/***/ "./node_modules/knex/lib/schema/viewcompiler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint max-len:0 */

// View Compiler
// -------
const { pushQuery } = __webpack_require__("./node_modules/knex/lib/schema/internal/helpers.js");
const groupBy = __webpack_require__("./node_modules/lodash/groupBy.js");
const { columnize: columnize_ } = __webpack_require__("./node_modules/knex/lib/formatter/wrappingFormatter.js");

class ViewCompiler {
  constructor(client, viewBuilder) {
    this.client = client;
    this.viewBuilder = viewBuilder;
    this._commonBuilder = this.viewBuilder;
    this.method = viewBuilder._method;
    this.schemaNameRaw = viewBuilder._schemaName;
    this.viewNameRaw = viewBuilder._viewName;
    this.single = viewBuilder._single;
    this.selectQuery = viewBuilder._selectQuery;
    this.columns = viewBuilder._columns;
    this.grouped = groupBy(viewBuilder._statements, 'grouping');

    this.formatter = client.formatter(viewBuilder);
    this.bindings = [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;

    this.sequence = [];
  }

  // Convert the tableCompiler toSQL
  toSQL() {
    this[this.method]();
    return this.sequence;
  }

  // Column Compilation
  // -------

  create() {
    this.createQuery(this.columns, this.selectQuery);
  }

  createOrReplace() {
    throw new Error('replace views is not supported by this dialect.');
  }

  createMaterializedView() {
    throw new Error('materialized views are not supported by this dialect.');
  }

  createQuery(columns, selectQuery, materialized, replace) {
    const createStatement =
      'create ' +
      (materialized ? 'materialized ' : '') +
      (replace ? 'or replace ' : '') +
      'view ';
    const columnList = columns
      ? ' (' +
        columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) +
        ')'
      : '';
    let sql = createStatement + this.viewName() + columnList;
    sql += ' as ';
    sql += selectQuery.toString();
    switch (this.single.checkOption) {
      case 'default_option':
        sql += ' with check option';
        break;
      case 'local':
        sql += ' with local check option';
        break;
      case 'cascaded':
        sql += ' with cascaded check option';
        break;
      default:
        break;
    }
    this.pushQuery({
      sql,
    });
  }

  renameView(from, to) {
    throw new Error(
      'rename view is not supported by this dialect (instead drop, then create another view).'
    );
  }

  refreshMaterializedView() {
    throw new Error('materialized views are not supported by this dialect.');
  }

  alter() {
    this.alterView();
  }

  alterView() {
    const alterView = this.grouped.alterView || [];
    for (let i = 0, l = alterView.length; i < l; i++) {
      const statement = alterView[i];
      if (this[statement.method]) {
        this[statement.method].apply(this, statement.args);
      } else {
        this.client.logger.error(`Debug: ${statement.method} does not exist`);
      }
    }
    for (const item in this.single) {
      if (typeof this[item] === 'function') this[item](this.single[item]);
    }
  }

  renameColumn(from, to) {
    throw new Error('rename column of views is not supported by this dialect.');
  }

  defaultTo(column, defaultValue) {
    throw new Error(
      'change default values of views is not supported by this dialect.'
    );
  }

  viewName() {
    const name = this.schemaNameRaw
      ? `${this.schemaNameRaw}.${this.viewNameRaw}`
      : this.viewNameRaw;

    return this.formatter.wrap(name);
  }
}

ViewCompiler.prototype.pushQuery = pushQuery;

module.exports = ViewCompiler;


/***/ }),

/***/ "./node_modules/knex/lib/util/finally-mixin.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const noop = __webpack_require__("./node_modules/knex/lib/util/noop.js");

const finallyMixin = (prototype) =>
  Object.assign(prototype, {
    finally(onFinally) {
      return this.then().finally(onFinally);
    },
  });

// FYI: Support for `Promise.prototype.finally` was not introduced until Node 9.
//      Therefore, Knex will need to conditionally inject support for `.finally(..)`
//      until support for Node 8 is officially dropped.
module.exports = Promise.prototype.finally ? finallyMixin : noop;


/***/ }),

/***/ "./node_modules/knex/lib/util/helpers.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isPlainObject = __webpack_require__("./node_modules/lodash/isPlainObject.js");
const isTypedArray = __webpack_require__("./node_modules/lodash/isTypedArray.js");
const { CLIENT_ALIASES } = __webpack_require__("./node_modules/knex/lib/constants.js");
const { isFunction } = __webpack_require__("./node_modules/knex/lib/util/is.js");

// Check if the first argument is an array, otherwise uses all arguments as an
// array.
function normalizeArr(...args) {
  if (Array.isArray(args[0])) {
    return args[0];
  }

  return args;
}

function containsUndefined(mixed) {
  let argContainsUndefined = false;

  if (isTypedArray(mixed)) return false;

  if (mixed && isFunction(mixed.toSQL)) {
    //Any QueryBuilder or Raw will automatically be validated during compile.
    return argContainsUndefined;
  }

  if (Array.isArray(mixed)) {
    for (let i = 0; i < mixed.length; i++) {
      if (argContainsUndefined) break;
      argContainsUndefined = containsUndefined(mixed[i]);
    }
  } else if (isPlainObject(mixed)) {
    Object.keys(mixed).forEach((key) => {
      if (!argContainsUndefined) {
        argContainsUndefined = containsUndefined(mixed[key]);
      }
    });
  } else {
    argContainsUndefined = mixed === undefined;
  }

  return argContainsUndefined;
}

function getUndefinedIndices(mixed) {
  const indices = [];

  if (Array.isArray(mixed)) {
    mixed.forEach((item, index) => {
      if (containsUndefined(item)) {
        indices.push(index);
      }
    });
  } else if (isPlainObject(mixed)) {
    Object.keys(mixed).forEach((key) => {
      if (containsUndefined(mixed[key])) {
        indices.push(key);
      }
    });
  } else {
    indices.push(0);
  }

  return indices;
}

function addQueryContext(Target) {
  // Stores or returns (if called with no arguments) context passed to
  // wrapIdentifier and postProcessResponse hooks
  Target.prototype.queryContext = function (context) {
    if (context === undefined) {
      return this._queryContext;
    }
    this._queryContext = context;
    return this;
  };
}

function resolveClientNameWithAliases(clientName) {
  return CLIENT_ALIASES[clientName] || clientName;
}

function toNumber(val, fallback) {
  if (val === undefined || val === null) return fallback;
  const number = parseInt(val, 10);
  return isNaN(number) ? fallback : number;
}

module.exports = {
  addQueryContext,
  containsUndefined,
  getUndefinedIndices,
  normalizeArr,
  resolveClientNameWithAliases,
  toNumber,
};


/***/ }),

/***/ "./node_modules/knex/lib/util/is.js":
/***/ ((module) => {

function isString(value) {
  return typeof value === 'string';
}

function isNumber(value) {
  return typeof value === 'number';
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function isUndefined(value) {
  return typeof value === 'undefined';
}

function isObject(value) {
  return typeof value === 'object' && value !== null;
}

function isFunction(value) {
  return typeof value === 'function';
}

module.exports = {
  isString,
  isNumber,
  isBoolean,
  isUndefined,
  isObject,
  isFunction,
};


/***/ }),

/***/ "./node_modules/knex/lib/util/nanoid.js":
/***/ ((module) => {

// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
// optimize the gzip compression for this alphabet.
const urlAlphabet =
  'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';

const numberAlphabet = '0123456789';

/**
 * Generate URL-friendly unique ID. This method uses the non-secure
 * predictable random generator with bigger collision probability.
 * Based on https://github.com/ai/nanoid
 *
 * ```js
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 * ```
 *
 * @param size Size of the ID. The default size is 21.
 * @returns A random string.
 */
function nanoid(size = 21) {
  let id = '';
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size;
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[(Math.random() * 64) | 0];
  }
  return id;
}

function nanonum(size = 21) {
  let id = '';
  let i = size;
  while (i--) {
    id += numberAlphabet[(Math.random() * 10) | 0];
  }
  return id;
}

module.exports = { nanoid, nanonum };


/***/ }),

/***/ "./node_modules/knex/lib/util/noop.js":
/***/ ((module) => {

module.exports = function () {};


/***/ }),

/***/ "./node_modules/knex/lib/util/save-async-stack.js":
/***/ ((module) => {

module.exports = function saveAsyncStack(instance, lines) {
  if (instance.client.config.asyncStackTraces) {
    // a hack to get a callstack into the client code despite this
    // node.js bug https://github.com/nodejs/node/issues/11865

    // Save error here but not error trace
    // reading trace with '--enable-source-maps' flag on node can be very costly

    instance._asyncStack = {
      error: new Error(),
      lines,
    };
  }
};


/***/ }),

/***/ "./node_modules/knex/lib/util/security.js":
/***/ ((module) => {

/**
 * Sets a hidden (non-enumerable) property on the `target` object, copying it
 * from `source`.
 *
 * This is useful when we want to protect certain data from being accidentally
 * leaked through logs, also when the property is non-enumerable on the `source`
 * object and we want to ensure that it is properly copied.
 *
 * @param {object} target
 * @param {object} source - default: target
 * @param {string} propertyName - default: 'password'
 */
function setHiddenProperty(target, source, propertyName = 'password') {
  if (!source) {
    source = target;
  }

  Object.defineProperty(target, propertyName, {
    enumerable: false,
    value: source[propertyName],
  });
}

module.exports = {
  setHiddenProperty,
};


/***/ }),

/***/ "./node_modules/knex/lib/util/string.js":
/***/ ((module) => {

/*eslint max-len: 0, no-var:0 */

const charsRegex = /[\0\b\t\n\r\x1a"'\\]/g; // eslint-disable-line no-control-regex
const charsMap = {
  '\0': '\\0',
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\r': '\\r',
  '\x1a': '\\Z',
  '"': '\\"',
  "'": "\\'",
  '\\': '\\\\',
};

function wrapEscape(escapeFn) {
  return function finalEscape(val, ctx = {}) {
    return escapeFn(val, finalEscape, ctx);
  };
}

function makeEscape(config = {}) {
  const finalEscapeDate = config.escapeDate || dateToString;
  const finalEscapeArray = config.escapeArray || arrayToList;
  const finalEscapeBuffer = config.escapeBuffer || bufferToString;
  const finalEscapeString = config.escapeString || escapeString;
  const finalEscapeObject = config.escapeObject || escapeObject;
  const finalWrap = config.wrap || wrapEscape;

  function escapeFn(val, finalEscape, ctx) {
    if (val === undefined || val === null) {
      return 'NULL';
    }
    switch (typeof val) {
      case 'boolean':
        return val ? 'true' : 'false';
      case 'number':
        return val + '';
      case 'object':
        if (val instanceof Date) {
          val = finalEscapeDate(val, finalEscape, ctx);
        } else if (Array.isArray(val)) {
          return finalEscapeArray(val, finalEscape, ctx);
        } else if (Buffer.isBuffer(val)) {
          return finalEscapeBuffer(val, finalEscape, ctx);
        } else {
          return finalEscapeObject(val, finalEscape, ctx);
        }
    }
    return finalEscapeString(val, finalEscape, ctx);
  }

  return finalWrap ? finalWrap(escapeFn) : escapeFn;
}

function escapeObject(val, finalEscape, ctx) {
  if (val && typeof val.toSQL === 'function') {
    return val.toSQL(ctx);
  } else {
    return JSON.stringify(val);
  }
}

function arrayToList(array, finalEscape, ctx) {
  let sql = '';
  for (let i = 0; i < array.length; i++) {
    const val = array[i];
    if (Array.isArray(val)) {
      sql +=
        (i === 0 ? '' : ', ') + '(' + arrayToList(val, finalEscape, ctx) + ')';
    } else {
      sql += (i === 0 ? '' : ', ') + finalEscape(val, ctx);
    }
  }
  return sql;
}

function bufferToString(buffer) {
  return 'X' + escapeString(buffer.toString('hex'));
}

function escapeString(val, finalEscape, ctx) {
  let chunkIndex = (charsRegex.lastIndex = 0);
  let escapedVal = '';
  let match;

  while ((match = charsRegex.exec(val))) {
    escapedVal += val.slice(chunkIndex, match.index) + charsMap[match[0]];
    chunkIndex = charsRegex.lastIndex;
  }

  if (chunkIndex === 0) {
    // Nothing was escaped
    return "'" + val + "'";
  }

  if (chunkIndex < val.length) {
    return "'" + escapedVal + val.slice(chunkIndex) + "'";
  }

  return "'" + escapedVal + "'";
}

function dateToString(date, finalEscape, ctx = {}) {
  const timeZone = ctx.timeZone || 'local';

  const dt = new Date(date);
  let year;
  let month;
  let day;
  let hour;
  let minute;
  let second;
  let millisecond;

  if (timeZone === 'local') {
    year = dt.getFullYear();
    month = dt.getMonth() + 1;
    day = dt.getDate();
    hour = dt.getHours();
    minute = dt.getMinutes();
    second = dt.getSeconds();
    millisecond = dt.getMilliseconds();
  } else {
    const tz = convertTimezone(timeZone);

    if (tz !== false && tz !== 0) {
      dt.setTime(dt.getTime() + tz * 60000);
    }

    year = dt.getUTCFullYear();
    month = dt.getUTCMonth() + 1;
    day = dt.getUTCDate();
    hour = dt.getUTCHours();
    minute = dt.getUTCMinutes();
    second = dt.getUTCSeconds();
    millisecond = dt.getUTCMilliseconds();
  }

  // YYYY-MM-DD HH:mm:ss.mmm
  return (
    zeroPad(year, 4) +
    '-' +
    zeroPad(month, 2) +
    '-' +
    zeroPad(day, 2) +
    ' ' +
    zeroPad(hour, 2) +
    ':' +
    zeroPad(minute, 2) +
    ':' +
    zeroPad(second, 2) +
    '.' +
    zeroPad(millisecond, 3)
  );
}

function zeroPad(number, length) {
  number = number.toString();
  while (number.length < length) {
    number = '0' + number;
  }
  return number;
}

function convertTimezone(tz) {
  if (tz === 'Z') {
    return 0;
  }
  const m = tz.match(/([+\-\s])(\d\d):?(\d\d)?/);
  if (m) {
    return (
      (m[1] == '-' ? -1 : 1) *
      (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) *
      60
    );
  }
  return false;
}

module.exports = {
  arrayToList,
  bufferToString,
  dateToString,
  escapeString,
  charsRegex,
  charsMap,
  escapeObject,
  makeEscape,
};


/***/ }),

/***/ "./node_modules/knex/lib/util/timeout.js":
/***/ ((module) => {

class KnexTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'KnexTimeoutError';
  }
}

function timeout(promise, ms) {
  return new Promise(function (resolve, reject) {
    const id = setTimeout(function () {
      reject(new KnexTimeoutError('operation timed out'));
    }, ms);

    function wrappedResolve(value) {
      clearTimeout(id);
      resolve(value);
    }

    function wrappedReject(err) {
      clearTimeout(id);
      reject(err);
    }

    promise.then(wrappedResolve, wrappedReject);
  });
}

module.exports.KnexTimeoutError = KnexTimeoutError;
module.exports.timeout = timeout;


/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js"),
    root = __webpack_require__("./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__("./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__("./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__("./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__("./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__("./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__("./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__("./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__("./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__("./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__("./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js"),
    root = __webpack_require__("./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__("./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__("./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__("./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__("./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__("./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js"),
    root = __webpack_require__("./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js"),
    root = __webpack_require__("./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__("./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__("./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__("./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__("./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__("./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__("./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__("./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__("./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__("./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__("./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__("./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js"),
    root = __webpack_require__("./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayAggregator.js":
/***/ ((module) => {

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

module.exports = arrayAggregator;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__("./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__("./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__("./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__("./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__("./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_asciiToArray.js":
/***/ ((module) => {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__("./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__("./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__("./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__("./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__("./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAggregator.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__("./node_modules/lodash/_baseEach.js");

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__("./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__("./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__("./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__("./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__("./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__("./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__("./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__("./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__("./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__("./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__("./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__("./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__("./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__("./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__("./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__("./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__("./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__("./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__("./node_modules/lodash/isSet.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__("./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseDelay.js":
/***/ ((module) => {

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * The base implementation of `_.delay` and `_.defer` which accepts `args`
 * to provide to `func`.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Array} args The arguments to provide to `func`.
 * @returns {number|Object} Returns the timer id or timeout object.
 */
function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return setTimeout(function() { func.apply(undefined, args); }, wait);
}

module.exports = baseDelay;


/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__("./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__("./node_modules/lodash/_createBaseEach.js");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__("./node_modules/lodash/_baseEach.js");

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__("./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__("./node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__("./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__("./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__("./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__("./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__("./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__("./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__("./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__("./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__("./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__("./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__("./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__("./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__("./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__("./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__("./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__("./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__("./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__("./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__("./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__("./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__("./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__("./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__("./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__("./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__("./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__("./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__("./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__("./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__("./node_modules/lodash/identity.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    property = __webpack_require__("./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__("./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__("./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__("./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__("./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__("./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js");

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__("./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__("./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__("./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__("./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__("./node_modules/lodash/get.js"),
    hasIn = __webpack_require__("./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__("./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__("./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__("./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__("./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__("./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__("./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__("./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__("./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__("./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__("./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__("./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__("./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__("./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__("./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__("./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__("./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__("./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__("./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__("./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__("./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__("./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__("./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__("./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__("./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__("./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__("./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/***/ ((module) => {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__("./node_modules/lodash/identity.js"),
    overRest = __webpack_require__("./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__("./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__("./node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__("./node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__("./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    toKey = __webpack_require__("./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__("./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__("./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__("./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseSlice.js":
/***/ ((module) => {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),

/***/ "./node_modules/lodash/_baseSome.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__("./node_modules/lodash/_baseEach.js");

/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

module.exports = baseSome;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__("./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__("./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__("./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__("./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__("./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__("./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__("./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__("./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__("./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__("./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__("./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__("./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__("./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__("./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__("./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__("./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__("./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createAggregator.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayAggregator = __webpack_require__("./node_modules/lodash/_arrayAggregator.js"),
    baseAggregator = __webpack_require__("./node_modules/lodash/_baseAggregator.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__("./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__("./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__("./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__("./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__("./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__("./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__("./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__("./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__("./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__("./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__("./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__("./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__("./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__("./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__("./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__("./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__("./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__("./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__("./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__("./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__("./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__("./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__("./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__("./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__("./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__("./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__("./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__("./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__("./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__("./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__("./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__("./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__("./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__("./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__("./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__("./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__("./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__("./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__("./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__("./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__("./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__("./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__("./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__("./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__("./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__("./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__("./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__("./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__("./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__("./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__("./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__("./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__("./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__("./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__("./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_iteratorToArray.js":
/***/ ((module) => {

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__("./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__("./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__("./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__("./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__("./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__("./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__("./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__("./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__("./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__("./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__("./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__("./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__("./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__("./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__("./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__("./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__("./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__("./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__("./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__("./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__("./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__("./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__("./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_stringToArray.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiToArray = __webpack_require__("./node_modules/lodash/_asciiToArray.js"),
    hasUnicode = __webpack_require__("./node_modules/lodash/_hasUnicode.js"),
    unicodeToArray = __webpack_require__("./node_modules/lodash/_unicodeToArray.js");

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__("./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__("./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/_unicodeToArray.js":
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),

/***/ "./node_modules/lodash/assign.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__("./node_modules/lodash/_assignValue.js"),
    copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__("./node_modules/lodash/_createAssigner.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js"),
    isPrototype = __webpack_require__("./node_modules/lodash/_isPrototype.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;


/***/ }),

/***/ "./node_modules/lodash/assignIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__("./node_modules/lodash/_createAssigner.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js");

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = createAssigner(function(object, source) {
  copyObject(source, keysIn(source), object);
});

module.exports = assignIn;


/***/ }),

/***/ "./node_modules/lodash/chunk.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSlice = __webpack_require__("./node_modules/lodash/_baseSlice.js"),
    isIterateeCall = __webpack_require__("./node_modules/lodash/_isIterateeCall.js"),
    toInteger = __webpack_require__("./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

module.exports = chunk;


/***/ }),

/***/ "./node_modules/lodash/clone.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__("./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__("./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/compact.js":
/***/ ((module) => {

/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = compact;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__("./node_modules/lodash/_baseRest.js"),
    eq = __webpack_require__("./node_modules/lodash/eq.js"),
    isIterateeCall = __webpack_require__("./node_modules/lodash/_isIterateeCall.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/lodash/defer.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseDelay = __webpack_require__("./node_modules/lodash/_baseDelay.js"),
    baseRest = __webpack_require__("./node_modules/lodash/_baseRest.js");

/**
 * Defers invoking the `func` until the current call stack has cleared. Any
 * additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to defer.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.defer(function(text) {
 *   console.log(text);
 * }, 'deferred');
 * // => Logs 'deferred' after one millisecond.
 */
var defer = baseRest(function(func, args) {
  return baseDelay(func, 1, args);
});

module.exports = defer;


/***/ }),

/***/ "./node_modules/lodash/each.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("./node_modules/lodash/forEach.js");


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/extend.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("./node_modules/lodash/assignIn.js");


/***/ }),

/***/ "./node_modules/lodash/filter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__("./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__("./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ "./node_modules/lodash/first.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("./node_modules/lodash/head.js");


/***/ }),

/***/ "./node_modules/lodash/flatten.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__("./node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__("./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__("./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__("./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__("./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/groupBy.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__("./node_modules/lodash/_baseAssignValue.js"),
    createAggregator = __webpack_require__("./node_modules/lodash/_createAggregator.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

module.exports = groupBy;


/***/ }),

/***/ "./node_modules/lodash/has.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__("./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__("./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__("./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__("./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/head.js":
/***/ ((module) => {

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

module.exports = head;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/indexOf.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__("./node_modules/lodash/_baseIndexOf.js"),
    toInteger = __webpack_require__("./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

module.exports = indexOf;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__("./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__("./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__("./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__("./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__("./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__("./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__("./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__("./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__("./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__("./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__("./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__("./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__("./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__("./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__("./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__("./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__("./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__("./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__("./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__("./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__("./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__("./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__("./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__("./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__("./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__("./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__("./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/last.js":
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "./node_modules/lodash/map.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__("./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__("./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__("./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/merge.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__("./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__("./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "./node_modules/lodash/negate.js":
/***/ ((module) => {

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

module.exports = negate;


/***/ }),

/***/ "./node_modules/lodash/omitBy.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    negate = __webpack_require__("./node_modules/lodash/negate.js"),
    pickBy = __webpack_require__("./node_modules/lodash/pickBy.js");

/**
 * The opposite of `_.pickBy`; this method creates an object composed of
 * the own and inherited enumerable string keyed properties of `object` that
 * `predicate` doesn't return truthy for. The predicate is invoked with two
 * arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 */
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}

module.exports = omitBy;


/***/ }),

/***/ "./node_modules/lodash/pickBy.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__("./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    basePickBy = __webpack_require__("./node_modules/lodash/_basePickBy.js"),
    getAllKeysIn = __webpack_require__("./node_modules/lodash/_getAllKeysIn.js");

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

module.exports = pickBy;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__("./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__("./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__("./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__("./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__("./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__("./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__("./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js");

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;


/***/ }),

/***/ "./node_modules/lodash/reject.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__("./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__("./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    negate = __webpack_require__("./node_modules/lodash/negate.js");

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, negate(baseIteratee(predicate, 3)));
}

module.exports = reject;


/***/ }),

/***/ "./node_modules/lodash/some.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySome = __webpack_require__("./node_modules/lodash/_arraySome.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    baseSome = __webpack_require__("./node_modules/lodash/_baseSome.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isIterateeCall = __webpack_require__("./node_modules/lodash/_isIterateeCall.js");

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, guard) {
  var func = isArray(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = some;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/tail.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSlice = __webpack_require__("./node_modules/lodash/_baseSlice.js");

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 1, length) : [];
}

module.exports = tail;


/***/ }),

/***/ "./node_modules/lodash/toArray.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__("./node_modules/lodash/_Symbol.js"),
    copyArray = __webpack_require__("./node_modules/lodash/_copyArray.js"),
    getTag = __webpack_require__("./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__("./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__("./node_modules/lodash/isString.js"),
    iteratorToArray = __webpack_require__("./node_modules/lodash/_iteratorToArray.js"),
    mapToArray = __webpack_require__("./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__("./node_modules/lodash/_setToArray.js"),
    stringToArray = __webpack_require__("./node_modules/lodash/_stringToArray.js"),
    values = __webpack_require__("./node_modules/lodash/values.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var symIterator = Symbol ? Symbol.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

module.exports = toArray;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__("./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__("./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__("./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__("./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__("./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__("./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__("./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/lodash/transform.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__("./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__("./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__("./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__("./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__("./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__("./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__("./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__("./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__("./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__("./node_modules/lodash/isTypedArray.js");

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ "./node_modules/lodash/uniqueId.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__("./node_modules/lodash/toString.js");

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;


/***/ }),

/***/ "./node_modules/lodash/values.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__("./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__("./node_modules/lodash/keys.js");

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ "./node_modules/ms/index.js":
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/mysql/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Classes = Object.create(null);

/**
 * Create a new Connection instance.
 * @param {object|string} config Configuration or connection string for new MySQL connection
 * @return {Connection} A new MySQL connection
 * @public
 */
exports.createConnection = function createConnection(config) {
  var Connection       = loadClass('Connection');
  var ConnectionConfig = loadClass('ConnectionConfig');

  return new Connection({config: new ConnectionConfig(config)});
};

/**
 * Create a new Pool instance.
 * @param {object|string} config Configuration or connection string for new MySQL connections
 * @return {Pool} A new MySQL pool
 * @public
 */
exports.createPool = function createPool(config) {
  var Pool       = loadClass('Pool');
  var PoolConfig = loadClass('PoolConfig');

  return new Pool({config: new PoolConfig(config)});
};

/**
 * Create a new PoolCluster instance.
 * @param {object} [config] Configuration for pool cluster
 * @return {PoolCluster} New MySQL pool cluster
 * @public
 */
exports.createPoolCluster = function createPoolCluster(config) {
  var PoolCluster = loadClass('PoolCluster');

  return new PoolCluster(config);
};

/**
 * Create a new Query instance.
 * @param {string} sql The SQL for the query
 * @param {array} [values] Any values to insert into placeholders in sql
 * @param {function} [callback] The callback to use when query is complete
 * @return {Query} New query object
 * @public
 */
exports.createQuery = function createQuery(sql, values, callback) {
  var Connection = loadClass('Connection');

  return Connection.createQuery(sql, values, callback);
};

/**
 * Escape a value for SQL.
 * @param {*} value The value to escape
 * @param {boolean} [stringifyObjects=false] Setting if objects should be stringified
 * @param {string} [timeZone=local] Setting for time zone to use for Date conversion
 * @return {string} Escaped string value
 * @public
 */
exports.escape = function escape(value, stringifyObjects, timeZone) {
  var SqlString = loadClass('SqlString');

  return SqlString.escape(value, stringifyObjects, timeZone);
};

/**
 * Escape an identifier for SQL.
 * @param {*} value The value to escape
 * @param {boolean} [forbidQualified=false] Setting to treat '.' as part of identifier
 * @return {string} Escaped string value
 * @public
 */
exports.escapeId = function escapeId(value, forbidQualified) {
  var SqlString = loadClass('SqlString');

  return SqlString.escapeId(value, forbidQualified);
};

/**
 * Format SQL and replacement values into a SQL string.
 * @param {string} sql The SQL for the query
 * @param {array} [values] Any values to insert into placeholders in sql
 * @param {boolean} [stringifyObjects=false] Setting if objects should be stringified
 * @param {string} [timeZone=local] Setting for time zone to use for Date conversion
 * @return {string} Formatted SQL string
 * @public
 */
exports.format = function format(sql, values, stringifyObjects, timeZone) {
  var SqlString = loadClass('SqlString');

  return SqlString.format(sql, values, stringifyObjects, timeZone);
};

/**
 * Wrap raw SQL strings from escape overriding.
 * @param {string} sql The raw SQL
 * @return {object} Wrapped object
 * @public
 */
exports.raw = function raw(sql) {
  var SqlString = loadClass('SqlString');

  return SqlString.raw(sql);
};

/**
 * The type constants.
 * @public
 */
Object.defineProperty(exports, "Types", ({
  get: loadClass.bind(null, 'Types')
}));

/**
 * Load the given class.
 * @param {string} className Name of class to default
 * @return {function|object} Class constructor or exports
 * @private
 */
function loadClass(className) {
  var Class = Classes[className];

  if (Class !== undefined) {
    return Class;
  }

  // This uses a switch for static require analysis
  switch (className) {
    case 'Connection':
      Class = __webpack_require__("./node_modules/mysql/lib/Connection.js");
      break;
    case 'ConnectionConfig':
      Class = __webpack_require__("./node_modules/mysql/lib/ConnectionConfig.js");
      break;
    case 'Pool':
      Class = __webpack_require__("./node_modules/mysql/lib/Pool.js");
      break;
    case 'PoolCluster':
      Class = __webpack_require__("./node_modules/mysql/lib/PoolCluster.js");
      break;
    case 'PoolConfig':
      Class = __webpack_require__("./node_modules/mysql/lib/PoolConfig.js");
      break;
    case 'SqlString':
      Class = __webpack_require__("./node_modules/mysql/lib/protocol/SqlString.js");
      break;
    case 'Types':
      Class = __webpack_require__("./node_modules/mysql/lib/protocol/constants/types.js");
      break;
    default:
      throw new Error('Cannot find class \'' + className + '\'');
  }

  // Store to prevent invoking require()
  Classes[className] = Class;

  return Class;
}


/***/ }),

/***/ "./node_modules/mysql/lib/Connection.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Crypto           = __webpack_require__("crypto");
var Events           = __webpack_require__("events");
var Net              = __webpack_require__("net");
var tls              = __webpack_require__("tls");
var ConnectionConfig = __webpack_require__("./node_modules/mysql/lib/ConnectionConfig.js");
var Protocol         = __webpack_require__("./node_modules/mysql/lib/protocol/Protocol.js");
var SqlString        = __webpack_require__("./node_modules/mysql/lib/protocol/SqlString.js");
var Query            = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Query.js");
var Util             = __webpack_require__("util");

module.exports = Connection;
Util.inherits(Connection, Events.EventEmitter);
function Connection(options) {
  Events.EventEmitter.call(this);

  this.config = options.config;

  this._socket        = options.socket;
  this._protocol      = new Protocol({config: this.config, connection: this});
  this._connectCalled = false;
  this.state          = 'disconnected';
  this.threadId       = null;
}

Connection.createQuery = function createQuery(sql, values, callback) {
  if (sql instanceof Query) {
    return sql;
  }

  var cb      = callback;
  var options = {};

  if (typeof sql === 'function') {
    cb = sql;
  } else if (typeof sql === 'object') {
    options = Object.create(sql);

    if (typeof values === 'function') {
      cb = values;
    } else if (values !== undefined) {
      Object.defineProperty(options, 'values', { value: values });
    }
  } else {
    options.sql = sql;

    if (typeof values === 'function') {
      cb = values;
    } else if (values !== undefined) {
      options.values = values;
    }
  }

  if (cb !== undefined) {
    cb = wrapCallbackInDomain(null, cb);

    if (cb === undefined) {
      throw new TypeError('argument callback must be a function when provided');
    }
  }

  return new Query(options, cb);
};

Connection.prototype.connect = function connect(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  if (!this._connectCalled) {
    this._connectCalled = true;

    // Connect either via a UNIX domain socket or a TCP socket.
    this._socket = (this.config.socketPath)
      ? Net.createConnection(this.config.socketPath)
      : Net.createConnection(this.config.port, this.config.host);

    // Connect socket to connection domain
    if (Events.usingDomains) {
      this._socket.domain = this.domain;
    }

    var connection = this;
    this._protocol.on('data', function(data) {
      connection._socket.write(data);
    });
    this._socket.on('data', wrapToDomain(connection, function (data) {
      connection._protocol.write(data);
    }));
    this._protocol.on('end', function() {
      connection._socket.end();
    });
    this._socket.on('end', wrapToDomain(connection, function () {
      connection._protocol.end();
    }));

    this._socket.on('error', this._handleNetworkError.bind(this));
    this._socket.on('connect', this._handleProtocolConnect.bind(this));
    this._protocol.on('handshake', this._handleProtocolHandshake.bind(this));
    this._protocol.on('initialize', this._handleProtocolInitialize.bind(this));
    this._protocol.on('unhandledError', this._handleProtocolError.bind(this));
    this._protocol.on('drain', this._handleProtocolDrain.bind(this));
    this._protocol.on('end', this._handleProtocolEnd.bind(this));
    this._protocol.on('enqueue', this._handleProtocolEnqueue.bind(this));

    if (this.config.connectTimeout) {
      var handleConnectTimeout = this._handleConnectTimeout.bind(this);

      this._socket.setTimeout(this.config.connectTimeout, handleConnectTimeout);
      this._socket.once('connect', function() {
        this.setTimeout(0, handleConnectTimeout);
      });
    }
  }

  this._protocol.handshake(options, wrapCallbackInDomain(this, callback));
};

Connection.prototype.changeUser = function changeUser(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  this._implyConnect();

  var charsetNumber = (options.charset)
    ? ConnectionConfig.getCharsetNumber(options.charset)
    : this.config.charsetNumber;

  return this._protocol.changeUser({
    user          : options.user || this.config.user,
    password      : options.password || this.config.password,
    database      : options.database || this.config.database,
    timeout       : options.timeout,
    charsetNumber : charsetNumber,
    currentConfig : this.config
  }, wrapCallbackInDomain(this, callback));
};

Connection.prototype.beginTransaction = function beginTransaction(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};
  options.sql = 'START TRANSACTION';
  options.values = null;

  return this.query(options, callback);
};

Connection.prototype.commit = function commit(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};
  options.sql = 'COMMIT';
  options.values = null;

  return this.query(options, callback);
};

Connection.prototype.rollback = function rollback(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};
  options.sql = 'ROLLBACK';
  options.values = null;

  return this.query(options, callback);
};

Connection.prototype.query = function query(sql, values, cb) {
  var query = Connection.createQuery(sql, values, cb);
  query._connection = this;

  if (!(typeof sql === 'object' && 'typeCast' in sql)) {
    query.typeCast = this.config.typeCast;
  }

  if (query.sql) {
    query.sql = this.format(query.sql, query.values);
  }

  if (query._callback) {
    query._callback = wrapCallbackInDomain(this, query._callback);
  }

  this._implyConnect();

  return this._protocol._enqueue(query);
};

Connection.prototype.ping = function ping(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  this._implyConnect();
  this._protocol.ping(options, wrapCallbackInDomain(this, callback));
};

Connection.prototype.statistics = function statistics(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  this._implyConnect();
  this._protocol.stats(options, wrapCallbackInDomain(this, callback));
};

Connection.prototype.end = function end(options, callback) {
  var cb   = callback;
  var opts = options;

  if (!callback && typeof options === 'function') {
    cb   = options;
    opts = null;
  }

  // create custom options reference
  opts = Object.create(opts || null);

  if (opts.timeout === undefined) {
    // default timeout of 30 seconds
    opts.timeout = 30000;
  }

  this._implyConnect();
  this._protocol.quit(opts, wrapCallbackInDomain(this, cb));
};

Connection.prototype.destroy = function() {
  this.state = 'disconnected';
  this._implyConnect();
  this._socket.destroy();
  this._protocol.destroy();
};

Connection.prototype.pause = function() {
  this._socket.pause();
  this._protocol.pause();
};

Connection.prototype.resume = function() {
  this._socket.resume();
  this._protocol.resume();
};

Connection.prototype.escape = function(value) {
  return SqlString.escape(value, false, this.config.timezone);
};

Connection.prototype.escapeId = function escapeId(value) {
  return SqlString.escapeId(value, false);
};

Connection.prototype.format = function(sql, values) {
  if (typeof this.config.queryFormat === 'function') {
    return this.config.queryFormat.call(this, sql, values, this.config.timezone);
  }
  return SqlString.format(sql, values, this.config.stringifyObjects, this.config.timezone);
};

if (tls.TLSSocket) {
  // 0.11+ environment
  Connection.prototype._startTLS = function _startTLS(onSecure) {
    var connection = this;

    createSecureContext(this.config, function (err, secureContext) {
      if (err) {
        onSecure(err);
        return;
      }

      // "unpipe"
      connection._socket.removeAllListeners('data');
      connection._protocol.removeAllListeners('data');

      // socket <-> encrypted
      var rejectUnauthorized = connection.config.ssl.rejectUnauthorized;
      var secureEstablished  = false;
      var secureSocket       = new tls.TLSSocket(connection._socket, {
        rejectUnauthorized : rejectUnauthorized,
        requestCert        : true,
        secureContext      : secureContext,
        isServer           : false
      });

      // error handler for secure socket
      secureSocket.on('_tlsError', function(err) {
        if (secureEstablished) {
          connection._handleNetworkError(err);
        } else {
          onSecure(err);
        }
      });

      // cleartext <-> protocol
      secureSocket.pipe(connection._protocol);
      connection._protocol.on('data', function(data) {
        secureSocket.write(data);
      });

      secureSocket.on('secure', function() {
        secureEstablished = true;

        onSecure(rejectUnauthorized ? this.ssl.verifyError() : null);
      });

      // start TLS communications
      secureSocket._start();
    });
  };
} else {
  // pre-0.11 environment
  Connection.prototype._startTLS = function _startTLS(onSecure) {
    // before TLS:
    //  _socket <-> _protocol
    // after:
    //  _socket <-> securePair.encrypted <-> securePair.cleartext <-> _protocol

    var connection  = this;
    var credentials = Crypto.createCredentials({
      ca         : this.config.ssl.ca,
      cert       : this.config.ssl.cert,
      ciphers    : this.config.ssl.ciphers,
      key        : this.config.ssl.key,
      passphrase : this.config.ssl.passphrase
    });

    var rejectUnauthorized = this.config.ssl.rejectUnauthorized;
    var secureEstablished  = false;
    var securePair         = tls.createSecurePair(credentials, false, true, rejectUnauthorized);

    // error handler for secure pair
    securePair.on('error', function(err) {
      if (secureEstablished) {
        connection._handleNetworkError(err);
      } else {
        onSecure(err);
      }
    });

    // "unpipe"
    this._socket.removeAllListeners('data');
    this._protocol.removeAllListeners('data');

    // socket <-> encrypted
    securePair.encrypted.pipe(this._socket);
    this._socket.on('data', function(data) {
      securePair.encrypted.write(data);
    });

    // cleartext <-> protocol
    securePair.cleartext.pipe(this._protocol);
    this._protocol.on('data', function(data) {
      securePair.cleartext.write(data);
    });

    // secure established
    securePair.on('secure', function() {
      secureEstablished = true;

      if (!rejectUnauthorized) {
        onSecure();
        return;
      }

      var verifyError = this.ssl.verifyError();
      var err = verifyError;

      // node.js 0.6 support
      if (typeof err === 'string') {
        err = new Error(verifyError);
        err.code = verifyError;
      }

      onSecure(err);
    });

    // node.js 0.8 bug
    securePair._cycle = securePair.cycle;
    securePair.cycle  = function cycle() {
      if (this.ssl && this.ssl.error) {
        this.error();
      }

      return this._cycle.apply(this, arguments);
    };
  };
}

Connection.prototype._handleConnectTimeout = function() {
  if (this._socket) {
    this._socket.setTimeout(0);
    this._socket.destroy();
  }

  var err = new Error('connect ETIMEDOUT');
  err.errorno = 'ETIMEDOUT';
  err.code = 'ETIMEDOUT';
  err.syscall = 'connect';

  this._handleNetworkError(err);
};

Connection.prototype._handleNetworkError = function(err) {
  this._protocol.handleNetworkError(err);
};

Connection.prototype._handleProtocolError = function(err) {
  this.state = 'protocol_error';
  this.emit('error', err);
};

Connection.prototype._handleProtocolDrain = function() {
  this.emit('drain');
};

Connection.prototype._handleProtocolConnect = function() {
  this.state = 'connected';
  this.emit('connect');
};

Connection.prototype._handleProtocolHandshake = function _handleProtocolHandshake() {
  this.state = 'authenticated';
};

Connection.prototype._handleProtocolInitialize = function _handleProtocolInitialize(packet) {
  this.threadId = packet.threadId;
};

Connection.prototype._handleProtocolEnd = function(err) {
  this.state = 'disconnected';
  this.emit('end', err);
};

Connection.prototype._handleProtocolEnqueue = function _handleProtocolEnqueue(sequence) {
  this.emit('enqueue', sequence);
};

Connection.prototype._implyConnect = function() {
  if (!this._connectCalled) {
    this.connect();
  }
};

function createSecureContext (config, cb) {
  var context = null;
  var error   = null;

  try {
    context = tls.createSecureContext({
      ca         : config.ssl.ca,
      cert       : config.ssl.cert,
      ciphers    : config.ssl.ciphers,
      key        : config.ssl.key,
      passphrase : config.ssl.passphrase
    });
  } catch (err) {
    error = err;
  }

  cb(error, context);
}

function unwrapFromDomain(fn) {
  return function () {
    var domains = [];
    var ret;

    while (process.domain) {
      domains.shift(process.domain);
      process.domain.exit();
    }

    try {
      ret = fn.apply(this, arguments);
    } finally {
      for (var i = 0; i < domains.length; i++) {
        domains[i].enter();
      }
    }

    return ret;
  };
}

function wrapCallbackInDomain(ee, fn) {
  if (typeof fn !== 'function') {
    return undefined;
  }

  if (fn.domain) {
    return fn;
  }

  var domain = process.domain;

  if (domain) {
    return domain.bind(fn);
  } else if (ee) {
    return unwrapFromDomain(wrapToDomain(ee, fn));
  } else {
    return fn;
  }
}

function wrapToDomain(ee, fn) {
  return function () {
    if (Events.usingDomains && ee.domain) {
      ee.domain.enter();
      fn.apply(this, arguments);
      ee.domain.exit();
    } else {
      fn.apply(this, arguments);
    }
  };
}


/***/ }),

/***/ "./node_modules/mysql/lib/ConnectionConfig.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var urlParse        = (__webpack_require__("url").parse);
var ClientConstants = __webpack_require__("./node_modules/mysql/lib/protocol/constants/client.js");
var Charsets        = __webpack_require__("./node_modules/mysql/lib/protocol/constants/charsets.js");
var SSLProfiles     = null;

module.exports = ConnectionConfig;
function ConnectionConfig(options) {
  if (typeof options === 'string') {
    options = ConnectionConfig.parseUrl(options);
  }

  this.host               = options.host || 'localhost';
  this.port               = options.port || 3306;
  this.localAddress       = options.localAddress;
  this.socketPath         = options.socketPath;
  this.user               = options.user || undefined;
  this.password           = options.password || undefined;
  this.database           = options.database;
  this.connectTimeout     = (options.connectTimeout === undefined)
    ? (10 * 1000)
    : options.connectTimeout;
  this.insecureAuth       = options.insecureAuth || false;
  this.supportBigNumbers  = options.supportBigNumbers || false;
  this.bigNumberStrings   = options.bigNumberStrings || false;
  this.dateStrings        = options.dateStrings || false;
  this.debug              = options.debug;
  this.trace              = options.trace !== false;
  this.stringifyObjects   = options.stringifyObjects || false;
  this.timezone           = options.timezone || 'local';
  this.flags              = options.flags || '';
  this.queryFormat        = options.queryFormat;
  this.pool               = options.pool || undefined;
  this.ssl                = (typeof options.ssl === 'string')
    ? ConnectionConfig.getSSLProfile(options.ssl)
    : (options.ssl || false);
  this.localInfile        = (options.localInfile === undefined)
    ? true
    : options.localInfile;
  this.multipleStatements = options.multipleStatements || false;
  this.typeCast           = (options.typeCast === undefined)
    ? true
    : options.typeCast;

  if (this.timezone[0] === ' ') {
    // "+" is a url encoded char for space so it
    // gets translated to space when giving a
    // connection string..
    this.timezone = '+' + this.timezone.substr(1);
  }

  if (this.ssl) {
    // Default rejectUnauthorized to true
    this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
  }

  this.maxPacketSize = 0;
  this.charsetNumber = (options.charset)
    ? ConnectionConfig.getCharsetNumber(options.charset)
    : options.charsetNumber || Charsets.UTF8_GENERAL_CI;

  // Set the client flags
  var defaultFlags = ConnectionConfig.getDefaultFlags(options);
  this.clientFlags = ConnectionConfig.mergeFlags(defaultFlags, options.flags);
}

ConnectionConfig.mergeFlags = function mergeFlags(defaultFlags, userFlags) {
  var allFlags = ConnectionConfig.parseFlagList(defaultFlags);
  var newFlags = ConnectionConfig.parseFlagList(userFlags);

  // Merge the new flags
  for (var flag in newFlags) {
    if (allFlags[flag] !== false) {
      allFlags[flag] = newFlags[flag];
    }
  }

  // Build flags
  var flags = 0x0;
  for (var flag in allFlags) {
    if (allFlags[flag]) {
      // TODO: Throw here on some future release
      flags |= ClientConstants['CLIENT_' + flag] || 0x0;
    }
  }

  return flags;
};

ConnectionConfig.getCharsetNumber = function getCharsetNumber(charset) {
  var num = Charsets[charset.toUpperCase()];

  if (num === undefined) {
    throw new TypeError('Unknown charset \'' + charset + '\'');
  }

  return num;
};

ConnectionConfig.getDefaultFlags = function getDefaultFlags(options) {
  var defaultFlags = [
    '-COMPRESS',          // Compression protocol *NOT* supported
    '-CONNECT_ATTRS',     // Does *NOT* send connection attributes in Protocol::HandshakeResponse41
    '+CONNECT_WITH_DB',   // One can specify db on connect in Handshake Response Packet
    '+FOUND_ROWS',        // Send found rows instead of affected rows
    '+IGNORE_SIGPIPE',    // Don't issue SIGPIPE if network failures
    '+IGNORE_SPACE',      // Let the parser ignore spaces before '('
    '+LOCAL_FILES',       // Can use LOAD DATA LOCAL
    '+LONG_FLAG',         // Longer flags in Protocol::ColumnDefinition320
    '+LONG_PASSWORD',     // Use the improved version of Old Password Authentication
    '+MULTI_RESULTS',     // Can handle multiple resultsets for COM_QUERY
    '+ODBC',              // Special handling of ODBC behaviour
    '-PLUGIN_AUTH',       // Does *NOT* support auth plugins
    '+PROTOCOL_41',       // Uses the 4.1 protocol
    '+PS_MULTI_RESULTS',  // Can handle multiple resultsets for COM_STMT_EXECUTE
    '+RESERVED',          // Unused
    '+SECURE_CONNECTION', // Supports Authentication::Native41
    '+TRANSACTIONS'       // Expects status flags
  ];

  if (options && options.localInfile !== undefined && !options.localInfile) {
    // Disable LOCAL modifier for LOAD DATA INFILE
    defaultFlags.push('-LOCAL_FILES');
  }

  if (options && options.multipleStatements) {
    // May send multiple statements per COM_QUERY and COM_STMT_PREPARE
    defaultFlags.push('+MULTI_STATEMENTS');
  }

  return defaultFlags;
};

ConnectionConfig.getSSLProfile = function getSSLProfile(name) {
  if (!SSLProfiles) {
    SSLProfiles = __webpack_require__("./node_modules/mysql/lib/protocol/constants/ssl_profiles.js");
  }

  var ssl = SSLProfiles[name];

  if (ssl === undefined) {
    throw new TypeError('Unknown SSL profile \'' + name + '\'');
  }

  return ssl;
};

ConnectionConfig.parseFlagList = function parseFlagList(flagList) {
  var allFlags = Object.create(null);

  if (!flagList) {
    return allFlags;
  }

  var flags = !Array.isArray(flagList)
    ? String(flagList || '').toUpperCase().split(/\s*,+\s*/)
    : flagList;

  for (var i = 0; i < flags.length; i++) {
    var flag   = flags[i];
    var offset = 1;
    var state  = flag[0];

    if (state === undefined) {
      // TODO: throw here on some future release
      continue;
    }

    if (state !== '-' && state !== '+') {
      offset = 0;
      state  = '+';
    }

    allFlags[flag.substr(offset)] = state === '+';
  }

  return allFlags;
};

ConnectionConfig.parseUrl = function(url) {
  url = urlParse(url, true);

  var options = {
    host     : url.hostname,
    port     : url.port,
    database : url.pathname.substr(1)
  };

  if (url.auth) {
    var auth = url.auth.split(':');
    options.user     = auth.shift();
    options.password = auth.join(':');
  }

  if (url.query) {
    for (var key in url.query) {
      var value = url.query[key];

      try {
        // Try to parse this as a JSON expression first
        options[key] = JSON.parse(value);
      } catch (err) {
        // Otherwise assume it is a plain string
        options[key] = value;
      }
    }
  }

  return options;
};


/***/ }),

/***/ "./node_modules/mysql/lib/Pool.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mysql          = __webpack_require__("./node_modules/mysql/index.js");
var Connection     = __webpack_require__("./node_modules/mysql/lib/Connection.js");
var EventEmitter   = (__webpack_require__("events").EventEmitter);
var Util           = __webpack_require__("util");
var PoolConnection = __webpack_require__("./node_modules/mysql/lib/PoolConnection.js");

module.exports = Pool;

Util.inherits(Pool, EventEmitter);
function Pool(options) {
  EventEmitter.call(this);
  this.config = options.config;
  this.config.connectionConfig.pool = this;

  this._acquiringConnections = [];
  this._allConnections       = [];
  this._freeConnections      = [];
  this._connectionQueue      = [];
  this._closed               = false;
}

Pool.prototype.getConnection = function (cb) {

  if (this._closed) {
    var err = new Error('Pool is closed.');
    err.code = 'POOL_CLOSED';
    process.nextTick(function () {
      cb(err);
    });
    return;
  }

  var connection;
  var pool = this;

  if (this._freeConnections.length > 0) {
    connection = this._freeConnections.shift();
    this.acquireConnection(connection, cb);
    return;
  }

  if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {
    connection = new PoolConnection(this, { config: this.config.newConnectionConfig() });

    this._acquiringConnections.push(connection);
    this._allConnections.push(connection);

    connection.connect({timeout: this.config.acquireTimeout}, function onConnect(err) {
      spliceConnection(pool._acquiringConnections, connection);

      if (pool._closed) {
        err = new Error('Pool is closed.');
        err.code = 'POOL_CLOSED';
      }

      if (err) {
        pool._purgeConnection(connection);
        cb(err);
        return;
      }

      pool.emit('connection', connection);
      pool.emit('acquire', connection);
      cb(null, connection);
    });
    return;
  }

  if (!this.config.waitForConnections) {
    process.nextTick(function(){
      var err = new Error('No connections available.');
      err.code = 'POOL_CONNLIMIT';
      cb(err);
    });
    return;
  }

  this._enqueueCallback(cb);
};

Pool.prototype.acquireConnection = function acquireConnection(connection, cb) {
  if (connection._pool !== this) {
    throw new Error('Connection acquired from wrong pool.');
  }

  var changeUser = this._needsChangeUser(connection);
  var pool       = this;

  this._acquiringConnections.push(connection);

  function onOperationComplete(err) {
    spliceConnection(pool._acquiringConnections, connection);

    if (pool._closed) {
      err = new Error('Pool is closed.');
      err.code = 'POOL_CLOSED';
    }

    if (err) {
      pool._connectionQueue.unshift(cb);
      pool._purgeConnection(connection);
      return;
    }

    if (changeUser) {
      pool.emit('connection', connection);
    }

    pool.emit('acquire', connection);
    cb(null, connection);
  }

  if (changeUser) {
    // restore user back to pool configuration
    connection.config = this.config.newConnectionConfig();
    connection.changeUser({timeout: this.config.acquireTimeout}, onOperationComplete);
  } else {
    // ping connection
    connection.ping({timeout: this.config.acquireTimeout}, onOperationComplete);
  }
};

Pool.prototype.releaseConnection = function releaseConnection(connection) {

  if (this._acquiringConnections.indexOf(connection) !== -1) {
    // connection is being acquired
    return;
  }

  if (connection._pool) {
    if (connection._pool !== this) {
      throw new Error('Connection released to wrong pool');
    }

    if (this._freeConnections.indexOf(connection) !== -1) {
      // connection already in free connection pool
      // this won't catch all double-release cases
      throw new Error('Connection already released');
    } else {
      // add connection to end of free queue
      this._freeConnections.push(connection);
      this.emit('release', connection);
    }
  }

  if (this._closed) {
    // empty the connection queue
    this._connectionQueue.splice(0).forEach(function (cb) {
      var err = new Error('Pool is closed.');
      err.code = 'POOL_CLOSED';
      process.nextTick(function () {
        cb(err);
      });
    });
  } else if (this._connectionQueue.length) {
    // get connection with next waiting callback
    this.getConnection(this._connectionQueue.shift());
  }
};

Pool.prototype.end = function (cb) {
  this._closed = true;

  if (typeof cb !== 'function') {
    cb = function (err) {
      if (err) throw err;
    };
  }

  var calledBack   = false;
  var waitingClose = 0;

  function onEnd(err) {
    if (!calledBack && (err || --waitingClose <= 0)) {
      calledBack = true;
      cb(err);
    }
  }

  while (this._allConnections.length !== 0) {
    waitingClose++;
    this._purgeConnection(this._allConnections[0], onEnd);
  }

  if (waitingClose === 0) {
    process.nextTick(onEnd);
  }
};

Pool.prototype.query = function (sql, values, cb) {
  var query = Connection.createQuery(sql, values, cb);

  if (!(typeof sql === 'object' && 'typeCast' in sql)) {
    query.typeCast = this.config.connectionConfig.typeCast;
  }

  if (this.config.connectionConfig.trace) {
    // Long stack trace support
    query._callSite = new Error();
  }

  this.getConnection(function (err, conn) {
    if (err) {
      query.on('error', function () {});
      query.end(err);
      return;
    }

    // Release connection based off event
    query.once('end', function() {
      conn.release();
    });

    conn.query(query);
  });

  return query;
};

Pool.prototype._enqueueCallback = function _enqueueCallback(callback) {

  if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) {
    process.nextTick(function () {
      var err = new Error('Queue limit reached.');
      err.code = 'POOL_ENQUEUELIMIT';
      callback(err);
    });
    return;
  }

  // Bind to domain, as dequeue will likely occur in a different domain
  var cb = process.domain
    ? process.domain.bind(callback)
    : callback;

  this._connectionQueue.push(cb);
  this.emit('enqueue');
};

Pool.prototype._needsChangeUser = function _needsChangeUser(connection) {
  var connConfig = connection.config;
  var poolConfig = this.config.connectionConfig;

  // check if changeUser values are different
  return connConfig.user !== poolConfig.user
    || connConfig.database !== poolConfig.database
    || connConfig.password !== poolConfig.password
    || connConfig.charsetNumber !== poolConfig.charsetNumber;
};

Pool.prototype._purgeConnection = function _purgeConnection(connection, callback) {
  var cb = callback || function () {};

  if (connection.state === 'disconnected') {
    connection.destroy();
  }

  this._removeConnection(connection);

  if (connection.state !== 'disconnected' && !connection._protocol._quitSequence) {
    connection._realEnd(cb);
    return;
  }

  process.nextTick(cb);
};

Pool.prototype._removeConnection = function(connection) {
  connection._pool = null;

  // Remove connection from all connections
  spliceConnection(this._allConnections, connection);

  // Remove connection from free connections
  spliceConnection(this._freeConnections, connection);

  this.releaseConnection(connection);
};

Pool.prototype.escape = function(value) {
  return mysql.escape(value, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
};

Pool.prototype.escapeId = function escapeId(value) {
  return mysql.escapeId(value, false);
};

function spliceConnection(array, connection) {
  var index;
  if ((index = array.indexOf(connection)) !== -1) {
    // Remove connection from all connections
    array.splice(index, 1);
  }
}


/***/ }),

/***/ "./node_modules/mysql/lib/PoolCluster.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Pool          = __webpack_require__("./node_modules/mysql/lib/Pool.js");
var PoolConfig    = __webpack_require__("./node_modules/mysql/lib/PoolConfig.js");
var PoolNamespace = __webpack_require__("./node_modules/mysql/lib/PoolNamespace.js");
var PoolSelector  = __webpack_require__("./node_modules/mysql/lib/PoolSelector.js");
var Util          = __webpack_require__("util");
var EventEmitter  = (__webpack_require__("events").EventEmitter);

module.exports = PoolCluster;

/**
 * PoolCluster
 * @constructor
 * @param {object} [config] The pool cluster configuration
 * @public
 */
function PoolCluster(config) {
  EventEmitter.call(this);

  config = config || {};
  this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;
  this._defaultSelector = config.defaultSelector || 'RR';
  this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
  this._restoreNodeTimeout = config.restoreNodeTimeout || 0;

  this._closed = false;
  this._findCaches = Object.create(null);
  this._lastId = 0;
  this._namespaces = Object.create(null);
  this._nodes = Object.create(null);
}

Util.inherits(PoolCluster, EventEmitter);

PoolCluster.prototype.add = function add(id, config) {
  if (this._closed) {
    throw new Error('PoolCluster is closed.');
  }

  var nodeId = typeof id === 'object'
    ? 'CLUSTER::' + (++this._lastId)
    : String(id);

  if (this._nodes[nodeId] !== undefined) {
    throw new Error('Node ID "' + nodeId + '" is already defined in PoolCluster.');
  }

  var poolConfig = typeof id !== 'object'
    ? new PoolConfig(config)
    : new PoolConfig(id);

  this._nodes[nodeId] = {
    id            : nodeId,
    errorCount    : 0,
    pool          : new Pool({config: poolConfig}),
    _offlineUntil : 0
  };

  this._clearFindCaches();
};

PoolCluster.prototype.end = function end(callback) {
  var cb = callback !== undefined
    ? callback
    : _cb;

  if (typeof cb !== 'function') {
    throw TypeError('callback argument must be a function');
  }

  if (this._closed) {
    process.nextTick(cb);
    return;
  }

  this._closed = true;

  var calledBack   = false;
  var nodeIds      = Object.keys(this._nodes);
  var waitingClose = 0;

  function onEnd(err) {
    if (!calledBack && (err || --waitingClose <= 0)) {
      calledBack = true;
      cb(err);
    }
  }

  for (var i = 0; i < nodeIds.length; i++) {
    var nodeId = nodeIds[i];
    var node = this._nodes[nodeId];

    waitingClose++;
    node.pool.end(onEnd);
  }

  if (waitingClose === 0) {
    process.nextTick(onEnd);
  }
};

PoolCluster.prototype.of = function(pattern, selector) {
  pattern = pattern || '*';

  selector = selector || this._defaultSelector;
  selector = selector.toUpperCase();
  if (typeof PoolSelector[selector] === 'undefined') {
    selector = this._defaultSelector;
  }

  var key = pattern + selector;

  if (typeof this._namespaces[key] === 'undefined') {
    this._namespaces[key] = new PoolNamespace(this, pattern, selector);
  }

  return this._namespaces[key];
};

PoolCluster.prototype.remove = function remove(pattern) {
  var foundNodeIds = this._findNodeIds(pattern, true);

  for (var i = 0; i < foundNodeIds.length; i++) {
    var node = this._getNode(foundNodeIds[i]);

    if (node) {
      this._removeNode(node);
    }
  }
};

PoolCluster.prototype.getConnection = function(pattern, selector, cb) {
  var namespace;
  if (typeof pattern === 'function') {
    cb = pattern;
    namespace = this.of();
  } else {
    if (typeof selector === 'function') {
      cb = selector;
      selector = this._defaultSelector;
    }

    namespace = this.of(pattern, selector);
  }

  namespace.getConnection(cb);
};

PoolCluster.prototype._clearFindCaches = function _clearFindCaches() {
  this._findCaches = Object.create(null);
};

PoolCluster.prototype._decreaseErrorCount = function _decreaseErrorCount(node) {
  var errorCount = node.errorCount;

  if (errorCount > this._removeNodeErrorCount) {
    errorCount = this._removeNodeErrorCount;
  }

  if (errorCount < 1) {
    errorCount = 1;
  }

  node.errorCount = errorCount - 1;

  if (node._offlineUntil) {
    node._offlineUntil = 0;
    this.emit('online', node.id);
  }
};

PoolCluster.prototype._findNodeIds = function _findNodeIds(pattern, includeOffline) {
  var currentTime  = 0;
  var foundNodeIds = this._findCaches[pattern];

  if (foundNodeIds === undefined) {
    var expression = patternRegExp(pattern);
    var nodeIds    = Object.keys(this._nodes);

    foundNodeIds = nodeIds.filter(function (id) {
      return id.match(expression);
    });

    this._findCaches[pattern] = foundNodeIds;
  }

  if (includeOffline) {
    return foundNodeIds;
  }

  return foundNodeIds.filter(function (nodeId) {
    var node = this._getNode(nodeId);

    if (!node._offlineUntil) {
      return true;
    }

    if (!currentTime) {
      currentTime = getMonotonicMilliseconds();
    }

    return node._offlineUntil <= currentTime;
  }, this);
};

PoolCluster.prototype._getNode = function _getNode(id) {
  return this._nodes[id] || null;
};

PoolCluster.prototype._increaseErrorCount = function _increaseErrorCount(node) {
  var errorCount = ++node.errorCount;

  if (this._removeNodeErrorCount > errorCount) {
    return;
  }

  if (this._restoreNodeTimeout > 0) {
    node._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;
    this.emit('offline', node.id);
    return;
  }

  this._removeNode(node);
  this.emit('remove', node.id);
};

PoolCluster.prototype._getConnection = function(node, cb) {
  var self = this;

  node.pool.getConnection(function (err, connection) {
    if (err) {
      self._increaseErrorCount(node);
      cb(err);
      return;
    } else {
      self._decreaseErrorCount(node);
    }

    connection._clusterId = node.id;

    cb(null, connection);
  });
};

PoolCluster.prototype._removeNode = function _removeNode(node) {
  delete this._nodes[node.id];

  this._clearFindCaches();

  node.pool.end(_noop);
};

function getMonotonicMilliseconds() {
  var ms;

  if (typeof process.hrtime === 'function') {
    ms = process.hrtime();
    ms = ms[0] * 1e3 + ms[1] * 1e-6;
  } else {
    ms = process.uptime() * 1000;
  }

  return Math.floor(ms);
}

function isRegExp(val) {
  return typeof val === 'object'
    && Object.prototype.toString.call(val) === '[object RegExp]';
}

function patternRegExp(pattern) {
  if (isRegExp(pattern)) {
    return pattern;
  }

  var source = pattern
    .replace(/([.+?^=!:${}()|\[\]\/\\])/g, '\\$1')
    .replace(/\*/g, '.*');

  return new RegExp('^' + source + '$');
}

function _cb(err) {
  if (err) {
    throw err;
  }
}

function _noop() {}


/***/ }),

/***/ "./node_modules/mysql/lib/PoolConfig.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ConnectionConfig = __webpack_require__("./node_modules/mysql/lib/ConnectionConfig.js");

module.exports = PoolConfig;
function PoolConfig(options) {
  if (typeof options === 'string') {
    options = ConnectionConfig.parseUrl(options);
  }

  this.acquireTimeout     = (options.acquireTimeout === undefined)
    ? 10 * 1000
    : Number(options.acquireTimeout);
  this.connectionConfig   = new ConnectionConfig(options);
  this.waitForConnections = (options.waitForConnections === undefined)
    ? true
    : Boolean(options.waitForConnections);
  this.connectionLimit    = (options.connectionLimit === undefined)
    ? 10
    : Number(options.connectionLimit);
  this.queueLimit         = (options.queueLimit === undefined)
    ? 0
    : Number(options.queueLimit);
}

PoolConfig.prototype.newConnectionConfig = function newConnectionConfig() {
  var connectionConfig = new ConnectionConfig(this.connectionConfig);

  connectionConfig.clientFlags   = this.connectionConfig.clientFlags;
  connectionConfig.maxPacketSize = this.connectionConfig.maxPacketSize;

  return connectionConfig;
};


/***/ }),

/***/ "./node_modules/mysql/lib/PoolConnection.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits   = (__webpack_require__("util").inherits);
var Connection = __webpack_require__("./node_modules/mysql/lib/Connection.js");
var Events     = __webpack_require__("events");

module.exports = PoolConnection;
inherits(PoolConnection, Connection);

function PoolConnection(pool, options) {
  Connection.call(this, options);
  this._pool  = pool;

  // Bind connection to pool domain
  if (Events.usingDomains) {
    this.domain = pool.domain;
  }

  // When a fatal error occurs the connection's protocol ends, which will cause
  // the connection to end as well, thus we only need to watch for the end event
  // and we will be notified of disconnects.
  this.on('end', this._removeFromPool);
  this.on('error', function (err) {
    if (err.fatal) {
      this._removeFromPool();
    }
  });
}

PoolConnection.prototype.release = function release() {
  var pool = this._pool;

  if (!pool || pool._closed) {
    return undefined;
  }

  return pool.releaseConnection(this);
};

// TODO: Remove this when we are removing PoolConnection#end
PoolConnection.prototype._realEnd = Connection.prototype.end;

PoolConnection.prototype.end = function () {
  console.warn(
    'Calling conn.end() to release a pooled connection is ' +
    'deprecated. In next version calling conn.end() will be ' +
    'restored to default conn.end() behavior. Use ' +
    'conn.release() instead.'
  );
  this.release();
};

PoolConnection.prototype.destroy = function () {
  Connection.prototype.destroy.apply(this, arguments);
  this._removeFromPool(this);
};

PoolConnection.prototype._removeFromPool = function _removeFromPool() {
  if (!this._pool || this._pool._closed) {
    return;
  }

  var pool = this._pool;
  this._pool = null;

  pool._purgeConnection(this);
};


/***/ }),

/***/ "./node_modules/mysql/lib/PoolNamespace.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Connection   = __webpack_require__("./node_modules/mysql/lib/Connection.js");
var PoolSelector = __webpack_require__("./node_modules/mysql/lib/PoolSelector.js");

module.exports = PoolNamespace;

/**
 * PoolNamespace
 * @constructor
 * @param {PoolCluster} cluster The parent cluster for the namespace
 * @param {string} pattern The selection pattern to use
 * @param {string} selector The selector name to use
 * @public
 */
function PoolNamespace(cluster, pattern, selector) {
  this._cluster = cluster;
  this._pattern = pattern;
  this._selector = new PoolSelector[selector]();
}

PoolNamespace.prototype.getConnection = function(cb) {
  var clusterNode = this._getClusterNode();
  var cluster     = this._cluster;
  var namespace   = this;

  if (clusterNode === null) {
    var err = null;

    if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
      err = new Error('Pool does not have online node.');
      err.code = 'POOL_NONEONLINE';
    } else {
      err = new Error('Pool does not exist.');
      err.code = 'POOL_NOEXIST';
    }

    cb(err);
    return;
  }

  cluster._getConnection(clusterNode, function(err, connection) {
    var retry = err && cluster._canRetry
      && cluster._findNodeIds(namespace._pattern).length !== 0;

    if (retry) {
      namespace.getConnection(cb);
      return;
    }

    if (err) {
      cb(err);
      return;
    }

    cb(null, connection);
  });
};

PoolNamespace.prototype.query = function (sql, values, cb) {
  var cluster     = this._cluster;
  var clusterNode = this._getClusterNode();
  var query       = Connection.createQuery(sql, values, cb);
  var namespace   = this;

  if (clusterNode === null) {
    var err = null;

    if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
      err = new Error('Pool does not have online node.');
      err.code = 'POOL_NONEONLINE';
    } else {
      err = new Error('Pool does not exist.');
      err.code = 'POOL_NOEXIST';
    }

    process.nextTick(function () {
      query.on('error', function () {});
      query.end(err);
    });
    return query;
  }

  if (!(typeof sql === 'object' && 'typeCast' in sql)) {
    query.typeCast = clusterNode.pool.config.connectionConfig.typeCast;
  }

  if (clusterNode.pool.config.connectionConfig.trace) {
    // Long stack trace support
    query._callSite = new Error();
  }

  cluster._getConnection(clusterNode, function (err, conn) {
    var retry = err && cluster._canRetry
      && cluster._findNodeIds(namespace._pattern).length !== 0;

    if (retry) {
      namespace.query(query);
      return;
    }

    if (err) {
      query.on('error', function () {});
      query.end(err);
      return;
    }

    // Release connection based off event
    query.once('end', function() {
      conn.release();
    });

    conn.query(query);
  });

  return query;
};

PoolNamespace.prototype._getClusterNode = function _getClusterNode() {
  var foundNodeIds = this._cluster._findNodeIds(this._pattern);
  var nodeId;

  switch (foundNodeIds.length) {
    case 0:
      nodeId = null;
      break;
    case 1:
      nodeId = foundNodeIds[0];
      break;
    default:
      nodeId = this._selector(foundNodeIds);
      break;
  }

  return nodeId !== null
    ? this._cluster._getNode(nodeId)
    : null;
};


/***/ }),

/***/ "./node_modules/mysql/lib/PoolSelector.js":
/***/ ((module) => {


/**
 * PoolSelector
 */
var PoolSelector = module.exports = {};

PoolSelector.RR = function PoolSelectorRoundRobin() {
  var index = 0;

  return function(clusterIds) {
    if (index >= clusterIds.length) {
      index = 0;
    }

    var clusterId = clusterIds[index++];

    return clusterId;
  };
};

PoolSelector.RANDOM = function PoolSelectorRandom() {
  return function(clusterIds) {
    return clusterIds[Math.floor(Math.random() * clusterIds.length)];
  };
};

PoolSelector.ORDER = function PoolSelectorOrder() {
  return function(clusterIds) {
    return clusterIds[0];
  };
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/Auth.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
var Crypto = __webpack_require__("crypto");
var Auth   = exports;

function auth(name, data, options) {
  options = options || {};

  switch (name) {
    case 'mysql_native_password':
      return Auth.token(options.password, data.slice(0, 20));
    default:
      return undefined;
  }
}
Auth.auth = auth;

function sha1(msg) {
  var hash = Crypto.createHash('sha1');
  hash.update(msg, 'binary');
  return hash.digest('binary');
}
Auth.sha1 = sha1;

function xor(a, b) {
  a = Buffer.from(a, 'binary');
  b = Buffer.from(b, 'binary');
  var result = Buffer.allocUnsafe(a.length);
  for (var i = 0; i < a.length; i++) {
    result[i] = (a[i] ^ b[i]);
  }
  return result;
}
Auth.xor = xor;

Auth.token = function(password, scramble) {
  if (!password) {
    return Buffer.alloc(0);
  }

  // password must be in binary format, not utf8
  var stage1 = sha1((Buffer.from(password, 'utf8')).toString('binary'));
  var stage2 = sha1(stage1);
  var stage3 = sha1(scramble.toString('binary') + stage2);
  return xor(stage3, stage1);
};

// This is a port of sql/password.c:hash_password which needs to be used for
// pre-4.1 passwords.
Auth.hashPassword = function(password) {
  var nr     = [0x5030, 0x5735];
  var add    = 7;
  var nr2    = [0x1234, 0x5671];
  var result = Buffer.alloc(8);

  if (typeof password === 'string'){
    password = Buffer.from(password);
  }

  for (var i = 0; i < password.length; i++) {
    var c = password[i];
    if (c === 32 || c === 9) {
      // skip space in password
      continue;
    }

    // nr^= (((nr & 63)+add)*c)+ (nr << 8);
    // nr = xor(nr, add(mul(add(and(nr, 63), add), c), shl(nr, 8)))
    nr = this.xor32(nr, this.add32(this.mul32(this.add32(this.and32(nr, [0, 63]), [0, add]), [0, c]), this.shl32(nr, 8)));

    // nr2+=(nr2 << 8) ^ nr;
    // nr2 = add(nr2, xor(shl(nr2, 8), nr))
    nr2 = this.add32(nr2, this.xor32(this.shl32(nr2, 8), nr));

    // add+=tmp;
    add += c;
  }

  this.int31Write(result, nr, 0);
  this.int31Write(result, nr2, 4);

  return result;
};

Auth.randomInit = function(seed1, seed2) {
  return {
    max_value     : 0x3FFFFFFF,
    max_value_dbl : 0x3FFFFFFF,
    seed1         : seed1 % 0x3FFFFFFF,
    seed2         : seed2 % 0x3FFFFFFF
  };
};

Auth.myRnd = function(r){
  r.seed1 = (r.seed1 * 3 + r.seed2) % r.max_value;
  r.seed2 = (r.seed1 + r.seed2 + 33) % r.max_value;

  return r.seed1 / r.max_value_dbl;
};

Auth.scramble323 = function(message, password) {
  if (!password) {
    return Buffer.alloc(0);
  }

  var to          = Buffer.allocUnsafe(8);
  var hashPass    = this.hashPassword(password);
  var hashMessage = this.hashPassword(message.slice(0, 8));
  var seed1       = this.int32Read(hashPass, 0) ^ this.int32Read(hashMessage, 0);
  var seed2       = this.int32Read(hashPass, 4) ^ this.int32Read(hashMessage, 4);
  var r           = this.randomInit(seed1, seed2);

  for (var i = 0; i < 8; i++){
    to[i] = Math.floor(this.myRnd(r) * 31) + 64;
  }
  var extra = (Math.floor(this.myRnd(r) * 31));

  for (var i = 0; i < 8; i++){
    to[i] ^= extra;
  }

  return to;
};

Auth.xor32 = function(a, b){
  return [a[0] ^ b[0], a[1] ^ b[1]];
};

Auth.add32 = function(a, b){
  var w1 = a[1] + b[1];
  var w2 = a[0] + b[0] + ((w1 & 0xFFFF0000) >> 16);

  return [w2 & 0xFFFF, w1 & 0xFFFF];
};

Auth.mul32 = function(a, b){
  // based on this example of multiplying 32b ints using 16b
  // http://www.dsprelated.com/showmessage/89790/1.php
  var w1 = a[1] * b[1];
  var w2 = (((a[1] * b[1]) >> 16) & 0xFFFF) + ((a[0] * b[1]) & 0xFFFF) + (a[1] * b[0] & 0xFFFF);

  return [w2 & 0xFFFF, w1 & 0xFFFF];
};

Auth.and32 = function(a, b){
  return [a[0] & b[0], a[1] & b[1]];
};

Auth.shl32 = function(a, b){
  // assume b is 16 or less
  var w1 = a[1] << b;
  var w2 = (a[0] << b) | ((w1 & 0xFFFF0000) >> 16);

  return [w2 & 0xFFFF, w1 & 0xFFFF];
};

Auth.int31Write = function(buffer, number, offset) {
  buffer[offset] = (number[0] >> 8) & 0x7F;
  buffer[offset + 1] = (number[0]) & 0xFF;
  buffer[offset + 2] = (number[1] >> 8) & 0xFF;
  buffer[offset + 3] = (number[1]) & 0xFF;
};

Auth.int32Read = function(buffer, offset){
  return (buffer[offset] << 24)
       + (buffer[offset + 1] << 16)
       + (buffer[offset + 2] << 8)
       + (buffer[offset + 3]);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/BufferList.js":
/***/ ((module) => {


module.exports = BufferList;
function BufferList() {
  this.bufs = [];
  this.size = 0;
}

BufferList.prototype.shift = function shift() {
  var buf = this.bufs.shift();

  if (buf) {
    this.size -= buf.length;
  }

  return buf;
};

BufferList.prototype.push = function push(buf) {
  if (!buf || !buf.length) {
    return;
  }

  this.bufs.push(buf);
  this.size += buf.length;
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/PacketHeader.js":
/***/ ((module) => {

module.exports = PacketHeader;
function PacketHeader(length, number) {
  this.length = length;
  this.number = number;
}


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/PacketWriter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BIT_16            = Math.pow(2, 16);
var BIT_24            = Math.pow(2, 24);
var BUFFER_ALLOC_SIZE = Math.pow(2, 8);
// The maximum precision JS Numbers can hold precisely
// Don't panic: Good enough to represent byte values up to 8192 TB
var IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);
var MAX_PACKET_LENGTH            = Math.pow(2, 24) - 1;
var Buffer                       = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);

module.exports = PacketWriter;
function PacketWriter() {
  this._buffer = null;
  this._offset = 0;
}

PacketWriter.prototype.toBuffer = function toBuffer(parser) {
  if (!this._buffer) {
    this._buffer = Buffer.alloc(0);
    this._offset = 0;
  }

  var buffer  = this._buffer;
  var length  = this._offset;
  var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;

  this._buffer = Buffer.allocUnsafe(length + packets * 4);
  this._offset = 0;

  for (var packet = 0; packet < packets; packet++) {
    var isLast = (packet + 1 === packets);
    var packetLength = (isLast)
      ? length % MAX_PACKET_LENGTH
      : MAX_PACKET_LENGTH;

    var packetNumber = parser.incrementPacketNumber();

    this.writeUnsignedNumber(3, packetLength);
    this.writeUnsignedNumber(1, packetNumber);

    var start = packet * MAX_PACKET_LENGTH;
    var end   = start + packetLength;

    this.writeBuffer(buffer.slice(start, end));
  }

  return this._buffer;
};

PacketWriter.prototype.writeUnsignedNumber = function(bytes, value) {
  this._allocate(bytes);

  for (var i = 0; i < bytes; i++) {
    this._buffer[this._offset++] = (value >> (i * 8)) & 0xff;
  }
};

PacketWriter.prototype.writeFiller = function(bytes) {
  this._allocate(bytes);

  for (var i = 0; i < bytes; i++) {
    this._buffer[this._offset++] = 0x00;
  }
};

PacketWriter.prototype.writeNullTerminatedString = function(value, encoding) {
  // Typecast undefined into '' and numbers into strings
  value = value || '';
  value = value + '';

  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;
  this._allocate(bytes);

  this._buffer.write(value, this._offset, encoding);
  this._buffer[this._offset + bytes - 1] = 0x00;

  this._offset += bytes;
};

PacketWriter.prototype.writeString = function(value) {
  // Typecast undefined into '' and numbers into strings
  value = value || '';
  value = value + '';

  var bytes = Buffer.byteLength(value, 'utf-8');
  this._allocate(bytes);

  this._buffer.write(value, this._offset, 'utf-8');

  this._offset += bytes;
};

PacketWriter.prototype.writeBuffer = function(value) {
  var bytes = value.length;

  this._allocate(bytes);
  value.copy(this._buffer, this._offset);
  this._offset += bytes;
};

PacketWriter.prototype.writeLengthCodedNumber = function(value) {
  if (value === null) {
    this._allocate(1);
    this._buffer[this._offset++] = 251;
    return;
  }

  if (value <= 250) {
    this._allocate(1);
    this._buffer[this._offset++] = value;
    return;
  }

  if (value > IEEE_754_BINARY_64_PRECISION) {
    throw new Error(
      'writeLengthCodedNumber: JS precision range exceeded, your ' +
      'number is > 53 bit: "' + value + '"'
    );
  }

  if (value < BIT_16) {
    this._allocate(3);
    this._buffer[this._offset++] = 252;
  } else if (value < BIT_24) {
    this._allocate(4);
    this._buffer[this._offset++] = 253;
  } else {
    this._allocate(9);
    this._buffer[this._offset++] = 254;
  }

  // 16 Bit
  this._buffer[this._offset++] = value & 0xff;
  this._buffer[this._offset++] = (value >> 8) & 0xff;

  if (value < BIT_16) {
    return;
  }

  // 24 Bit
  this._buffer[this._offset++] = (value >> 16) & 0xff;

  if (value < BIT_24) {
    return;
  }

  this._buffer[this._offset++] = (value >> 24) & 0xff;

  // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)
  value = value.toString(2);
  value = value.substr(0, value.length - 32);
  value = parseInt(value, 2);

  this._buffer[this._offset++] = value & 0xff;
  this._buffer[this._offset++] = (value >> 8) & 0xff;
  this._buffer[this._offset++] = (value >> 16) & 0xff;

  // Set last byte to 0, as we can only support 53 bits in JS (see above)
  this._buffer[this._offset++] = 0;
};

PacketWriter.prototype.writeLengthCodedBuffer = function(value) {
  var bytes = value.length;
  this.writeLengthCodedNumber(bytes);
  this.writeBuffer(value);
};

PacketWriter.prototype.writeNullTerminatedBuffer = function(value) {
  this.writeBuffer(value);
  this.writeFiller(1); // 0x00 terminator
};

PacketWriter.prototype.writeLengthCodedString = function(value) {
  if (value === null) {
    this.writeLengthCodedNumber(null);
    return;
  }

  value = (value === undefined)
    ? ''
    : String(value);

  var bytes = Buffer.byteLength(value, 'utf-8');
  this.writeLengthCodedNumber(bytes);

  if (!bytes) {
    return;
  }

  this._allocate(bytes);
  this._buffer.write(value, this._offset, 'utf-8');
  this._offset += bytes;
};

PacketWriter.prototype._allocate = function _allocate(bytes) {
  if (!this._buffer) {
    this._buffer = Buffer.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));
    this._offset = 0;
    return;
  }

  var bytesRemaining = this._buffer.length - this._offset;
  if (bytesRemaining >= bytes) {
    return;
  }

  var newSize   = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);
  var oldBuffer = this._buffer;

  this._buffer = Buffer.alloc(newSize);
  oldBuffer.copy(this._buffer);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/Parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var PacketHeader = __webpack_require__("./node_modules/mysql/lib/protocol/PacketHeader.js");
var BigNumber    = __webpack_require__("./node_modules/bignumber.js/bignumber.mjs");
var Buffer       = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
var BufferList   = __webpack_require__("./node_modules/mysql/lib/protocol/BufferList.js");

var MAX_PACKET_LENGTH    = Math.pow(2, 24) - 1;
var MUL_32BIT            = Math.pow(2, 32);
var PACKET_HEADER_LENGTH = 4;

module.exports = Parser;
function Parser(options) {
  options = options || {};

  this._supportBigNumbers = options.config && options.config.supportBigNumbers;
  this._buffer            = Buffer.alloc(0);
  this._nextBuffers       = new BufferList();
  this._longPacketBuffers = new BufferList();
  this._offset            = 0;
  this._packetEnd         = null;
  this._packetHeader      = null;
  this._packetOffset      = null;
  this._onError           = options.onError || function(err) { throw err; };
  this._onPacket          = options.onPacket || function() {};
  this._nextPacketNumber  = 0;
  this._encoding          = 'utf-8';
  this._paused            = false;
}

Parser.prototype.write = function write(chunk) {
  this._nextBuffers.push(chunk);

  while (!this._paused) {
    var packetHeader = this._tryReadPacketHeader();

    if (!packetHeader) {
      break;
    }

    if (!this._combineNextBuffers(packetHeader.length)) {
      break;
    }

    this._parsePacket(packetHeader);
  }
};

Parser.prototype.append = function append(chunk) {
  if (!chunk || chunk.length === 0) {
    return;
  }

  // Calculate slice ranges
  var sliceEnd    = this._buffer.length;
  var sliceStart  = this._packetOffset === null
    ? this._offset
    : this._packetOffset;
  var sliceLength = sliceEnd - sliceStart;

  // Get chunk data
  var buffer = null;
  var chunks = !(chunk instanceof Array || Array.isArray(chunk)) ? [chunk] : chunk;
  var length = 0;
  var offset = 0;

  for (var i = 0; i < chunks.length; i++) {
    length += chunks[i].length;
  }

  if (sliceLength !== 0) {
    // Create a new Buffer
    buffer = Buffer.allocUnsafe(sliceLength + length);
    offset = 0;

    // Copy data slice
    offset += this._buffer.copy(buffer, 0, sliceStart, sliceEnd);

    // Copy chunks
    for (var i = 0; i < chunks.length; i++) {
      offset += chunks[i].copy(buffer, offset);
    }
  } else if (chunks.length > 1) {
    // Create a new Buffer
    buffer = Buffer.allocUnsafe(length);
    offset = 0;

    // Copy chunks
    for (var i = 0; i < chunks.length; i++) {
      offset += chunks[i].copy(buffer, offset);
    }
  } else {
    // Buffer is the only chunk
    buffer = chunks[0];
  }

  // Adjust data-tracking pointers
  this._buffer       = buffer;
  this._offset       = this._offset - sliceStart;
  this._packetEnd    = this._packetEnd !== null
    ? this._packetEnd - sliceStart
    : null;
  this._packetOffset = this._packetOffset !== null
    ? this._packetOffset - sliceStart
    : null;
};

Parser.prototype.pause = function() {
  this._paused = true;
};

Parser.prototype.resume = function() {
  this._paused = false;

  // nextTick() to avoid entering write() multiple times within the same stack
  // which would cause problems as write manipulates the state of the object.
  process.nextTick(this.write.bind(this));
};

Parser.prototype.peak = function peak(offset) {
  return this._buffer[this._offset + (offset >>> 0)];
};

Parser.prototype.parseUnsignedNumber = function parseUnsignedNumber(bytes) {
  if (bytes === 1) {
    return this._buffer[this._offset++];
  }

  var buffer = this._buffer;
  var offset = this._offset + bytes - 1;
  var value  = 0;

  if (bytes > 4) {
    var err    = new Error('parseUnsignedNumber: Supports only up to 4 bytes');
    err.offset = (this._offset - this._packetOffset - 1);
    err.code   = 'PARSER_UNSIGNED_TOO_LONG';
    throw err;
  }

  while (offset >= this._offset) {
    value = ((value << 8) | buffer[offset]) >>> 0;
    offset--;
  }

  this._offset += bytes;

  return value;
};

Parser.prototype.parseLengthCodedString = function() {
  var length = this.parseLengthCodedNumber();

  if (length === null) {
    return null;
  }

  return this.parseString(length);
};

Parser.prototype.parseLengthCodedBuffer = function() {
  var length = this.parseLengthCodedNumber();

  if (length === null) {
    return null;
  }

  return this.parseBuffer(length);
};

Parser.prototype.parseLengthCodedNumber = function parseLengthCodedNumber() {
  if (this._offset >= this._buffer.length) {
    var err    = new Error('Parser: read past end');
    err.offset = (this._offset - this._packetOffset);
    err.code   = 'PARSER_READ_PAST_END';
    throw err;
  }

  var bits = this._buffer[this._offset++];

  if (bits <= 250) {
    return bits;
  }

  switch (bits) {
    case 251:
      return null;
    case 252:
      return this.parseUnsignedNumber(2);
    case 253:
      return this.parseUnsignedNumber(3);
    case 254:
      break;
    default:
      var err    = new Error('Unexpected first byte' + (bits ? ': 0x' + bits.toString(16) : ''));
      err.offset = (this._offset - this._packetOffset - 1);
      err.code   = 'PARSER_BAD_LENGTH_BYTE';
      throw err;
  }

  var low = this.parseUnsignedNumber(4);
  var high = this.parseUnsignedNumber(4);
  var value;

  if (high >>> 21) {
    value = BigNumber(MUL_32BIT).times(high).plus(low).toString();

    if (this._supportBigNumbers) {
      return value;
    }

    var err    = new Error(
      'parseLengthCodedNumber: JS precision range exceeded, ' +
      'number is >= 53 bit: "' + value + '"'
    );
    err.offset = (this._offset - this._packetOffset - 8);
    err.code   = 'PARSER_JS_PRECISION_RANGE_EXCEEDED';
    throw err;
  }

  value = low + (MUL_32BIT * high);

  return value;
};

Parser.prototype.parseFiller = function(length) {
  return this.parseBuffer(length);
};

Parser.prototype.parseNullTerminatedBuffer = function() {
  var end      = this._nullByteOffset();
  var value    = this._buffer.slice(this._offset, end);
  this._offset = end + 1;

  return value;
};

Parser.prototype.parseNullTerminatedString = function() {
  var end      = this._nullByteOffset();
  var value    = this._buffer.toString(this._encoding, this._offset, end);
  this._offset = end + 1;

  return value;
};

Parser.prototype._nullByteOffset = function() {
  var offset = this._offset;

  while (this._buffer[offset] !== 0x00) {
    offset++;

    if (offset >= this._buffer.length) {
      var err    = new Error('Offset of null terminated string not found.');
      err.offset = (this._offset - this._packetOffset);
      err.code   = 'PARSER_MISSING_NULL_BYTE';
      throw err;
    }
  }

  return offset;
};

Parser.prototype.parsePacketTerminatedBuffer = function parsePacketTerminatedBuffer() {
  var length = this._packetEnd - this._offset;
  return this.parseBuffer(length);
};

Parser.prototype.parsePacketTerminatedString = function() {
  var length = this._packetEnd - this._offset;
  return this.parseString(length);
};

Parser.prototype.parseBuffer = function(length) {
  var response = Buffer.alloc(length);
  this._buffer.copy(response, 0, this._offset, this._offset + length);

  this._offset += length;
  return response;
};

Parser.prototype.parseString = function(length) {
  var offset = this._offset;
  var end = offset + length;
  var value = this._buffer.toString(this._encoding, offset, end);

  this._offset = end;
  return value;
};

Parser.prototype.parseGeometryValue = function() {
  var buffer = this.parseLengthCodedBuffer();
  var offset = 4;

  if (buffer === null || !buffer.length) {
    return null;
  }

  function parseGeometry() {
    var result = null;
    var byteOrder = buffer.readUInt8(offset); offset += 1;
    var wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
    switch (wkbType) {
      case 1: // WKBPoint
        var x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
        var y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
        result = {x: x, y: y};
        break;
      case 2: // WKBLineString
        var numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
        result = [];
        for (var i = numPoints; i > 0; i--) {
          var x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
          var y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
          result.push({x: x, y: y});
        }
        break;
      case 3: // WKBPolygon
        var numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
        result = [];
        for (var i = numRings; i > 0; i--) {
          var numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
          var line = [];
          for (var j = numPoints; j > 0; j--) {
            var x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
            var y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
            line.push({x: x, y: y});
          }
          result.push(line);
        }
        break;
      case 4: // WKBMultiPoint
      case 5: // WKBMultiLineString
      case 6: // WKBMultiPolygon
      case 7: // WKBGeometryCollection
        var num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
        var result = [];
        for (var i = num; i > 0; i--) {
          result.push(parseGeometry());
        }
        break;
    }
    return result;
  }
  return parseGeometry();
};

Parser.prototype.reachedPacketEnd = function() {
  return this._offset === this._packetEnd;
};

Parser.prototype.incrementPacketNumber = function() {
  var currentPacketNumber = this._nextPacketNumber;
  this._nextPacketNumber = (this._nextPacketNumber + 1) % 256;

  return currentPacketNumber;
};

Parser.prototype.resetPacketNumber = function() {
  this._nextPacketNumber = 0;
};

Parser.prototype.packetLength = function packetLength() {
  if (!this._packetHeader) {
    return null;
  }

  return this._packetHeader.length + this._longPacketBuffers.size;
};

Parser.prototype._combineNextBuffers = function _combineNextBuffers(bytes) {
  var length = this._buffer.length - this._offset;

  if (length >= bytes) {
    return true;
  }

  if ((length + this._nextBuffers.size) < bytes) {
    return false;
  }

  var buffers     = [];
  var bytesNeeded = bytes - length;

  while (bytesNeeded > 0) {
    var buffer = this._nextBuffers.shift();
    buffers.push(buffer);
    bytesNeeded -= buffer.length;
  }

  this.append(buffers);
  return true;
};

Parser.prototype._combineLongPacketBuffers = function _combineLongPacketBuffers() {
  if (!this._longPacketBuffers.size) {
    return;
  }

  // Calculate bytes
  var remainingBytes      = this._buffer.length - this._offset;
  var trailingPacketBytes = this._buffer.length - this._packetEnd;

  // Create buffer
  var buf    = null;
  var buffer = Buffer.allocUnsafe(remainingBytes + this._longPacketBuffers.size);
  var offset = 0;

  // Copy long buffers
  while ((buf = this._longPacketBuffers.shift())) {
    offset += buf.copy(buffer, offset);
  }

  // Copy remaining bytes
  this._buffer.copy(buffer, offset, this._offset);

  this._buffer       = buffer;
  this._offset       = 0;
  this._packetEnd    = this._buffer.length - trailingPacketBytes;
  this._packetOffset = 0;
};

Parser.prototype._parsePacket = function _parsePacket(packetHeader) {
  this._packetEnd    = this._offset + packetHeader.length;
  this._packetOffset = this._offset;

  if (packetHeader.length === MAX_PACKET_LENGTH) {
    this._longPacketBuffers.push(this._buffer.slice(this._packetOffset, this._packetEnd));
    this._advanceToNextPacket();
    return;
  }

  this._combineLongPacketBuffers();

  var hadException = true;
  try {
    this._onPacket(packetHeader);
    hadException = false;
  } catch (err) {
    if (!err || typeof err.code !== 'string' || err.code.substr(0, 7) !== 'PARSER_') {
      throw err; // Rethrow non-MySQL errors
    }

    // Pass down parser errors
    this._onError(err);
    hadException = false;
  } finally {
    this._advanceToNextPacket();

    // If there was an exception, the parser while loop will be broken out
    // of after the finally block. So schedule a blank write to re-enter it
    // to continue parsing any bytes that may already have been received.
    if (hadException) {
      process.nextTick(this.write.bind(this));
    }
  }
};

Parser.prototype._tryReadPacketHeader = function _tryReadPacketHeader() {
  if (this._packetHeader) {
    return this._packetHeader;
  }

  if (!this._combineNextBuffers(PACKET_HEADER_LENGTH)) {
    return null;
  }

  this._packetHeader = new PacketHeader(
    this.parseUnsignedNumber(3),
    this.parseUnsignedNumber(1)
  );

  if (this._packetHeader.number !== this._nextPacketNumber) {
    var err = new Error(
      'Packets out of order. Got: ' + this._packetHeader.number + ' ' +
      'Expected: ' + this._nextPacketNumber
    );

    err.code  = 'PROTOCOL_PACKETS_OUT_OF_ORDER';
    err.fatal = true;

    this._onError(err);
  }

  this.incrementPacketNumber();

  return this._packetHeader;
};

Parser.prototype._advanceToNextPacket = function() {
  this._offset       = this._packetEnd;
  this._packetHeader = null;
  this._packetEnd    = null;
  this._packetOffset = null;
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/Protocol.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Parser       = __webpack_require__("./node_modules/mysql/lib/protocol/Parser.js");
var Sequences    = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/index.js");
var Packets      = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");
var Stream       = (__webpack_require__("stream").Stream);
var Util         = __webpack_require__("util");
var PacketWriter = __webpack_require__("./node_modules/mysql/lib/protocol/PacketWriter.js");

module.exports = Protocol;
Util.inherits(Protocol, Stream);
function Protocol(options) {
  Stream.call(this);

  options = options || {};

  this.readable = true;
  this.writable = true;

  this._config                        = options.config || {};
  this._connection                    = options.connection;
  this._callback                      = null;
  this._fatalError                    = null;
  this._quitSequence                  = null;
  this._handshake                     = false;
  this._handshaked                    = false;
  this._ended                         = false;
  this._destroyed                     = false;
  this._queue                         = [];
  this._handshakeInitializationPacket = null;

  this._parser = new Parser({
    onError  : this.handleParserError.bind(this),
    onPacket : this._parsePacket.bind(this),
    config   : this._config
  });
}

Protocol.prototype.write = function(buffer) {
  this._parser.write(buffer);
  return true;
};

Protocol.prototype.handshake = function handshake(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};
  options.config = this._config;

  var sequence = this._enqueue(new Sequences.Handshake(options, callback));

  this._handshake = true;

  return sequence;
};

Protocol.prototype.query = function query(options, callback) {
  return this._enqueue(new Sequences.Query(options, callback));
};

Protocol.prototype.changeUser = function changeUser(options, callback) {
  return this._enqueue(new Sequences.ChangeUser(options, callback));
};

Protocol.prototype.ping = function ping(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  return this._enqueue(new Sequences.Ping(options, callback));
};

Protocol.prototype.stats = function stats(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  return this._enqueue(new Sequences.Statistics(options, callback));
};

Protocol.prototype.quit = function quit(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  var self     = this;
  var sequence = this._enqueue(new Sequences.Quit(options, callback));

  sequence.on('end', function () {
    self.end();
  });

  return this._quitSequence = sequence;
};

Protocol.prototype.end = function() {
  if (this._ended) {
    return;
  }
  this._ended = true;

  if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {
    this._quitSequence.end();
    this.emit('end');
    return;
  }

  var err = new Error('Connection lost: The server closed the connection.');
  err.fatal = true;
  err.code = 'PROTOCOL_CONNECTION_LOST';

  this._delegateError(err);
};

Protocol.prototype.pause = function() {
  this._parser.pause();
  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.
  var seq = this._queue[0];
  if (seq && seq.emit) {
    seq.emit('pause');
  }
};

Protocol.prototype.resume = function() {
  this._parser.resume();
  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.
  var seq = this._queue[0];
  if (seq && seq.emit) {
    seq.emit('resume');
  }
};

Protocol.prototype._enqueue = function(sequence) {
  if (!this._validateEnqueue(sequence)) {
    return sequence;
  }

  if (this._config.trace) {
    // Long stack trace support
    sequence._callSite = sequence._callSite || new Error();
  }

  this._queue.push(sequence);
  this.emit('enqueue', sequence);

  var self = this;
  sequence
    .on('error', function(err) {
      self._delegateError(err, sequence);
    })
    .on('packet', function(packet) {
      sequence._timer.active();
      self._emitPacket(packet);
    })
    .on('timeout', function() {
      var err = new Error(sequence.constructor.name + ' inactivity timeout');

      err.code    = 'PROTOCOL_SEQUENCE_TIMEOUT';
      err.fatal   = true;
      err.timeout = sequence._timeout;

      self._delegateError(err, sequence);
    });

  if (sequence.constructor === Sequences.Handshake) {
    sequence.on('start-tls', function () {
      sequence._timer.active();
      self._connection._startTLS(function(err) {
        if (err) {
          // SSL negotiation error are fatal
          err.code  = 'HANDSHAKE_SSL_ERROR';
          err.fatal = true;
          sequence.end(err);
          return;
        }

        sequence._timer.active();
        sequence._tlsUpgradeCompleteHandler();
      });
    });

    sequence.on('end', function () {
      self._handshaked = true;

      if (!self._fatalError) {
        self.emit('handshake', self._handshakeInitializationPacket);
      }
    });
  }

  sequence.on('end', function () {
    self._dequeue(sequence);
  });

  if (this._queue.length === 1) {
    this._parser.resetPacketNumber();
    this._startSequence(sequence);
  }

  return sequence;
};

Protocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {
  var err;
  var prefix = 'Cannot enqueue ' + sequence.constructor.name;

  if (this._fatalError) {
    err      = new Error(prefix + ' after fatal error.');
    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';
  } else if (this._quitSequence) {
    err      = new Error(prefix + ' after invoking quit.');
    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';
  } else if (this._destroyed) {
    err      = new Error(prefix + ' after being destroyed.');
    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';
  } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {
    err      = new Error(prefix + ' after already enqueuing a Handshake.');
    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';
  } else {
    return true;
  }

  var self  = this;
  err.fatal = false;

  // add error handler
  sequence.on('error', function (err) {
    self._delegateError(err, sequence);
  });

  process.nextTick(function () {
    sequence.end(err);
  });

  return false;
};

Protocol.prototype._parsePacket = function() {
  var sequence = this._queue[0];

  if (!sequence) {
    var err   = new Error('Received packet with no active sequence.');
    err.code  = 'PROTOCOL_STRAY_PACKET';
    err.fatal = true;

    this._delegateError(err);
    return;
  }

  var Packet     = this._determinePacket(sequence);
  var packet     = new Packet({protocol41: this._config.protocol41});
  var packetName = Packet.name;

  // Special case: Faster dispatch, and parsing done inside sequence
  if (Packet === Packets.RowDataPacket) {
    sequence.RowDataPacket(packet, this._parser, this._connection);

    if (this._config.debug) {
      this._debugPacket(true, packet);
    }

    return;
  }

  if (this._config.debug) {
    this._parsePacketDebug(packet);
  } else {
    packet.parse(this._parser);
  }

  if (Packet === Packets.HandshakeInitializationPacket) {
    this._handshakeInitializationPacket = packet;
    this.emit('initialize', packet);
  }

  sequence._timer.active();

  if (!sequence[packetName]) {
    var err   = new Error('Received packet in the wrong sequence.');
    err.code  = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';
    err.fatal = true;

    this._delegateError(err);
    return;
  }

  sequence[packetName](packet);
};

Protocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {
  try {
    packet.parse(this._parser);
  } finally {
    this._debugPacket(true, packet);
  }
};

Protocol.prototype._emitPacket = function(packet) {
  var packetWriter = new PacketWriter();
  packet.write(packetWriter);
  this.emit('data', packetWriter.toBuffer(this._parser));

  if (this._config.debug) {
    this._debugPacket(false, packet);
  }
};

Protocol.prototype._determinePacket = function(sequence) {
  var firstByte = this._parser.peak();

  if (sequence.determinePacket) {
    var Packet = sequence.determinePacket(firstByte, this._parser);
    if (Packet) {
      return Packet;
    }
  }

  switch (firstByte) {
    case 0x00: return Packets.OkPacket;
    case 0xfe: return Packets.EofPacket;
    case 0xff: return Packets.ErrorPacket;
  }

  throw new Error('Could not determine packet, firstByte = ' + firstByte);
};

Protocol.prototype._dequeue = function(sequence) {
  sequence._timer.stop();

  // No point in advancing the queue, we are dead
  if (this._fatalError) {
    return;
  }

  this._queue.shift();

  var sequence = this._queue[0];
  if (!sequence) {
    this.emit('drain');
    return;
  }

  this._parser.resetPacketNumber();

  this._startSequence(sequence);
};

Protocol.prototype._startSequence = function(sequence) {
  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {
    sequence._timer.start(sequence._timeout);
  }

  if (sequence.constructor === Sequences.ChangeUser) {
    sequence.start(this._handshakeInitializationPacket);
  } else {
    sequence.start();
  }
};

Protocol.prototype.handleNetworkError = function(err) {
  err.fatal = true;

  var sequence = this._queue[0];
  if (sequence) {
    sequence.end(err);
  } else {
    this._delegateError(err);
  }
};

Protocol.prototype.handleParserError = function handleParserError(err) {
  var sequence = this._queue[0];
  if (sequence) {
    sequence.end(err);
  } else {
    this._delegateError(err);
  }
};

Protocol.prototype._delegateError = function(err, sequence) {
  // Stop delegating errors after the first fatal error
  if (this._fatalError) {
    return;
  }

  if (err.fatal) {
    this._fatalError = err;
  }

  if (this._shouldErrorBubbleUp(err, sequence)) {
    // Can't use regular 'error' event here as that always destroys the pipe
    // between socket and protocol which is not what we want (unless the
    // exception was fatal).
    this.emit('unhandledError', err);
  } else if (err.fatal) {
    // Send fatal error to all sequences in the queue
    var queue = this._queue;
    process.nextTick(function () {
      queue.forEach(function (sequence) {
        sequence.end(err);
      });
      queue.length = 0;
    });
  }

  // Make sure the stream we are piping to is getting closed
  if (err.fatal) {
    this.emit('end', err);
  }
};

Protocol.prototype._shouldErrorBubbleUp = function(err, sequence) {
  if (sequence) {
    if (sequence.hasErrorHandler()) {
      return false;
    } else if (!err.fatal) {
      return true;
    }
  }

  return (err.fatal && !this._hasPendingErrorHandlers());
};

Protocol.prototype._hasPendingErrorHandlers = function() {
  return this._queue.some(function(sequence) {
    return sequence.hasErrorHandler();
  });
};

Protocol.prototype.destroy = function() {
  this._destroyed = true;
  this._parser.pause();

  if (this._connection.state !== 'disconnected') {
    if (!this._ended) {
      this.end();
    }
  }
};

Protocol.prototype._debugPacket = function(incoming, packet) {
  var connection = this._connection;
  var direction  = incoming
    ? '<--'
    : '-->';
  var packetName = packet.constructor.name;
  var threadId   = connection && connection.threadId !== null
    ? ' (' + connection.threadId + ')'
    : '';

  // check for debug packet restriction
  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {
    return;
  }

  var packetPayload = Util.inspect(packet).replace(/^[^{]+/, '');

  console.log('%s%s %s %s\n', direction, threadId, packetName, packetPayload);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/ResultSet.js":
/***/ ((module) => {

module.exports = ResultSet;
function ResultSet(resultSetHeaderPacket) {
  this.resultSetHeaderPacket = resultSetHeaderPacket;
  this.fieldPackets          = [];
  this.eofPackets            = [];
  this.rows                  = [];
}


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/SqlString.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("./node_modules/sqlstring/index.js");


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/Timer.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Timers = __webpack_require__("timers");

module.exports = Timer;
function Timer(object) {
  this._object  = object;
  this._timeout = null;
}

Timer.prototype.active = function active() {
  if (this._timeout) {
    if (this._timeout.refresh) {
      this._timeout.refresh();
    } else {
      Timers.active(this._timeout);
    }
  }
};

Timer.prototype.start = function start(msecs) {
  this.stop();
  this._timeout = Timers.setTimeout(this._onTimeout.bind(this), msecs);
};

Timer.prototype.stop = function stop() {
  if (this._timeout) {
    Timers.clearTimeout(this._timeout);
    this._timeout = null;
  }
};

Timer.prototype._onTimeout = function _onTimeout() {
  return this._object._onTimeout();
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/constants/charsets.js":
/***/ ((__unused_webpack_module, exports) => {

exports.BIG5_CHINESE_CI              = 1;
exports.LATIN2_CZECH_CS              = 2;
exports.DEC8_SWEDISH_CI              = 3;
exports.CP850_GENERAL_CI             = 4;
exports.LATIN1_GERMAN1_CI            = 5;
exports.HP8_ENGLISH_CI               = 6;
exports.KOI8R_GENERAL_CI             = 7;
exports.LATIN1_SWEDISH_CI            = 8;
exports.LATIN2_GENERAL_CI            = 9;
exports.SWE7_SWEDISH_CI              = 10;
exports.ASCII_GENERAL_CI             = 11;
exports.UJIS_JAPANESE_CI             = 12;
exports.SJIS_JAPANESE_CI             = 13;
exports.CP1251_BULGARIAN_CI          = 14;
exports.LATIN1_DANISH_CI             = 15;
exports.HEBREW_GENERAL_CI            = 16;
exports.TIS620_THAI_CI               = 18;
exports.EUCKR_KOREAN_CI              = 19;
exports.LATIN7_ESTONIAN_CS           = 20;
exports.LATIN2_HUNGARIAN_CI          = 21;
exports.KOI8U_GENERAL_CI             = 22;
exports.CP1251_UKRAINIAN_CI          = 23;
exports.GB2312_CHINESE_CI            = 24;
exports.GREEK_GENERAL_CI             = 25;
exports.CP1250_GENERAL_CI            = 26;
exports.LATIN2_CROATIAN_CI           = 27;
exports.GBK_CHINESE_CI               = 28;
exports.CP1257_LITHUANIAN_CI         = 29;
exports.LATIN5_TURKISH_CI            = 30;
exports.LATIN1_GERMAN2_CI            = 31;
exports.ARMSCII8_GENERAL_CI          = 32;
exports.UTF8_GENERAL_CI              = 33;
exports.CP1250_CZECH_CS              = 34;
exports.UCS2_GENERAL_CI              = 35;
exports.CP866_GENERAL_CI             = 36;
exports.KEYBCS2_GENERAL_CI           = 37;
exports.MACCE_GENERAL_CI             = 38;
exports.MACROMAN_GENERAL_CI          = 39;
exports.CP852_GENERAL_CI             = 40;
exports.LATIN7_GENERAL_CI            = 41;
exports.LATIN7_GENERAL_CS            = 42;
exports.MACCE_BIN                    = 43;
exports.CP1250_CROATIAN_CI           = 44;
exports.UTF8MB4_GENERAL_CI           = 45;
exports.UTF8MB4_BIN                  = 46;
exports.LATIN1_BIN                   = 47;
exports.LATIN1_GENERAL_CI            = 48;
exports.LATIN1_GENERAL_CS            = 49;
exports.CP1251_BIN                   = 50;
exports.CP1251_GENERAL_CI            = 51;
exports.CP1251_GENERAL_CS            = 52;
exports.MACROMAN_BIN                 = 53;
exports.UTF16_GENERAL_CI             = 54;
exports.UTF16_BIN                    = 55;
exports.UTF16LE_GENERAL_CI           = 56;
exports.CP1256_GENERAL_CI            = 57;
exports.CP1257_BIN                   = 58;
exports.CP1257_GENERAL_CI            = 59;
exports.UTF32_GENERAL_CI             = 60;
exports.UTF32_BIN                    = 61;
exports.UTF16LE_BIN                  = 62;
exports.BINARY                       = 63;
exports.ARMSCII8_BIN                 = 64;
exports.ASCII_BIN                    = 65;
exports.CP1250_BIN                   = 66;
exports.CP1256_BIN                   = 67;
exports.CP866_BIN                    = 68;
exports.DEC8_BIN                     = 69;
exports.GREEK_BIN                    = 70;
exports.HEBREW_BIN                   = 71;
exports.HP8_BIN                      = 72;
exports.KEYBCS2_BIN                  = 73;
exports.KOI8R_BIN                    = 74;
exports.KOI8U_BIN                    = 75;
exports.LATIN2_BIN                   = 77;
exports.LATIN5_BIN                   = 78;
exports.LATIN7_BIN                   = 79;
exports.CP850_BIN                    = 80;
exports.CP852_BIN                    = 81;
exports.SWE7_BIN                     = 82;
exports.UTF8_BIN                     = 83;
exports.BIG5_BIN                     = 84;
exports.EUCKR_BIN                    = 85;
exports.GB2312_BIN                   = 86;
exports.GBK_BIN                      = 87;
exports.SJIS_BIN                     = 88;
exports.TIS620_BIN                   = 89;
exports.UCS2_BIN                     = 90;
exports.UJIS_BIN                     = 91;
exports.GEOSTD8_GENERAL_CI           = 92;
exports.GEOSTD8_BIN                  = 93;
exports.LATIN1_SPANISH_CI            = 94;
exports.CP932_JAPANESE_CI            = 95;
exports.CP932_BIN                    = 96;
exports.EUCJPMS_JAPANESE_CI          = 97;
exports.EUCJPMS_BIN                  = 98;
exports.CP1250_POLISH_CI             = 99;
exports.UTF16_UNICODE_CI             = 101;
exports.UTF16_ICELANDIC_CI           = 102;
exports.UTF16_LATVIAN_CI             = 103;
exports.UTF16_ROMANIAN_CI            = 104;
exports.UTF16_SLOVENIAN_CI           = 105;
exports.UTF16_POLISH_CI              = 106;
exports.UTF16_ESTONIAN_CI            = 107;
exports.UTF16_SPANISH_CI             = 108;
exports.UTF16_SWEDISH_CI             = 109;
exports.UTF16_TURKISH_CI             = 110;
exports.UTF16_CZECH_CI               = 111;
exports.UTF16_DANISH_CI              = 112;
exports.UTF16_LITHUANIAN_CI          = 113;
exports.UTF16_SLOVAK_CI              = 114;
exports.UTF16_SPANISH2_CI            = 115;
exports.UTF16_ROMAN_CI               = 116;
exports.UTF16_PERSIAN_CI             = 117;
exports.UTF16_ESPERANTO_CI           = 118;
exports.UTF16_HUNGARIAN_CI           = 119;
exports.UTF16_SINHALA_CI             = 120;
exports.UTF16_GERMAN2_CI             = 121;
exports.UTF16_CROATIAN_MYSQL561_CI   = 122;
exports.UTF16_UNICODE_520_CI         = 123;
exports.UTF16_VIETNAMESE_CI          = 124;
exports.UCS2_UNICODE_CI              = 128;
exports.UCS2_ICELANDIC_CI            = 129;
exports.UCS2_LATVIAN_CI              = 130;
exports.UCS2_ROMANIAN_CI             = 131;
exports.UCS2_SLOVENIAN_CI            = 132;
exports.UCS2_POLISH_CI               = 133;
exports.UCS2_ESTONIAN_CI             = 134;
exports.UCS2_SPANISH_CI              = 135;
exports.UCS2_SWEDISH_CI              = 136;
exports.UCS2_TURKISH_CI              = 137;
exports.UCS2_CZECH_CI                = 138;
exports.UCS2_DANISH_CI               = 139;
exports.UCS2_LITHUANIAN_CI           = 140;
exports.UCS2_SLOVAK_CI               = 141;
exports.UCS2_SPANISH2_CI             = 142;
exports.UCS2_ROMAN_CI                = 143;
exports.UCS2_PERSIAN_CI              = 144;
exports.UCS2_ESPERANTO_CI            = 145;
exports.UCS2_HUNGARIAN_CI            = 146;
exports.UCS2_SINHALA_CI              = 147;
exports.UCS2_GERMAN2_CI              = 148;
exports.UCS2_CROATIAN_MYSQL561_CI    = 149;
exports.UCS2_UNICODE_520_CI          = 150;
exports.UCS2_VIETNAMESE_CI           = 151;
exports.UCS2_GENERAL_MYSQL500_CI     = 159;
exports.UTF32_UNICODE_CI             = 160;
exports.UTF32_ICELANDIC_CI           = 161;
exports.UTF32_LATVIAN_CI             = 162;
exports.UTF32_ROMANIAN_CI            = 163;
exports.UTF32_SLOVENIAN_CI           = 164;
exports.UTF32_POLISH_CI              = 165;
exports.UTF32_ESTONIAN_CI            = 166;
exports.UTF32_SPANISH_CI             = 167;
exports.UTF32_SWEDISH_CI             = 168;
exports.UTF32_TURKISH_CI             = 169;
exports.UTF32_CZECH_CI               = 170;
exports.UTF32_DANISH_CI              = 171;
exports.UTF32_LITHUANIAN_CI          = 172;
exports.UTF32_SLOVAK_CI              = 173;
exports.UTF32_SPANISH2_CI            = 174;
exports.UTF32_ROMAN_CI               = 175;
exports.UTF32_PERSIAN_CI             = 176;
exports.UTF32_ESPERANTO_CI           = 177;
exports.UTF32_HUNGARIAN_CI           = 178;
exports.UTF32_SINHALA_CI             = 179;
exports.UTF32_GERMAN2_CI             = 180;
exports.UTF32_CROATIAN_MYSQL561_CI   = 181;
exports.UTF32_UNICODE_520_CI         = 182;
exports.UTF32_VIETNAMESE_CI          = 183;
exports.UTF8_UNICODE_CI              = 192;
exports.UTF8_ICELANDIC_CI            = 193;
exports.UTF8_LATVIAN_CI              = 194;
exports.UTF8_ROMANIAN_CI             = 195;
exports.UTF8_SLOVENIAN_CI            = 196;
exports.UTF8_POLISH_CI               = 197;
exports.UTF8_ESTONIAN_CI             = 198;
exports.UTF8_SPANISH_CI              = 199;
exports.UTF8_SWEDISH_CI              = 200;
exports.UTF8_TURKISH_CI              = 201;
exports.UTF8_CZECH_CI                = 202;
exports.UTF8_DANISH_CI               = 203;
exports.UTF8_LITHUANIAN_CI           = 204;
exports.UTF8_SLOVAK_CI               = 205;
exports.UTF8_SPANISH2_CI             = 206;
exports.UTF8_ROMAN_CI                = 207;
exports.UTF8_PERSIAN_CI              = 208;
exports.UTF8_ESPERANTO_CI            = 209;
exports.UTF8_HUNGARIAN_CI            = 210;
exports.UTF8_SINHALA_CI              = 211;
exports.UTF8_GERMAN2_CI              = 212;
exports.UTF8_CROATIAN_MYSQL561_CI    = 213;
exports.UTF8_UNICODE_520_CI          = 214;
exports.UTF8_VIETNAMESE_CI           = 215;
exports.UTF8_GENERAL_MYSQL500_CI     = 223;
exports.UTF8MB4_UNICODE_CI           = 224;
exports.UTF8MB4_ICELANDIC_CI         = 225;
exports.UTF8MB4_LATVIAN_CI           = 226;
exports.UTF8MB4_ROMANIAN_CI          = 227;
exports.UTF8MB4_SLOVENIAN_CI         = 228;
exports.UTF8MB4_POLISH_CI            = 229;
exports.UTF8MB4_ESTONIAN_CI          = 230;
exports.UTF8MB4_SPANISH_CI           = 231;
exports.UTF8MB4_SWEDISH_CI           = 232;
exports.UTF8MB4_TURKISH_CI           = 233;
exports.UTF8MB4_CZECH_CI             = 234;
exports.UTF8MB4_DANISH_CI            = 235;
exports.UTF8MB4_LITHUANIAN_CI        = 236;
exports.UTF8MB4_SLOVAK_CI            = 237;
exports.UTF8MB4_SPANISH2_CI          = 238;
exports.UTF8MB4_ROMAN_CI             = 239;
exports.UTF8MB4_PERSIAN_CI           = 240;
exports.UTF8MB4_ESPERANTO_CI         = 241;
exports.UTF8MB4_HUNGARIAN_CI         = 242;
exports.UTF8MB4_SINHALA_CI           = 243;
exports.UTF8MB4_GERMAN2_CI           = 244;
exports.UTF8MB4_CROATIAN_MYSQL561_CI = 245;
exports.UTF8MB4_UNICODE_520_CI       = 246;
exports.UTF8MB4_VIETNAMESE_CI        = 247;
exports.UTF8_GENERAL50_CI            = 253;

// short aliases
exports.ARMSCII8 = exports.ARMSCII8_GENERAL_CI;
exports.ASCII    = exports.ASCII_GENERAL_CI;
exports.BIG5     = exports.BIG5_CHINESE_CI;
exports.BINARY   = exports.BINARY;
exports.CP1250   = exports.CP1250_GENERAL_CI;
exports.CP1251   = exports.CP1251_GENERAL_CI;
exports.CP1256   = exports.CP1256_GENERAL_CI;
exports.CP1257   = exports.CP1257_GENERAL_CI;
exports.CP866    = exports.CP866_GENERAL_CI;
exports.CP850    = exports.CP850_GENERAL_CI;
exports.CP852    = exports.CP852_GENERAL_CI;
exports.CP932    = exports.CP932_JAPANESE_CI;
exports.DEC8     = exports.DEC8_SWEDISH_CI;
exports.EUCJPMS  = exports.EUCJPMS_JAPANESE_CI;
exports.EUCKR    = exports.EUCKR_KOREAN_CI;
exports.GB2312   = exports.GB2312_CHINESE_CI;
exports.GBK      = exports.GBK_CHINESE_CI;
exports.GEOSTD8  = exports.GEOSTD8_GENERAL_CI;
exports.GREEK    = exports.GREEK_GENERAL_CI;
exports.HEBREW   = exports.HEBREW_GENERAL_CI;
exports.HP8      = exports.HP8_ENGLISH_CI;
exports.KEYBCS2  = exports.KEYBCS2_GENERAL_CI;
exports.KOI8R    = exports.KOI8R_GENERAL_CI;
exports.KOI8U    = exports.KOI8U_GENERAL_CI;
exports.LATIN1   = exports.LATIN1_SWEDISH_CI;
exports.LATIN2   = exports.LATIN2_GENERAL_CI;
exports.LATIN5   = exports.LATIN5_TURKISH_CI;
exports.LATIN7   = exports.LATIN7_GENERAL_CI;
exports.MACCE    = exports.MACCE_GENERAL_CI;
exports.MACROMAN = exports.MACROMAN_GENERAL_CI;
exports.SJIS     = exports.SJIS_JAPANESE_CI;
exports.SWE7     = exports.SWE7_SWEDISH_CI;
exports.TIS620   = exports.TIS620_THAI_CI;
exports.UCS2     = exports.UCS2_GENERAL_CI;
exports.UJIS     = exports.UJIS_JAPANESE_CI;
exports.UTF16    = exports.UTF16_GENERAL_CI;
exports.UTF16LE  = exports.UTF16LE_GENERAL_CI;
exports.UTF8     = exports.UTF8_GENERAL_CI;
exports.UTF8MB4  = exports.UTF8MB4_GENERAL_CI;
exports.UTF32    = exports.UTF32_GENERAL_CI;


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/constants/client.js":
/***/ ((__unused_webpack_module, exports) => {

// Manually extracted from mysql-5.5.23/include/mysql_com.h
exports.CLIENT_LONG_PASSWORD     = 1; /* new more secure passwords */
exports.CLIENT_FOUND_ROWS        = 2; /* Found instead of affected rows */
exports.CLIENT_LONG_FLAG         = 4; /* Get all column flags */
exports.CLIENT_CONNECT_WITH_DB   = 8; /* One can specify db on connect */
exports.CLIENT_NO_SCHEMA         = 16; /* Don't allow database.table.column */
exports.CLIENT_COMPRESS          = 32; /* Can use compression protocol */
exports.CLIENT_ODBC              = 64; /* Odbc client */
exports.CLIENT_LOCAL_FILES       = 128; /* Can use LOAD DATA LOCAL */
exports.CLIENT_IGNORE_SPACE      = 256; /* Ignore spaces before '(' */
exports.CLIENT_PROTOCOL_41       = 512; /* New 4.1 protocol */
exports.CLIENT_INTERACTIVE       = 1024; /* This is an interactive client */
exports.CLIENT_SSL               = 2048; /* Switch to SSL after handshake */
exports.CLIENT_IGNORE_SIGPIPE    = 4096;    /* IGNORE sigpipes */
exports.CLIENT_TRANSACTIONS      = 8192; /* Client knows about transactions */
exports.CLIENT_RESERVED          = 16384;   /* Old flag for 4.1 protocol  */
exports.CLIENT_SECURE_CONNECTION = 32768;  /* New 4.1 authentication */

exports.CLIENT_MULTI_STATEMENTS = 65536; /* Enable/disable multi-stmt support */
exports.CLIENT_MULTI_RESULTS    = 131072; /* Enable/disable multi-results */
exports.CLIENT_PS_MULTI_RESULTS = 262144; /* Multi-results in PS-protocol */

exports.CLIENT_PLUGIN_AUTH = 524288; /* Client supports plugin authentication */

exports.CLIENT_SSL_VERIFY_SERVER_CERT = 1073741824;
exports.CLIENT_REMEMBER_OPTIONS       = 2147483648;


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/constants/errors.js":
/***/ ((__unused_webpack_module, exports) => {

/**
 * MySQL error constants
 *
 * Extracted from version 5.7.29
 *
 * !! Generated by generate-error-constants.js, do not modify by hand !!
 */

exports.EE_CANTCREATEFILE                                                                = 1;
exports.EE_READ                                                                          = 2;
exports.EE_WRITE                                                                         = 3;
exports.EE_BADCLOSE                                                                      = 4;
exports.EE_OUTOFMEMORY                                                                   = 5;
exports.EE_DELETE                                                                        = 6;
exports.EE_LINK                                                                          = 7;
exports.EE_EOFERR                                                                        = 9;
exports.EE_CANTLOCK                                                                      = 10;
exports.EE_CANTUNLOCK                                                                    = 11;
exports.EE_DIR                                                                           = 12;
exports.EE_STAT                                                                          = 13;
exports.EE_CANT_CHSIZE                                                                   = 14;
exports.EE_CANT_OPEN_STREAM                                                              = 15;
exports.EE_GETWD                                                                         = 16;
exports.EE_SETWD                                                                         = 17;
exports.EE_LINK_WARNING                                                                  = 18;
exports.EE_OPEN_WARNING                                                                  = 19;
exports.EE_DISK_FULL                                                                     = 20;
exports.EE_CANT_MKDIR                                                                    = 21;
exports.EE_UNKNOWN_CHARSET                                                               = 22;
exports.EE_OUT_OF_FILERESOURCES                                                          = 23;
exports.EE_CANT_READLINK                                                                 = 24;
exports.EE_CANT_SYMLINK                                                                  = 25;
exports.EE_REALPATH                                                                      = 26;
exports.EE_SYNC                                                                          = 27;
exports.EE_UNKNOWN_COLLATION                                                             = 28;
exports.EE_FILENOTFOUND                                                                  = 29;
exports.EE_FILE_NOT_CLOSED                                                               = 30;
exports.EE_CHANGE_OWNERSHIP                                                              = 31;
exports.EE_CHANGE_PERMISSIONS                                                            = 32;
exports.EE_CANT_SEEK                                                                     = 33;
exports.EE_CAPACITY_EXCEEDED                                                             = 34;
exports.HA_ERR_KEY_NOT_FOUND                                                             = 120;
exports.HA_ERR_FOUND_DUPP_KEY                                                            = 121;
exports.HA_ERR_INTERNAL_ERROR                                                            = 122;
exports.HA_ERR_RECORD_CHANGED                                                            = 123;
exports.HA_ERR_WRONG_INDEX                                                               = 124;
exports.HA_ERR_CRASHED                                                                   = 126;
exports.HA_ERR_WRONG_IN_RECORD                                                           = 127;
exports.HA_ERR_OUT_OF_MEM                                                                = 128;
exports.HA_ERR_NOT_A_TABLE                                                               = 130;
exports.HA_ERR_WRONG_COMMAND                                                             = 131;
exports.HA_ERR_OLD_FILE                                                                  = 132;
exports.HA_ERR_NO_ACTIVE_RECORD                                                          = 133;
exports.HA_ERR_RECORD_DELETED                                                            = 134;
exports.HA_ERR_RECORD_FILE_FULL                                                          = 135;
exports.HA_ERR_INDEX_FILE_FULL                                                           = 136;
exports.HA_ERR_END_OF_FILE                                                               = 137;
exports.HA_ERR_UNSUPPORTED                                                               = 138;
exports.HA_ERR_TOO_BIG_ROW                                                               = 139;
exports.HA_WRONG_CREATE_OPTION                                                           = 140;
exports.HA_ERR_FOUND_DUPP_UNIQUE                                                         = 141;
exports.HA_ERR_UNKNOWN_CHARSET                                                           = 142;
exports.HA_ERR_WRONG_MRG_TABLE_DEF                                                       = 143;
exports.HA_ERR_CRASHED_ON_REPAIR                                                         = 144;
exports.HA_ERR_CRASHED_ON_USAGE                                                          = 145;
exports.HA_ERR_LOCK_WAIT_TIMEOUT                                                         = 146;
exports.HA_ERR_LOCK_TABLE_FULL                                                           = 147;
exports.HA_ERR_READ_ONLY_TRANSACTION                                                     = 148;
exports.HA_ERR_LOCK_DEADLOCK                                                             = 149;
exports.HA_ERR_CANNOT_ADD_FOREIGN                                                        = 150;
exports.HA_ERR_NO_REFERENCED_ROW                                                         = 151;
exports.HA_ERR_ROW_IS_REFERENCED                                                         = 152;
exports.HA_ERR_NO_SAVEPOINT                                                              = 153;
exports.HA_ERR_NON_UNIQUE_BLOCK_SIZE                                                     = 154;
exports.HA_ERR_NO_SUCH_TABLE                                                             = 155;
exports.HA_ERR_TABLE_EXIST                                                               = 156;
exports.HA_ERR_NO_CONNECTION                                                             = 157;
exports.HA_ERR_NULL_IN_SPATIAL                                                           = 158;
exports.HA_ERR_TABLE_DEF_CHANGED                                                         = 159;
exports.HA_ERR_NO_PARTITION_FOUND                                                        = 160;
exports.HA_ERR_RBR_LOGGING_FAILED                                                        = 161;
exports.HA_ERR_DROP_INDEX_FK                                                             = 162;
exports.HA_ERR_FOREIGN_DUPLICATE_KEY                                                     = 163;
exports.HA_ERR_TABLE_NEEDS_UPGRADE                                                       = 164;
exports.HA_ERR_TABLE_READONLY                                                            = 165;
exports.HA_ERR_AUTOINC_READ_FAILED                                                       = 166;
exports.HA_ERR_AUTOINC_ERANGE                                                            = 167;
exports.HA_ERR_GENERIC                                                                   = 168;
exports.HA_ERR_RECORD_IS_THE_SAME                                                        = 169;
exports.HA_ERR_LOGGING_IMPOSSIBLE                                                        = 170;
exports.HA_ERR_CORRUPT_EVENT                                                             = 171;
exports.HA_ERR_NEW_FILE                                                                  = 172;
exports.HA_ERR_ROWS_EVENT_APPLY                                                          = 173;
exports.HA_ERR_INITIALIZATION                                                            = 174;
exports.HA_ERR_FILE_TOO_SHORT                                                            = 175;
exports.HA_ERR_WRONG_CRC                                                                 = 176;
exports.HA_ERR_TOO_MANY_CONCURRENT_TRXS                                                  = 177;
exports.HA_ERR_NOT_IN_LOCK_PARTITIONS                                                    = 178;
exports.HA_ERR_INDEX_COL_TOO_LONG                                                        = 179;
exports.HA_ERR_INDEX_CORRUPT                                                             = 180;
exports.HA_ERR_UNDO_REC_TOO_BIG                                                          = 181;
exports.HA_FTS_INVALID_DOCID                                                             = 182;
exports.HA_ERR_TABLE_IN_FK_CHECK                                                         = 183;
exports.HA_ERR_TABLESPACE_EXISTS                                                         = 184;
exports.HA_ERR_TOO_MANY_FIELDS                                                           = 185;
exports.HA_ERR_ROW_IN_WRONG_PARTITION                                                    = 186;
exports.HA_ERR_INNODB_READ_ONLY                                                          = 187;
exports.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT                                             = 188;
exports.HA_ERR_TEMP_FILE_WRITE_FAILURE                                                   = 189;
exports.HA_ERR_INNODB_FORCED_RECOVERY                                                    = 190;
exports.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE                                              = 191;
exports.HA_ERR_FK_DEPTH_EXCEEDED                                                         = 192;
exports.HA_MISSING_CREATE_OPTION                                                         = 193;
exports.HA_ERR_SE_OUT_OF_MEMORY                                                          = 194;
exports.HA_ERR_TABLE_CORRUPT                                                             = 195;
exports.HA_ERR_QUERY_INTERRUPTED                                                         = 196;
exports.HA_ERR_TABLESPACE_MISSING                                                        = 197;
exports.HA_ERR_TABLESPACE_IS_NOT_EMPTY                                                   = 198;
exports.HA_ERR_WRONG_FILE_NAME                                                           = 199;
exports.HA_ERR_NOT_ALLOWED_COMMAND                                                       = 200;
exports.HA_ERR_COMPUTE_FAILED                                                            = 201;
exports.ER_HASHCHK                                                                       = 1000;
exports.ER_NISAMCHK                                                                      = 1001;
exports.ER_NO                                                                            = 1002;
exports.ER_YES                                                                           = 1003;
exports.ER_CANT_CREATE_FILE                                                              = 1004;
exports.ER_CANT_CREATE_TABLE                                                             = 1005;
exports.ER_CANT_CREATE_DB                                                                = 1006;
exports.ER_DB_CREATE_EXISTS                                                              = 1007;
exports.ER_DB_DROP_EXISTS                                                                = 1008;
exports.ER_DB_DROP_DELETE                                                                = 1009;
exports.ER_DB_DROP_RMDIR                                                                 = 1010;
exports.ER_CANT_DELETE_FILE                                                              = 1011;
exports.ER_CANT_FIND_SYSTEM_REC                                                          = 1012;
exports.ER_CANT_GET_STAT                                                                 = 1013;
exports.ER_CANT_GET_WD                                                                   = 1014;
exports.ER_CANT_LOCK                                                                     = 1015;
exports.ER_CANT_OPEN_FILE                                                                = 1016;
exports.ER_FILE_NOT_FOUND                                                                = 1017;
exports.ER_CANT_READ_DIR                                                                 = 1018;
exports.ER_CANT_SET_WD                                                                   = 1019;
exports.ER_CHECKREAD                                                                     = 1020;
exports.ER_DISK_FULL                                                                     = 1021;
exports.ER_DUP_KEY                                                                       = 1022;
exports.ER_ERROR_ON_CLOSE                                                                = 1023;
exports.ER_ERROR_ON_READ                                                                 = 1024;
exports.ER_ERROR_ON_RENAME                                                               = 1025;
exports.ER_ERROR_ON_WRITE                                                                = 1026;
exports.ER_FILE_USED                                                                     = 1027;
exports.ER_FILSORT_ABORT                                                                 = 1028;
exports.ER_FORM_NOT_FOUND                                                                = 1029;
exports.ER_GET_ERRNO                                                                     = 1030;
exports.ER_ILLEGAL_HA                                                                    = 1031;
exports.ER_KEY_NOT_FOUND                                                                 = 1032;
exports.ER_NOT_FORM_FILE                                                                 = 1033;
exports.ER_NOT_KEYFILE                                                                   = 1034;
exports.ER_OLD_KEYFILE                                                                   = 1035;
exports.ER_OPEN_AS_READONLY                                                              = 1036;
exports.ER_OUTOFMEMORY                                                                   = 1037;
exports.ER_OUT_OF_SORTMEMORY                                                             = 1038;
exports.ER_UNEXPECTED_EOF                                                                = 1039;
exports.ER_CON_COUNT_ERROR                                                               = 1040;
exports.ER_OUT_OF_RESOURCES                                                              = 1041;
exports.ER_BAD_HOST_ERROR                                                                = 1042;
exports.ER_HANDSHAKE_ERROR                                                               = 1043;
exports.ER_DBACCESS_DENIED_ERROR                                                         = 1044;
exports.ER_ACCESS_DENIED_ERROR                                                           = 1045;
exports.ER_NO_DB_ERROR                                                                   = 1046;
exports.ER_UNKNOWN_COM_ERROR                                                             = 1047;
exports.ER_BAD_NULL_ERROR                                                                = 1048;
exports.ER_BAD_DB_ERROR                                                                  = 1049;
exports.ER_TABLE_EXISTS_ERROR                                                            = 1050;
exports.ER_BAD_TABLE_ERROR                                                               = 1051;
exports.ER_NON_UNIQ_ERROR                                                                = 1052;
exports.ER_SERVER_SHUTDOWN                                                               = 1053;
exports.ER_BAD_FIELD_ERROR                                                               = 1054;
exports.ER_WRONG_FIELD_WITH_GROUP                                                        = 1055;
exports.ER_WRONG_GROUP_FIELD                                                             = 1056;
exports.ER_WRONG_SUM_SELECT                                                              = 1057;
exports.ER_WRONG_VALUE_COUNT                                                             = 1058;
exports.ER_TOO_LONG_IDENT                                                                = 1059;
exports.ER_DUP_FIELDNAME                                                                 = 1060;
exports.ER_DUP_KEYNAME                                                                   = 1061;
exports.ER_DUP_ENTRY                                                                     = 1062;
exports.ER_WRONG_FIELD_SPEC                                                              = 1063;
exports.ER_PARSE_ERROR                                                                   = 1064;
exports.ER_EMPTY_QUERY                                                                   = 1065;
exports.ER_NONUNIQ_TABLE                                                                 = 1066;
exports.ER_INVALID_DEFAULT                                                               = 1067;
exports.ER_MULTIPLE_PRI_KEY                                                              = 1068;
exports.ER_TOO_MANY_KEYS                                                                 = 1069;
exports.ER_TOO_MANY_KEY_PARTS                                                            = 1070;
exports.ER_TOO_LONG_KEY                                                                  = 1071;
exports.ER_KEY_COLUMN_DOES_NOT_EXITS                                                     = 1072;
exports.ER_BLOB_USED_AS_KEY                                                              = 1073;
exports.ER_TOO_BIG_FIELDLENGTH                                                           = 1074;
exports.ER_WRONG_AUTO_KEY                                                                = 1075;
exports.ER_READY                                                                         = 1076;
exports.ER_NORMAL_SHUTDOWN                                                               = 1077;
exports.ER_GOT_SIGNAL                                                                    = 1078;
exports.ER_SHUTDOWN_COMPLETE                                                             = 1079;
exports.ER_FORCING_CLOSE                                                                 = 1080;
exports.ER_IPSOCK_ERROR                                                                  = 1081;
exports.ER_NO_SUCH_INDEX                                                                 = 1082;
exports.ER_WRONG_FIELD_TERMINATORS                                                       = 1083;
exports.ER_BLOBS_AND_NO_TERMINATED                                                       = 1084;
exports.ER_TEXTFILE_NOT_READABLE                                                         = 1085;
exports.ER_FILE_EXISTS_ERROR                                                             = 1086;
exports.ER_LOAD_INFO                                                                     = 1087;
exports.ER_ALTER_INFO                                                                    = 1088;
exports.ER_WRONG_SUB_KEY                                                                 = 1089;
exports.ER_CANT_REMOVE_ALL_FIELDS                                                        = 1090;
exports.ER_CANT_DROP_FIELD_OR_KEY                                                        = 1091;
exports.ER_INSERT_INFO                                                                   = 1092;
exports.ER_UPDATE_TABLE_USED                                                             = 1093;
exports.ER_NO_SUCH_THREAD                                                                = 1094;
exports.ER_KILL_DENIED_ERROR                                                             = 1095;
exports.ER_NO_TABLES_USED                                                                = 1096;
exports.ER_TOO_BIG_SET                                                                   = 1097;
exports.ER_NO_UNIQUE_LOGFILE                                                             = 1098;
exports.ER_TABLE_NOT_LOCKED_FOR_WRITE                                                    = 1099;
exports.ER_TABLE_NOT_LOCKED                                                              = 1100;
exports.ER_BLOB_CANT_HAVE_DEFAULT                                                        = 1101;
exports.ER_WRONG_DB_NAME                                                                 = 1102;
exports.ER_WRONG_TABLE_NAME                                                              = 1103;
exports.ER_TOO_BIG_SELECT                                                                = 1104;
exports.ER_UNKNOWN_ERROR                                                                 = 1105;
exports.ER_UNKNOWN_PROCEDURE                                                             = 1106;
exports.ER_WRONG_PARAMCOUNT_TO_PROCEDURE                                                 = 1107;
exports.ER_WRONG_PARAMETERS_TO_PROCEDURE                                                 = 1108;
exports.ER_UNKNOWN_TABLE                                                                 = 1109;
exports.ER_FIELD_SPECIFIED_TWICE                                                         = 1110;
exports.ER_INVALID_GROUP_FUNC_USE                                                        = 1111;
exports.ER_UNSUPPORTED_EXTENSION                                                         = 1112;
exports.ER_TABLE_MUST_HAVE_COLUMNS                                                       = 1113;
exports.ER_RECORD_FILE_FULL                                                              = 1114;
exports.ER_UNKNOWN_CHARACTER_SET                                                         = 1115;
exports.ER_TOO_MANY_TABLES                                                               = 1116;
exports.ER_TOO_MANY_FIELDS                                                               = 1117;
exports.ER_TOO_BIG_ROWSIZE                                                               = 1118;
exports.ER_STACK_OVERRUN                                                                 = 1119;
exports.ER_WRONG_OUTER_JOIN                                                              = 1120;
exports.ER_NULL_COLUMN_IN_INDEX                                                          = 1121;
exports.ER_CANT_FIND_UDF                                                                 = 1122;
exports.ER_CANT_INITIALIZE_UDF                                                           = 1123;
exports.ER_UDF_NO_PATHS                                                                  = 1124;
exports.ER_UDF_EXISTS                                                                    = 1125;
exports.ER_CANT_OPEN_LIBRARY                                                             = 1126;
exports.ER_CANT_FIND_DL_ENTRY                                                            = 1127;
exports.ER_FUNCTION_NOT_DEFINED                                                          = 1128;
exports.ER_HOST_IS_BLOCKED                                                               = 1129;
exports.ER_HOST_NOT_PRIVILEGED                                                           = 1130;
exports.ER_PASSWORD_ANONYMOUS_USER                                                       = 1131;
exports.ER_PASSWORD_NOT_ALLOWED                                                          = 1132;
exports.ER_PASSWORD_NO_MATCH                                                             = 1133;
exports.ER_UPDATE_INFO                                                                   = 1134;
exports.ER_CANT_CREATE_THREAD                                                            = 1135;
exports.ER_WRONG_VALUE_COUNT_ON_ROW                                                      = 1136;
exports.ER_CANT_REOPEN_TABLE                                                             = 1137;
exports.ER_INVALID_USE_OF_NULL                                                           = 1138;
exports.ER_REGEXP_ERROR                                                                  = 1139;
exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS                                                  = 1140;
exports.ER_NONEXISTING_GRANT                                                             = 1141;
exports.ER_TABLEACCESS_DENIED_ERROR                                                      = 1142;
exports.ER_COLUMNACCESS_DENIED_ERROR                                                     = 1143;
exports.ER_ILLEGAL_GRANT_FOR_TABLE                                                       = 1144;
exports.ER_GRANT_WRONG_HOST_OR_USER                                                      = 1145;
exports.ER_NO_SUCH_TABLE                                                                 = 1146;
exports.ER_NONEXISTING_TABLE_GRANT                                                       = 1147;
exports.ER_NOT_ALLOWED_COMMAND                                                           = 1148;
exports.ER_SYNTAX_ERROR                                                                  = 1149;
exports.ER_DELAYED_CANT_CHANGE_LOCK                                                      = 1150;
exports.ER_TOO_MANY_DELAYED_THREADS                                                      = 1151;
exports.ER_ABORTING_CONNECTION                                                           = 1152;
exports.ER_NET_PACKET_TOO_LARGE                                                          = 1153;
exports.ER_NET_READ_ERROR_FROM_PIPE                                                      = 1154;
exports.ER_NET_FCNTL_ERROR                                                               = 1155;
exports.ER_NET_PACKETS_OUT_OF_ORDER                                                      = 1156;
exports.ER_NET_UNCOMPRESS_ERROR                                                          = 1157;
exports.ER_NET_READ_ERROR                                                                = 1158;
exports.ER_NET_READ_INTERRUPTED                                                          = 1159;
exports.ER_NET_ERROR_ON_WRITE                                                            = 1160;
exports.ER_NET_WRITE_INTERRUPTED                                                         = 1161;
exports.ER_TOO_LONG_STRING                                                               = 1162;
exports.ER_TABLE_CANT_HANDLE_BLOB                                                        = 1163;
exports.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT                                              = 1164;
exports.ER_DELAYED_INSERT_TABLE_LOCKED                                                   = 1165;
exports.ER_WRONG_COLUMN_NAME                                                             = 1166;
exports.ER_WRONG_KEY_COLUMN                                                              = 1167;
exports.ER_WRONG_MRG_TABLE                                                               = 1168;
exports.ER_DUP_UNIQUE                                                                    = 1169;
exports.ER_BLOB_KEY_WITHOUT_LENGTH                                                       = 1170;
exports.ER_PRIMARY_CANT_HAVE_NULL                                                        = 1171;
exports.ER_TOO_MANY_ROWS                                                                 = 1172;
exports.ER_REQUIRES_PRIMARY_KEY                                                          = 1173;
exports.ER_NO_RAID_COMPILED                                                              = 1174;
exports.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE                                               = 1175;
exports.ER_KEY_DOES_NOT_EXITS                                                            = 1176;
exports.ER_CHECK_NO_SUCH_TABLE                                                           = 1177;
exports.ER_CHECK_NOT_IMPLEMENTED                                                         = 1178;
exports.ER_CANT_DO_THIS_DURING_AN_TRANSACTION                                            = 1179;
exports.ER_ERROR_DURING_COMMIT                                                           = 1180;
exports.ER_ERROR_DURING_ROLLBACK                                                         = 1181;
exports.ER_ERROR_DURING_FLUSH_LOGS                                                       = 1182;
exports.ER_ERROR_DURING_CHECKPOINT                                                       = 1183;
exports.ER_NEW_ABORTING_CONNECTION                                                       = 1184;
exports.ER_DUMP_NOT_IMPLEMENTED                                                          = 1185;
exports.ER_FLUSH_MASTER_BINLOG_CLOSED                                                    = 1186;
exports.ER_INDEX_REBUILD                                                                 = 1187;
exports.ER_MASTER                                                                        = 1188;
exports.ER_MASTER_NET_READ                                                               = 1189;
exports.ER_MASTER_NET_WRITE                                                              = 1190;
exports.ER_FT_MATCHING_KEY_NOT_FOUND                                                     = 1191;
exports.ER_LOCK_OR_ACTIVE_TRANSACTION                                                    = 1192;
exports.ER_UNKNOWN_SYSTEM_VARIABLE                                                       = 1193;
exports.ER_CRASHED_ON_USAGE                                                              = 1194;
exports.ER_CRASHED_ON_REPAIR                                                             = 1195;
exports.ER_WARNING_NOT_COMPLETE_ROLLBACK                                                 = 1196;
exports.ER_TRANS_CACHE_FULL                                                              = 1197;
exports.ER_SLAVE_MUST_STOP                                                               = 1198;
exports.ER_SLAVE_NOT_RUNNING                                                             = 1199;
exports.ER_BAD_SLAVE                                                                     = 1200;
exports.ER_MASTER_INFO                                                                   = 1201;
exports.ER_SLAVE_THREAD                                                                  = 1202;
exports.ER_TOO_MANY_USER_CONNECTIONS                                                     = 1203;
exports.ER_SET_CONSTANTS_ONLY                                                            = 1204;
exports.ER_LOCK_WAIT_TIMEOUT                                                             = 1205;
exports.ER_LOCK_TABLE_FULL                                                               = 1206;
exports.ER_READ_ONLY_TRANSACTION                                                         = 1207;
exports.ER_DROP_DB_WITH_READ_LOCK                                                        = 1208;
exports.ER_CREATE_DB_WITH_READ_LOCK                                                      = 1209;
exports.ER_WRONG_ARGUMENTS                                                               = 1210;
exports.ER_NO_PERMISSION_TO_CREATE_USER                                                  = 1211;
exports.ER_UNION_TABLES_IN_DIFFERENT_DIR                                                 = 1212;
exports.ER_LOCK_DEADLOCK                                                                 = 1213;
exports.ER_TABLE_CANT_HANDLE_FT                                                          = 1214;
exports.ER_CANNOT_ADD_FOREIGN                                                            = 1215;
exports.ER_NO_REFERENCED_ROW                                                             = 1216;
exports.ER_ROW_IS_REFERENCED                                                             = 1217;
exports.ER_CONNECT_TO_MASTER                                                             = 1218;
exports.ER_QUERY_ON_MASTER                                                               = 1219;
exports.ER_ERROR_WHEN_EXECUTING_COMMAND                                                  = 1220;
exports.ER_WRONG_USAGE                                                                   = 1221;
exports.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT                                             = 1222;
exports.ER_CANT_UPDATE_WITH_READLOCK                                                     = 1223;
exports.ER_MIXING_NOT_ALLOWED                                                            = 1224;
exports.ER_DUP_ARGUMENT                                                                  = 1225;
exports.ER_USER_LIMIT_REACHED                                                            = 1226;
exports.ER_SPECIFIC_ACCESS_DENIED_ERROR                                                  = 1227;
exports.ER_LOCAL_VARIABLE                                                                = 1228;
exports.ER_GLOBAL_VARIABLE                                                               = 1229;
exports.ER_NO_DEFAULT                                                                    = 1230;
exports.ER_WRONG_VALUE_FOR_VAR                                                           = 1231;
exports.ER_WRONG_TYPE_FOR_VAR                                                            = 1232;
exports.ER_VAR_CANT_BE_READ                                                              = 1233;
exports.ER_CANT_USE_OPTION_HERE                                                          = 1234;
exports.ER_NOT_SUPPORTED_YET                                                             = 1235;
exports.ER_MASTER_FATAL_ERROR_READING_BINLOG                                             = 1236;
exports.ER_SLAVE_IGNORED_TABLE                                                           = 1237;
exports.ER_INCORRECT_GLOBAL_LOCAL_VAR                                                    = 1238;
exports.ER_WRONG_FK_DEF                                                                  = 1239;
exports.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF                                                = 1240;
exports.ER_OPERAND_COLUMNS                                                               = 1241;
exports.ER_SUBQUERY_NO_1_ROW                                                             = 1242;
exports.ER_UNKNOWN_STMT_HANDLER                                                          = 1243;
exports.ER_CORRUPT_HELP_DB                                                               = 1244;
exports.ER_CYCLIC_REFERENCE                                                              = 1245;
exports.ER_AUTO_CONVERT                                                                  = 1246;
exports.ER_ILLEGAL_REFERENCE                                                             = 1247;
exports.ER_DERIVED_MUST_HAVE_ALIAS                                                       = 1248;
exports.ER_SELECT_REDUCED                                                                = 1249;
exports.ER_TABLENAME_NOT_ALLOWED_HERE                                                    = 1250;
exports.ER_NOT_SUPPORTED_AUTH_MODE                                                       = 1251;
exports.ER_SPATIAL_CANT_HAVE_NULL                                                        = 1252;
exports.ER_COLLATION_CHARSET_MISMATCH                                                    = 1253;
exports.ER_SLAVE_WAS_RUNNING                                                             = 1254;
exports.ER_SLAVE_WAS_NOT_RUNNING                                                         = 1255;
exports.ER_TOO_BIG_FOR_UNCOMPRESS                                                        = 1256;
exports.ER_ZLIB_Z_MEM_ERROR                                                              = 1257;
exports.ER_ZLIB_Z_BUF_ERROR                                                              = 1258;
exports.ER_ZLIB_Z_DATA_ERROR                                                             = 1259;
exports.ER_CUT_VALUE_GROUP_CONCAT                                                        = 1260;
exports.ER_WARN_TOO_FEW_RECORDS                                                          = 1261;
exports.ER_WARN_TOO_MANY_RECORDS                                                         = 1262;
exports.ER_WARN_NULL_TO_NOTNULL                                                          = 1263;
exports.ER_WARN_DATA_OUT_OF_RANGE                                                        = 1264;
exports.WARN_DATA_TRUNCATED                                                              = 1265;
exports.ER_WARN_USING_OTHER_HANDLER                                                      = 1266;
exports.ER_CANT_AGGREGATE_2COLLATIONS                                                    = 1267;
exports.ER_DROP_USER                                                                     = 1268;
exports.ER_REVOKE_GRANTS                                                                 = 1269;
exports.ER_CANT_AGGREGATE_3COLLATIONS                                                    = 1270;
exports.ER_CANT_AGGREGATE_NCOLLATIONS                                                    = 1271;
exports.ER_VARIABLE_IS_NOT_STRUCT                                                        = 1272;
exports.ER_UNKNOWN_COLLATION                                                             = 1273;
exports.ER_SLAVE_IGNORED_SSL_PARAMS                                                      = 1274;
exports.ER_SERVER_IS_IN_SECURE_AUTH_MODE                                                 = 1275;
exports.ER_WARN_FIELD_RESOLVED                                                           = 1276;
exports.ER_BAD_SLAVE_UNTIL_COND                                                          = 1277;
exports.ER_MISSING_SKIP_SLAVE                                                            = 1278;
exports.ER_UNTIL_COND_IGNORED                                                            = 1279;
exports.ER_WRONG_NAME_FOR_INDEX                                                          = 1280;
exports.ER_WRONG_NAME_FOR_CATALOG                                                        = 1281;
exports.ER_WARN_QC_RESIZE                                                                = 1282;
exports.ER_BAD_FT_COLUMN                                                                 = 1283;
exports.ER_UNKNOWN_KEY_CACHE                                                             = 1284;
exports.ER_WARN_HOSTNAME_WONT_WORK                                                       = 1285;
exports.ER_UNKNOWN_STORAGE_ENGINE                                                        = 1286;
exports.ER_WARN_DEPRECATED_SYNTAX                                                        = 1287;
exports.ER_NON_UPDATABLE_TABLE                                                           = 1288;
exports.ER_FEATURE_DISABLED                                                              = 1289;
exports.ER_OPTION_PREVENTS_STATEMENT                                                     = 1290;
exports.ER_DUPLICATED_VALUE_IN_TYPE                                                      = 1291;
exports.ER_TRUNCATED_WRONG_VALUE                                                         = 1292;
exports.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS                                                  = 1293;
exports.ER_INVALID_ON_UPDATE                                                             = 1294;
exports.ER_UNSUPPORTED_PS                                                                = 1295;
exports.ER_GET_ERRMSG                                                                    = 1296;
exports.ER_GET_TEMPORARY_ERRMSG                                                          = 1297;
exports.ER_UNKNOWN_TIME_ZONE                                                             = 1298;
exports.ER_WARN_INVALID_TIMESTAMP                                                        = 1299;
exports.ER_INVALID_CHARACTER_STRING                                                      = 1300;
exports.ER_WARN_ALLOWED_PACKET_OVERFLOWED                                                = 1301;
exports.ER_CONFLICTING_DECLARATIONS                                                      = 1302;
exports.ER_SP_NO_RECURSIVE_CREATE                                                        = 1303;
exports.ER_SP_ALREADY_EXISTS                                                             = 1304;
exports.ER_SP_DOES_NOT_EXIST                                                             = 1305;
exports.ER_SP_DROP_FAILED                                                                = 1306;
exports.ER_SP_STORE_FAILED                                                               = 1307;
exports.ER_SP_LILABEL_MISMATCH                                                           = 1308;
exports.ER_SP_LABEL_REDEFINE                                                             = 1309;
exports.ER_SP_LABEL_MISMATCH                                                             = 1310;
exports.ER_SP_UNINIT_VAR                                                                 = 1311;
exports.ER_SP_BADSELECT                                                                  = 1312;
exports.ER_SP_BADRETURN                                                                  = 1313;
exports.ER_SP_BADSTATEMENT                                                               = 1314;
exports.ER_UPDATE_LOG_DEPRECATED_IGNORED                                                 = 1315;
exports.ER_UPDATE_LOG_DEPRECATED_TRANSLATED                                              = 1316;
exports.ER_QUERY_INTERRUPTED                                                             = 1317;
exports.ER_SP_WRONG_NO_OF_ARGS                                                           = 1318;
exports.ER_SP_COND_MISMATCH                                                              = 1319;
exports.ER_SP_NORETURN                                                                   = 1320;
exports.ER_SP_NORETURNEND                                                                = 1321;
exports.ER_SP_BAD_CURSOR_QUERY                                                           = 1322;
exports.ER_SP_BAD_CURSOR_SELECT                                                          = 1323;
exports.ER_SP_CURSOR_MISMATCH                                                            = 1324;
exports.ER_SP_CURSOR_ALREADY_OPEN                                                        = 1325;
exports.ER_SP_CURSOR_NOT_OPEN                                                            = 1326;
exports.ER_SP_UNDECLARED_VAR                                                             = 1327;
exports.ER_SP_WRONG_NO_OF_FETCH_ARGS                                                     = 1328;
exports.ER_SP_FETCH_NO_DATA                                                              = 1329;
exports.ER_SP_DUP_PARAM                                                                  = 1330;
exports.ER_SP_DUP_VAR                                                                    = 1331;
exports.ER_SP_DUP_COND                                                                   = 1332;
exports.ER_SP_DUP_CURS                                                                   = 1333;
exports.ER_SP_CANT_ALTER                                                                 = 1334;
exports.ER_SP_SUBSELECT_NYI                                                              = 1335;
exports.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG                                                 = 1336;
exports.ER_SP_VARCOND_AFTER_CURSHNDLR                                                    = 1337;
exports.ER_SP_CURSOR_AFTER_HANDLER                                                       = 1338;
exports.ER_SP_CASE_NOT_FOUND                                                             = 1339;
exports.ER_FPARSER_TOO_BIG_FILE                                                          = 1340;
exports.ER_FPARSER_BAD_HEADER                                                            = 1341;
exports.ER_FPARSER_EOF_IN_COMMENT                                                        = 1342;
exports.ER_FPARSER_ERROR_IN_PARAMETER                                                    = 1343;
exports.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER                                              = 1344;
exports.ER_VIEW_NO_EXPLAIN                                                               = 1345;
exports.ER_FRM_UNKNOWN_TYPE                                                              = 1346;
exports.ER_WRONG_OBJECT                                                                  = 1347;
exports.ER_NONUPDATEABLE_COLUMN                                                          = 1348;
exports.ER_VIEW_SELECT_DERIVED                                                           = 1349;
exports.ER_VIEW_SELECT_CLAUSE                                                            = 1350;
exports.ER_VIEW_SELECT_VARIABLE                                                          = 1351;
exports.ER_VIEW_SELECT_TMPTABLE                                                          = 1352;
exports.ER_VIEW_WRONG_LIST                                                               = 1353;
exports.ER_WARN_VIEW_MERGE                                                               = 1354;
exports.ER_WARN_VIEW_WITHOUT_KEY                                                         = 1355;
exports.ER_VIEW_INVALID                                                                  = 1356;
exports.ER_SP_NO_DROP_SP                                                                 = 1357;
exports.ER_SP_GOTO_IN_HNDLR                                                              = 1358;
exports.ER_TRG_ALREADY_EXISTS                                                            = 1359;
exports.ER_TRG_DOES_NOT_EXIST                                                            = 1360;
exports.ER_TRG_ON_VIEW_OR_TEMP_TABLE                                                     = 1361;
exports.ER_TRG_CANT_CHANGE_ROW                                                           = 1362;
exports.ER_TRG_NO_SUCH_ROW_IN_TRG                                                        = 1363;
exports.ER_NO_DEFAULT_FOR_FIELD                                                          = 1364;
exports.ER_DIVISION_BY_ZERO                                                              = 1365;
exports.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD                                               = 1366;
exports.ER_ILLEGAL_VALUE_FOR_TYPE                                                        = 1367;
exports.ER_VIEW_NONUPD_CHECK                                                             = 1368;
exports.ER_VIEW_CHECK_FAILED                                                             = 1369;
exports.ER_PROCACCESS_DENIED_ERROR                                                       = 1370;
exports.ER_RELAY_LOG_FAIL                                                                = 1371;
exports.ER_PASSWD_LENGTH                                                                 = 1372;
exports.ER_UNKNOWN_TARGET_BINLOG                                                         = 1373;
exports.ER_IO_ERR_LOG_INDEX_READ                                                         = 1374;
exports.ER_BINLOG_PURGE_PROHIBITED                                                       = 1375;
exports.ER_FSEEK_FAIL                                                                    = 1376;
exports.ER_BINLOG_PURGE_FATAL_ERR                                                        = 1377;
exports.ER_LOG_IN_USE                                                                    = 1378;
exports.ER_LOG_PURGE_UNKNOWN_ERR                                                         = 1379;
exports.ER_RELAY_LOG_INIT                                                                = 1380;
exports.ER_NO_BINARY_LOGGING                                                             = 1381;
exports.ER_RESERVED_SYNTAX                                                               = 1382;
exports.ER_WSAS_FAILED                                                                   = 1383;
exports.ER_DIFF_GROUPS_PROC                                                              = 1384;
exports.ER_NO_GROUP_FOR_PROC                                                             = 1385;
exports.ER_ORDER_WITH_PROC                                                               = 1386;
exports.ER_LOGGING_PROHIBIT_CHANGING_OF                                                  = 1387;
exports.ER_NO_FILE_MAPPING                                                               = 1388;
exports.ER_WRONG_MAGIC                                                                   = 1389;
exports.ER_PS_MANY_PARAM                                                                 = 1390;
exports.ER_KEY_PART_0                                                                    = 1391;
exports.ER_VIEW_CHECKSUM                                                                 = 1392;
exports.ER_VIEW_MULTIUPDATE                                                              = 1393;
exports.ER_VIEW_NO_INSERT_FIELD_LIST                                                     = 1394;
exports.ER_VIEW_DELETE_MERGE_VIEW                                                        = 1395;
exports.ER_CANNOT_USER                                                                   = 1396;
exports.ER_XAER_NOTA                                                                     = 1397;
exports.ER_XAER_INVAL                                                                    = 1398;
exports.ER_XAER_RMFAIL                                                                   = 1399;
exports.ER_XAER_OUTSIDE                                                                  = 1400;
exports.ER_XAER_RMERR                                                                    = 1401;
exports.ER_XA_RBROLLBACK                                                                 = 1402;
exports.ER_NONEXISTING_PROC_GRANT                                                        = 1403;
exports.ER_PROC_AUTO_GRANT_FAIL                                                          = 1404;
exports.ER_PROC_AUTO_REVOKE_FAIL                                                         = 1405;
exports.ER_DATA_TOO_LONG                                                                 = 1406;
exports.ER_SP_BAD_SQLSTATE                                                               = 1407;
exports.ER_STARTUP                                                                       = 1408;
exports.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR                                              = 1409;
exports.ER_CANT_CREATE_USER_WITH_GRANT                                                   = 1410;
exports.ER_WRONG_VALUE_FOR_TYPE                                                          = 1411;
exports.ER_TABLE_DEF_CHANGED                                                             = 1412;
exports.ER_SP_DUP_HANDLER                                                                = 1413;
exports.ER_SP_NOT_VAR_ARG                                                                = 1414;
exports.ER_SP_NO_RETSET                                                                  = 1415;
exports.ER_CANT_CREATE_GEOMETRY_OBJECT                                                   = 1416;
exports.ER_FAILED_ROUTINE_BREAK_BINLOG                                                   = 1417;
exports.ER_BINLOG_UNSAFE_ROUTINE                                                         = 1418;
exports.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER                                              = 1419;
exports.ER_EXEC_STMT_WITH_OPEN_CURSOR                                                    = 1420;
exports.ER_STMT_HAS_NO_OPEN_CURSOR                                                       = 1421;
exports.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG                                               = 1422;
exports.ER_NO_DEFAULT_FOR_VIEW_FIELD                                                     = 1423;
exports.ER_SP_NO_RECURSION                                                               = 1424;
exports.ER_TOO_BIG_SCALE                                                                 = 1425;
exports.ER_TOO_BIG_PRECISION                                                             = 1426;
exports.ER_M_BIGGER_THAN_D                                                               = 1427;
exports.ER_WRONG_LOCK_OF_SYSTEM_TABLE                                                    = 1428;
exports.ER_CONNECT_TO_FOREIGN_DATA_SOURCE                                                = 1429;
exports.ER_QUERY_ON_FOREIGN_DATA_SOURCE                                                  = 1430;
exports.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST                                              = 1431;
exports.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE                                       = 1432;
exports.ER_FOREIGN_DATA_STRING_INVALID                                                   = 1433;
exports.ER_CANT_CREATE_FEDERATED_TABLE                                                   = 1434;
exports.ER_TRG_IN_WRONG_SCHEMA                                                           = 1435;
exports.ER_STACK_OVERRUN_NEED_MORE                                                       = 1436;
exports.ER_TOO_LONG_BODY                                                                 = 1437;
exports.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE                                               = 1438;
exports.ER_TOO_BIG_DISPLAYWIDTH                                                          = 1439;
exports.ER_XAER_DUPID                                                                    = 1440;
exports.ER_DATETIME_FUNCTION_OVERFLOW                                                    = 1441;
exports.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG                                           = 1442;
exports.ER_VIEW_PREVENT_UPDATE                                                           = 1443;
exports.ER_PS_NO_RECURSION                                                               = 1444;
exports.ER_SP_CANT_SET_AUTOCOMMIT                                                        = 1445;
exports.ER_MALFORMED_DEFINER                                                             = 1446;
exports.ER_VIEW_FRM_NO_USER                                                              = 1447;
exports.ER_VIEW_OTHER_USER                                                               = 1448;
exports.ER_NO_SUCH_USER                                                                  = 1449;
exports.ER_FORBID_SCHEMA_CHANGE                                                          = 1450;
exports.ER_ROW_IS_REFERENCED_2                                                           = 1451;
exports.ER_NO_REFERENCED_ROW_2                                                           = 1452;
exports.ER_SP_BAD_VAR_SHADOW                                                             = 1453;
exports.ER_TRG_NO_DEFINER                                                                = 1454;
exports.ER_OLD_FILE_FORMAT                                                               = 1455;
exports.ER_SP_RECURSION_LIMIT                                                            = 1456;
exports.ER_SP_PROC_TABLE_CORRUPT                                                         = 1457;
exports.ER_SP_WRONG_NAME                                                                 = 1458;
exports.ER_TABLE_NEEDS_UPGRADE                                                           = 1459;
exports.ER_SP_NO_AGGREGATE                                                               = 1460;
exports.ER_MAX_PREPARED_STMT_COUNT_REACHED                                               = 1461;
exports.ER_VIEW_RECURSIVE                                                                = 1462;
exports.ER_NON_GROUPING_FIELD_USED                                                       = 1463;
exports.ER_TABLE_CANT_HANDLE_SPKEYS                                                      = 1464;
exports.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA                                                  = 1465;
exports.ER_REMOVED_SPACES                                                                = 1466;
exports.ER_AUTOINC_READ_FAILED                                                           = 1467;
exports.ER_USERNAME                                                                      = 1468;
exports.ER_HOSTNAME                                                                      = 1469;
exports.ER_WRONG_STRING_LENGTH                                                           = 1470;
exports.ER_NON_INSERTABLE_TABLE                                                          = 1471;
exports.ER_ADMIN_WRONG_MRG_TABLE                                                         = 1472;
exports.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT                                          = 1473;
exports.ER_NAME_BECOMES_EMPTY                                                            = 1474;
exports.ER_AMBIGUOUS_FIELD_TERM                                                          = 1475;
exports.ER_FOREIGN_SERVER_EXISTS                                                         = 1476;
exports.ER_FOREIGN_SERVER_DOESNT_EXIST                                                   = 1477;
exports.ER_ILLEGAL_HA_CREATE_OPTION                                                      = 1478;
exports.ER_PARTITION_REQUIRES_VALUES_ERROR                                               = 1479;
exports.ER_PARTITION_WRONG_VALUES_ERROR                                                  = 1480;
exports.ER_PARTITION_MAXVALUE_ERROR                                                      = 1481;
exports.ER_PARTITION_SUBPARTITION_ERROR                                                  = 1482;
exports.ER_PARTITION_SUBPART_MIX_ERROR                                                   = 1483;
exports.ER_PARTITION_WRONG_NO_PART_ERROR                                                 = 1484;
exports.ER_PARTITION_WRONG_NO_SUBPART_ERROR                                              = 1485;
exports.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR                                            = 1486;
exports.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR                                          = 1487;
exports.ER_FIELD_NOT_FOUND_PART_ERROR                                                    = 1488;
exports.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR                                             = 1489;
exports.ER_INCONSISTENT_PARTITION_INFO_ERROR                                             = 1490;
exports.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR                                              = 1491;
exports.ER_PARTITIONS_MUST_BE_DEFINED_ERROR                                              = 1492;
exports.ER_RANGE_NOT_INCREASING_ERROR                                                    = 1493;
exports.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR                                          = 1494;
exports.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR                                         = 1495;
exports.ER_PARTITION_ENTRY_ERROR                                                         = 1496;
exports.ER_MIX_HANDLER_ERROR                                                             = 1497;
exports.ER_PARTITION_NOT_DEFINED_ERROR                                                   = 1498;
exports.ER_TOO_MANY_PARTITIONS_ERROR                                                     = 1499;
exports.ER_SUBPARTITION_ERROR                                                            = 1500;
exports.ER_CANT_CREATE_HANDLER_FILE                                                      = 1501;
exports.ER_BLOB_FIELD_IN_PART_FUNC_ERROR                                                 = 1502;
exports.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF                                              = 1503;
exports.ER_NO_PARTS_ERROR                                                                = 1504;
exports.ER_PARTITION_MGMT_ON_NONPARTITIONED                                              = 1505;
exports.ER_FOREIGN_KEY_ON_PARTITIONED                                                    = 1506;
exports.ER_DROP_PARTITION_NON_EXISTENT                                                   = 1507;
exports.ER_DROP_LAST_PARTITION                                                           = 1508;
exports.ER_COALESCE_ONLY_ON_HASH_PARTITION                                               = 1509;
exports.ER_REORG_HASH_ONLY_ON_SAME_NO                                                    = 1510;
exports.ER_REORG_NO_PARAM_ERROR                                                          = 1511;
exports.ER_ONLY_ON_RANGE_LIST_PARTITION                                                  = 1512;
exports.ER_ADD_PARTITION_SUBPART_ERROR                                                   = 1513;
exports.ER_ADD_PARTITION_NO_NEW_PARTITION                                                = 1514;
exports.ER_COALESCE_PARTITION_NO_PARTITION                                               = 1515;
exports.ER_REORG_PARTITION_NOT_EXIST                                                     = 1516;
exports.ER_SAME_NAME_PARTITION                                                           = 1517;
exports.ER_NO_BINLOG_ERROR                                                               = 1518;
exports.ER_CONSECUTIVE_REORG_PARTITIONS                                                  = 1519;
exports.ER_REORG_OUTSIDE_RANGE                                                           = 1520;
exports.ER_PARTITION_FUNCTION_FAILURE                                                    = 1521;
exports.ER_PART_STATE_ERROR                                                              = 1522;
exports.ER_LIMITED_PART_RANGE                                                            = 1523;
exports.ER_PLUGIN_IS_NOT_LOADED                                                          = 1524;
exports.ER_WRONG_VALUE                                                                   = 1525;
exports.ER_NO_PARTITION_FOR_GIVEN_VALUE                                                  = 1526;
exports.ER_FILEGROUP_OPTION_ONLY_ONCE                                                    = 1527;
exports.ER_CREATE_FILEGROUP_FAILED                                                       = 1528;
exports.ER_DROP_FILEGROUP_FAILED                                                         = 1529;
exports.ER_TABLESPACE_AUTO_EXTEND_ERROR                                                  = 1530;
exports.ER_WRONG_SIZE_NUMBER                                                             = 1531;
exports.ER_SIZE_OVERFLOW_ERROR                                                           = 1532;
exports.ER_ALTER_FILEGROUP_FAILED                                                        = 1533;
exports.ER_BINLOG_ROW_LOGGING_FAILED                                                     = 1534;
exports.ER_BINLOG_ROW_WRONG_TABLE_DEF                                                    = 1535;
exports.ER_BINLOG_ROW_RBR_TO_SBR                                                         = 1536;
exports.ER_EVENT_ALREADY_EXISTS                                                          = 1537;
exports.ER_EVENT_STORE_FAILED                                                            = 1538;
exports.ER_EVENT_DOES_NOT_EXIST                                                          = 1539;
exports.ER_EVENT_CANT_ALTER                                                              = 1540;
exports.ER_EVENT_DROP_FAILED                                                             = 1541;
exports.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG                                        = 1542;
exports.ER_EVENT_ENDS_BEFORE_STARTS                                                      = 1543;
exports.ER_EVENT_EXEC_TIME_IN_THE_PAST                                                   = 1544;
exports.ER_EVENT_OPEN_TABLE_FAILED                                                       = 1545;
exports.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT                                                 = 1546;
exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED                                              = 1547;
exports.ER_CANNOT_LOAD_FROM_TABLE                                                        = 1548;
exports.ER_EVENT_CANNOT_DELETE                                                           = 1549;
exports.ER_EVENT_COMPILE_ERROR                                                           = 1550;
exports.ER_EVENT_SAME_NAME                                                               = 1551;
exports.ER_EVENT_DATA_TOO_LONG                                                           = 1552;
exports.ER_DROP_INDEX_FK                                                                 = 1553;
exports.ER_WARN_DEPRECATED_SYNTAX_WITH_VER                                               = 1554;
exports.ER_CANT_WRITE_LOCK_LOG_TABLE                                                     = 1555;
exports.ER_CANT_LOCK_LOG_TABLE                                                           = 1556;
exports.ER_FOREIGN_DUPLICATE_KEY                                                         = 1557;
exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE                                          = 1558;
exports.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR                                         = 1559;
exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT                                 = 1560;
exports.ER_NDB_CANT_SWITCH_BINLOG_FORMAT                                                 = 1561;
exports.ER_PARTITION_NO_TEMPORARY                                                        = 1562;
exports.ER_PARTITION_CONST_DOMAIN_ERROR                                                  = 1563;
exports.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED                                             = 1564;
exports.ER_DDL_LOG_ERROR                                                                 = 1565;
exports.ER_NULL_IN_VALUES_LESS_THAN                                                      = 1566;
exports.ER_WRONG_PARTITION_NAME                                                          = 1567;
exports.ER_CANT_CHANGE_TX_CHARACTERISTICS                                                = 1568;
exports.ER_DUP_ENTRY_AUTOINCREMENT_CASE                                                  = 1569;
exports.ER_EVENT_MODIFY_QUEUE_ERROR                                                      = 1570;
exports.ER_EVENT_SET_VAR_ERROR                                                           = 1571;
exports.ER_PARTITION_MERGE_ERROR                                                         = 1572;
exports.ER_CANT_ACTIVATE_LOG                                                             = 1573;
exports.ER_RBR_NOT_AVAILABLE                                                             = 1574;
exports.ER_BASE64_DECODE_ERROR                                                           = 1575;
exports.ER_EVENT_RECURSION_FORBIDDEN                                                     = 1576;
exports.ER_EVENTS_DB_ERROR                                                               = 1577;
exports.ER_ONLY_INTEGERS_ALLOWED                                                         = 1578;
exports.ER_UNSUPORTED_LOG_ENGINE                                                         = 1579;
exports.ER_BAD_LOG_STATEMENT                                                             = 1580;
exports.ER_CANT_RENAME_LOG_TABLE                                                         = 1581;
exports.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT                                                = 1582;
exports.ER_WRONG_PARAMETERS_TO_NATIVE_FCT                                                = 1583;
exports.ER_WRONG_PARAMETERS_TO_STORED_FCT                                                = 1584;
exports.ER_NATIVE_FCT_NAME_COLLISION                                                     = 1585;
exports.ER_DUP_ENTRY_WITH_KEY_NAME                                                       = 1586;
exports.ER_BINLOG_PURGE_EMFILE                                                           = 1587;
exports.ER_EVENT_CANNOT_CREATE_IN_THE_PAST                                               = 1588;
exports.ER_EVENT_CANNOT_ALTER_IN_THE_PAST                                                = 1589;
exports.ER_SLAVE_INCIDENT                                                                = 1590;
exports.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT                                           = 1591;
exports.ER_BINLOG_UNSAFE_STATEMENT                                                       = 1592;
exports.ER_SLAVE_FATAL_ERROR                                                             = 1593;
exports.ER_SLAVE_RELAY_LOG_READ_FAILURE                                                  = 1594;
exports.ER_SLAVE_RELAY_LOG_WRITE_FAILURE                                                 = 1595;
exports.ER_SLAVE_CREATE_EVENT_FAILURE                                                    = 1596;
exports.ER_SLAVE_MASTER_COM_FAILURE                                                      = 1597;
exports.ER_BINLOG_LOGGING_IMPOSSIBLE                                                     = 1598;
exports.ER_VIEW_NO_CREATION_CTX                                                          = 1599;
exports.ER_VIEW_INVALID_CREATION_CTX                                                     = 1600;
exports.ER_SR_INVALID_CREATION_CTX                                                       = 1601;
exports.ER_TRG_CORRUPTED_FILE                                                            = 1602;
exports.ER_TRG_NO_CREATION_CTX                                                           = 1603;
exports.ER_TRG_INVALID_CREATION_CTX                                                      = 1604;
exports.ER_EVENT_INVALID_CREATION_CTX                                                    = 1605;
exports.ER_TRG_CANT_OPEN_TABLE                                                           = 1606;
exports.ER_CANT_CREATE_SROUTINE                                                          = 1607;
exports.ER_NEVER_USED                                                                    = 1608;
exports.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT                           = 1609;
exports.ER_SLAVE_CORRUPT_EVENT                                                           = 1610;
exports.ER_LOAD_DATA_INVALID_COLUMN                                                      = 1611;
exports.ER_LOG_PURGE_NO_FILE                                                             = 1612;
exports.ER_XA_RBTIMEOUT                                                                  = 1613;
exports.ER_XA_RBDEADLOCK                                                                 = 1614;
exports.ER_NEED_REPREPARE                                                                = 1615;
exports.ER_DELAYED_NOT_SUPPORTED                                                         = 1616;
exports.WARN_NO_MASTER_INFO                                                              = 1617;
exports.WARN_OPTION_IGNORED                                                              = 1618;
exports.ER_PLUGIN_DELETE_BUILTIN                                                         = 1619;
exports.WARN_PLUGIN_BUSY                                                                 = 1620;
exports.ER_VARIABLE_IS_READONLY                                                          = 1621;
exports.ER_WARN_ENGINE_TRANSACTION_ROLLBACK                                              = 1622;
exports.ER_SLAVE_HEARTBEAT_FAILURE                                                       = 1623;
exports.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE                                            = 1624;
exports.ER_NDB_REPLICATION_SCHEMA_ERROR                                                  = 1625;
exports.ER_CONFLICT_FN_PARSE_ERROR                                                       = 1626;
exports.ER_EXCEPTIONS_WRITE_ERROR                                                        = 1627;
exports.ER_TOO_LONG_TABLE_COMMENT                                                        = 1628;
exports.ER_TOO_LONG_FIELD_COMMENT                                                        = 1629;
exports.ER_FUNC_INEXISTENT_NAME_COLLISION                                                = 1630;
exports.ER_DATABASE_NAME                                                                 = 1631;
exports.ER_TABLE_NAME                                                                    = 1632;
exports.ER_PARTITION_NAME                                                                = 1633;
exports.ER_SUBPARTITION_NAME                                                             = 1634;
exports.ER_TEMPORARY_NAME                                                                = 1635;
exports.ER_RENAMED_NAME                                                                  = 1636;
exports.ER_TOO_MANY_CONCURRENT_TRXS                                                      = 1637;
exports.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED                                         = 1638;
exports.ER_DEBUG_SYNC_TIMEOUT                                                            = 1639;
exports.ER_DEBUG_SYNC_HIT_LIMIT                                                          = 1640;
exports.ER_DUP_SIGNAL_SET                                                                = 1641;
exports.ER_SIGNAL_WARN                                                                   = 1642;
exports.ER_SIGNAL_NOT_FOUND                                                              = 1643;
exports.ER_SIGNAL_EXCEPTION                                                              = 1644;
exports.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER                                               = 1645;
exports.ER_SIGNAL_BAD_CONDITION_TYPE                                                     = 1646;
exports.WARN_COND_ITEM_TRUNCATED                                                         = 1647;
exports.ER_COND_ITEM_TOO_LONG                                                            = 1648;
exports.ER_UNKNOWN_LOCALE                                                                = 1649;
exports.ER_SLAVE_IGNORE_SERVER_IDS                                                       = 1650;
exports.ER_QUERY_CACHE_DISABLED                                                          = 1651;
exports.ER_SAME_NAME_PARTITION_FIELD                                                     = 1652;
exports.ER_PARTITION_COLUMN_LIST_ERROR                                                   = 1653;
exports.ER_WRONG_TYPE_COLUMN_VALUE_ERROR                                                 = 1654;
exports.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR                                          = 1655;
exports.ER_MAXVALUE_IN_VALUES_IN                                                         = 1656;
exports.ER_TOO_MANY_VALUES_ERROR                                                         = 1657;
exports.ER_ROW_SINGLE_PARTITION_FIELD_ERROR                                              = 1658;
exports.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD                                     = 1659;
exports.ER_PARTITION_FIELDS_TOO_LONG                                                     = 1660;
exports.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE                                             = 1661;
exports.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE                                               = 1662;
exports.ER_BINLOG_UNSAFE_AND_STMT_ENGINE                                                 = 1663;
exports.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE                                          = 1664;
exports.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE                                               = 1665;
exports.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE                                            = 1666;
exports.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE                               = 1667;
exports.ER_BINLOG_UNSAFE_LIMIT                                                           = 1668;
exports.ER_BINLOG_UNSAFE_INSERT_DELAYED                                                  = 1669;
exports.ER_BINLOG_UNSAFE_SYSTEM_TABLE                                                    = 1670;
exports.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS                                                 = 1671;
exports.ER_BINLOG_UNSAFE_UDF                                                             = 1672;
exports.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE                                                 = 1673;
exports.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION                                                 = 1674;
exports.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS                                            = 1675;
exports.ER_MESSAGE_AND_STATEMENT                                                         = 1676;
exports.ER_SLAVE_CONVERSION_FAILED                                                       = 1677;
exports.ER_SLAVE_CANT_CREATE_CONVERSION                                                  = 1678;
exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT                              = 1679;
exports.ER_PATH_LENGTH                                                                   = 1680;
exports.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT                                         = 1681;
exports.ER_WRONG_NATIVE_TABLE_STRUCTURE                                                  = 1682;
exports.ER_WRONG_PERFSCHEMA_USAGE                                                        = 1683;
exports.ER_WARN_I_S_SKIPPED_TABLE                                                        = 1684;
exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT                              = 1685;
exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT                                 = 1686;
exports.ER_SPATIAL_MUST_HAVE_GEOM_COL                                                    = 1687;
exports.ER_TOO_LONG_INDEX_COMMENT                                                        = 1688;
exports.ER_LOCK_ABORTED                                                                  = 1689;
exports.ER_DATA_OUT_OF_RANGE                                                             = 1690;
exports.ER_WRONG_SPVAR_TYPE_IN_LIMIT                                                     = 1691;
exports.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE                        = 1692;
exports.ER_BINLOG_UNSAFE_MIXED_STATEMENT                                                 = 1693;
exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN                                = 1694;
exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN                                   = 1695;
exports.ER_FAILED_READ_FROM_PAR_FILE                                                     = 1696;
exports.ER_VALUES_IS_NOT_INT_TYPE_ERROR                                                  = 1697;
exports.ER_ACCESS_DENIED_NO_PASSWORD_ERROR                                               = 1698;
exports.ER_SET_PASSWORD_AUTH_PLUGIN                                                      = 1699;
exports.ER_GRANT_PLUGIN_USER_EXISTS                                                      = 1700;
exports.ER_TRUNCATE_ILLEGAL_FK                                                           = 1701;
exports.ER_PLUGIN_IS_PERMANENT                                                           = 1702;
exports.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN                                        = 1703;
exports.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX                                        = 1704;
exports.ER_STMT_CACHE_FULL                                                               = 1705;
exports.ER_MULTI_UPDATE_KEY_CONFLICT                                                     = 1706;
exports.ER_TABLE_NEEDS_REBUILD                                                           = 1707;
exports.WARN_OPTION_BELOW_LIMIT                                                          = 1708;
exports.ER_INDEX_COLUMN_TOO_LONG                                                         = 1709;
exports.ER_ERROR_IN_TRIGGER_BODY                                                         = 1710;
exports.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY                                                 = 1711;
exports.ER_INDEX_CORRUPT                                                                 = 1712;
exports.ER_UNDO_RECORD_TOO_BIG                                                           = 1713;
exports.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT                                            = 1714;
exports.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE                                            = 1715;
exports.ER_BINLOG_UNSAFE_REPLACE_SELECT                                                  = 1716;
exports.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT                                            = 1717;
exports.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT                                           = 1718;
exports.ER_BINLOG_UNSAFE_UPDATE_IGNORE                                                   = 1719;
exports.ER_PLUGIN_NO_UNINSTALL                                                           = 1720;
exports.ER_PLUGIN_NO_INSTALL                                                             = 1721;
exports.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT                                            = 1722;
exports.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC                                           = 1723;
exports.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS                                                 = 1724;
exports.ER_TABLE_IN_FK_CHECK                                                             = 1725;
exports.ER_UNSUPPORTED_ENGINE                                                            = 1726;
exports.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST                                               = 1727;
exports.ER_CANNOT_LOAD_FROM_TABLE_V2                                                     = 1728;
exports.ER_MASTER_DELAY_VALUE_OUT_OF_RANGE                                               = 1729;
exports.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT                            = 1730;
exports.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION                                           = 1731;
exports.ER_PARTITION_EXCHANGE_PART_TABLE                                                 = 1732;
exports.ER_PARTITION_EXCHANGE_TEMP_TABLE                                                 = 1733;
exports.ER_PARTITION_INSTEAD_OF_SUBPARTITION                                             = 1734;
exports.ER_UNKNOWN_PARTITION                                                             = 1735;
exports.ER_TABLES_DIFFERENT_METADATA                                                     = 1736;
exports.ER_ROW_DOES_NOT_MATCH_PARTITION                                                  = 1737;
exports.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX                                            = 1738;
exports.ER_WARN_INDEX_NOT_APPLICABLE                                                     = 1739;
exports.ER_PARTITION_EXCHANGE_FOREIGN_KEY                                                = 1740;
exports.ER_NO_SUCH_KEY_VALUE                                                             = 1741;
exports.ER_RPL_INFO_DATA_TOO_LONG                                                        = 1742;
exports.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE                                           = 1743;
exports.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE                                            = 1744;
exports.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX                                       = 1745;
exports.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT                                      = 1746;
exports.ER_PARTITION_CLAUSE_ON_NONPARTITIONED                                            = 1747;
exports.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET                                        = 1748;
exports.ER_NO_SUCH_PARTITION                                                             = 1749;
exports.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE                                            = 1750;
exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE                         = 1751;
exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE                         = 1752;
exports.ER_MTS_FEATURE_IS_NOT_SUPPORTED                                                  = 1753;
exports.ER_MTS_UPDATED_DBS_GREATER_MAX                                                   = 1754;
exports.ER_MTS_CANT_PARALLEL                                                             = 1755;
exports.ER_MTS_INCONSISTENT_DATA                                                         = 1756;
exports.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING                                      = 1757;
exports.ER_DA_INVALID_CONDITION_NUMBER                                                   = 1758;
exports.ER_INSECURE_PLAIN_TEXT                                                           = 1759;
exports.ER_INSECURE_CHANGE_MASTER                                                        = 1760;
exports.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO                                         = 1761;
exports.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO                                      = 1762;
exports.ER_SQLTHREAD_WITH_SECURE_SLAVE                                                   = 1763;
exports.ER_TABLE_HAS_NO_FT                                                               = 1764;
exports.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER                                        = 1765;
exports.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION                                          = 1766;
exports.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST                                            = 1767;
exports.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION                                          = 1768;
exports.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION                                          = 1769;
exports.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL                     = 1770;
exports.ER_SKIPPING_LOGGED_TRANSACTION                                                   = 1771;
exports.ER_MALFORMED_GTID_SET_SPECIFICATION                                              = 1772;
exports.ER_MALFORMED_GTID_SET_ENCODING                                                   = 1773;
exports.ER_MALFORMED_GTID_SPECIFICATION                                                  = 1774;
exports.ER_GNO_EXHAUSTED                                                                 = 1775;
exports.ER_BAD_SLAVE_AUTO_POSITION                                                       = 1776;
exports.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF                                      = 1777;
exports.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET                          = 1778;
exports.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON                             = 1779;
exports.ER_GTID_MODE_REQUIRES_BINLOG                                                     = 1780;
exports.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF                              = 1781;
exports.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON                          = 1782;
exports.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF                     = 1783;
exports.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF                                        = 1784;
exports.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE                                           = 1785;
exports.ER_GTID_UNSAFE_CREATE_SELECT                                                     = 1786;
exports.ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION                        = 1787;
exports.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME                                  = 1788;
exports.ER_MASTER_HAS_PURGED_REQUIRED_GTIDS                                              = 1789;
exports.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID                                           = 1790;
exports.ER_UNKNOWN_EXPLAIN_FORMAT                                                        = 1791;
exports.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION                                         = 1792;
exports.ER_TOO_LONG_TABLE_PARTITION_COMMENT                                              = 1793;
exports.ER_SLAVE_CONFIGURATION                                                           = 1794;
exports.ER_INNODB_FT_LIMIT                                                               = 1795;
exports.ER_INNODB_NO_FT_TEMP_TABLE                                                       = 1796;
exports.ER_INNODB_FT_WRONG_DOCID_COLUMN                                                  = 1797;
exports.ER_INNODB_FT_WRONG_DOCID_INDEX                                                   = 1798;
exports.ER_INNODB_ONLINE_LOG_TOO_BIG                                                     = 1799;
exports.ER_UNKNOWN_ALTER_ALGORITHM                                                       = 1800;
exports.ER_UNKNOWN_ALTER_LOCK                                                            = 1801;
exports.ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS                                          = 1802;
exports.ER_MTS_RECOVERY_FAILURE                                                          = 1803;
exports.ER_MTS_RESET_WORKERS                                                             = 1804;
exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2                                           = 1805;
exports.ER_SLAVE_SILENT_RETRY_TRANSACTION                                                = 1806;
exports.ER_DISCARD_FK_CHECKS_RUNNING                                                     = 1807;
exports.ER_TABLE_SCHEMA_MISMATCH                                                         = 1808;
exports.ER_TABLE_IN_SYSTEM_TABLESPACE                                                    = 1809;
exports.ER_IO_READ_ERROR                                                                 = 1810;
exports.ER_IO_WRITE_ERROR                                                                = 1811;
exports.ER_TABLESPACE_MISSING                                                            = 1812;
exports.ER_TABLESPACE_EXISTS                                                             = 1813;
exports.ER_TABLESPACE_DISCARDED                                                          = 1814;
exports.ER_INTERNAL_ERROR                                                                = 1815;
exports.ER_INNODB_IMPORT_ERROR                                                           = 1816;
exports.ER_INNODB_INDEX_CORRUPT                                                          = 1817;
exports.ER_INVALID_YEAR_COLUMN_LENGTH                                                    = 1818;
exports.ER_NOT_VALID_PASSWORD                                                            = 1819;
exports.ER_MUST_CHANGE_PASSWORD                                                          = 1820;
exports.ER_FK_NO_INDEX_CHILD                                                             = 1821;
exports.ER_FK_NO_INDEX_PARENT                                                            = 1822;
exports.ER_FK_FAIL_ADD_SYSTEM                                                            = 1823;
exports.ER_FK_CANNOT_OPEN_PARENT                                                         = 1824;
exports.ER_FK_INCORRECT_OPTION                                                           = 1825;
exports.ER_FK_DUP_NAME                                                                   = 1826;
exports.ER_PASSWORD_FORMAT                                                               = 1827;
exports.ER_FK_COLUMN_CANNOT_DROP                                                         = 1828;
exports.ER_FK_COLUMN_CANNOT_DROP_CHILD                                                   = 1829;
exports.ER_FK_COLUMN_NOT_NULL                                                            = 1830;
exports.ER_DUP_INDEX                                                                     = 1831;
exports.ER_FK_COLUMN_CANNOT_CHANGE                                                       = 1832;
exports.ER_FK_COLUMN_CANNOT_CHANGE_CHILD                                                 = 1833;
exports.ER_FK_CANNOT_DELETE_PARENT                                                       = 1834;
exports.ER_MALFORMED_PACKET                                                              = 1835;
exports.ER_READ_ONLY_MODE                                                                = 1836;
exports.ER_GTID_NEXT_TYPE_UNDEFINED_GROUP                                                = 1837;
exports.ER_VARIABLE_NOT_SETTABLE_IN_SP                                                   = 1838;
exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF                                    = 1839;
exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY                          = 1840;
exports.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY                            = 1841;
exports.ER_GTID_PURGED_WAS_CHANGED                                                       = 1842;
exports.ER_GTID_EXECUTED_WAS_CHANGED                                                     = 1843;
exports.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES                                           = 1844;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED                                                 = 1845;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON                                          = 1846;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY                                     = 1847;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION                                = 1848;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME                                = 1849;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE                              = 1850;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK                                 = 1851;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE                                   = 1852;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK                                     = 1853;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC                                  = 1854;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS                               = 1855;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS                               = 1856;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS                                      = 1857;
exports.ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE                              = 1858;
exports.ER_DUP_UNKNOWN_IN_INDEX                                                          = 1859;
exports.ER_IDENT_CAUSES_TOO_LONG_PATH                                                    = 1860;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL                                 = 1861;
exports.ER_MUST_CHANGE_PASSWORD_LOGIN                                                    = 1862;
exports.ER_ROW_IN_WRONG_PARTITION                                                        = 1863;
exports.ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX                                        = 1864;
exports.ER_INNODB_NO_FT_USES_PARSER                                                      = 1865;
exports.ER_BINLOG_LOGICAL_CORRUPTION                                                     = 1866;
exports.ER_WARN_PURGE_LOG_IN_USE                                                         = 1867;
exports.ER_WARN_PURGE_LOG_IS_ACTIVE                                                      = 1868;
exports.ER_AUTO_INCREMENT_CONFLICT                                                       = 1869;
exports.WARN_ON_BLOCKHOLE_IN_RBR                                                         = 1870;
exports.ER_SLAVE_MI_INIT_REPOSITORY                                                      = 1871;
exports.ER_SLAVE_RLI_INIT_REPOSITORY                                                     = 1872;
exports.ER_ACCESS_DENIED_CHANGE_USER_ERROR                                               = 1873;
exports.ER_INNODB_READ_ONLY                                                              = 1874;
exports.ER_STOP_SLAVE_SQL_THREAD_TIMEOUT                                                 = 1875;
exports.ER_STOP_SLAVE_IO_THREAD_TIMEOUT                                                  = 1876;
exports.ER_TABLE_CORRUPT                                                                 = 1877;
exports.ER_TEMP_FILE_WRITE_FAILURE                                                       = 1878;
exports.ER_INNODB_FT_AUX_NOT_HEX_ID                                                      = 1879;
exports.ER_OLD_TEMPORALS_UPGRADED                                                        = 1880;
exports.ER_INNODB_FORCED_RECOVERY                                                        = 1881;
exports.ER_AES_INVALID_IV                                                                = 1882;
exports.ER_PLUGIN_CANNOT_BE_UNINSTALLED                                                  = 1883;
exports.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_GTID_GROUP                        = 1884;
exports.ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER                                              = 1885;
exports.ER_MISSING_KEY                                                                   = 1886;
exports.WARN_NAMED_PIPE_ACCESS_EVERYONE                                                  = 1887;
exports.ER_FOUND_MISSING_GTIDS                                                           = 1888;
exports.ER_FILE_CORRUPT                                                                  = 3000;
exports.ER_ERROR_ON_MASTER                                                               = 3001;
exports.ER_INCONSISTENT_ERROR                                                            = 3002;
exports.ER_STORAGE_ENGINE_NOT_LOADED                                                     = 3003;
exports.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER                                         = 3004;
exports.ER_WARN_LEGACY_SYNTAX_CONVERTED                                                  = 3005;
exports.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN                                                 = 3006;
exports.ER_CANNOT_DISCARD_TEMPORARY_TABLE                                                = 3007;
exports.ER_FK_DEPTH_EXCEEDED                                                             = 3008;
exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2                                       = 3009;
exports.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED                                              = 3010;
exports.ER_REFERENCED_TRG_DOES_NOT_EXIST                                                 = 3011;
exports.ER_EXPLAIN_NOT_SUPPORTED                                                         = 3012;
exports.ER_INVALID_FIELD_SIZE                                                            = 3013;
exports.ER_MISSING_HA_CREATE_OPTION                                                      = 3014;
exports.ER_ENGINE_OUT_OF_MEMORY                                                          = 3015;
exports.ER_PASSWORD_EXPIRE_ANONYMOUS_USER                                                = 3016;
exports.ER_SLAVE_SQL_THREAD_MUST_STOP                                                    = 3017;
exports.ER_NO_FT_MATERIALIZED_SUBQUERY                                                   = 3018;
exports.ER_INNODB_UNDO_LOG_FULL                                                          = 3019;
exports.ER_INVALID_ARGUMENT_FOR_LOGARITHM                                                = 3020;
exports.ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP                                             = 3021;
exports.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO                                            = 3022;
exports.ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS                                              = 3023;
exports.ER_QUERY_TIMEOUT                                                                 = 3024;
exports.ER_NON_RO_SELECT_DISABLE_TIMER                                                   = 3025;
exports.ER_DUP_LIST_ENTRY                                                                = 3026;
exports.ER_SQL_MODE_NO_EFFECT                                                            = 3027;
exports.ER_AGGREGATE_ORDER_FOR_UNION                                                     = 3028;
exports.ER_AGGREGATE_ORDER_NON_AGG_QUERY                                                 = 3029;
exports.ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR                                       = 3030;
exports.ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER                                      = 3031;
exports.ER_SERVER_OFFLINE_MODE                                                           = 3032;
exports.ER_GIS_DIFFERENT_SRIDS                                                           = 3033;
exports.ER_GIS_UNSUPPORTED_ARGUMENT                                                      = 3034;
exports.ER_GIS_UNKNOWN_ERROR                                                             = 3035;
exports.ER_GIS_UNKNOWN_EXCEPTION                                                         = 3036;
exports.ER_GIS_INVALID_DATA                                                              = 3037;
exports.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION                                          = 3038;
exports.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION                                             = 3039;
exports.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION                                = 3040;
exports.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION                                            = 3041;
exports.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION                              = 3042;
exports.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION                                              = 3043;
exports.ER_STD_BAD_ALLOC_ERROR                                                           = 3044;
exports.ER_STD_DOMAIN_ERROR                                                              = 3045;
exports.ER_STD_LENGTH_ERROR                                                              = 3046;
exports.ER_STD_INVALID_ARGUMENT                                                          = 3047;
exports.ER_STD_OUT_OF_RANGE_ERROR                                                        = 3048;
exports.ER_STD_OVERFLOW_ERROR                                                            = 3049;
exports.ER_STD_RANGE_ERROR                                                               = 3050;
exports.ER_STD_UNDERFLOW_ERROR                                                           = 3051;
exports.ER_STD_LOGIC_ERROR                                                               = 3052;
exports.ER_STD_RUNTIME_ERROR                                                             = 3053;
exports.ER_STD_UNKNOWN_EXCEPTION                                                         = 3054;
exports.ER_GIS_DATA_WRONG_ENDIANESS                                                      = 3055;
exports.ER_CHANGE_MASTER_PASSWORD_LENGTH                                                 = 3056;
exports.ER_USER_LOCK_WRONG_NAME                                                          = 3057;
exports.ER_USER_LOCK_DEADLOCK                                                            = 3058;
exports.ER_REPLACE_INACCESSIBLE_ROWS                                                     = 3059;
exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS                                      = 3060;
exports.ER_ILLEGAL_USER_VAR                                                              = 3061;
exports.ER_GTID_MODE_OFF                                                                 = 3062;
exports.ER_UNSUPPORTED_BY_REPLICATION_THREAD                                             = 3063;
exports.ER_INCORRECT_TYPE                                                                = 3064;
exports.ER_FIELD_IN_ORDER_NOT_SELECT                                                     = 3065;
exports.ER_AGGREGATE_IN_ORDER_NOT_SELECT                                                 = 3066;
exports.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN                                         = 3067;
exports.ER_NET_OK_PACKET_TOO_LARGE                                                       = 3068;
exports.ER_INVALID_JSON_DATA                                                             = 3069;
exports.ER_INVALID_GEOJSON_MISSING_MEMBER                                                = 3070;
exports.ER_INVALID_GEOJSON_WRONG_TYPE                                                    = 3071;
exports.ER_INVALID_GEOJSON_UNSPECIFIED                                                   = 3072;
exports.ER_DIMENSION_UNSUPPORTED                                                         = 3073;
exports.ER_SLAVE_CHANNEL_DOES_NOT_EXIST                                                  = 3074;
exports.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT                                             = 3075;
exports.ER_SLAVE_CHANNEL_NAME_INVALID_OR_TOO_LONG                                        = 3076;
exports.ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY                                            = 3077;
exports.ER_SLAVE_CHANNEL_DELETE                                                          = 3078;
exports.ER_SLAVE_MULTIPLE_CHANNELS_CMD                                                   = 3079;
exports.ER_SLAVE_MAX_CHANNELS_EXCEEDED                                                   = 3080;
exports.ER_SLAVE_CHANNEL_MUST_STOP                                                       = 3081;
exports.ER_SLAVE_CHANNEL_NOT_RUNNING                                                     = 3082;
exports.ER_SLAVE_CHANNEL_WAS_RUNNING                                                     = 3083;
exports.ER_SLAVE_CHANNEL_WAS_NOT_RUNNING                                                 = 3084;
exports.ER_SLAVE_CHANNEL_SQL_THREAD_MUST_STOP                                            = 3085;
exports.ER_SLAVE_CHANNEL_SQL_SKIP_COUNTER                                                = 3086;
exports.ER_WRONG_FIELD_WITH_GROUP_V2                                                     = 3087;
exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2                                               = 3088;
exports.ER_WARN_DEPRECATED_SYSVAR_UPDATE                                                 = 3089;
exports.ER_WARN_DEPRECATED_SQLMODE                                                       = 3090;
exports.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID                                    = 3091;
exports.ER_GROUP_REPLICATION_CONFIGURATION                                               = 3092;
exports.ER_GROUP_REPLICATION_RUNNING                                                     = 3093;
exports.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR                                          = 3094;
exports.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT                                 = 3095;
exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR                           = 3096;
exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR                              = 3097;
exports.ER_BEFORE_DML_VALIDATION_ERROR                                                   = 3098;
exports.ER_PREVENTS_VARIABLE_WITHOUT_RBR                                                 = 3099;
exports.ER_RUN_HOOK_ERROR                                                                = 3100;
exports.ER_TRANSACTION_ROLLBACK_DURING_COMMIT                                            = 3101;
exports.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED                                      = 3102;
exports.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN                                   = 3103;
exports.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN                                          = 3104;
exports.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN                                        = 3105;
exports.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN                                        = 3106;
exports.ER_GENERATED_COLUMN_NON_PRIOR                                                    = 3107;
exports.ER_DEPENDENT_BY_GENERATED_COLUMN                                                 = 3108;
exports.ER_GENERATED_COLUMN_REF_AUTO_INC                                                 = 3109;
exports.ER_FEATURE_NOT_AVAILABLE                                                         = 3110;
exports.ER_CANT_SET_GTID_MODE                                                            = 3111;
exports.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF                                     = 3112;
exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION                                   = 3113;
exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON                                    = 3114;
exports.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF                                        = 3115;
exports.ER_CANT_SET_ENFORCE_GTID_CONSISTENCY_ON_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS = 3116;
exports.ER_SET_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS    = 3117;
exports.ER_ACCOUNT_HAS_BEEN_LOCKED                                                       = 3118;
exports.ER_WRONG_TABLESPACE_NAME                                                         = 3119;
exports.ER_TABLESPACE_IS_NOT_EMPTY                                                       = 3120;
exports.ER_WRONG_FILE_NAME                                                               = 3121;
exports.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION                                   = 3122;
exports.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR                                              = 3123;
exports.ER_WARN_BAD_MAX_EXECUTION_TIME                                                   = 3124;
exports.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME                                           = 3125;
exports.ER_WARN_CONFLICTING_HINT                                                         = 3126;
exports.ER_WARN_UNKNOWN_QB_NAME                                                          = 3127;
exports.ER_UNRESOLVED_HINT_NAME                                                          = 3128;
exports.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE                                         = 3129;
exports.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED                                      = 3130;
exports.ER_LOCKING_SERVICE_WRONG_NAME                                                    = 3131;
exports.ER_LOCKING_SERVICE_DEADLOCK                                                      = 3132;
exports.ER_LOCKING_SERVICE_TIMEOUT                                                       = 3133;
exports.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED                                         = 3134;
exports.ER_SQL_MODE_MERGED                                                               = 3135;
exports.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH                                                  = 3136;
exports.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND                                                 = 3137;
exports.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID                                            = 3138;
exports.ER_SLAVE_CHANNEL_OPERATION_NOT_ALLOWED                                           = 3139;
exports.ER_INVALID_JSON_TEXT                                                             = 3140;
exports.ER_INVALID_JSON_TEXT_IN_PARAM                                                    = 3141;
exports.ER_INVALID_JSON_BINARY_DATA                                                      = 3142;
exports.ER_INVALID_JSON_PATH                                                             = 3143;
exports.ER_INVALID_JSON_CHARSET                                                          = 3144;
exports.ER_INVALID_JSON_CHARSET_IN_FUNCTION                                              = 3145;
exports.ER_INVALID_TYPE_FOR_JSON                                                         = 3146;
exports.ER_INVALID_CAST_TO_JSON                                                          = 3147;
exports.ER_INVALID_JSON_PATH_CHARSET                                                     = 3148;
exports.ER_INVALID_JSON_PATH_WILDCARD                                                    = 3149;
exports.ER_JSON_VALUE_TOO_BIG                                                            = 3150;
exports.ER_JSON_KEY_TOO_BIG                                                              = 3151;
exports.ER_JSON_USED_AS_KEY                                                              = 3152;
exports.ER_JSON_VACUOUS_PATH                                                             = 3153;
exports.ER_JSON_BAD_ONE_OR_ALL_ARG                                                       = 3154;
exports.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE                                               = 3155;
exports.ER_INVALID_JSON_VALUE_FOR_CAST                                                   = 3156;
exports.ER_JSON_DOCUMENT_TOO_DEEP                                                        = 3157;
exports.ER_JSON_DOCUMENT_NULL_KEY                                                        = 3158;
exports.ER_SECURE_TRANSPORT_REQUIRED                                                     = 3159;
exports.ER_NO_SECURE_TRANSPORTS_CONFIGURED                                               = 3160;
exports.ER_DISABLED_STORAGE_ENGINE                                                       = 3161;
exports.ER_USER_DOES_NOT_EXIST                                                           = 3162;
exports.ER_USER_ALREADY_EXISTS                                                           = 3163;
exports.ER_AUDIT_API_ABORT                                                               = 3164;
exports.ER_INVALID_JSON_PATH_ARRAY_CELL                                                  = 3165;
exports.ER_BUFPOOL_RESIZE_INPROGRESS                                                     = 3166;
exports.ER_FEATURE_DISABLED_SEE_DOC                                                      = 3167;
exports.ER_SERVER_ISNT_AVAILABLE                                                         = 3168;
exports.ER_SESSION_WAS_KILLED                                                            = 3169;
exports.ER_CAPACITY_EXCEEDED                                                             = 3170;
exports.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER                                          = 3171;
exports.ER_TABLE_NEEDS_UPG_PART                                                          = 3172;
exports.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID                           = 3173;
exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL                                           = 3174;
exports.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT                                        = 3175;
exports.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE                                        = 3176;
exports.ER_LOCK_REFUSED_BY_ENGINE                                                        = 3177;
exports.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN                                    = 3178;
exports.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE                                       = 3179;
exports.ER_MASTER_KEY_ROTATION_ERROR_BY_SE                                               = 3180;
exports.ER_MASTER_KEY_ROTATION_BINLOG_FAILED                                             = 3181;
exports.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE                                            = 3182;
exports.ER_TABLESPACE_CANNOT_ENCRYPT                                                     = 3183;
exports.ER_INVALID_ENCRYPTION_OPTION                                                     = 3184;
exports.ER_CANNOT_FIND_KEY_IN_KEYRING                                                    = 3185;
exports.ER_CAPACITY_EXCEEDED_IN_PARSER                                                   = 3186;
exports.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE                                          = 3187;
exports.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR                                             = 3188;
exports.ER_USER_COLUMN_OLD_LENGTH                                                        = 3189;
exports.ER_CANT_RESET_MASTER                                                             = 3190;
exports.ER_GROUP_REPLICATION_MAX_GROUP_SIZE                                              = 3191;
exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED                                            = 3192;
exports.ER_TABLE_REFERENCED                                                              = 3193;
exports.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE                                         = 3194;
exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO                                       = 3195;
exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID                                            = 3196;
exports.ER_XA_RETRY                                                                      = 3197;
exports.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR                                                 = 3198;
exports.ER_BINLOG_UNSAFE_XA                                                              = 3199;
exports.ER_UDF_ERROR                                                                     = 3200;
exports.ER_KEYRING_MIGRATION_FAILURE                                                     = 3201;
exports.ER_KEYRING_ACCESS_DENIED_ERROR                                                   = 3202;
exports.ER_KEYRING_MIGRATION_STATUS                                                      = 3203;
exports.ER_PLUGIN_FAILED_TO_OPEN_TABLES                                                  = 3204;
exports.ER_PLUGIN_FAILED_TO_OPEN_TABLE                                                   = 3205;
exports.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED                                         = 3206;
exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET                                = 3207;
exports.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY                                            = 3208;
exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED                               = 3209;
exports.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED                                          = 3210;
exports.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE                                          = 3211;
exports.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED                                            = 3212;
exports.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS                                      = 3213;
exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE                                           = 3214;
exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT                                          = 3215;
exports.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED                                              = 3216;
exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE                          = 3217;
exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE                         = 3218;
exports.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR                                           = 3219;
exports.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY                                    = 3220;
exports.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY                                      = 3221;
exports.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS                                         = 3222;
exports.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC                           = 3223;
exports.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER                                         = 3224;
exports.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER                                         = 3225;
exports.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP                                     = 3226;
exports.ER_XA_REPLICATION_FILTERS                                                        = 3227;
exports.ER_CANT_OPEN_ERROR_LOG                                                           = 3228;
exports.ER_GROUPING_ON_TIMESTAMP_IN_DST                                                  = 3229;
exports.ER_CANT_START_SERVER_NAMED_PIPE                                                  = 3230;

// Lookup-by-number table
exports[1]    = 'EE_CANTCREATEFILE';
exports[2]    = 'EE_READ';
exports[3]    = 'EE_WRITE';
exports[4]    = 'EE_BADCLOSE';
exports[5]    = 'EE_OUTOFMEMORY';
exports[6]    = 'EE_DELETE';
exports[7]    = 'EE_LINK';
exports[9]    = 'EE_EOFERR';
exports[10]   = 'EE_CANTLOCK';
exports[11]   = 'EE_CANTUNLOCK';
exports[12]   = 'EE_DIR';
exports[13]   = 'EE_STAT';
exports[14]   = 'EE_CANT_CHSIZE';
exports[15]   = 'EE_CANT_OPEN_STREAM';
exports[16]   = 'EE_GETWD';
exports[17]   = 'EE_SETWD';
exports[18]   = 'EE_LINK_WARNING';
exports[19]   = 'EE_OPEN_WARNING';
exports[20]   = 'EE_DISK_FULL';
exports[21]   = 'EE_CANT_MKDIR';
exports[22]   = 'EE_UNKNOWN_CHARSET';
exports[23]   = 'EE_OUT_OF_FILERESOURCES';
exports[24]   = 'EE_CANT_READLINK';
exports[25]   = 'EE_CANT_SYMLINK';
exports[26]   = 'EE_REALPATH';
exports[27]   = 'EE_SYNC';
exports[28]   = 'EE_UNKNOWN_COLLATION';
exports[29]   = 'EE_FILENOTFOUND';
exports[30]   = 'EE_FILE_NOT_CLOSED';
exports[31]   = 'EE_CHANGE_OWNERSHIP';
exports[32]   = 'EE_CHANGE_PERMISSIONS';
exports[33]   = 'EE_CANT_SEEK';
exports[34]   = 'EE_CAPACITY_EXCEEDED';
exports[120]  = 'HA_ERR_KEY_NOT_FOUND';
exports[121]  = 'HA_ERR_FOUND_DUPP_KEY';
exports[122]  = 'HA_ERR_INTERNAL_ERROR';
exports[123]  = 'HA_ERR_RECORD_CHANGED';
exports[124]  = 'HA_ERR_WRONG_INDEX';
exports[126]  = 'HA_ERR_CRASHED';
exports[127]  = 'HA_ERR_WRONG_IN_RECORD';
exports[128]  = 'HA_ERR_OUT_OF_MEM';
exports[130]  = 'HA_ERR_NOT_A_TABLE';
exports[131]  = 'HA_ERR_WRONG_COMMAND';
exports[132]  = 'HA_ERR_OLD_FILE';
exports[133]  = 'HA_ERR_NO_ACTIVE_RECORD';
exports[134]  = 'HA_ERR_RECORD_DELETED';
exports[135]  = 'HA_ERR_RECORD_FILE_FULL';
exports[136]  = 'HA_ERR_INDEX_FILE_FULL';
exports[137]  = 'HA_ERR_END_OF_FILE';
exports[138]  = 'HA_ERR_UNSUPPORTED';
exports[139]  = 'HA_ERR_TOO_BIG_ROW';
exports[140]  = 'HA_WRONG_CREATE_OPTION';
exports[141]  = 'HA_ERR_FOUND_DUPP_UNIQUE';
exports[142]  = 'HA_ERR_UNKNOWN_CHARSET';
exports[143]  = 'HA_ERR_WRONG_MRG_TABLE_DEF';
exports[144]  = 'HA_ERR_CRASHED_ON_REPAIR';
exports[145]  = 'HA_ERR_CRASHED_ON_USAGE';
exports[146]  = 'HA_ERR_LOCK_WAIT_TIMEOUT';
exports[147]  = 'HA_ERR_LOCK_TABLE_FULL';
exports[148]  = 'HA_ERR_READ_ONLY_TRANSACTION';
exports[149]  = 'HA_ERR_LOCK_DEADLOCK';
exports[150]  = 'HA_ERR_CANNOT_ADD_FOREIGN';
exports[151]  = 'HA_ERR_NO_REFERENCED_ROW';
exports[152]  = 'HA_ERR_ROW_IS_REFERENCED';
exports[153]  = 'HA_ERR_NO_SAVEPOINT';
exports[154]  = 'HA_ERR_NON_UNIQUE_BLOCK_SIZE';
exports[155]  = 'HA_ERR_NO_SUCH_TABLE';
exports[156]  = 'HA_ERR_TABLE_EXIST';
exports[157]  = 'HA_ERR_NO_CONNECTION';
exports[158]  = 'HA_ERR_NULL_IN_SPATIAL';
exports[159]  = 'HA_ERR_TABLE_DEF_CHANGED';
exports[160]  = 'HA_ERR_NO_PARTITION_FOUND';
exports[161]  = 'HA_ERR_RBR_LOGGING_FAILED';
exports[162]  = 'HA_ERR_DROP_INDEX_FK';
exports[163]  = 'HA_ERR_FOREIGN_DUPLICATE_KEY';
exports[164]  = 'HA_ERR_TABLE_NEEDS_UPGRADE';
exports[165]  = 'HA_ERR_TABLE_READONLY';
exports[166]  = 'HA_ERR_AUTOINC_READ_FAILED';
exports[167]  = 'HA_ERR_AUTOINC_ERANGE';
exports[168]  = 'HA_ERR_GENERIC';
exports[169]  = 'HA_ERR_RECORD_IS_THE_SAME';
exports[170]  = 'HA_ERR_LOGGING_IMPOSSIBLE';
exports[171]  = 'HA_ERR_CORRUPT_EVENT';
exports[172]  = 'HA_ERR_NEW_FILE';
exports[173]  = 'HA_ERR_ROWS_EVENT_APPLY';
exports[174]  = 'HA_ERR_INITIALIZATION';
exports[175]  = 'HA_ERR_FILE_TOO_SHORT';
exports[176]  = 'HA_ERR_WRONG_CRC';
exports[177]  = 'HA_ERR_TOO_MANY_CONCURRENT_TRXS';
exports[178]  = 'HA_ERR_NOT_IN_LOCK_PARTITIONS';
exports[179]  = 'HA_ERR_INDEX_COL_TOO_LONG';
exports[180]  = 'HA_ERR_INDEX_CORRUPT';
exports[181]  = 'HA_ERR_UNDO_REC_TOO_BIG';
exports[182]  = 'HA_FTS_INVALID_DOCID';
exports[183]  = 'HA_ERR_TABLE_IN_FK_CHECK';
exports[184]  = 'HA_ERR_TABLESPACE_EXISTS';
exports[185]  = 'HA_ERR_TOO_MANY_FIELDS';
exports[186]  = 'HA_ERR_ROW_IN_WRONG_PARTITION';
exports[187]  = 'HA_ERR_INNODB_READ_ONLY';
exports[188]  = 'HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT';
exports[189]  = 'HA_ERR_TEMP_FILE_WRITE_FAILURE';
exports[190]  = 'HA_ERR_INNODB_FORCED_RECOVERY';
exports[191]  = 'HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE';
exports[192]  = 'HA_ERR_FK_DEPTH_EXCEEDED';
exports[193]  = 'HA_MISSING_CREATE_OPTION';
exports[194]  = 'HA_ERR_SE_OUT_OF_MEMORY';
exports[195]  = 'HA_ERR_TABLE_CORRUPT';
exports[196]  = 'HA_ERR_QUERY_INTERRUPTED';
exports[197]  = 'HA_ERR_TABLESPACE_MISSING';
exports[198]  = 'HA_ERR_TABLESPACE_IS_NOT_EMPTY';
exports[199]  = 'HA_ERR_WRONG_FILE_NAME';
exports[200]  = 'HA_ERR_NOT_ALLOWED_COMMAND';
exports[201]  = 'HA_ERR_COMPUTE_FAILED';
exports[1000] = 'ER_HASHCHK';
exports[1001] = 'ER_NISAMCHK';
exports[1002] = 'ER_NO';
exports[1003] = 'ER_YES';
exports[1004] = 'ER_CANT_CREATE_FILE';
exports[1005] = 'ER_CANT_CREATE_TABLE';
exports[1006] = 'ER_CANT_CREATE_DB';
exports[1007] = 'ER_DB_CREATE_EXISTS';
exports[1008] = 'ER_DB_DROP_EXISTS';
exports[1009] = 'ER_DB_DROP_DELETE';
exports[1010] = 'ER_DB_DROP_RMDIR';
exports[1011] = 'ER_CANT_DELETE_FILE';
exports[1012] = 'ER_CANT_FIND_SYSTEM_REC';
exports[1013] = 'ER_CANT_GET_STAT';
exports[1014] = 'ER_CANT_GET_WD';
exports[1015] = 'ER_CANT_LOCK';
exports[1016] = 'ER_CANT_OPEN_FILE';
exports[1017] = 'ER_FILE_NOT_FOUND';
exports[1018] = 'ER_CANT_READ_DIR';
exports[1019] = 'ER_CANT_SET_WD';
exports[1020] = 'ER_CHECKREAD';
exports[1021] = 'ER_DISK_FULL';
exports[1022] = 'ER_DUP_KEY';
exports[1023] = 'ER_ERROR_ON_CLOSE';
exports[1024] = 'ER_ERROR_ON_READ';
exports[1025] = 'ER_ERROR_ON_RENAME';
exports[1026] = 'ER_ERROR_ON_WRITE';
exports[1027] = 'ER_FILE_USED';
exports[1028] = 'ER_FILSORT_ABORT';
exports[1029] = 'ER_FORM_NOT_FOUND';
exports[1030] = 'ER_GET_ERRNO';
exports[1031] = 'ER_ILLEGAL_HA';
exports[1032] = 'ER_KEY_NOT_FOUND';
exports[1033] = 'ER_NOT_FORM_FILE';
exports[1034] = 'ER_NOT_KEYFILE';
exports[1035] = 'ER_OLD_KEYFILE';
exports[1036] = 'ER_OPEN_AS_READONLY';
exports[1037] = 'ER_OUTOFMEMORY';
exports[1038] = 'ER_OUT_OF_SORTMEMORY';
exports[1039] = 'ER_UNEXPECTED_EOF';
exports[1040] = 'ER_CON_COUNT_ERROR';
exports[1041] = 'ER_OUT_OF_RESOURCES';
exports[1042] = 'ER_BAD_HOST_ERROR';
exports[1043] = 'ER_HANDSHAKE_ERROR';
exports[1044] = 'ER_DBACCESS_DENIED_ERROR';
exports[1045] = 'ER_ACCESS_DENIED_ERROR';
exports[1046] = 'ER_NO_DB_ERROR';
exports[1047] = 'ER_UNKNOWN_COM_ERROR';
exports[1048] = 'ER_BAD_NULL_ERROR';
exports[1049] = 'ER_BAD_DB_ERROR';
exports[1050] = 'ER_TABLE_EXISTS_ERROR';
exports[1051] = 'ER_BAD_TABLE_ERROR';
exports[1052] = 'ER_NON_UNIQ_ERROR';
exports[1053] = 'ER_SERVER_SHUTDOWN';
exports[1054] = 'ER_BAD_FIELD_ERROR';
exports[1055] = 'ER_WRONG_FIELD_WITH_GROUP';
exports[1056] = 'ER_WRONG_GROUP_FIELD';
exports[1057] = 'ER_WRONG_SUM_SELECT';
exports[1058] = 'ER_WRONG_VALUE_COUNT';
exports[1059] = 'ER_TOO_LONG_IDENT';
exports[1060] = 'ER_DUP_FIELDNAME';
exports[1061] = 'ER_DUP_KEYNAME';
exports[1062] = 'ER_DUP_ENTRY';
exports[1063] = 'ER_WRONG_FIELD_SPEC';
exports[1064] = 'ER_PARSE_ERROR';
exports[1065] = 'ER_EMPTY_QUERY';
exports[1066] = 'ER_NONUNIQ_TABLE';
exports[1067] = 'ER_INVALID_DEFAULT';
exports[1068] = 'ER_MULTIPLE_PRI_KEY';
exports[1069] = 'ER_TOO_MANY_KEYS';
exports[1070] = 'ER_TOO_MANY_KEY_PARTS';
exports[1071] = 'ER_TOO_LONG_KEY';
exports[1072] = 'ER_KEY_COLUMN_DOES_NOT_EXITS';
exports[1073] = 'ER_BLOB_USED_AS_KEY';
exports[1074] = 'ER_TOO_BIG_FIELDLENGTH';
exports[1075] = 'ER_WRONG_AUTO_KEY';
exports[1076] = 'ER_READY';
exports[1077] = 'ER_NORMAL_SHUTDOWN';
exports[1078] = 'ER_GOT_SIGNAL';
exports[1079] = 'ER_SHUTDOWN_COMPLETE';
exports[1080] = 'ER_FORCING_CLOSE';
exports[1081] = 'ER_IPSOCK_ERROR';
exports[1082] = 'ER_NO_SUCH_INDEX';
exports[1083] = 'ER_WRONG_FIELD_TERMINATORS';
exports[1084] = 'ER_BLOBS_AND_NO_TERMINATED';
exports[1085] = 'ER_TEXTFILE_NOT_READABLE';
exports[1086] = 'ER_FILE_EXISTS_ERROR';
exports[1087] = 'ER_LOAD_INFO';
exports[1088] = 'ER_ALTER_INFO';
exports[1089] = 'ER_WRONG_SUB_KEY';
exports[1090] = 'ER_CANT_REMOVE_ALL_FIELDS';
exports[1091] = 'ER_CANT_DROP_FIELD_OR_KEY';
exports[1092] = 'ER_INSERT_INFO';
exports[1093] = 'ER_UPDATE_TABLE_USED';
exports[1094] = 'ER_NO_SUCH_THREAD';
exports[1095] = 'ER_KILL_DENIED_ERROR';
exports[1096] = 'ER_NO_TABLES_USED';
exports[1097] = 'ER_TOO_BIG_SET';
exports[1098] = 'ER_NO_UNIQUE_LOGFILE';
exports[1099] = 'ER_TABLE_NOT_LOCKED_FOR_WRITE';
exports[1100] = 'ER_TABLE_NOT_LOCKED';
exports[1101] = 'ER_BLOB_CANT_HAVE_DEFAULT';
exports[1102] = 'ER_WRONG_DB_NAME';
exports[1103] = 'ER_WRONG_TABLE_NAME';
exports[1104] = 'ER_TOO_BIG_SELECT';
exports[1105] = 'ER_UNKNOWN_ERROR';
exports[1106] = 'ER_UNKNOWN_PROCEDURE';
exports[1107] = 'ER_WRONG_PARAMCOUNT_TO_PROCEDURE';
exports[1108] = 'ER_WRONG_PARAMETERS_TO_PROCEDURE';
exports[1109] = 'ER_UNKNOWN_TABLE';
exports[1110] = 'ER_FIELD_SPECIFIED_TWICE';
exports[1111] = 'ER_INVALID_GROUP_FUNC_USE';
exports[1112] = 'ER_UNSUPPORTED_EXTENSION';
exports[1113] = 'ER_TABLE_MUST_HAVE_COLUMNS';
exports[1114] = 'ER_RECORD_FILE_FULL';
exports[1115] = 'ER_UNKNOWN_CHARACTER_SET';
exports[1116] = 'ER_TOO_MANY_TABLES';
exports[1117] = 'ER_TOO_MANY_FIELDS';
exports[1118] = 'ER_TOO_BIG_ROWSIZE';
exports[1119] = 'ER_STACK_OVERRUN';
exports[1120] = 'ER_WRONG_OUTER_JOIN';
exports[1121] = 'ER_NULL_COLUMN_IN_INDEX';
exports[1122] = 'ER_CANT_FIND_UDF';
exports[1123] = 'ER_CANT_INITIALIZE_UDF';
exports[1124] = 'ER_UDF_NO_PATHS';
exports[1125] = 'ER_UDF_EXISTS';
exports[1126] = 'ER_CANT_OPEN_LIBRARY';
exports[1127] = 'ER_CANT_FIND_DL_ENTRY';
exports[1128] = 'ER_FUNCTION_NOT_DEFINED';
exports[1129] = 'ER_HOST_IS_BLOCKED';
exports[1130] = 'ER_HOST_NOT_PRIVILEGED';
exports[1131] = 'ER_PASSWORD_ANONYMOUS_USER';
exports[1132] = 'ER_PASSWORD_NOT_ALLOWED';
exports[1133] = 'ER_PASSWORD_NO_MATCH';
exports[1134] = 'ER_UPDATE_INFO';
exports[1135] = 'ER_CANT_CREATE_THREAD';
exports[1136] = 'ER_WRONG_VALUE_COUNT_ON_ROW';
exports[1137] = 'ER_CANT_REOPEN_TABLE';
exports[1138] = 'ER_INVALID_USE_OF_NULL';
exports[1139] = 'ER_REGEXP_ERROR';
exports[1140] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS';
exports[1141] = 'ER_NONEXISTING_GRANT';
exports[1142] = 'ER_TABLEACCESS_DENIED_ERROR';
exports[1143] = 'ER_COLUMNACCESS_DENIED_ERROR';
exports[1144] = 'ER_ILLEGAL_GRANT_FOR_TABLE';
exports[1145] = 'ER_GRANT_WRONG_HOST_OR_USER';
exports[1146] = 'ER_NO_SUCH_TABLE';
exports[1147] = 'ER_NONEXISTING_TABLE_GRANT';
exports[1148] = 'ER_NOT_ALLOWED_COMMAND';
exports[1149] = 'ER_SYNTAX_ERROR';
exports[1150] = 'ER_DELAYED_CANT_CHANGE_LOCK';
exports[1151] = 'ER_TOO_MANY_DELAYED_THREADS';
exports[1152] = 'ER_ABORTING_CONNECTION';
exports[1153] = 'ER_NET_PACKET_TOO_LARGE';
exports[1154] = 'ER_NET_READ_ERROR_FROM_PIPE';
exports[1155] = 'ER_NET_FCNTL_ERROR';
exports[1156] = 'ER_NET_PACKETS_OUT_OF_ORDER';
exports[1157] = 'ER_NET_UNCOMPRESS_ERROR';
exports[1158] = 'ER_NET_READ_ERROR';
exports[1159] = 'ER_NET_READ_INTERRUPTED';
exports[1160] = 'ER_NET_ERROR_ON_WRITE';
exports[1161] = 'ER_NET_WRITE_INTERRUPTED';
exports[1162] = 'ER_TOO_LONG_STRING';
exports[1163] = 'ER_TABLE_CANT_HANDLE_BLOB';
exports[1164] = 'ER_TABLE_CANT_HANDLE_AUTO_INCREMENT';
exports[1165] = 'ER_DELAYED_INSERT_TABLE_LOCKED';
exports[1166] = 'ER_WRONG_COLUMN_NAME';
exports[1167] = 'ER_WRONG_KEY_COLUMN';
exports[1168] = 'ER_WRONG_MRG_TABLE';
exports[1169] = 'ER_DUP_UNIQUE';
exports[1170] = 'ER_BLOB_KEY_WITHOUT_LENGTH';
exports[1171] = 'ER_PRIMARY_CANT_HAVE_NULL';
exports[1172] = 'ER_TOO_MANY_ROWS';
exports[1173] = 'ER_REQUIRES_PRIMARY_KEY';
exports[1174] = 'ER_NO_RAID_COMPILED';
exports[1175] = 'ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE';
exports[1176] = 'ER_KEY_DOES_NOT_EXITS';
exports[1177] = 'ER_CHECK_NO_SUCH_TABLE';
exports[1178] = 'ER_CHECK_NOT_IMPLEMENTED';
exports[1179] = 'ER_CANT_DO_THIS_DURING_AN_TRANSACTION';
exports[1180] = 'ER_ERROR_DURING_COMMIT';
exports[1181] = 'ER_ERROR_DURING_ROLLBACK';
exports[1182] = 'ER_ERROR_DURING_FLUSH_LOGS';
exports[1183] = 'ER_ERROR_DURING_CHECKPOINT';
exports[1184] = 'ER_NEW_ABORTING_CONNECTION';
exports[1185] = 'ER_DUMP_NOT_IMPLEMENTED';
exports[1186] = 'ER_FLUSH_MASTER_BINLOG_CLOSED';
exports[1187] = 'ER_INDEX_REBUILD';
exports[1188] = 'ER_MASTER';
exports[1189] = 'ER_MASTER_NET_READ';
exports[1190] = 'ER_MASTER_NET_WRITE';
exports[1191] = 'ER_FT_MATCHING_KEY_NOT_FOUND';
exports[1192] = 'ER_LOCK_OR_ACTIVE_TRANSACTION';
exports[1193] = 'ER_UNKNOWN_SYSTEM_VARIABLE';
exports[1194] = 'ER_CRASHED_ON_USAGE';
exports[1195] = 'ER_CRASHED_ON_REPAIR';
exports[1196] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK';
exports[1197] = 'ER_TRANS_CACHE_FULL';
exports[1198] = 'ER_SLAVE_MUST_STOP';
exports[1199] = 'ER_SLAVE_NOT_RUNNING';
exports[1200] = 'ER_BAD_SLAVE';
exports[1201] = 'ER_MASTER_INFO';
exports[1202] = 'ER_SLAVE_THREAD';
exports[1203] = 'ER_TOO_MANY_USER_CONNECTIONS';
exports[1204] = 'ER_SET_CONSTANTS_ONLY';
exports[1205] = 'ER_LOCK_WAIT_TIMEOUT';
exports[1206] = 'ER_LOCK_TABLE_FULL';
exports[1207] = 'ER_READ_ONLY_TRANSACTION';
exports[1208] = 'ER_DROP_DB_WITH_READ_LOCK';
exports[1209] = 'ER_CREATE_DB_WITH_READ_LOCK';
exports[1210] = 'ER_WRONG_ARGUMENTS';
exports[1211] = 'ER_NO_PERMISSION_TO_CREATE_USER';
exports[1212] = 'ER_UNION_TABLES_IN_DIFFERENT_DIR';
exports[1213] = 'ER_LOCK_DEADLOCK';
exports[1214] = 'ER_TABLE_CANT_HANDLE_FT';
exports[1215] = 'ER_CANNOT_ADD_FOREIGN';
exports[1216] = 'ER_NO_REFERENCED_ROW';
exports[1217] = 'ER_ROW_IS_REFERENCED';
exports[1218] = 'ER_CONNECT_TO_MASTER';
exports[1219] = 'ER_QUERY_ON_MASTER';
exports[1220] = 'ER_ERROR_WHEN_EXECUTING_COMMAND';
exports[1221] = 'ER_WRONG_USAGE';
exports[1222] = 'ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT';
exports[1223] = 'ER_CANT_UPDATE_WITH_READLOCK';
exports[1224] = 'ER_MIXING_NOT_ALLOWED';
exports[1225] = 'ER_DUP_ARGUMENT';
exports[1226] = 'ER_USER_LIMIT_REACHED';
exports[1227] = 'ER_SPECIFIC_ACCESS_DENIED_ERROR';
exports[1228] = 'ER_LOCAL_VARIABLE';
exports[1229] = 'ER_GLOBAL_VARIABLE';
exports[1230] = 'ER_NO_DEFAULT';
exports[1231] = 'ER_WRONG_VALUE_FOR_VAR';
exports[1232] = 'ER_WRONG_TYPE_FOR_VAR';
exports[1233] = 'ER_VAR_CANT_BE_READ';
exports[1234] = 'ER_CANT_USE_OPTION_HERE';
exports[1235] = 'ER_NOT_SUPPORTED_YET';
exports[1236] = 'ER_MASTER_FATAL_ERROR_READING_BINLOG';
exports[1237] = 'ER_SLAVE_IGNORED_TABLE';
exports[1238] = 'ER_INCORRECT_GLOBAL_LOCAL_VAR';
exports[1239] = 'ER_WRONG_FK_DEF';
exports[1240] = 'ER_KEY_REF_DO_NOT_MATCH_TABLE_REF';
exports[1241] = 'ER_OPERAND_COLUMNS';
exports[1242] = 'ER_SUBQUERY_NO_1_ROW';
exports[1243] = 'ER_UNKNOWN_STMT_HANDLER';
exports[1244] = 'ER_CORRUPT_HELP_DB';
exports[1245] = 'ER_CYCLIC_REFERENCE';
exports[1246] = 'ER_AUTO_CONVERT';
exports[1247] = 'ER_ILLEGAL_REFERENCE';
exports[1248] = 'ER_DERIVED_MUST_HAVE_ALIAS';
exports[1249] = 'ER_SELECT_REDUCED';
exports[1250] = 'ER_TABLENAME_NOT_ALLOWED_HERE';
exports[1251] = 'ER_NOT_SUPPORTED_AUTH_MODE';
exports[1252] = 'ER_SPATIAL_CANT_HAVE_NULL';
exports[1253] = 'ER_COLLATION_CHARSET_MISMATCH';
exports[1254] = 'ER_SLAVE_WAS_RUNNING';
exports[1255] = 'ER_SLAVE_WAS_NOT_RUNNING';
exports[1256] = 'ER_TOO_BIG_FOR_UNCOMPRESS';
exports[1257] = 'ER_ZLIB_Z_MEM_ERROR';
exports[1258] = 'ER_ZLIB_Z_BUF_ERROR';
exports[1259] = 'ER_ZLIB_Z_DATA_ERROR';
exports[1260] = 'ER_CUT_VALUE_GROUP_CONCAT';
exports[1261] = 'ER_WARN_TOO_FEW_RECORDS';
exports[1262] = 'ER_WARN_TOO_MANY_RECORDS';
exports[1263] = 'ER_WARN_NULL_TO_NOTNULL';
exports[1264] = 'ER_WARN_DATA_OUT_OF_RANGE';
exports[1265] = 'WARN_DATA_TRUNCATED';
exports[1266] = 'ER_WARN_USING_OTHER_HANDLER';
exports[1267] = 'ER_CANT_AGGREGATE_2COLLATIONS';
exports[1268] = 'ER_DROP_USER';
exports[1269] = 'ER_REVOKE_GRANTS';
exports[1270] = 'ER_CANT_AGGREGATE_3COLLATIONS';
exports[1271] = 'ER_CANT_AGGREGATE_NCOLLATIONS';
exports[1272] = 'ER_VARIABLE_IS_NOT_STRUCT';
exports[1273] = 'ER_UNKNOWN_COLLATION';
exports[1274] = 'ER_SLAVE_IGNORED_SSL_PARAMS';
exports[1275] = 'ER_SERVER_IS_IN_SECURE_AUTH_MODE';
exports[1276] = 'ER_WARN_FIELD_RESOLVED';
exports[1277] = 'ER_BAD_SLAVE_UNTIL_COND';
exports[1278] = 'ER_MISSING_SKIP_SLAVE';
exports[1279] = 'ER_UNTIL_COND_IGNORED';
exports[1280] = 'ER_WRONG_NAME_FOR_INDEX';
exports[1281] = 'ER_WRONG_NAME_FOR_CATALOG';
exports[1282] = 'ER_WARN_QC_RESIZE';
exports[1283] = 'ER_BAD_FT_COLUMN';
exports[1284] = 'ER_UNKNOWN_KEY_CACHE';
exports[1285] = 'ER_WARN_HOSTNAME_WONT_WORK';
exports[1286] = 'ER_UNKNOWN_STORAGE_ENGINE';
exports[1287] = 'ER_WARN_DEPRECATED_SYNTAX';
exports[1288] = 'ER_NON_UPDATABLE_TABLE';
exports[1289] = 'ER_FEATURE_DISABLED';
exports[1290] = 'ER_OPTION_PREVENTS_STATEMENT';
exports[1291] = 'ER_DUPLICATED_VALUE_IN_TYPE';
exports[1292] = 'ER_TRUNCATED_WRONG_VALUE';
exports[1293] = 'ER_TOO_MUCH_AUTO_TIMESTAMP_COLS';
exports[1294] = 'ER_INVALID_ON_UPDATE';
exports[1295] = 'ER_UNSUPPORTED_PS';
exports[1296] = 'ER_GET_ERRMSG';
exports[1297] = 'ER_GET_TEMPORARY_ERRMSG';
exports[1298] = 'ER_UNKNOWN_TIME_ZONE';
exports[1299] = 'ER_WARN_INVALID_TIMESTAMP';
exports[1300] = 'ER_INVALID_CHARACTER_STRING';
exports[1301] = 'ER_WARN_ALLOWED_PACKET_OVERFLOWED';
exports[1302] = 'ER_CONFLICTING_DECLARATIONS';
exports[1303] = 'ER_SP_NO_RECURSIVE_CREATE';
exports[1304] = 'ER_SP_ALREADY_EXISTS';
exports[1305] = 'ER_SP_DOES_NOT_EXIST';
exports[1306] = 'ER_SP_DROP_FAILED';
exports[1307] = 'ER_SP_STORE_FAILED';
exports[1308] = 'ER_SP_LILABEL_MISMATCH';
exports[1309] = 'ER_SP_LABEL_REDEFINE';
exports[1310] = 'ER_SP_LABEL_MISMATCH';
exports[1311] = 'ER_SP_UNINIT_VAR';
exports[1312] = 'ER_SP_BADSELECT';
exports[1313] = 'ER_SP_BADRETURN';
exports[1314] = 'ER_SP_BADSTATEMENT';
exports[1315] = 'ER_UPDATE_LOG_DEPRECATED_IGNORED';
exports[1316] = 'ER_UPDATE_LOG_DEPRECATED_TRANSLATED';
exports[1317] = 'ER_QUERY_INTERRUPTED';
exports[1318] = 'ER_SP_WRONG_NO_OF_ARGS';
exports[1319] = 'ER_SP_COND_MISMATCH';
exports[1320] = 'ER_SP_NORETURN';
exports[1321] = 'ER_SP_NORETURNEND';
exports[1322] = 'ER_SP_BAD_CURSOR_QUERY';
exports[1323] = 'ER_SP_BAD_CURSOR_SELECT';
exports[1324] = 'ER_SP_CURSOR_MISMATCH';
exports[1325] = 'ER_SP_CURSOR_ALREADY_OPEN';
exports[1326] = 'ER_SP_CURSOR_NOT_OPEN';
exports[1327] = 'ER_SP_UNDECLARED_VAR';
exports[1328] = 'ER_SP_WRONG_NO_OF_FETCH_ARGS';
exports[1329] = 'ER_SP_FETCH_NO_DATA';
exports[1330] = 'ER_SP_DUP_PARAM';
exports[1331] = 'ER_SP_DUP_VAR';
exports[1332] = 'ER_SP_DUP_COND';
exports[1333] = 'ER_SP_DUP_CURS';
exports[1334] = 'ER_SP_CANT_ALTER';
exports[1335] = 'ER_SP_SUBSELECT_NYI';
exports[1336] = 'ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG';
exports[1337] = 'ER_SP_VARCOND_AFTER_CURSHNDLR';
exports[1338] = 'ER_SP_CURSOR_AFTER_HANDLER';
exports[1339] = 'ER_SP_CASE_NOT_FOUND';
exports[1340] = 'ER_FPARSER_TOO_BIG_FILE';
exports[1341] = 'ER_FPARSER_BAD_HEADER';
exports[1342] = 'ER_FPARSER_EOF_IN_COMMENT';
exports[1343] = 'ER_FPARSER_ERROR_IN_PARAMETER';
exports[1344] = 'ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER';
exports[1345] = 'ER_VIEW_NO_EXPLAIN';
exports[1346] = 'ER_FRM_UNKNOWN_TYPE';
exports[1347] = 'ER_WRONG_OBJECT';
exports[1348] = 'ER_NONUPDATEABLE_COLUMN';
exports[1349] = 'ER_VIEW_SELECT_DERIVED';
exports[1350] = 'ER_VIEW_SELECT_CLAUSE';
exports[1351] = 'ER_VIEW_SELECT_VARIABLE';
exports[1352] = 'ER_VIEW_SELECT_TMPTABLE';
exports[1353] = 'ER_VIEW_WRONG_LIST';
exports[1354] = 'ER_WARN_VIEW_MERGE';
exports[1355] = 'ER_WARN_VIEW_WITHOUT_KEY';
exports[1356] = 'ER_VIEW_INVALID';
exports[1357] = 'ER_SP_NO_DROP_SP';
exports[1358] = 'ER_SP_GOTO_IN_HNDLR';
exports[1359] = 'ER_TRG_ALREADY_EXISTS';
exports[1360] = 'ER_TRG_DOES_NOT_EXIST';
exports[1361] = 'ER_TRG_ON_VIEW_OR_TEMP_TABLE';
exports[1362] = 'ER_TRG_CANT_CHANGE_ROW';
exports[1363] = 'ER_TRG_NO_SUCH_ROW_IN_TRG';
exports[1364] = 'ER_NO_DEFAULT_FOR_FIELD';
exports[1365] = 'ER_DIVISION_BY_ZERO';
exports[1366] = 'ER_TRUNCATED_WRONG_VALUE_FOR_FIELD';
exports[1367] = 'ER_ILLEGAL_VALUE_FOR_TYPE';
exports[1368] = 'ER_VIEW_NONUPD_CHECK';
exports[1369] = 'ER_VIEW_CHECK_FAILED';
exports[1370] = 'ER_PROCACCESS_DENIED_ERROR';
exports[1371] = 'ER_RELAY_LOG_FAIL';
exports[1372] = 'ER_PASSWD_LENGTH';
exports[1373] = 'ER_UNKNOWN_TARGET_BINLOG';
exports[1374] = 'ER_IO_ERR_LOG_INDEX_READ';
exports[1375] = 'ER_BINLOG_PURGE_PROHIBITED';
exports[1376] = 'ER_FSEEK_FAIL';
exports[1377] = 'ER_BINLOG_PURGE_FATAL_ERR';
exports[1378] = 'ER_LOG_IN_USE';
exports[1379] = 'ER_LOG_PURGE_UNKNOWN_ERR';
exports[1380] = 'ER_RELAY_LOG_INIT';
exports[1381] = 'ER_NO_BINARY_LOGGING';
exports[1382] = 'ER_RESERVED_SYNTAX';
exports[1383] = 'ER_WSAS_FAILED';
exports[1384] = 'ER_DIFF_GROUPS_PROC';
exports[1385] = 'ER_NO_GROUP_FOR_PROC';
exports[1386] = 'ER_ORDER_WITH_PROC';
exports[1387] = 'ER_LOGGING_PROHIBIT_CHANGING_OF';
exports[1388] = 'ER_NO_FILE_MAPPING';
exports[1389] = 'ER_WRONG_MAGIC';
exports[1390] = 'ER_PS_MANY_PARAM';
exports[1391] = 'ER_KEY_PART_0';
exports[1392] = 'ER_VIEW_CHECKSUM';
exports[1393] = 'ER_VIEW_MULTIUPDATE';
exports[1394] = 'ER_VIEW_NO_INSERT_FIELD_LIST';
exports[1395] = 'ER_VIEW_DELETE_MERGE_VIEW';
exports[1396] = 'ER_CANNOT_USER';
exports[1397] = 'ER_XAER_NOTA';
exports[1398] = 'ER_XAER_INVAL';
exports[1399] = 'ER_XAER_RMFAIL';
exports[1400] = 'ER_XAER_OUTSIDE';
exports[1401] = 'ER_XAER_RMERR';
exports[1402] = 'ER_XA_RBROLLBACK';
exports[1403] = 'ER_NONEXISTING_PROC_GRANT';
exports[1404] = 'ER_PROC_AUTO_GRANT_FAIL';
exports[1405] = 'ER_PROC_AUTO_REVOKE_FAIL';
exports[1406] = 'ER_DATA_TOO_LONG';
exports[1407] = 'ER_SP_BAD_SQLSTATE';
exports[1408] = 'ER_STARTUP';
exports[1409] = 'ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR';
exports[1410] = 'ER_CANT_CREATE_USER_WITH_GRANT';
exports[1411] = 'ER_WRONG_VALUE_FOR_TYPE';
exports[1412] = 'ER_TABLE_DEF_CHANGED';
exports[1413] = 'ER_SP_DUP_HANDLER';
exports[1414] = 'ER_SP_NOT_VAR_ARG';
exports[1415] = 'ER_SP_NO_RETSET';
exports[1416] = 'ER_CANT_CREATE_GEOMETRY_OBJECT';
exports[1417] = 'ER_FAILED_ROUTINE_BREAK_BINLOG';
exports[1418] = 'ER_BINLOG_UNSAFE_ROUTINE';
exports[1419] = 'ER_BINLOG_CREATE_ROUTINE_NEED_SUPER';
exports[1420] = 'ER_EXEC_STMT_WITH_OPEN_CURSOR';
exports[1421] = 'ER_STMT_HAS_NO_OPEN_CURSOR';
exports[1422] = 'ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG';
exports[1423] = 'ER_NO_DEFAULT_FOR_VIEW_FIELD';
exports[1424] = 'ER_SP_NO_RECURSION';
exports[1425] = 'ER_TOO_BIG_SCALE';
exports[1426] = 'ER_TOO_BIG_PRECISION';
exports[1427] = 'ER_M_BIGGER_THAN_D';
exports[1428] = 'ER_WRONG_LOCK_OF_SYSTEM_TABLE';
exports[1429] = 'ER_CONNECT_TO_FOREIGN_DATA_SOURCE';
exports[1430] = 'ER_QUERY_ON_FOREIGN_DATA_SOURCE';
exports[1431] = 'ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST';
exports[1432] = 'ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE';
exports[1433] = 'ER_FOREIGN_DATA_STRING_INVALID';
exports[1434] = 'ER_CANT_CREATE_FEDERATED_TABLE';
exports[1435] = 'ER_TRG_IN_WRONG_SCHEMA';
exports[1436] = 'ER_STACK_OVERRUN_NEED_MORE';
exports[1437] = 'ER_TOO_LONG_BODY';
exports[1438] = 'ER_WARN_CANT_DROP_DEFAULT_KEYCACHE';
exports[1439] = 'ER_TOO_BIG_DISPLAYWIDTH';
exports[1440] = 'ER_XAER_DUPID';
exports[1441] = 'ER_DATETIME_FUNCTION_OVERFLOW';
exports[1442] = 'ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG';
exports[1443] = 'ER_VIEW_PREVENT_UPDATE';
exports[1444] = 'ER_PS_NO_RECURSION';
exports[1445] = 'ER_SP_CANT_SET_AUTOCOMMIT';
exports[1446] = 'ER_MALFORMED_DEFINER';
exports[1447] = 'ER_VIEW_FRM_NO_USER';
exports[1448] = 'ER_VIEW_OTHER_USER';
exports[1449] = 'ER_NO_SUCH_USER';
exports[1450] = 'ER_FORBID_SCHEMA_CHANGE';
exports[1451] = 'ER_ROW_IS_REFERENCED_2';
exports[1452] = 'ER_NO_REFERENCED_ROW_2';
exports[1453] = 'ER_SP_BAD_VAR_SHADOW';
exports[1454] = 'ER_TRG_NO_DEFINER';
exports[1455] = 'ER_OLD_FILE_FORMAT';
exports[1456] = 'ER_SP_RECURSION_LIMIT';
exports[1457] = 'ER_SP_PROC_TABLE_CORRUPT';
exports[1458] = 'ER_SP_WRONG_NAME';
exports[1459] = 'ER_TABLE_NEEDS_UPGRADE';
exports[1460] = 'ER_SP_NO_AGGREGATE';
exports[1461] = 'ER_MAX_PREPARED_STMT_COUNT_REACHED';
exports[1462] = 'ER_VIEW_RECURSIVE';
exports[1463] = 'ER_NON_GROUPING_FIELD_USED';
exports[1464] = 'ER_TABLE_CANT_HANDLE_SPKEYS';
exports[1465] = 'ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA';
exports[1466] = 'ER_REMOVED_SPACES';
exports[1467] = 'ER_AUTOINC_READ_FAILED';
exports[1468] = 'ER_USERNAME';
exports[1469] = 'ER_HOSTNAME';
exports[1470] = 'ER_WRONG_STRING_LENGTH';
exports[1471] = 'ER_NON_INSERTABLE_TABLE';
exports[1472] = 'ER_ADMIN_WRONG_MRG_TABLE';
exports[1473] = 'ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT';
exports[1474] = 'ER_NAME_BECOMES_EMPTY';
exports[1475] = 'ER_AMBIGUOUS_FIELD_TERM';
exports[1476] = 'ER_FOREIGN_SERVER_EXISTS';
exports[1477] = 'ER_FOREIGN_SERVER_DOESNT_EXIST';
exports[1478] = 'ER_ILLEGAL_HA_CREATE_OPTION';
exports[1479] = 'ER_PARTITION_REQUIRES_VALUES_ERROR';
exports[1480] = 'ER_PARTITION_WRONG_VALUES_ERROR';
exports[1481] = 'ER_PARTITION_MAXVALUE_ERROR';
exports[1482] = 'ER_PARTITION_SUBPARTITION_ERROR';
exports[1483] = 'ER_PARTITION_SUBPART_MIX_ERROR';
exports[1484] = 'ER_PARTITION_WRONG_NO_PART_ERROR';
exports[1485] = 'ER_PARTITION_WRONG_NO_SUBPART_ERROR';
exports[1486] = 'ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR';
exports[1487] = 'ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR';
exports[1488] = 'ER_FIELD_NOT_FOUND_PART_ERROR';
exports[1489] = 'ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR';
exports[1490] = 'ER_INCONSISTENT_PARTITION_INFO_ERROR';
exports[1491] = 'ER_PARTITION_FUNC_NOT_ALLOWED_ERROR';
exports[1492] = 'ER_PARTITIONS_MUST_BE_DEFINED_ERROR';
exports[1493] = 'ER_RANGE_NOT_INCREASING_ERROR';
exports[1494] = 'ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR';
exports[1495] = 'ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR';
exports[1496] = 'ER_PARTITION_ENTRY_ERROR';
exports[1497] = 'ER_MIX_HANDLER_ERROR';
exports[1498] = 'ER_PARTITION_NOT_DEFINED_ERROR';
exports[1499] = 'ER_TOO_MANY_PARTITIONS_ERROR';
exports[1500] = 'ER_SUBPARTITION_ERROR';
exports[1501] = 'ER_CANT_CREATE_HANDLER_FILE';
exports[1502] = 'ER_BLOB_FIELD_IN_PART_FUNC_ERROR';
exports[1503] = 'ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF';
exports[1504] = 'ER_NO_PARTS_ERROR';
exports[1505] = 'ER_PARTITION_MGMT_ON_NONPARTITIONED';
exports[1506] = 'ER_FOREIGN_KEY_ON_PARTITIONED';
exports[1507] = 'ER_DROP_PARTITION_NON_EXISTENT';
exports[1508] = 'ER_DROP_LAST_PARTITION';
exports[1509] = 'ER_COALESCE_ONLY_ON_HASH_PARTITION';
exports[1510] = 'ER_REORG_HASH_ONLY_ON_SAME_NO';
exports[1511] = 'ER_REORG_NO_PARAM_ERROR';
exports[1512] = 'ER_ONLY_ON_RANGE_LIST_PARTITION';
exports[1513] = 'ER_ADD_PARTITION_SUBPART_ERROR';
exports[1514] = 'ER_ADD_PARTITION_NO_NEW_PARTITION';
exports[1515] = 'ER_COALESCE_PARTITION_NO_PARTITION';
exports[1516] = 'ER_REORG_PARTITION_NOT_EXIST';
exports[1517] = 'ER_SAME_NAME_PARTITION';
exports[1518] = 'ER_NO_BINLOG_ERROR';
exports[1519] = 'ER_CONSECUTIVE_REORG_PARTITIONS';
exports[1520] = 'ER_REORG_OUTSIDE_RANGE';
exports[1521] = 'ER_PARTITION_FUNCTION_FAILURE';
exports[1522] = 'ER_PART_STATE_ERROR';
exports[1523] = 'ER_LIMITED_PART_RANGE';
exports[1524] = 'ER_PLUGIN_IS_NOT_LOADED';
exports[1525] = 'ER_WRONG_VALUE';
exports[1526] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE';
exports[1527] = 'ER_FILEGROUP_OPTION_ONLY_ONCE';
exports[1528] = 'ER_CREATE_FILEGROUP_FAILED';
exports[1529] = 'ER_DROP_FILEGROUP_FAILED';
exports[1530] = 'ER_TABLESPACE_AUTO_EXTEND_ERROR';
exports[1531] = 'ER_WRONG_SIZE_NUMBER';
exports[1532] = 'ER_SIZE_OVERFLOW_ERROR';
exports[1533] = 'ER_ALTER_FILEGROUP_FAILED';
exports[1534] = 'ER_BINLOG_ROW_LOGGING_FAILED';
exports[1535] = 'ER_BINLOG_ROW_WRONG_TABLE_DEF';
exports[1536] = 'ER_BINLOG_ROW_RBR_TO_SBR';
exports[1537] = 'ER_EVENT_ALREADY_EXISTS';
exports[1538] = 'ER_EVENT_STORE_FAILED';
exports[1539] = 'ER_EVENT_DOES_NOT_EXIST';
exports[1540] = 'ER_EVENT_CANT_ALTER';
exports[1541] = 'ER_EVENT_DROP_FAILED';
exports[1542] = 'ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG';
exports[1543] = 'ER_EVENT_ENDS_BEFORE_STARTS';
exports[1544] = 'ER_EVENT_EXEC_TIME_IN_THE_PAST';
exports[1545] = 'ER_EVENT_OPEN_TABLE_FAILED';
exports[1546] = 'ER_EVENT_NEITHER_M_EXPR_NOR_M_AT';
exports[1547] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED';
exports[1548] = 'ER_CANNOT_LOAD_FROM_TABLE';
exports[1549] = 'ER_EVENT_CANNOT_DELETE';
exports[1550] = 'ER_EVENT_COMPILE_ERROR';
exports[1551] = 'ER_EVENT_SAME_NAME';
exports[1552] = 'ER_EVENT_DATA_TOO_LONG';
exports[1553] = 'ER_DROP_INDEX_FK';
exports[1554] = 'ER_WARN_DEPRECATED_SYNTAX_WITH_VER';
exports[1555] = 'ER_CANT_WRITE_LOCK_LOG_TABLE';
exports[1556] = 'ER_CANT_LOCK_LOG_TABLE';
exports[1557] = 'ER_FOREIGN_DUPLICATE_KEY';
exports[1558] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE';
exports[1559] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR';
exports[1560] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT';
exports[1561] = 'ER_NDB_CANT_SWITCH_BINLOG_FORMAT';
exports[1562] = 'ER_PARTITION_NO_TEMPORARY';
exports[1563] = 'ER_PARTITION_CONST_DOMAIN_ERROR';
exports[1564] = 'ER_PARTITION_FUNCTION_IS_NOT_ALLOWED';
exports[1565] = 'ER_DDL_LOG_ERROR';
exports[1566] = 'ER_NULL_IN_VALUES_LESS_THAN';
exports[1567] = 'ER_WRONG_PARTITION_NAME';
exports[1568] = 'ER_CANT_CHANGE_TX_CHARACTERISTICS';
exports[1569] = 'ER_DUP_ENTRY_AUTOINCREMENT_CASE';
exports[1570] = 'ER_EVENT_MODIFY_QUEUE_ERROR';
exports[1571] = 'ER_EVENT_SET_VAR_ERROR';
exports[1572] = 'ER_PARTITION_MERGE_ERROR';
exports[1573] = 'ER_CANT_ACTIVATE_LOG';
exports[1574] = 'ER_RBR_NOT_AVAILABLE';
exports[1575] = 'ER_BASE64_DECODE_ERROR';
exports[1576] = 'ER_EVENT_RECURSION_FORBIDDEN';
exports[1577] = 'ER_EVENTS_DB_ERROR';
exports[1578] = 'ER_ONLY_INTEGERS_ALLOWED';
exports[1579] = 'ER_UNSUPORTED_LOG_ENGINE';
exports[1580] = 'ER_BAD_LOG_STATEMENT';
exports[1581] = 'ER_CANT_RENAME_LOG_TABLE';
exports[1582] = 'ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT';
exports[1583] = 'ER_WRONG_PARAMETERS_TO_NATIVE_FCT';
exports[1584] = 'ER_WRONG_PARAMETERS_TO_STORED_FCT';
exports[1585] = 'ER_NATIVE_FCT_NAME_COLLISION';
exports[1586] = 'ER_DUP_ENTRY_WITH_KEY_NAME';
exports[1587] = 'ER_BINLOG_PURGE_EMFILE';
exports[1588] = 'ER_EVENT_CANNOT_CREATE_IN_THE_PAST';
exports[1589] = 'ER_EVENT_CANNOT_ALTER_IN_THE_PAST';
exports[1590] = 'ER_SLAVE_INCIDENT';
exports[1591] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT';
exports[1592] = 'ER_BINLOG_UNSAFE_STATEMENT';
exports[1593] = 'ER_SLAVE_FATAL_ERROR';
exports[1594] = 'ER_SLAVE_RELAY_LOG_READ_FAILURE';
exports[1595] = 'ER_SLAVE_RELAY_LOG_WRITE_FAILURE';
exports[1596] = 'ER_SLAVE_CREATE_EVENT_FAILURE';
exports[1597] = 'ER_SLAVE_MASTER_COM_FAILURE';
exports[1598] = 'ER_BINLOG_LOGGING_IMPOSSIBLE';
exports[1599] = 'ER_VIEW_NO_CREATION_CTX';
exports[1600] = 'ER_VIEW_INVALID_CREATION_CTX';
exports[1601] = 'ER_SR_INVALID_CREATION_CTX';
exports[1602] = 'ER_TRG_CORRUPTED_FILE';
exports[1603] = 'ER_TRG_NO_CREATION_CTX';
exports[1604] = 'ER_TRG_INVALID_CREATION_CTX';
exports[1605] = 'ER_EVENT_INVALID_CREATION_CTX';
exports[1606] = 'ER_TRG_CANT_OPEN_TABLE';
exports[1607] = 'ER_CANT_CREATE_SROUTINE';
exports[1608] = 'ER_NEVER_USED';
exports[1609] = 'ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT';
exports[1610] = 'ER_SLAVE_CORRUPT_EVENT';
exports[1611] = 'ER_LOAD_DATA_INVALID_COLUMN';
exports[1612] = 'ER_LOG_PURGE_NO_FILE';
exports[1613] = 'ER_XA_RBTIMEOUT';
exports[1614] = 'ER_XA_RBDEADLOCK';
exports[1615] = 'ER_NEED_REPREPARE';
exports[1616] = 'ER_DELAYED_NOT_SUPPORTED';
exports[1617] = 'WARN_NO_MASTER_INFO';
exports[1618] = 'WARN_OPTION_IGNORED';
exports[1619] = 'ER_PLUGIN_DELETE_BUILTIN';
exports[1620] = 'WARN_PLUGIN_BUSY';
exports[1621] = 'ER_VARIABLE_IS_READONLY';
exports[1622] = 'ER_WARN_ENGINE_TRANSACTION_ROLLBACK';
exports[1623] = 'ER_SLAVE_HEARTBEAT_FAILURE';
exports[1624] = 'ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE';
exports[1625] = 'ER_NDB_REPLICATION_SCHEMA_ERROR';
exports[1626] = 'ER_CONFLICT_FN_PARSE_ERROR';
exports[1627] = 'ER_EXCEPTIONS_WRITE_ERROR';
exports[1628] = 'ER_TOO_LONG_TABLE_COMMENT';
exports[1629] = 'ER_TOO_LONG_FIELD_COMMENT';
exports[1630] = 'ER_FUNC_INEXISTENT_NAME_COLLISION';
exports[1631] = 'ER_DATABASE_NAME';
exports[1632] = 'ER_TABLE_NAME';
exports[1633] = 'ER_PARTITION_NAME';
exports[1634] = 'ER_SUBPARTITION_NAME';
exports[1635] = 'ER_TEMPORARY_NAME';
exports[1636] = 'ER_RENAMED_NAME';
exports[1637] = 'ER_TOO_MANY_CONCURRENT_TRXS';
exports[1638] = 'WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED';
exports[1639] = 'ER_DEBUG_SYNC_TIMEOUT';
exports[1640] = 'ER_DEBUG_SYNC_HIT_LIMIT';
exports[1641] = 'ER_DUP_SIGNAL_SET';
exports[1642] = 'ER_SIGNAL_WARN';
exports[1643] = 'ER_SIGNAL_NOT_FOUND';
exports[1644] = 'ER_SIGNAL_EXCEPTION';
exports[1645] = 'ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER';
exports[1646] = 'ER_SIGNAL_BAD_CONDITION_TYPE';
exports[1647] = 'WARN_COND_ITEM_TRUNCATED';
exports[1648] = 'ER_COND_ITEM_TOO_LONG';
exports[1649] = 'ER_UNKNOWN_LOCALE';
exports[1650] = 'ER_SLAVE_IGNORE_SERVER_IDS';
exports[1651] = 'ER_QUERY_CACHE_DISABLED';
exports[1652] = 'ER_SAME_NAME_PARTITION_FIELD';
exports[1653] = 'ER_PARTITION_COLUMN_LIST_ERROR';
exports[1654] = 'ER_WRONG_TYPE_COLUMN_VALUE_ERROR';
exports[1655] = 'ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR';
exports[1656] = 'ER_MAXVALUE_IN_VALUES_IN';
exports[1657] = 'ER_TOO_MANY_VALUES_ERROR';
exports[1658] = 'ER_ROW_SINGLE_PARTITION_FIELD_ERROR';
exports[1659] = 'ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD';
exports[1660] = 'ER_PARTITION_FIELDS_TOO_LONG';
exports[1661] = 'ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE';
exports[1662] = 'ER_BINLOG_ROW_MODE_AND_STMT_ENGINE';
exports[1663] = 'ER_BINLOG_UNSAFE_AND_STMT_ENGINE';
exports[1664] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE';
exports[1665] = 'ER_BINLOG_STMT_MODE_AND_ROW_ENGINE';
exports[1666] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_MODE';
exports[1667] = 'ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
exports[1668] = 'ER_BINLOG_UNSAFE_LIMIT';
exports[1669] = 'ER_BINLOG_UNSAFE_INSERT_DELAYED';
exports[1670] = 'ER_BINLOG_UNSAFE_SYSTEM_TABLE';
exports[1671] = 'ER_BINLOG_UNSAFE_AUTOINC_COLUMNS';
exports[1672] = 'ER_BINLOG_UNSAFE_UDF';
exports[1673] = 'ER_BINLOG_UNSAFE_SYSTEM_VARIABLE';
exports[1674] = 'ER_BINLOG_UNSAFE_SYSTEM_FUNCTION';
exports[1675] = 'ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS';
exports[1676] = 'ER_MESSAGE_AND_STATEMENT';
exports[1677] = 'ER_SLAVE_CONVERSION_FAILED';
exports[1678] = 'ER_SLAVE_CANT_CREATE_CONVERSION';
exports[1679] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT';
exports[1680] = 'ER_PATH_LENGTH';
exports[1681] = 'ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT';
exports[1682] = 'ER_WRONG_NATIVE_TABLE_STRUCTURE';
exports[1683] = 'ER_WRONG_PERFSCHEMA_USAGE';
exports[1684] = 'ER_WARN_I_S_SKIPPED_TABLE';
exports[1685] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT';
exports[1686] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT';
exports[1687] = 'ER_SPATIAL_MUST_HAVE_GEOM_COL';
exports[1688] = 'ER_TOO_LONG_INDEX_COMMENT';
exports[1689] = 'ER_LOCK_ABORTED';
exports[1690] = 'ER_DATA_OUT_OF_RANGE';
exports[1691] = 'ER_WRONG_SPVAR_TYPE_IN_LIMIT';
exports[1692] = 'ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
exports[1693] = 'ER_BINLOG_UNSAFE_MIXED_STATEMENT';
exports[1694] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN';
exports[1695] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN';
exports[1696] = 'ER_FAILED_READ_FROM_PAR_FILE';
exports[1697] = 'ER_VALUES_IS_NOT_INT_TYPE_ERROR';
exports[1698] = 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR';
exports[1699] = 'ER_SET_PASSWORD_AUTH_PLUGIN';
exports[1700] = 'ER_GRANT_PLUGIN_USER_EXISTS';
exports[1701] = 'ER_TRUNCATE_ILLEGAL_FK';
exports[1702] = 'ER_PLUGIN_IS_PERMANENT';
exports[1703] = 'ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN';
exports[1704] = 'ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX';
exports[1705] = 'ER_STMT_CACHE_FULL';
exports[1706] = 'ER_MULTI_UPDATE_KEY_CONFLICT';
exports[1707] = 'ER_TABLE_NEEDS_REBUILD';
exports[1708] = 'WARN_OPTION_BELOW_LIMIT';
exports[1709] = 'ER_INDEX_COLUMN_TOO_LONG';
exports[1710] = 'ER_ERROR_IN_TRIGGER_BODY';
exports[1711] = 'ER_ERROR_IN_UNKNOWN_TRIGGER_BODY';
exports[1712] = 'ER_INDEX_CORRUPT';
exports[1713] = 'ER_UNDO_RECORD_TOO_BIG';
exports[1714] = 'ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT';
exports[1715] = 'ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE';
exports[1716] = 'ER_BINLOG_UNSAFE_REPLACE_SELECT';
exports[1717] = 'ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT';
exports[1718] = 'ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT';
exports[1719] = 'ER_BINLOG_UNSAFE_UPDATE_IGNORE';
exports[1720] = 'ER_PLUGIN_NO_UNINSTALL';
exports[1721] = 'ER_PLUGIN_NO_INSTALL';
exports[1722] = 'ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT';
exports[1723] = 'ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC';
exports[1724] = 'ER_BINLOG_UNSAFE_INSERT_TWO_KEYS';
exports[1725] = 'ER_TABLE_IN_FK_CHECK';
exports[1726] = 'ER_UNSUPPORTED_ENGINE';
exports[1727] = 'ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST';
exports[1728] = 'ER_CANNOT_LOAD_FROM_TABLE_V2';
exports[1729] = 'ER_MASTER_DELAY_VALUE_OUT_OF_RANGE';
exports[1730] = 'ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT';
exports[1731] = 'ER_PARTITION_EXCHANGE_DIFFERENT_OPTION';
exports[1732] = 'ER_PARTITION_EXCHANGE_PART_TABLE';
exports[1733] = 'ER_PARTITION_EXCHANGE_TEMP_TABLE';
exports[1734] = 'ER_PARTITION_INSTEAD_OF_SUBPARTITION';
exports[1735] = 'ER_UNKNOWN_PARTITION';
exports[1736] = 'ER_TABLES_DIFFERENT_METADATA';
exports[1737] = 'ER_ROW_DOES_NOT_MATCH_PARTITION';
exports[1738] = 'ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX';
exports[1739] = 'ER_WARN_INDEX_NOT_APPLICABLE';
exports[1740] = 'ER_PARTITION_EXCHANGE_FOREIGN_KEY';
exports[1741] = 'ER_NO_SUCH_KEY_VALUE';
exports[1742] = 'ER_RPL_INFO_DATA_TOO_LONG';
exports[1743] = 'ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE';
exports[1744] = 'ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE';
exports[1745] = 'ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX';
exports[1746] = 'ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT';
exports[1747] = 'ER_PARTITION_CLAUSE_ON_NONPARTITIONED';
exports[1748] = 'ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET';
exports[1749] = 'ER_NO_SUCH_PARTITION';
exports[1750] = 'ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE';
exports[1751] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE';
exports[1752] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE';
exports[1753] = 'ER_MTS_FEATURE_IS_NOT_SUPPORTED';
exports[1754] = 'ER_MTS_UPDATED_DBS_GREATER_MAX';
exports[1755] = 'ER_MTS_CANT_PARALLEL';
exports[1756] = 'ER_MTS_INCONSISTENT_DATA';
exports[1757] = 'ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING';
exports[1758] = 'ER_DA_INVALID_CONDITION_NUMBER';
exports[1759] = 'ER_INSECURE_PLAIN_TEXT';
exports[1760] = 'ER_INSECURE_CHANGE_MASTER';
exports[1761] = 'ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO';
exports[1762] = 'ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO';
exports[1763] = 'ER_SQLTHREAD_WITH_SECURE_SLAVE';
exports[1764] = 'ER_TABLE_HAS_NO_FT';
exports[1765] = 'ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER';
exports[1766] = 'ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION';
exports[1767] = 'ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST';
exports[1768] = 'ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION';
exports[1769] = 'ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION';
exports[1770] = 'ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL';
exports[1771] = 'ER_SKIPPING_LOGGED_TRANSACTION';
exports[1772] = 'ER_MALFORMED_GTID_SET_SPECIFICATION';
exports[1773] = 'ER_MALFORMED_GTID_SET_ENCODING';
exports[1774] = 'ER_MALFORMED_GTID_SPECIFICATION';
exports[1775] = 'ER_GNO_EXHAUSTED';
exports[1776] = 'ER_BAD_SLAVE_AUTO_POSITION';
exports[1777] = 'ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF';
exports[1778] = 'ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET';
exports[1779] = 'ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON';
exports[1780] = 'ER_GTID_MODE_REQUIRES_BINLOG';
exports[1781] = 'ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF';
exports[1782] = 'ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON';
exports[1783] = 'ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF';
exports[1784] = 'ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF';
exports[1785] = 'ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE';
exports[1786] = 'ER_GTID_UNSAFE_CREATE_SELECT';
exports[1787] = 'ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION';
exports[1788] = 'ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME';
exports[1789] = 'ER_MASTER_HAS_PURGED_REQUIRED_GTIDS';
exports[1790] = 'ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID';
exports[1791] = 'ER_UNKNOWN_EXPLAIN_FORMAT';
exports[1792] = 'ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION';
exports[1793] = 'ER_TOO_LONG_TABLE_PARTITION_COMMENT';
exports[1794] = 'ER_SLAVE_CONFIGURATION';
exports[1795] = 'ER_INNODB_FT_LIMIT';
exports[1796] = 'ER_INNODB_NO_FT_TEMP_TABLE';
exports[1797] = 'ER_INNODB_FT_WRONG_DOCID_COLUMN';
exports[1798] = 'ER_INNODB_FT_WRONG_DOCID_INDEX';
exports[1799] = 'ER_INNODB_ONLINE_LOG_TOO_BIG';
exports[1800] = 'ER_UNKNOWN_ALTER_ALGORITHM';
exports[1801] = 'ER_UNKNOWN_ALTER_LOCK';
exports[1802] = 'ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS';
exports[1803] = 'ER_MTS_RECOVERY_FAILURE';
exports[1804] = 'ER_MTS_RESET_WORKERS';
exports[1805] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2';
exports[1806] = 'ER_SLAVE_SILENT_RETRY_TRANSACTION';
exports[1807] = 'ER_DISCARD_FK_CHECKS_RUNNING';
exports[1808] = 'ER_TABLE_SCHEMA_MISMATCH';
exports[1809] = 'ER_TABLE_IN_SYSTEM_TABLESPACE';
exports[1810] = 'ER_IO_READ_ERROR';
exports[1811] = 'ER_IO_WRITE_ERROR';
exports[1812] = 'ER_TABLESPACE_MISSING';
exports[1813] = 'ER_TABLESPACE_EXISTS';
exports[1814] = 'ER_TABLESPACE_DISCARDED';
exports[1815] = 'ER_INTERNAL_ERROR';
exports[1816] = 'ER_INNODB_IMPORT_ERROR';
exports[1817] = 'ER_INNODB_INDEX_CORRUPT';
exports[1818] = 'ER_INVALID_YEAR_COLUMN_LENGTH';
exports[1819] = 'ER_NOT_VALID_PASSWORD';
exports[1820] = 'ER_MUST_CHANGE_PASSWORD';
exports[1821] = 'ER_FK_NO_INDEX_CHILD';
exports[1822] = 'ER_FK_NO_INDEX_PARENT';
exports[1823] = 'ER_FK_FAIL_ADD_SYSTEM';
exports[1824] = 'ER_FK_CANNOT_OPEN_PARENT';
exports[1825] = 'ER_FK_INCORRECT_OPTION';
exports[1826] = 'ER_FK_DUP_NAME';
exports[1827] = 'ER_PASSWORD_FORMAT';
exports[1828] = 'ER_FK_COLUMN_CANNOT_DROP';
exports[1829] = 'ER_FK_COLUMN_CANNOT_DROP_CHILD';
exports[1830] = 'ER_FK_COLUMN_NOT_NULL';
exports[1831] = 'ER_DUP_INDEX';
exports[1832] = 'ER_FK_COLUMN_CANNOT_CHANGE';
exports[1833] = 'ER_FK_COLUMN_CANNOT_CHANGE_CHILD';
exports[1834] = 'ER_FK_CANNOT_DELETE_PARENT';
exports[1835] = 'ER_MALFORMED_PACKET';
exports[1836] = 'ER_READ_ONLY_MODE';
exports[1837] = 'ER_GTID_NEXT_TYPE_UNDEFINED_GROUP';
exports[1838] = 'ER_VARIABLE_NOT_SETTABLE_IN_SP';
exports[1839] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF';
exports[1840] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY';
exports[1841] = 'ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY';
exports[1842] = 'ER_GTID_PURGED_WAS_CHANGED';
exports[1843] = 'ER_GTID_EXECUTED_WAS_CHANGED';
exports[1844] = 'ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES';
exports[1845] = 'ER_ALTER_OPERATION_NOT_SUPPORTED';
exports[1846] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON';
exports[1847] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY';
exports[1848] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION';
exports[1849] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME';
exports[1850] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE';
exports[1851] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK';
exports[1852] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE';
exports[1853] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK';
exports[1854] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC';
exports[1855] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS';
exports[1856] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS';
exports[1857] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS';
exports[1858] = 'ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE';
exports[1859] = 'ER_DUP_UNKNOWN_IN_INDEX';
exports[1860] = 'ER_IDENT_CAUSES_TOO_LONG_PATH';
exports[1861] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL';
exports[1862] = 'ER_MUST_CHANGE_PASSWORD_LOGIN';
exports[1863] = 'ER_ROW_IN_WRONG_PARTITION';
exports[1864] = 'ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX';
exports[1865] = 'ER_INNODB_NO_FT_USES_PARSER';
exports[1866] = 'ER_BINLOG_LOGICAL_CORRUPTION';
exports[1867] = 'ER_WARN_PURGE_LOG_IN_USE';
exports[1868] = 'ER_WARN_PURGE_LOG_IS_ACTIVE';
exports[1869] = 'ER_AUTO_INCREMENT_CONFLICT';
exports[1870] = 'WARN_ON_BLOCKHOLE_IN_RBR';
exports[1871] = 'ER_SLAVE_MI_INIT_REPOSITORY';
exports[1872] = 'ER_SLAVE_RLI_INIT_REPOSITORY';
exports[1873] = 'ER_ACCESS_DENIED_CHANGE_USER_ERROR';
exports[1874] = 'ER_INNODB_READ_ONLY';
exports[1875] = 'ER_STOP_SLAVE_SQL_THREAD_TIMEOUT';
exports[1876] = 'ER_STOP_SLAVE_IO_THREAD_TIMEOUT';
exports[1877] = 'ER_TABLE_CORRUPT';
exports[1878] = 'ER_TEMP_FILE_WRITE_FAILURE';
exports[1879] = 'ER_INNODB_FT_AUX_NOT_HEX_ID';
exports[1880] = 'ER_OLD_TEMPORALS_UPGRADED';
exports[1881] = 'ER_INNODB_FORCED_RECOVERY';
exports[1882] = 'ER_AES_INVALID_IV';
exports[1883] = 'ER_PLUGIN_CANNOT_BE_UNINSTALLED';
exports[1884] = 'ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_GTID_GROUP';
exports[1885] = 'ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER';
exports[1886] = 'ER_MISSING_KEY';
exports[1887] = 'WARN_NAMED_PIPE_ACCESS_EVERYONE';
exports[1888] = 'ER_FOUND_MISSING_GTIDS';
exports[3000] = 'ER_FILE_CORRUPT';
exports[3001] = 'ER_ERROR_ON_MASTER';
exports[3002] = 'ER_INCONSISTENT_ERROR';
exports[3003] = 'ER_STORAGE_ENGINE_NOT_LOADED';
exports[3004] = 'ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER';
exports[3005] = 'ER_WARN_LEGACY_SYNTAX_CONVERTED';
exports[3006] = 'ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN';
exports[3007] = 'ER_CANNOT_DISCARD_TEMPORARY_TABLE';
exports[3008] = 'ER_FK_DEPTH_EXCEEDED';
exports[3009] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2';
exports[3010] = 'ER_WARN_TRIGGER_DOESNT_HAVE_CREATED';
exports[3011] = 'ER_REFERENCED_TRG_DOES_NOT_EXIST';
exports[3012] = 'ER_EXPLAIN_NOT_SUPPORTED';
exports[3013] = 'ER_INVALID_FIELD_SIZE';
exports[3014] = 'ER_MISSING_HA_CREATE_OPTION';
exports[3015] = 'ER_ENGINE_OUT_OF_MEMORY';
exports[3016] = 'ER_PASSWORD_EXPIRE_ANONYMOUS_USER';
exports[3017] = 'ER_SLAVE_SQL_THREAD_MUST_STOP';
exports[3018] = 'ER_NO_FT_MATERIALIZED_SUBQUERY';
exports[3019] = 'ER_INNODB_UNDO_LOG_FULL';
exports[3020] = 'ER_INVALID_ARGUMENT_FOR_LOGARITHM';
exports[3021] = 'ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP';
exports[3022] = 'ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO';
exports[3023] = 'ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS';
exports[3024] = 'ER_QUERY_TIMEOUT';
exports[3025] = 'ER_NON_RO_SELECT_DISABLE_TIMER';
exports[3026] = 'ER_DUP_LIST_ENTRY';
exports[3027] = 'ER_SQL_MODE_NO_EFFECT';
exports[3028] = 'ER_AGGREGATE_ORDER_FOR_UNION';
exports[3029] = 'ER_AGGREGATE_ORDER_NON_AGG_QUERY';
exports[3030] = 'ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR';
exports[3031] = 'ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER';
exports[3032] = 'ER_SERVER_OFFLINE_MODE';
exports[3033] = 'ER_GIS_DIFFERENT_SRIDS';
exports[3034] = 'ER_GIS_UNSUPPORTED_ARGUMENT';
exports[3035] = 'ER_GIS_UNKNOWN_ERROR';
exports[3036] = 'ER_GIS_UNKNOWN_EXCEPTION';
exports[3037] = 'ER_GIS_INVALID_DATA';
exports[3038] = 'ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION';
exports[3039] = 'ER_BOOST_GEOMETRY_CENTROID_EXCEPTION';
exports[3040] = 'ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION';
exports[3041] = 'ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION';
exports[3042] = 'ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION';
exports[3043] = 'ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION';
exports[3044] = 'ER_STD_BAD_ALLOC_ERROR';
exports[3045] = 'ER_STD_DOMAIN_ERROR';
exports[3046] = 'ER_STD_LENGTH_ERROR';
exports[3047] = 'ER_STD_INVALID_ARGUMENT';
exports[3048] = 'ER_STD_OUT_OF_RANGE_ERROR';
exports[3049] = 'ER_STD_OVERFLOW_ERROR';
exports[3050] = 'ER_STD_RANGE_ERROR';
exports[3051] = 'ER_STD_UNDERFLOW_ERROR';
exports[3052] = 'ER_STD_LOGIC_ERROR';
exports[3053] = 'ER_STD_RUNTIME_ERROR';
exports[3054] = 'ER_STD_UNKNOWN_EXCEPTION';
exports[3055] = 'ER_GIS_DATA_WRONG_ENDIANESS';
exports[3056] = 'ER_CHANGE_MASTER_PASSWORD_LENGTH';
exports[3057] = 'ER_USER_LOCK_WRONG_NAME';
exports[3058] = 'ER_USER_LOCK_DEADLOCK';
exports[3059] = 'ER_REPLACE_INACCESSIBLE_ROWS';
exports[3060] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS';
exports[3061] = 'ER_ILLEGAL_USER_VAR';
exports[3062] = 'ER_GTID_MODE_OFF';
exports[3063] = 'ER_UNSUPPORTED_BY_REPLICATION_THREAD';
exports[3064] = 'ER_INCORRECT_TYPE';
exports[3065] = 'ER_FIELD_IN_ORDER_NOT_SELECT';
exports[3066] = 'ER_AGGREGATE_IN_ORDER_NOT_SELECT';
exports[3067] = 'ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN';
exports[3068] = 'ER_NET_OK_PACKET_TOO_LARGE';
exports[3069] = 'ER_INVALID_JSON_DATA';
exports[3070] = 'ER_INVALID_GEOJSON_MISSING_MEMBER';
exports[3071] = 'ER_INVALID_GEOJSON_WRONG_TYPE';
exports[3072] = 'ER_INVALID_GEOJSON_UNSPECIFIED';
exports[3073] = 'ER_DIMENSION_UNSUPPORTED';
exports[3074] = 'ER_SLAVE_CHANNEL_DOES_NOT_EXIST';
exports[3075] = 'ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT';
exports[3076] = 'ER_SLAVE_CHANNEL_NAME_INVALID_OR_TOO_LONG';
exports[3077] = 'ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY';
exports[3078] = 'ER_SLAVE_CHANNEL_DELETE';
exports[3079] = 'ER_SLAVE_MULTIPLE_CHANNELS_CMD';
exports[3080] = 'ER_SLAVE_MAX_CHANNELS_EXCEEDED';
exports[3081] = 'ER_SLAVE_CHANNEL_MUST_STOP';
exports[3082] = 'ER_SLAVE_CHANNEL_NOT_RUNNING';
exports[3083] = 'ER_SLAVE_CHANNEL_WAS_RUNNING';
exports[3084] = 'ER_SLAVE_CHANNEL_WAS_NOT_RUNNING';
exports[3085] = 'ER_SLAVE_CHANNEL_SQL_THREAD_MUST_STOP';
exports[3086] = 'ER_SLAVE_CHANNEL_SQL_SKIP_COUNTER';
exports[3087] = 'ER_WRONG_FIELD_WITH_GROUP_V2';
exports[3088] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2';
exports[3089] = 'ER_WARN_DEPRECATED_SYSVAR_UPDATE';
exports[3090] = 'ER_WARN_DEPRECATED_SQLMODE';
exports[3091] = 'ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID';
exports[3092] = 'ER_GROUP_REPLICATION_CONFIGURATION';
exports[3093] = 'ER_GROUP_REPLICATION_RUNNING';
exports[3094] = 'ER_GROUP_REPLICATION_APPLIER_INIT_ERROR';
exports[3095] = 'ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT';
exports[3096] = 'ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR';
exports[3097] = 'ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR';
exports[3098] = 'ER_BEFORE_DML_VALIDATION_ERROR';
exports[3099] = 'ER_PREVENTS_VARIABLE_WITHOUT_RBR';
exports[3100] = 'ER_RUN_HOOK_ERROR';
exports[3101] = 'ER_TRANSACTION_ROLLBACK_DURING_COMMIT';
exports[3102] = 'ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED';
exports[3103] = 'ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN';
exports[3104] = 'ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN';
exports[3105] = 'ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN';
exports[3106] = 'ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN';
exports[3107] = 'ER_GENERATED_COLUMN_NON_PRIOR';
exports[3108] = 'ER_DEPENDENT_BY_GENERATED_COLUMN';
exports[3109] = 'ER_GENERATED_COLUMN_REF_AUTO_INC';
exports[3110] = 'ER_FEATURE_NOT_AVAILABLE';
exports[3111] = 'ER_CANT_SET_GTID_MODE';
exports[3112] = 'ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF';
exports[3113] = 'ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION';
exports[3114] = 'ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON';
exports[3115] = 'ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF';
exports[3116] = 'ER_CANT_SET_ENFORCE_GTID_CONSISTENCY_ON_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS';
exports[3117] = 'ER_SET_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS';
exports[3118] = 'ER_ACCOUNT_HAS_BEEN_LOCKED';
exports[3119] = 'ER_WRONG_TABLESPACE_NAME';
exports[3120] = 'ER_TABLESPACE_IS_NOT_EMPTY';
exports[3121] = 'ER_WRONG_FILE_NAME';
exports[3122] = 'ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION';
exports[3123] = 'ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR';
exports[3124] = 'ER_WARN_BAD_MAX_EXECUTION_TIME';
exports[3125] = 'ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME';
exports[3126] = 'ER_WARN_CONFLICTING_HINT';
exports[3127] = 'ER_WARN_UNKNOWN_QB_NAME';
exports[3128] = 'ER_UNRESOLVED_HINT_NAME';
exports[3129] = 'ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE';
exports[3130] = 'ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED';
exports[3131] = 'ER_LOCKING_SERVICE_WRONG_NAME';
exports[3132] = 'ER_LOCKING_SERVICE_DEADLOCK';
exports[3133] = 'ER_LOCKING_SERVICE_TIMEOUT';
exports[3134] = 'ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED';
exports[3135] = 'ER_SQL_MODE_MERGED';
exports[3136] = 'ER_VTOKEN_PLUGIN_TOKEN_MISMATCH';
exports[3137] = 'ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND';
exports[3138] = 'ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID';
exports[3139] = 'ER_SLAVE_CHANNEL_OPERATION_NOT_ALLOWED';
exports[3140] = 'ER_INVALID_JSON_TEXT';
exports[3141] = 'ER_INVALID_JSON_TEXT_IN_PARAM';
exports[3142] = 'ER_INVALID_JSON_BINARY_DATA';
exports[3143] = 'ER_INVALID_JSON_PATH';
exports[3144] = 'ER_INVALID_JSON_CHARSET';
exports[3145] = 'ER_INVALID_JSON_CHARSET_IN_FUNCTION';
exports[3146] = 'ER_INVALID_TYPE_FOR_JSON';
exports[3147] = 'ER_INVALID_CAST_TO_JSON';
exports[3148] = 'ER_INVALID_JSON_PATH_CHARSET';
exports[3149] = 'ER_INVALID_JSON_PATH_WILDCARD';
exports[3150] = 'ER_JSON_VALUE_TOO_BIG';
exports[3151] = 'ER_JSON_KEY_TOO_BIG';
exports[3152] = 'ER_JSON_USED_AS_KEY';
exports[3153] = 'ER_JSON_VACUOUS_PATH';
exports[3154] = 'ER_JSON_BAD_ONE_OR_ALL_ARG';
exports[3155] = 'ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE';
exports[3156] = 'ER_INVALID_JSON_VALUE_FOR_CAST';
exports[3157] = 'ER_JSON_DOCUMENT_TOO_DEEP';
exports[3158] = 'ER_JSON_DOCUMENT_NULL_KEY';
exports[3159] = 'ER_SECURE_TRANSPORT_REQUIRED';
exports[3160] = 'ER_NO_SECURE_TRANSPORTS_CONFIGURED';
exports[3161] = 'ER_DISABLED_STORAGE_ENGINE';
exports[3162] = 'ER_USER_DOES_NOT_EXIST';
exports[3163] = 'ER_USER_ALREADY_EXISTS';
exports[3164] = 'ER_AUDIT_API_ABORT';
exports[3165] = 'ER_INVALID_JSON_PATH_ARRAY_CELL';
exports[3166] = 'ER_BUFPOOL_RESIZE_INPROGRESS';
exports[3167] = 'ER_FEATURE_DISABLED_SEE_DOC';
exports[3168] = 'ER_SERVER_ISNT_AVAILABLE';
exports[3169] = 'ER_SESSION_WAS_KILLED';
exports[3170] = 'ER_CAPACITY_EXCEEDED';
exports[3171] = 'ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER';
exports[3172] = 'ER_TABLE_NEEDS_UPG_PART';
exports[3173] = 'ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID';
exports[3174] = 'ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL';
exports[3175] = 'ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT';
exports[3176] = 'ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE';
exports[3177] = 'ER_LOCK_REFUSED_BY_ENGINE';
exports[3178] = 'ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN';
exports[3179] = 'ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE';
exports[3180] = 'ER_MASTER_KEY_ROTATION_ERROR_BY_SE';
exports[3181] = 'ER_MASTER_KEY_ROTATION_BINLOG_FAILED';
exports[3182] = 'ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE';
exports[3183] = 'ER_TABLESPACE_CANNOT_ENCRYPT';
exports[3184] = 'ER_INVALID_ENCRYPTION_OPTION';
exports[3185] = 'ER_CANNOT_FIND_KEY_IN_KEYRING';
exports[3186] = 'ER_CAPACITY_EXCEEDED_IN_PARSER';
exports[3187] = 'ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE';
exports[3188] = 'ER_KEYRING_UDF_KEYRING_SERVICE_ERROR';
exports[3189] = 'ER_USER_COLUMN_OLD_LENGTH';
exports[3190] = 'ER_CANT_RESET_MASTER';
exports[3191] = 'ER_GROUP_REPLICATION_MAX_GROUP_SIZE';
exports[3192] = 'ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED';
exports[3193] = 'ER_TABLE_REFERENCED';
exports[3194] = 'ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE';
exports[3195] = 'ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO';
exports[3196] = 'ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID';
exports[3197] = 'ER_XA_RETRY';
exports[3198] = 'ER_KEYRING_AWS_UDF_AWS_KMS_ERROR';
exports[3199] = 'ER_BINLOG_UNSAFE_XA';
exports[3200] = 'ER_UDF_ERROR';
exports[3201] = 'ER_KEYRING_MIGRATION_FAILURE';
exports[3202] = 'ER_KEYRING_ACCESS_DENIED_ERROR';
exports[3203] = 'ER_KEYRING_MIGRATION_STATUS';
exports[3204] = 'ER_PLUGIN_FAILED_TO_OPEN_TABLES';
exports[3205] = 'ER_PLUGIN_FAILED_TO_OPEN_TABLE';
exports[3206] = 'ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED';
exports[3207] = 'ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET';
exports[3208] = 'ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY';
exports[3209] = 'ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED';
exports[3210] = 'ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED';
exports[3211] = 'ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE';
exports[3212] = 'ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED';
exports[3213] = 'ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS';
exports[3214] = 'ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE';
exports[3215] = 'ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT';
exports[3216] = 'ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED';
exports[3217] = 'ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE';
exports[3218] = 'ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE';
exports[3219] = 'ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR';
exports[3220] = 'ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY';
exports[3221] = 'ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY';
exports[3222] = 'ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS';
exports[3223] = 'ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC';
exports[3224] = 'ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER';
exports[3225] = 'ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER';
exports[3226] = 'WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP';
exports[3227] = 'ER_XA_REPLICATION_FILTERS';
exports[3228] = 'ER_CANT_OPEN_ERROR_LOG';
exports[3229] = 'ER_GROUPING_ON_TIMESTAMP_IN_DST';
exports[3230] = 'ER_CANT_START_SERVER_NAMED_PIPE';


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/constants/server_status.js":
/***/ ((__unused_webpack_module, exports) => {

// Manually extracted from mysql-5.5.23/include/mysql_com.h

/**
  Is raised when a multi-statement transaction
  has been started, either explicitly, by means
  of BEGIN or COMMIT AND CHAIN, or
  implicitly, by the first transactional
  statement, when autocommit=off.
*/
exports.SERVER_STATUS_IN_TRANS          = 1;
exports.SERVER_STATUS_AUTOCOMMIT        = 2;  /* Server in auto_commit mode */
exports.SERVER_MORE_RESULTS_EXISTS      = 8;    /* Multi query - next query exists */
exports.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
exports.SERVER_QUERY_NO_INDEX_USED      = 32;
/**
  The server was able to fulfill the clients request and opened a
  read-only non-scrollable cursor for a query. This flag comes
  in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands.
*/
exports.SERVER_STATUS_CURSOR_EXISTS = 64;
/**
  This flag is sent when a read-only cursor is exhausted, in reply to
  COM_STMT_FETCH command.
*/
exports.SERVER_STATUS_LAST_ROW_SENT        = 128;
exports.SERVER_STATUS_DB_DROPPED           = 256; /* A database was dropped */
exports.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
/**
  Sent to the client if after a prepared statement reprepare
  we discovered that the new statement returns a different
  number of result set columns.
*/
exports.SERVER_STATUS_METADATA_CHANGED = 1024;
exports.SERVER_QUERY_WAS_SLOW          = 2048;

/**
  To mark ResultSet containing output parameter values.
*/
exports.SERVER_PS_OUT_PARAMS = 4096;


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/constants/ssl_profiles.js":
/***/ ((__unused_webpack_module, exports) => {

// Certificates for Amazon RDS
exports["Amazon RDS"] = {
  ca: [
    /**
     * Amazon RDS global certificate 2010 to 2015
     *
     *   CN = aws.amazon.com/rds/
     *   OU = RDS
     *   O = Amazon.com
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2010-04-05T22:44:31Z/2015-04-04T22:41:31Z
     *   F = 7F:09:8D:A5:7D:BB:A6:EF:7C:70:D8:CA:4E:49:11:55:7E:89:A7:D3
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIDQzCCAqygAwIBAgIJAOd1tlfiGoEoMA0GCSqGSIb3DQEBBQUAMHUxCzAJBgNV\n'
    + 'BAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdTZWF0dGxlMRMw\n'
    + 'EQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNSRFMxHDAaBgNVBAMTE2F3cy5h\n'
    + 'bWF6b24uY29tL3Jkcy8wHhcNMTAwNDA1MjI0NDMxWhcNMTUwNDA0MjI0NDMxWjB1\n'
    + 'MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHU2Vh\n'
    + 'dHRsZTETMBEGA1UEChMKQW1hem9uLmNvbTEMMAoGA1UECxMDUkRTMRwwGgYDVQQD\n'
    + 'ExNhd3MuYW1hem9uLmNvbS9yZHMvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n'
    + 'gQDKhXGU7tizxUR5WaFoMTFcxNxa05PEjZaIOEN5ctkWrqYSRov0/nOMoZjqk8bC\n'
    + 'med9vPFoQGD0OTakPs0jVe3wwmR735hyVwmKIPPsGlaBYj1O6llIpZeQVyupNx56\n'
    + 'UzqtiLaDzh1KcmfqP3qP2dInzBfJQKjiRudo1FWnpPt33QIDAQABo4HaMIHXMB0G\n'
    + 'A1UdDgQWBBT/H3x+cqSkR/ePSIinPtc4yWKe3DCBpwYDVR0jBIGfMIGcgBT/H3x+\n'
    + 'cqSkR/ePSIinPtc4yWKe3KF5pHcwdTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldh\n'
    + 'c2hpbmd0b24xEDAOBgNVBAcTB1NlYXR0bGUxEzARBgNVBAoTCkFtYXpvbi5jb20x\n'
    + 'DDAKBgNVBAsTA1JEUzEcMBoGA1UEAxMTYXdzLmFtYXpvbi5jb20vcmRzL4IJAOd1\n'
    + 'tlfiGoEoMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAvguZy/BDT66x\n'
    + 'GfgnJlyQwnFSeVLQm9u/FIvz4huGjbq9dqnD6h/Gm56QPFdyMEyDiZWaqY6V08lY\n'
    + 'LTBNb4kcIc9/6pc0/ojKciP5QJRm6OiZ4vgG05nF4fYjhU7WClUx7cxq1fKjNc2J\n'
    + 'UCmmYqgiVkAGWRETVo+byOSDZ4swb10=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS global root CA 2015 to 2020
     *
     *   CN = Amazon RDS Root CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T09:11:31Z/2020-03-05T09:11:31Z
     *   F = E8:11:88:56:E7:A7:CE:3E:5E:DC:9A:31:25:1B:93:AC:DC:43:CE:B0
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID9DCCAtygAwIBAgIBQjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUwOTExMzFaFw0y\n'
    + 'MDAzMDUwOTExMzFaMIGKMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEbMBkGA1UEAwwSQW1hem9uIFJE\n'
    + 'UyBSb290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuD8nrZ8V\n'
    + 'u+VA8yVlUipCZIKPTDcOILYpUe8Tct0YeQQr0uyl018StdBsa3CjBgvwpDRq1HgF\n'
    + 'Ji2N3+39+shCNspQeE6aYU+BHXhKhIIStt3r7gl/4NqYiDDMWKHxHq0nsGDFfArf\n'
    + 'AOcjZdJagOMqb3fF46flc8k2E7THTm9Sz4L7RY1WdABMuurpICLFE3oHcGdapOb9\n'
    + 'T53pQR+xpHW9atkcf3pf7gbO0rlKVSIoUenBlZipUlp1VZl/OD/E+TtRhDDNdI2J\n'
    + 'P/DSMM3aEsq6ZQkfbz/Ilml+Lx3tJYXUDmp+ZjzMPLk/+3beT8EhrwtcG3VPpvwp\n'
    + 'BIOqsqVVTvw/CwIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw\n'
    + 'AwEB/zAdBgNVHQ4EFgQUTgLurD72FchM7Sz1BcGPnIQISYMwHwYDVR0jBBgwFoAU\n'
    + 'TgLurD72FchM7Sz1BcGPnIQISYMwDQYJKoZIhvcNAQEFBQADggEBAHZcgIio8pAm\n'
    + 'MjHD5cl6wKjXxScXKtXygWH2BoDMYBJF9yfyKO2jEFxYKbHePpnXB1R04zJSWAw5\n'
    + '2EUuDI1pSBh9BA82/5PkuNlNeSTB3dXDD2PEPdzVWbSKvUB8ZdooV+2vngL0Zm4r\n'
    + '47QPyd18yPHrRIbtBtHR/6CwKevLZ394zgExqhnekYKIqqEX41xsUV0Gm6x4vpjf\n'
    + '2u6O/+YE2U+qyyxHE5Wd5oqde0oo9UUpFETJPVb6Q2cEeQib8PBAyi0i6KnF+kIV\n'
    + 'A9dY7IHSubtCK/i8wxMVqfd5GtbA8mmpeJFwnDvm9rBEsHybl08qlax9syEwsUYr\n'
    + '/40NawZfTUU=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS global root CA 2019 to 2024
     *
     *   CN = Amazon RDS Root 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-08-22T17:08:50Z/2024-08-22T17:08:50Z
     *   F = D4:0D:DB:29:E3:75:0D:FF:A6:71:C3:14:0B:BF:5F:47:8D:1C:80:96
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD\n'
    + 'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n'
    + 'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n'
    + 'em9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw\n'
    + 'ODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\n'
    + 'BAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv\n'
    + 'biBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV\n'
    + 'BAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n'
    + 'AQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ\n'
    + 'oWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY\n'
    + '0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I\n'
    + '6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9\n'
    + 'O08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9\n'
    + 'McZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E\n'
    + 'BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa\n'
    + 'pmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN\n'
    + 'AQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV\n'
    + 'ynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc\n'
    + 'NUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu\n'
    + 'cbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY\n'
    + '0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/\n'
    + 'zPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-northeast-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS ap-northeast-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:06Z/2020-03-05T22:03:06Z
     *   F = 4B:2D:8A:E0:C1:A3:A9:AF:A7:BB:65:0C:5A:16:8A:39:3C:03:F2:C5
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEATCCAumgAwIBAgIBRDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMDZaFw0y\n'
    + 'MDAzMDUyMjAzMDZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
    + 'UyBhcC1ub3J0aGVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
    + 'ggEBAMmM2B4PfTXCZjbZMWiDPyxvk/eeNwIRJAhfzesiGUiLozX6CRy3rwC1ZOPV\n'
    + 'AcQf0LB+O8wY88C/cV+d4Q2nBDmnk+Vx7o2MyMh343r5rR3Na+4izd89tkQVt0WW\n'
    + 'vO21KRH5i8EuBjinboOwAwu6IJ+HyiQiM0VjgjrmEr/YzFPL8MgHD/YUHehqjACn\n'
    + 'C0+B7/gu7W4qJzBL2DOf7ub2qszGtwPE+qQzkCRDwE1A4AJmVE++/FLH2Zx78Egg\n'
    + 'fV1sUxPtYgjGH76VyyO6GNKM6rAUMD/q5mnPASQVIXgKbupr618bnH+SWHFjBqZq\n'
    + 'HvDGPMtiiWII41EmGUypyt5AbysCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFIiKM0Q6n1K4EmLxs3ZXxINbwEwR\n'
    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
    + 'A4IBAQBezGbE9Rw/k2e25iGjj5n8r+M3dlye8ORfCE/dijHtxqAKasXHgKX8I9Tw\n'
    + 'JkBiGWiuzqn7gO5MJ0nMMro1+gq29qjZnYX1pDHPgsRjUX8R+juRhgJ3JSHijRbf\n'
    + '4qNJrnwga7pj94MhcLq9u0f6dxH6dXbyMv21T4TZMTmcFduf1KgaiVx1PEyJjC6r\n'
    + 'M+Ru+A0eM+jJ7uCjUoZKcpX8xkj4nmSnz9NMPog3wdOSB9cAW7XIc5mHa656wr7I\n'
    + 'WJxVcYNHTXIjCcng2zMKd1aCcl2KSFfy56sRfT7J5Wp69QSr+jq8KM55gw8uqAwi\n'
    + 'VPrXn2899T1rcTtFYFP16WXjGuc0\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-northeast-2 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS ap-northeast-2 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-11-06T00:05:46Z/2020-03-05T00:05:46Z
     *   F = 77:D9:33:4E:CE:56:FC:42:7B:29:57:8D:67:59:ED:29:4E:18:CB:6B
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEATCCAumgAwIBAgIBTDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTExMDYwMDA1NDZaFw0y\n'
    + 'MDAzMDUwMDA1NDZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
    + 'UyBhcC1ub3J0aGVhc3QtMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
    + 'ggEBAKSwd+RVUzTRH0FgnbwoTK8TMm/zMT4+2BvALpAUe6YXbkisg2goycWuuWLg\n'
    + 'jOpFBB3GtyvXZnkqi7MkDWUmj1a2kf8l2oLyoaZ+Hm9x/sV+IJzOqPvj1XVUGjP6\n'
    + 'yYYnPJmUYqvZeI7fEkIGdFkP2m4/sgsSGsFvpD9FK1bL1Kx2UDpYX0kHTtr18Zm/\n'
    + '1oN6irqWALSmXMDydb8hE0FB2A1VFyeKE6PnoDj/Y5cPHwPPdEi6/3gkDkSaOG30\n'
    + 'rWeQfL3pOcKqzbHaWTxMphd0DSL/quZ64Nr+Ly65Q5PRcTrtr55ekOUziuqXwk+o\n'
    + '9QpACMwcJ7ROqOznZTqTzSFVXFECAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFM6Nox/QWbhzWVvzoJ/y0kGpNPK+\n'
    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
    + 'A4IBAQCTkWBqNvyRf3Y/W21DwFx3oT/AIWrHt0BdGZO34tavummXemTH9LZ/mqv9\n'
    + 'aljt6ZuDtf5DEQjdsAwXMsyo03ffnP7doWm8iaF1+Mui77ot0TmTsP/deyGwukvJ\n'
    + 'tkxX8bZjDh+EaNauWKr+CYnniNxCQLfFtXYJsfOdVBzK3xNL+Z3ucOQRhr2helWc\n'
    + 'CDQgwfhP1+3pRVKqHvWCPC4R3fT7RZHuRmZ38kndv476GxRntejh+ePffif78bFI\n'
    + '3rIZCPBGobrrUMycafSbyXteoGca/kA+/IqrAPlk0pWQ4aEL0yTWN2h2dnjoD7oX\n'
    + 'byIuL/g9AGRh97+ssn7D6bDRPTbW\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-southeast-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS ap-southeast-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:19Z/2020-03-05T22:03:19Z
     *   F = 0E:EC:5D:BD:F9:80:EE:A9:A0:8D:81:AC:37:D9:8D:34:1C:CD:27:D1
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEATCCAumgAwIBAgIBRTANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMTlaFw0y\n'
    + 'MDAzMDUyMjAzMTlaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
    + 'UyBhcC1zb3V0aGVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
    + 'ggEBANaXElmSEYt/UtxHFsARFhSUahTf1KNJzR0Dmay6hqOXQuRVbKRwPd19u5vx\n'
    + 'DdF1sLT7D69IK3VDnUiQScaCv2Dpu9foZt+rLx+cpx1qiQd1UHrvqq8xPzQOqCdC\n'
    + 'RFStq6yVYZ69yfpfoI67AjclMOjl2Vph3ftVnqP0IgVKZdzeC7fd+umGgR9xY0Qr\n'
    + 'Ubhd/lWdsbNvzK3f1TPWcfIKQnpvSt85PIEDJir6/nuJUKMtmJRwTymJf0i+JZ4x\n'
    + '7dJa341p2kHKcHMgOPW7nJQklGBA70ytjUV6/qebS3yIugr/28mwReflg3TJzVDl\n'
    + 'EOvi6pqbqNbkMuEwGDCmEQIVqgkCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFAu93/4k5xbWOsgdCdn+/KdiRuit\n'
    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
    + 'A4IBAQBlcjSyscpPjf5+MgzMuAsCxByqUt+WFspwcMCpwdaBeHOPSQrXNqX2Sk6P\n'
    + 'kth6oCivA64trWo8tFMvPYlUA1FYVD5WpN0kCK+P5pD4KHlaDsXhuhClJzp/OP8t\n'
    + 'pOyUr5109RHLxqoKB5J5m1XA7rgcFjnMxwBSWFe3/4uMk/+4T53YfCVXuc6QV3i7\n'
    + 'I/2LAJwFf//pTtt6fZenYfCsahnr2nvrNRNyAxcfvGZ/4Opn/mJtR6R/AjvQZHiR\n'
    + 'bkRNKF2GW0ueK5W4FkZVZVhhX9xh1Aj2Ollb+lbOqADaVj+AT3PoJPZ3MPQHKCXm\n'
    + 'xwG0LOLlRr/TfD6li1AfOVTAJXv9\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-southeast-2 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS ap-southeast-2 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:24Z/2020-03-05T22:03:24Z
     *   F = 20:D9:A8:82:23:AB:B9:E5:C5:24:10:D3:4D:0F:3D:B1:31:DF:E5:14
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEATCCAumgAwIBAgIBRjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMjRaFw0y\n'
    + 'MDAzMDUyMjAzMjRaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
    + 'UyBhcC1zb3V0aGVhc3QtMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
    + 'ggEBAJqBAJutz69hFOh3BtLHZTbwE8eejGGKayn9hu98YMDPzWzGXWCmW+ZYWELA\n'
    + 'cY3cNWNF8K4FqKXFr2ssorBYim1UtYFX8yhydT2hMD5zgQ2sCGUpuidijuPA6zaq\n'
    + 'Z3tdhVR94f0q8mpwpv2zqR9PcqaGDx2VR1x773FupRPRo7mEW1vC3IptHCQlP/zE\n'
    + '7jQiLl28bDIH2567xg7e7E9WnZToRnhlYdTaDaJsHTzi5mwILi4cihSok7Shv/ME\n'
    + 'hnukvxeSPUpaVtFaBhfBqq055ePq9I+Ns4KGreTKMhU0O9fkkaBaBmPaFgmeX/XO\n'
    + 'n2AX7gMouo3mtv34iDTZ0h6YCGkCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFIlQnY0KHYWn1jYumSdJYfwj/Nfw\n'
    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
    + 'A4IBAQA0wVU6/l41cTzHc4azc4CDYY2Wd90DFWiH9C/mw0SgToYfCJ/5Cfi0NT/Y\n'
    + 'PRnk3GchychCJgoPA/k9d0//IhYEAIiIDjyFVgjbTkKV3sh4RbdldKVOUB9kumz/\n'
    + 'ZpShplsGt3z4QQiVnKfrAgqxWDjR0I0pQKkxXa6Sjkicos9LQxVtJ0XA4ieG1E7z\n'
    + 'zJr+6t80wmzxvkInSaWP3xNJK9azVRTrgQZQlvkbpDbExl4mNTG66VD3bAp6t3Wa\n'
    + 'B49//uDdfZmPkqqbX+hsxp160OH0rxJppwO3Bh869PkDnaPEd/Pxw7PawC+li0gi\n'
    + 'NRV8iCEx85aFxcyOhqn0WZOasxee\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-central-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS eu-central-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:31Z/2020-03-05T22:03:31Z
     *   F = 94:B4:DF:B9:6D:7E:F7:C3:B7:BF:51:E9:A6:B7:44:A0:D0:82:11:84
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/zCCAuegAwIBAgIBRzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMzFaFw0y\n'
    + 'MDAzMDUyMjAzMzFaMIGSMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEjMCEGA1UEAwwaQW1hem9uIFJE\n'
    + 'UyBldS1jZW50cmFsLTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\n'
    + 'AQDFtP2dhSLuaPOI4ZrrPWsK4OY9ocQBp3yApH1KJYmI9wpQKZG/KCH2E6Oo7JAw\n'
    + 'QORU519r033T+FO2Z7pFPlmz1yrxGXyHpJs8ySx3Yo5S8ncDCdZJCLmtPiq/hahg\n'
    + '5/0ffexMFUCQaYicFZsrJ/cStdxUV+tSw2JQLD7UxS9J97LQWUPyyG+ZrjYVTVq+\n'
    + 'zudnFmNSe4QoecXMhAFTGJFQXxP7nhSL9Ao5FGgdXy7/JWeWdQIAj8ku6cBDKPa6\n'
    + 'Y6kP+ak+In+Lye8z9qsCD/afUozfWjPR2aA4JoIZVF8dNRShIMo8l0XfgfM2q0+n\n'
    + 'ApZWZ+BjhIO5XuoUgHS3D2YFAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNV\n'
    + 'HRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRm4GsWIA/M6q+tK8WGHWDGh2gcyTAf\n'
    + 'BgNVHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOC\n'
    + 'AQEAHpMmeVQNqcxgfQdbDIi5UIy+E7zZykmtAygN1XQrvga9nXTis4kOTN6g5/+g\n'
    + 'HCx7jIXeNJzAbvg8XFqBN84Quqgpl/tQkbpco9Jh1HDs558D5NnZQxNqH5qXQ3Mm\n'
    + 'uPgCw0pYcPOa7bhs07i+MdVwPBsX27CFDtsgAIru8HvKxY1oTZrWnyIRo93tt/pk\n'
    + 'WuItVMVHjaQZVfTCow0aDUbte6Vlw82KjUFq+n2NMSCJDiDKsDDHT6BJc4AJHIq3\n'
    + '/4Z52MSC9KMr0yAaaoWfW/yMEj9LliQauAgwVjArF4q78rxpfKTG9Rfd8U1BZANP\n'
    + '7FrFMN0ThjfA1IvmOYcgskY5bQ==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-west-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS eu-west-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:35Z/2020-03-05T22:03:35Z
     *   F = 1A:95:F0:43:82:D2:5D:A6:AD:F5:13:27:0B:40:8A:72:D9:92:F3:E0
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBSDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMzVaFw0y\n'
    + 'MDAzMDUyMjAzMzVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyBldS13ZXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx\n'
    + 'PdbqQ0HKRj79Pmocxvjc+P6i4Ux24kgFIl+ckiir1vzkmesc3a58gjrMlCksEObt\n'
    + 'Yihs5IhzEq1ePT0gbfS9GYFp34Uj/MtPwlrfCBWG4d2TcrsKRHr1/EXUYhWqmdrb\n'
    + 'RhX8XqoRhVkbF/auzFSBhTzcGGvZpQ2KIaxRcQfcXlMVhj/pxxAjh8U4F350Fb0h\n'
    + 'nX1jw4/KvEreBL0Xb2lnlGTkwVxaKGSgXEnOgIyOFdOQc61vdome0+eeZsP4jqeR\n'
    + 'TGYJA9izJsRbe2YJxHuazD+548hsPlM3vFzKKEVURCha466rAaYAHy3rKur3HYQx\n'
    + 'Yt+SoKcEz9PXuSGj96ejAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBTebg//h2oeXbZjQ4uuoiuLYzuiPDAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
    + 'TikPaGeZasTPw+4RBemlsyPAjtFFQLo7ddaFdORLgdEysVf8aBqndvbA6MT/v4lj\n'
    + 'GtEtUdF59ZcbWOrVm+fBZ2h/jYJ59dYF/xzb09nyRbdMSzB9+mkSsnOMqluq5y8o\n'
    + 'DY/PfP2vGhEg/2ZncRC7nlQU1Dm8F4lFWEiQ2fi7O1cW852Vmbq61RIfcYsH/9Ma\n'
    + 'kpgk10VZ75b8m3UhmpZ/2uRY+JEHImH5WpcTJ7wNiPNJsciZMznGtrgOnPzYco8L\n'
    + 'cDleOASIZifNMQi9PKOJKvi0ITz0B/imr8KBsW0YjZVJ54HMa7W1lwugSM7aMAs+\n'
    + 'E3Sd5lS+SHwWaOCHwhOEVA==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS sa-east-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS sa-east-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:40Z/2020-03-05T22:03:40Z
     *   F = 32:10:3D:FA:6D:42:F5:35:98:40:15:F4:4C:74:74:27:CB:CE:D4:B5
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBSTANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNDBaFw0y\n'
    + 'MDAzMDUyMjAzNDBaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyBzYS1lYXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCU\n'
    + 'X4OBnQ5xA6TLJAiFEI6l7bUWjoVJBa/VbMdCCSs2i2dOKmqUaXu2ix2zcPILj3lZ\n'
    + 'GMk3d/2zvTK/cKhcFrewHUBamTeVHdEmynhMQamqNmkM4ptYzFcvEUw1TGxHT4pV\n'
    + 'Q6gSN7+/AJewQvyHexHo8D0+LDN0/Wa9mRm4ixCYH2CyYYJNKaZt9+EZfNu+PPS4\n'
    + '8iB0TWH0DgQkbWMBfCRgolLLitAZklZ4dvdlEBS7evN1/7ttBxUK6SvkeeSx3zBl\n'
    + 'ww3BlXqc3bvTQL0A+RRysaVyFbvtp9domFaDKZCpMmDFAN/ntx215xmQdrSt+K3F\n'
    + 'cXdGQYHx5q410CAclGnbAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBT6iVWnm/uakS+tEX2mzIfw+8JL0zAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
    + 'FmDD+QuDklXn2EgShwQxV13+txPRuVdOSrutHhoCgMwFWCMtPPtBAKs6KPY7Guvw\n'
    + 'DpJoZSehDiOfsgMirjOWjvfkeWSNvKfjWTVneX7pZD9W5WPnsDBvTbCGezm+v87z\n'
    + 'b+ZM2ZMo98m/wkMcIEAgdSKilR2fuw8rLkAjhYFfs0A7tDgZ9noKwgHvoE4dsrI0\n'
    + 'KZYco6DlP/brASfHTPa2puBLN9McK3v+h0JaSqqm5Ro2Bh56tZkQh8AWy/miuDuK\n'
    + '3+hNEVdxosxlkM1TPa1DGj0EzzK0yoeerXuH2HX7LlCrrxf6/wdKnjR12PMrLQ4A\n'
    + 'pCqkcWw894z6bV9MAvKe6A==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-east-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS us-east-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T21:54:04Z/2020-03-05T21:54:04Z
     *   F = 34:47:8A:90:8A:83:AE:45:DC:B6:16:76:D2:35:EC:E9:75:C6:2C:63
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBQzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMTU0MDRaFw0y\n'
    + 'MDAzMDUyMTU0MDRaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyB1cy1lYXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDI\n'
    + 'UIuwh8NusKHk1SqPXcP7OqxY3S/M2ZyQWD3w7Bfihpyyy/fc1w0/suIpX3kbMhAV\n'
    + '2ESwged2/2zSx4pVnjp/493r4luhSqQYzru78TuPt9bhJIJ51WXunZW2SWkisSaf\n'
    + 'USYUzVN9ezR/bjXTumSUQaLIouJt3OHLX49s+3NAbUyOI8EdvgBQWD68H1epsC0n\n'
    + 'CI5s+pIktyOZ59c4DCDLQcXErQ+tNbDC++oct1ANd/q8p9URonYwGCGOBy7sbCYq\n'
    + '9eVHh1Iy2M+SNXddVOGw5EuruvHoCIQyOz5Lz4zSuZA9dRbrfztNOpezCNYu6NKM\n'
    + 'n+hzcvdiyxv77uNm8EaxAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBQSQG3TmMe6Sa3KufaPBa72v4QFDzAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
    + 'L/mOZfB3187xTmjOHMqN2G2oSKHBKiQLM9uv8+97qT+XR+TVsBT6b3yoPpMAGhHA\n'
    + 'Pc7nxAF5gPpuzatx0OTLPcmYucFmfqT/1qA5WlgCnMNtczyNMH97lKFTNV7Njtek\n'
    + 'jWEzAEQSyEWrkNpNlC4j6kMYyPzVXQeXUeZTgJ9FNnVZqmvfjip2N22tawMjrCn5\n'
    + '7KN/zN65EwY2oO9XsaTwwWmBu3NrDdMbzJnbxoWcFWj4RBwanR1XjQOVNhDwmCOl\n'
    + '/1Et13b8CPyj69PC8BOVU6cfTSx8WUVy0qvYOKHNY9Bqa5BDnIL3IVmUkeTlM1mt\n'
    + 'enRpyBj+Bk9rh/ICdiRKmA==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-west-1 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS us-west-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:45Z/2020-03-05T22:03:45Z
     *   F = EF:94:2F:E3:58:0E:09:D6:79:C2:16:97:91:FB:37:EA:D7:70:A8:4B
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBSjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNDVaFw0y\n'
    + 'MDAzMDUyMjAzNDVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyB1cy13ZXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDE\n'
    + 'Dhw+uw/ycaiIhhyu2pXFRimq0DlB8cNtIe8hdqndH8TV/TFrljNgR8QdzOgZtZ9C\n'
    + 'zzQ2GRpInN/qJF6slEd6wO+6TaDBQkPY+07TXNt52POFUhdVkhJXHpE2BS7Xn6J7\n'
    + '7RFAOeG1IZmc2DDt+sR1BgXzUqHslQGfFYNS0/MBO4P+ya6W7IhruB1qfa4HiYQS\n'
    + 'dbe4MvGWnv0UzwAqdR7OF8+8/5c58YXZIXCO9riYF2ql6KNSL5cyDPcYK5VK0+Q9\n'
    + 'VI6vuJHSMYcF7wLePw8jtBktqAFE/wbdZiIHhZvNyiNWPPNTGUmQbaJ+TzQEHDs5\n'
    + '8en+/W7JKnPyBOkxxENbAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBS0nw/tFR9bCjgqWTPJkyy4oOD8bzAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
    + 'CXGAY3feAak6lHdqj6+YWjy6yyUnLK37bRxZDsyDVXrPRQaXRzPTzx79jvDwEb/H\n'
    + 'Q/bdQ7zQRWqJcbivQlwhuPJ4kWPUZgSt3JUUuqkMsDzsvj/bwIjlrEFDOdHGh0mi\n'
    + 'eVIngFEjUXjMh+5aHPEF9BlQnB8LfVtKj18e15UDTXFa+xJPFxUR7wDzCfo4WI1m\n'
    + 'sUMG4q1FkGAZgsoyFPZfF8IVvgCuGdR8z30VWKklFxttlK0eGLlPAyIO0CQxPQlo\n'
    + 'saNJrHf4tLOgZIWk+LpDhNd9Et5EzvJ3aURUsKY4pISPPF5WdvM9OE59bERwUErd\n'
    + 'nuOuQWQeeadMceZnauRzJQ==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-west-2 certificate CA 2015 to 2020
     *
     *   CN = Amazon RDS us-west-2 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2015-02-05T22:03:50Z/2020-03-05T22:03:50Z
     *   F = 94:2C:A8:B0:23:48:17:F0:CD:2F:19:7F:C1:E0:21:7C:65:79:13:3A
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBSzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNTBaFw0y\n'
    + 'MDAzMDUyMjAzNTBaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyB1cy13ZXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDM\n'
    + 'H58SR48U6jyERC1vYTnub34smf5EQVXyzaTmspWGWGzT31NLNZGSDFaa7yef9kdO\n'
    + 'mzJsgebR5tXq6LdwlIoWkKYQ7ycUaadtVKVYdI40QcI3cHn0qLFlg2iBXmWp/B+i\n'
    + 'Z34VuVlCh31Uj5WmhaBoz8t/GRqh1V/aCsf3Wc6jCezH3QfuCjBpzxdOOHN6Ie2v\n'
    + 'xX09O5qmZTvMoRBAvPkxdaPg/Mi7fxueWTbEVk78kuFbF1jHYw8U1BLILIAhcqlq\n'
    + 'x4u8nl73t3O3l/soNUcIwUDK0/S+Kfqhwn9yQyPlhb4Wy3pfnZLJdkyHldktnQav\n'
    + '9TB9u7KH5Lk0aAYslMLxAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBT8roM4lRnlFHWMPWRz0zkwFZog1jAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
    + 'JwrxwgwmPtcdaU7O7WDdYa4hprpOMamI49NDzmE0s10oGrqmLwZygcWU0jT+fJ+Y\n'
    + 'pJe1w0CVfKaeLYNsOBVW3X4ZPmffYfWBheZiaiEflq/P6t7/Eg81gaKYnZ/x1Dfa\n'
    + 'sUYkzPvCkXe9wEz5zdUTOCptDt89rBR9CstL9vE7WYUgiVVmBJffWbHQLtfjv6OF\n'
    + 'NMb0QME981kGRzc2WhgP71YS2hHd1kXtsoYP1yTu4vThSKsoN4bkiHsaC1cRkLoy\n'
    + '0fFA4wpB3WloMEvCDaUvvH1LZlBXTNlwi9KtcwD4tDxkkBt4tQczKLGpQ/nF/W9n\n'
    + '8YDWk3IIc1sd0bkZqoau2Q==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-south-1 certificate CA 2016 to 2020
     *
     *   CN = Amazon RDS ap-south-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2016-05-03T21:29:22Z/2020-03-05T21:29:22Z
     *   F = F3:A3:C2:52:D9:82:20:AC:8C:62:31:2A:8C:AD:5D:7B:1C:31:F1:DD
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/TCCAuWgAwIBAgIBTTANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjA1MDMyMTI5MjJaFw0y\n'
    + 'MDAzMDUyMTI5MjJaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UEAwwYQW1hem9uIFJE\n'
    + 'UyBhcC1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n'
    + '06eWGLE0TeqL9kyWOLkS8q0fXO97z+xyBV3DKSB2lg2GkgBz3B98MkmkeB0SZy3G\n'
    + 'Ce4uCpCPbFKiFEdiUclOlhZsrBuCeaimxLM3Ig2wuenElO/7TqgaYHYUbT3d+VQW\n'
    + 'GUbLn5GRZJZe1OAClYdOWm7A1CKpuo+cVV1vxbY2nGUQSJPpVn2sT9gnwvjdE60U\n'
    + 'JGYU/RLCTm8zmZBvlWaNIeKDnreIc4rKn6gUnJ2cQn1ryCVleEeyc3xjYDSrjgdn\n'
    + 'FLYGcp9mphqVT0byeQMOk0c7RHpxrCSA0V5V6/CreFV2LteK50qcDQzDSM18vWP/\n'
    + 'p09FoN8O7QrtOeZJzH/lmwIDAQABo2YwZDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0T\n'
    + 'AQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU2i83QHuEl/d0keXF+69HNJph7cMwHwYD\n'
    + 'VR0jBBgwFoAUTgLurD72FchM7Sz1BcGPnIQISYMwDQYJKoZIhvcNAQELBQADggEB\n'
    + 'ACqnH2VjApoDqoSQOky52QBwsGaj+xWYHW5Gm7EvCqvQuhWMkeBuD6YJmMvNyA9G\n'
    + 'I2lh6/o+sUk/RIsbYbxPRdhNPTOgDR9zsNRw6qxaHztq/CEC+mxDCLa3O1hHBaDV\n'
    + 'BmB3nCZb93BvO0EQSEk7aytKq/f+sjyxqOcs385gintdHGU9uM7gTZHnU9vByJsm\n'
    + '/TL07Miq67X0NlhIoo3jAk+xHaeKJdxdKATQp0448P5cY20q4b8aMk1twcNaMvCP\n'
    + 'dG4M5doaoUA8OQ/0ukLLae/LBxLeTw04q1/a2SyFaVUX2Twbb1S3xVWwLA8vsyGr\n'
    + 'igXx7B5GgP+IHb6DTjPJAi0=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-east-2 certificate CA 2016 to 2020
     *
     *   CN = Amazon RDS us-east-2 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2016-08-11T19:58:45Z/2020-03-05T19:58:45Z
     *   F = 9B:78:E3:64:7F:74:BC:B2:52:18:CF:13:C3:62:B8:35:9D:3D:5F:B6
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBTjANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjA4MTExOTU4NDVaFw0y\n'
    + 'MDAzMDUxOTU4NDVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyB1cy1lYXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCp\n'
    + 'WnnUX7wM0zzstccX+4iXKJa9GR0a2PpvB1paEX4QRCgfhEdQWDaSqyrWNgdVCKkt\n'
    + '1aQkWu5j6VAC2XIG7kKoonm1ZdBVyBLqW5lXNywlaiU9yhJkwo8BR+/OqgE+PLt/\n'
    + 'EO1mlN0PQudja/XkExCXTO29TG2j7F/O7hox6vTyHNHc0H88zS21uPuBE+jivViS\n'
    + 'yzj/BkyoQ85hnkues3f9R6gCGdc+J51JbZnmgzUkvXjAEuKhAm9JksVOxcOKUYe5\n'
    + 'ERhn0U9zjzpfbAITIkul97VVa5IxskFFTHIPJbvRKHJkiF6wTJww/tc9wm+fSCJ1\n'
    + '+DbQTGZgkQ3bJrqRN29/AgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBSAHQzUYYZbepwKEMvGdHp8wzHnfDAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOCAQEA\n'
    + 'MbaEzSYZ+aZeTBxf8yi0ta8K4RdwEJsEmP6IhFFQHYUtva2Cynl4Q9tZg3RMsybT\n'
    + '9mlnSQQlbN/wqIIXbkrcgFcHoXG9Odm/bDtUwwwDaiEhXVfeQom3G77QHOWMTCGK\n'
    + 'qadwuh5msrb17JdXZoXr4PYHDKP7j0ONfAyFNER2+uecblHfRSpVq5UeF3L6ZJb8\n'
    + 'fSw/GtAV6an+/0r+Qm+PiI2H5XuZ4GmRJYnGMhqWhBYrY7p3jtVnKcsh39wgfUnW\n'
    + 'AvZEZG/yhFyAZW0Essa39LiL5VSq14Y1DOj0wgnhSY/9WHxaAo1HB1T9OeZknYbD\n'
    + 'fl/EGSZ0TEvZkENrXcPlVA==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ca-central-1 certificate CA 2016 to 2020
     *
     *   CN = Amazon RDS ca-central-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2016-09-15T00:10:11Z/2020-03-05T00:10:11Z
     *   F = D7:E0:16:AB:8A:0B:63:9F:67:1F:16:87:42:F4:0A:EE:73:A6:FC:04
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/zCCAuegAwIBAgIBTzANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjA5MTUwMDEwMTFaFw0y\n'
    + 'MDAzMDUwMDEwMTFaMIGSMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEjMCEGA1UEAwwaQW1hem9uIFJE\n'
    + 'UyBjYS1jZW50cmFsLTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\n'
    + 'AQCZYI/iQ6DrS3ny3t1EwX1wAD+3LMgh7Fd01EW5LIuaK2kYIIQpsVKhxLCit/V5\n'
    + 'AGc/1qiJS1Qz9ODLTh0Na6bZW6EakRzuHJLe32KJtoFYPC7Z09UqzXrpA/XL+1hM\n'
    + 'P0ZmCWsU7Nn/EmvfBp9zX3dZp6P6ATrvDuYaVFr+SA7aT3FXpBroqBS1fyzUPs+W\n'
    + 'c6zTR6+yc4zkHX0XQxC5RH6xjgpeRkoOajA/sNo7AQF7KlWmKHbdVF44cvvAhRKZ\n'
    + 'XaoVs/C4GjkaAEPTCbopYdhzg+KLx9eB2BQnYLRrIOQZtRfbQI2Nbj7p3VsRuOW1\n'
    + 'tlcks2w1Gb0YC6w6SuIMFkl1AgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNV\n'
    + 'HRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBToYWxE1lawl6Ks6NsvpbHQ3GKEtzAf\n'
    + 'BgNVHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOC\n'
    + 'AQEAG/8tQ0ooi3hoQpa5EJz0/E5VYBsAz3YxA2HoIonn0jJyG16bzB4yZt4vNQMA\n'
    + 'KsNlQ1uwDWYL1nz63axieUUFIxqxl1KmwfhsmLgZ0Hd2mnTPIl2Hw3uj5+wdgGBg\n'
    + 'agnAZ0bajsBYgD2VGQbqjdk2Qn7Fjy3LEWIvGZx4KyZ99OJ2QxB7JOPdauURAtWA\n'
    + 'DKYkP4LLJxtj07DSzG8kuRWb9B47uqUD+eKDIyjfjbnzGtd9HqqzYFau7EX3HVD9\n'
    + '9Qhnjl7bTZ6YfAEZ3nH2t3Vc0z76XfGh47rd0pNRhMV+xpok75asKf/lNh5mcUrr\n'
    + 'VKwflyMkQpSbDCmcdJ90N2xEXQ==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-west-2 certificate CA 2016 to 2020
     *
     *   CN = Amazon RDS eu-west-2 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2016-10-10T17:44:42Z/2020-03-05T17:44:42Z
     *   F = 47:79:51:9F:FF:07:D3:F4:27:D3:AB:64:56:7F:00:45:BB:84:C1:71
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBUDANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjEwMTAxNzQ0NDJaFw0y\n'
    + 'MDAzMDUxNzQ0NDJaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyBldS13ZXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDO\n'
    + 'cttLJfubB4XMMIGWNfJISkIdCMGJyOzLiMJaiWB5GYoXKhEl7YGotpy0qklwW3BQ\n'
    + 'a0fmVdcCLX+dIuVQ9iFK+ZcK7zwm7HtdDTCHOCKeOh2IcnU4c/VIokFi6Gn8udM6\n'
    + 'N/Zi5M5OGpVwLVALQU7Yctsn3c95el6MdVx6mJiIPVu7tCVZn88Z2koBQ2gq9P4O\n'
    + 'Sb249SHFqOb03lYDsaqy1NDsznEOhaRBw7DPJFpvmw1lA3/Y6qrExRI06H2VYR2i\n'
    + '7qxwDV50N58fs10n7Ye1IOxTVJsgEA7X6EkRRXqYaM39Z76R894548WHfwXWjUsi\n'
    + 'MEX0RS0/t1GmnUQjvevDAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBQBxmcuRSxERYCtNnSr5xNfySokHjAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOCAQEA\n'
    + 'UyCUQjsF3nUAABjfEZmpksTuUo07aT3KGYt+EMMFdejnBQ0+2lJJFGtT+CDAk1SD\n'
    + 'RSgfEBon5vvKEtlnTf9a3pv8WXOAkhfxnryr9FH6NiB8obISHNQNPHn0ljT2/T+I\n'
    + 'Y6ytfRvKHa0cu3V0NXbJm2B4KEOt4QCDiFxUIX9z6eB4Kditwu05OgQh6KcogOiP\n'
    + 'JesWxBMXXGoDC1rIYTFO7szwDyOHlCcVXJDNsTJhc32oDWYdeIbW7o/5I+aQsrXZ\n'
    + 'C96HykZcgWzz6sElrQxUaT3IoMw/5nmw4uWKKnZnxgI9bY4fpQwMeBZ96iHfFxvH\n'
    + 'mqfEEuC7uUoPofXdBp2ObQ==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-gov-west-1 CA 2017 to 2022
     *
     *   CN = Amazon RDS us-gov-west-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2017-05-19T22:31:19Z/2022-05-18T12:00:00Z
     *   F = 77:55:8C:C4:5E:71:1F:1B:57:E3:DA:6E:5B:74:27:12:4E:E8:69:E8
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECjCCAvKgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZMxCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSQwIgYDVQQDDBtBbWF6b24gUkRTIEdvdkNsb3VkIFJvb3QgQ0EwHhcNMTcwNTE5\n'
    + 'MjIzMTE5WhcNMjIwNTE4MTIwMDAwWjCBkzELMAkGA1UEBhMCVVMxEzARBgNVBAgM\n'
    + 'Cldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBX\n'
    + 'ZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJDAiBgNVBAMM\n'
    + 'G0FtYXpvbiBSRFMgdXMtZ292LXdlc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n'
    + 'ggEPADCCAQoCggEBAM8YZLKAzzOdNnoi7Klih26Zkj+OCpDfwx4ZYB6f8L8UoQi5\n'
    + '8z9ZtIwMjiJ/kO08P1yl4gfc7YZcNFvhGruQZNat3YNpxwUpQcr4mszjuffbL4uz\n'
    + '+/8FBxALdqCVOJ5Q0EVSfz3d9Bd1pUPL7ARtSpy7bn/tUPyQeI+lODYO906C0TQ3\n'
    + 'b9bjOsgAdBKkHfjLdsknsOZYYIzYWOJyFJJa0B11XjDUNBy/3IuC0KvDl6At0V5b\n'
    + '8M6cWcKhte2hgjwTYepV+/GTadeube1z5z6mWsN5arOAQUtYDLH6Aztq9mCJzLHm\n'
    + 'RccBugnGl3fRLJ2VjioN8PoGoN9l9hFBy5fnFgsCAwEAAaNmMGQwDgYDVR0PAQH/\n'
    + 'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEG7+br8KkvwPd5g\n'
    + '71Rvh2stclJbMB8GA1UdIwQYMBaAFEkQz6S4NS5lOYKcDjBSuCcVpdzjMA0GCSqG\n'
    + 'SIb3DQEBCwUAA4IBAQBMA327u5ABmhX+aPxljoIbxnydmAFWxW6wNp5+rZrvPig8\n'
    + 'zDRqGQWWr7wWOIjfcWugSElYtf/m9KZHG/Z6+NG7nAoUrdcd1h/IQhb+lFQ2b5g9\n'
    + 'sVzQv/H2JNkfZA8fL/Ko/Tm/f9tcqe0zrGCtT+5u0Nvz35Wl8CEUKLloS5xEb3k5\n'
    + '7D9IhG3fsE3vHWlWrGCk1cKry3j12wdPG5cUsug0vt34u6rdhP+FsM0tHI15Kjch\n'
    + 'RuUCvyQecy2ZFNAa3jmd5ycNdL63RWe8oayRBpQBxPPCbHfILxGZEdJbCH9aJ2D/\n'
    + 'l8oHIDnvOLdv7/cBjyYuvmprgPtu3QEkbre5Hln/\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-west-3 certificate CA 2017 to 2020
     *
     *   CN = Amazon RDS eu-west-3 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2017-08-25T21:39:26Z/2020-03-05T21:39:26Z
     *   F = FD:35:A7:84:60:68:98:00:12:54:ED:34:26:8C:66:0F:72:DD:B2:F4
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIID/DCCAuSgAwIBAgIBUTANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNzA4MjUyMTM5MjZaFw0y\n'
    + 'MDAzMDUyMTM5MjZaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
    + 'UyBldS13ZXN0LTMgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC+\n'
    + 'xmlEC/3a4cJH+UPwXCE02lC7Zq5NHd0dn6peMeLN8agb6jW4VfSY0NydjRj2DJZ8\n'
    + 'K7wV6sub5NUGT1NuFmvSmdbNR2T59KX0p2dVvxmXHHtIpQ9Y8Aq3ZfhmC5q5Bqgw\n'
    + 'tMA1xayDi7HmoPX3R8kk9ktAZQf6lDeksCvok8idjTu9tiSpDiMwds5BjMsWfyjZ\n'
    + 'd13PTGGNHYVdP692BSyXzSP1Vj84nJKnciW8tAqwIiadreJt5oXyrCXi8ekUMs80\n'
    + 'cUTuGm3aA3Q7PB5ljJMPqz0eVddaiIvmTJ9O3Ez3Du/HpImyMzXjkFaf+oNXf/Hx\n'
    + '/EW5jCRR6vEiXJcDRDS7AgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBRZ9mRtS5fHk3ZKhG20Oack4cAqMTAfBgNV\n'
    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOCAQEA\n'
    + 'F/u/9L6ExQwD73F/bhCw7PWcwwqsK1mypIdrjdIsu0JSgwWwGCXmrIspA3n3Dqxq\n'
    + 'sMhAJD88s9Em7337t+naar2VyLO63MGwjj+vA4mtvQRKq8ScIpiEc7xN6g8HUMsd\n'
    + 'gPG9lBGfNjuAZsrGJflrko4HyuSM7zHExMjXLH+CXcv/m3lWOZwnIvlVMa4x0Tz0\n'
    + 'A4fklaawryngzeEjuW6zOiYCzjZtPlP8Fw0SpzppJ8VpQfrZ751RDo4yudmPqoPK\n'
    + '5EUe36L8U+oYBXnC5TlYs9bpVv9o5wJQI5qA9oQE2eFWxF1E0AyZ4V5sgGUBStaX\n'
    + 'BjDDWul0wSo7rt1Tq7XpnA==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-northeast-3 certificate CA 2017 to 2020
     *
     *   CN = Amazon RDS ap-northeast-3 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2017-12-01T00:55:42Z/2020-03-05T00:55:42Z
     *   F = C0:C7:D4:B3:91:40:A0:77:43:28:BF:AF:77:57:DF:FD:98:FB:10:3F
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEATCCAumgAwIBAgIBTjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNzEyMDEwMDU1NDJaFw0y\n'
    + 'MDAzMDUwMDU1NDJaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
    + 'UyBhcC1ub3J0aGVhc3QtMyBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
    + 'ggEBAMZtQNnm/XT19mTa10ftHLzg5UhajoI65JHv4TQNdGXdsv+CQdGYU49BJ9Eu\n'
    + '3bYgiEtTzR2lQe9zGMvtuJobLhOWuavzp7IixoIQcHkFHN6wJ1CvqrxgvJfBq6Hy\n'
    + 'EuCDCiU+PPDLUNA6XM6Qx3IpHd1wrJkjRB80dhmMSpxmRmx849uFafhN+P1QybsM\n'
    + 'TI0o48VON2+vj+mNuQTyLMMP8D4odSQHjaoG+zyJfJGZeAyqQyoOUOFEyQaHC3TT\n'
    + '3IDSNCQlpxb9LerbCoKu79WFBBq3CS5cYpg8/fsnV2CniRBFFUumBt5z4dhw9RJU\n'
    + 'qlUXXO1ZyzpGd+c5v6FtrfXtnIUCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFETv7ELNplYy/xTeIOInl6nzeiHg\n'
    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
    + 'A4IBAQCpKxOQcd0tEKb3OtsOY8q/MPwTyustGk2Rt7t9G68idADp8IytB7M0SDRo\n'
    + 'wWZqynEq7orQVKdVOanhEWksNDzGp0+FPAf/KpVvdYCd7ru3+iI+V4ZEp2JFdjuZ\n'
    + 'Zz0PIjS6AgsZqE5Ri1J+NmfmjGZCPhsHnGZiBaenX6K5VRwwwmLN6xtoqrrfR5zL\n'
    + 'QfBeeZNJG6KiM3R/DxJ5rAa6Fz+acrhJ60L7HprhB7SFtj1RCijau3+ZwiGmUOMr\n'
    + 'yKlMv+VgmzSw7o4Hbxy1WVrA6zQsTHHSGf+vkQn2PHvnFMUEu/ZLbTDYFNmTLK91\n'
    + 'K6o4nMsEvhBKgo4z7H1EqqxXhvN2\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS GovCloud Root CA 2017 to 2022
     *
     *   CN = Amazon RDS GovCloud Root CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2017-05-19T22:29:11Z/2022-05-18T22:29:11Z
     *   F = A3:61:F9:C9:A2:5B:91:FE:73:A6:52:E3:59:14:8E:CE:35:12:0F:FD
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEDjCCAvagAwIBAgIJAMM61RQn3/kdMA0GCSqGSIb3DQEBCwUAMIGTMQswCQYD\n'
    + 'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n'
    + 'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n'
    + 'em9uIFJEUzEkMCIGA1UEAwwbQW1hem9uIFJEUyBHb3ZDbG91ZCBSb290IENBMB4X\n'
    + 'DTE3MDUxOTIyMjkxMVoXDTIyMDUxODIyMjkxMVowgZMxCzAJBgNVBAYTAlVTMRAw\n'
    + 'DgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQKDBlB\n'
    + 'bWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSQw\n'
    + 'IgYDVQQDDBtBbWF6b24gUkRTIEdvdkNsb3VkIFJvb3QgQ0EwggEiMA0GCSqGSIb3\n'
    + 'DQEBAQUAA4IBDwAwggEKAoIBAQDGS9bh1FGiJPT+GRb3C5aKypJVDC1H2gbh6n3u\n'
    + 'j8cUiyMXfmm+ak402zdLpSYMaxiQ7oL/B3wEmumIpRDAsQrSp3B/qEeY7ipQGOfh\n'
    + 'q2TXjXGIUjiJ/FaoGqkymHRLG+XkNNBtb7MRItsjlMVNELXECwSiMa3nJL2/YyHW\n'
    + 'nTr1+11/weeZEKgVbCUrOugFkMXnfZIBSn40j6EnRlO2u/NFU5ksK5ak2+j8raZ7\n'
    + 'xW7VXp9S1Tgf1IsWHjGZZZguwCkkh1tHOlHC9gVA3p63WecjrIzcrR/V27atul4m\n'
    + 'tn56s5NwFvYPUIx1dbC8IajLUrepVm6XOwdQCfd02DmOyjWJAgMBAAGjYzBhMA4G\n'
    + 'A1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRJEM+kuDUu\n'
    + 'ZTmCnA4wUrgnFaXc4zAfBgNVHSMEGDAWgBRJEM+kuDUuZTmCnA4wUrgnFaXc4zAN\n'
    + 'BgkqhkiG9w0BAQsFAAOCAQEAcfA7uirXsNZyI2j4AJFVtOTKOZlQwqbyNducnmlg\n'
    + '/5nug9fAkwM4AgvF5bBOD1Hw6khdsccMwIj+1S7wpL+EYb/nSc8G0qe1p/9lZ/mZ\n'
    + 'ff5g4JOa26lLuCrZDqAk4TzYnt6sQKfa5ZXVUUn0BK3okhiXS0i+NloMyaBCL7vk\n'
    + 'kDwkHwEqflRKfZ9/oFTcCfoiHPA7AdBtaPVr0/Kj9L7k+ouz122huqG5KqX0Zpo8\n'
    + 'S0IGvcd2FZjNSNPttNAK7YuBVsZ0m2nIH1SLp//00v7yAHIgytQwwB17PBcp4NXD\n'
    + 'pCfTa27ng9mMMC2YLqWQpW4TkqjDin2ZC+5X/mbrjzTvVg==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-east-1 certificate CA 2019 to 2022
     *
     *   CN = Amazon RDS ap-east-1 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-02-17T02:47:00Z/2022-06-01T12:00:00Z
     *   F = BC:F8:70:75:1F:93:3F:A7:82:86:67:63:A8:86:1F:A4:E8:07:CE:06
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSUwIwYDVQQDDBxBbWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBMB4XDTE5MDIx\n'
    + 'NzAyNDcwMFoXDTIyMDYwMTEyMDAwMFowgY8xCzAJBgNVBAYTAlVTMRMwEQYDVQQI\n'
    + 'DApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g\n'
    + 'V2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSAwHgYDVQQD\n'
    + 'DBdBbWF6b24gUkRTIGFwLWVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBAOcJAUofyJuBuPr5ISHi/Ha5ed8h3eGdzn4MBp6rytPOg9NVGRQs\n'
    + 'O93fNGCIKsUT6gPuk+1f1ncMTV8Y0Fdf4aqGWme+Khm3ZOP3V1IiGnVq0U2xiOmn\n'
    + 'SQ4Q7LoeQC4lC6zpoCHVJyDjZ4pAknQQfsXb77Togdt/tK5ahev0D+Q3gCwAoBoO\n'
    + 'DHKJ6t820qPi63AeGbJrsfNjLKiXlFPDUj4BGir4dUzjEeH7/hx37na1XG/3EcxP\n'
    + '399cT5k7sY/CR9kctMlUyEEUNQOmhi/ly1Lgtihm3QfjL6K9aGLFNwX35Bkh9aL2\n'
    + 'F058u+n8DP/dPeKUAcJKiQZUmzuen5n57x8CAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFlqgF4FQlb9yP6c+Q3E\n'
    + 'O3tXv+zOMB8GA1UdIwQYMBaAFK9T6sY/PBZVbnHcNcQXf58P4OuPMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQDeXiS3v1z4jWAo1UvVyKDeHjtrtEH1Rida1eOXauFuEQa5tuOk\n'
    + 'E53Os4haZCW4mOlKjigWs4LN+uLIAe1aFXGo92nGIqyJISHJ1L+bopx/JmIbHMCZ\n'
    + '0lTNJfR12yBma5VQy7vzeFku/SisKwX0Lov1oHD4MVhJoHbUJYkmAjxorcIHORvh\n'
    + 'I3Vj5XrgDWtLDPL8/Id/roul/L+WX5ir+PGScKBfQIIN2lWdZoqdsx8YWqhm/ikL\n'
    + 'C6qNieSwcvWL7C03ri0DefTQMY54r5wP33QU5hJ71JoaZI3YTeT0Nf+NRL4hM++w\n'
    + 'Q0veeNzBQXg1f/JxfeA39IDIX1kiCf71tGlT\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-northeast-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ap-northeast-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-18T16:56:20Z/2024-08-22T17:08:50Z
     *   F = 47:A3:F9:20:64:5C:9F:9D:48:8C:7D:E6:0B:86:D6:05:13:00:16:A1
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2\n'
    + 'MjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n'
    + 'em9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n'
    + 'AAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7\n'
    + '+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx\n'
    + '1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s\n'
    + 'BEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3\n'
    + 'UnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud\n'
    + 'QQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B\n'
    + 'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+\n'
    + 'snUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n'
    + 'KoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j\n'
    + 'b4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM\n'
    + 'gwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX\n'
    + 'Fiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq\n'
    + 'nvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf\n'
    + '2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-northeast-2 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ap-northeast-2 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-10T17:46:21Z/2024-08-22T17:08:50Z
     *   F = 8E:1C:70:C1:64:BD:FC:F9:93:9B:A2:67:CA:CF:52:F0:E1:F7:B4:F0
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2\n'
    + 'MjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n'
    + 'em9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n'
    + 'AAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5\n'
    + '8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN\n'
    + 'DpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s\n'
    + '3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc\n'
    + 'cQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ\n'
    + 'h32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B\n'
    + 'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U\n'
    + 'lrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n'
    + 'KoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc\n'
    + '9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6\n'
    + 'mkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV\n'
    + 'obcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx\n'
    + 'CRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4\n'
    + 'prf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-northeast-3 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ap-northeast-3 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-17T20:05:29Z/2024-08-22T17:08:50Z
     *   F = D1:08:B1:40:6D:6C:80:8E:F4:C1:2C:8A:1F:66:17:01:54:CD:1A:4E
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1\n'
    + 'MjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n'
    + 'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n'
    + 'AAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS\n'
    + 'kbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1\n'
    + 'xoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3\n'
    + 'Z+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV\n'
    + 'LhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn\n'
    + '7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B\n'
    + 'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+\n'
    + 'gv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n'
    + 'KoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w\n'
    + 'G0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad\n'
    + 'zQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN\n'
    + 'xngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W\n'
    + '8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy\n'
    + 'DgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-south-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ap-south-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-04T17:13:04Z/2024-08-22T17:08:50Z
     *   F = D6:AD:45:A9:54:36:E4:BA:9C:B7:9B:06:8C:0C:CD:CC:1E:81:B5:00
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz\n'
    + 'MDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\n'
    + 'em9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n'
    + 'DwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim\n'
    + 'eWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC\n'
    + 'BaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM\n'
    + 'p/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e\n'
    + 'qCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt\n'
    + 'lPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n'
    + 'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG\n'
    + 'i3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n'
    + '9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+\n'
    + 'hu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K\n'
    + 'jYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD\n'
    + 'tZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe\n'
    + 'iOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox\n'
    + 'AVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-southeast-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ap-southeast-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-13T20:11:42Z/2024-08-22T17:08:50Z
     *   F = 0D:20:FB:91:DE:BE:D2:CF:F3:F8:F8:43:AF:68:C6:03:76:F3:DD:B8
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx\n'
    + 'NDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n'
    + 'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n'
    + 'AAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb\n'
    + 'qddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns\n'
    + 'eHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5\n'
    + '6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH\n'
    + 'wzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw\n'
    + '61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B\n'
    + 'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5\n'
    + 'Ichd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n'
    + 'KoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP\n'
    + 'uYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj\n'
    + 'yjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h\n'
    + 'eIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi\n'
    + 'IRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI\n'
    + 'HfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ap-southeast-2 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ap-southeast-2 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-16T19:53:47Z/2024-08-22T17:08:50Z
     *   F = D5:D4:51:83:D9:A3:AC:47:B0:0A:5A:77:D8:A0:79:A9:6A:3F:6D:96
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz\n'
    + 'NDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n'
    + 'em9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n'
    + 'AAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo\n'
    + 'GHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd\n'
    + 'gEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn\n'
    + 'TpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j\n'
    + '7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH\n'
    + 'PbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B\n'
    + 'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV\n'
    + 'M5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n'
    + 'KoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz\n'
    + 'sl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M\n'
    + 'NsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw\n'
    + '1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL\n'
    + '+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR\n'
    + 'FZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS ca-central-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS ca-central-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-10T20:52:25Z/2024-08-22T17:08:50Z
     *   F = A1:03:46:F2:BB:29:BF:4F:EC:04:7E:82:9A:A6:C0:11:4D:AB:82:25
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy\n'
    + 'MjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\n'
    + 'em9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n'
    + 'ggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB\n'
    + 'viuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp\n'
    + 'XnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O\n'
    + 'qvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi\n'
    + 'qmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh\n'
    + 'YDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/\n'
    + 'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE\n'
    + 'CxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\n'
    + 'SIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2\n'
    + 'lKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9\n'
    + 'r8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp\n'
    + 'xl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv\n'
    + 'RbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x\n'
    + 'JXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-central-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS eu-central-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-11T19:36:20Z/2024-08-22T17:08:50Z
     *   F = 53:46:18:4A:42:65:A2:8C:5F:5B:0A:AD:E2:2C:80:E5:E6:8A:6D:2F
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2\n'
    + 'MjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\n'
    + 'em9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n'
    + 'ggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv\n'
    + 'n+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl\n'
    + 'I67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh\n'
    + 'm34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0\n'
    + '5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6\n'
    + 'D/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/\n'
    + 'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa\n'
    + 'TnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\n'
    + 'SIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt\n'
    + 'DAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE\n'
    + 'cXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH\n'
    + 'mgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W\n'
    + 'CBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc\n'
    + 'qpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-north-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS eu-north-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-12T18:19:44Z/2024-08-22T17:08:50Z
     *   F = D0:CA:9C:6E:47:4C:4F:DB:85:28:03:4A:60:AC:14:E0:E6:DF:D4:42
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5\n'
    + 'NDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\n'
    + 'em9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n'
    + 'DwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v\n'
    + 'Aoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO\n'
    + 'XsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs\n'
    + 'JXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e\n'
    + 'uhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE\n'
    + 'q+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n'
    + 'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc\n'
    + 'hnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n'
    + '9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI\n'
    + 'T5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl\n'
    + 'I1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe\n'
    + 'pxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc\n'
    + 'tKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN\n'
    + 'cjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-west-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS eu-west-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-11T17:31:48Z/2024-08-22T17:08:50Z
     *   F = 2D:1A:A6:3E:0D:EB:D6:26:03:3E:A1:8A:0A:DF:14:80:78:EC:B6:63
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx\n'
    + 'NDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n'
    + 'em9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ\n'
    + 'LXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X\n'
    + 'O++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69\n'
    + '7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5\n'
    + 'tvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS\n'
    + 'EMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt\n'
    + 'sLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP\n'
    + '0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy\n'
    + 'lGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd\n'
    + 'vH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9\n'
    + 'nRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A\n'
    + 'J116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-west-2 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS eu-west-2 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-12T21:32:32Z/2024-08-22T17:08:50Z
     *   F = 60:65:44:F4:74:6E:2E:29:50:19:38:7C:4B:BE:18:B9:5B:D4:CD:23
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy\n'
    + 'MzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n'
    + 'em9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u\n'
    + 'PFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn\n'
    + '7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB\n'
    + '6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX\n'
    + '7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y\n'
    + 'fYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv\n'
    + '2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM\n'
    + 'hnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q\n'
    + 'oHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10\n'
    + '7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU\n'
    + 'mqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD\n'
    + 'bpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS eu-west-3 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS eu-west-3 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-18T17:03:15Z/2024-08-22T17:08:50Z
     *   F = 6F:79:56:B0:74:9C:C6:3E:3B:50:26:C8:51:55:08:F0:BB:7E:32:04
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz\n'
    + 'MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n'
    + 'em9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh\n'
    + '1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg\n'
    + 'pVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2\n'
    + 'q+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr\n'
    + 'i+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV\n'
    + 'ARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3\n'
    + 'Y2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV\n'
    + 'SxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1\n'
    + 'AETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3\n'
    + 'O971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2\n'
    + 'zFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF\n'
    + 'wWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS me-south-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS me-south-1 Root CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-05-10T21:48:27Z/2024-05-08T21:48:27Z
     *   F = 8A:69:D7:00:FB:5D:62:9C:B0:D1:75:6F:B7:B6:38:AA:76:C4:BD:1F
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n'
    + 'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n'
    + 'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n'
    + 'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew\n'
    + 'HhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx\n'
    + 'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n'
    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
    + 'JjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq\n'
    + 'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT\n'
    + 'aPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk\n'
    + 'UA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8\n'
    + 'gkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw\n'
    + 'ERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd\n'
    + 'rdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw\n'
    + 'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf\n'
    + 'DjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda\n'
    + 'iqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA\n'
    + 'eC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7\n'
    + 'ny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB\n'
    + 'hitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso\n'
    + 'aTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv\n'
    + '3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS sa-east-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS sa-east-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-05T18:46:29Z/2024-08-22T17:08:50Z
     *   F = 8C:34:0F:AA:FB:10:80:9C:05:CE:D7:BF:0B:12:4D:07:42:39:74:7A
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2\n'
    + 'MjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n'
    + 'em9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H\n'
    + 'M6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld\n'
    + '5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J\n'
    + 'bFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc\n'
    + 'Jt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7\n'
    + 'JbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq\n'
    + 'ccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I\n'
    + '93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR\n'
    + '4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn\n'
    + '/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q\n'
    + 'Ls1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C\n'
    + 'jkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-east-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS us-east-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-19T18:16:53Z/2024-08-22T17:08:50Z
     *   F = F0:ED:82:3E:D1:44:47:BA:B5:57:FD:F3:E4:92:74:66:98:8C:1C:78
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2\n'
    + 'NTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n'
    + 'em9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL\n'
    + 'InXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt\n'
    + 'i8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs\n'
    + 'XcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso\n'
    + 'QIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK\n'
    + 'glMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR\n'
    + 'RBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK\n'
    + 'PJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC\n'
    + 'E1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4\n'
    + '0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i\n'
    + 'h2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF\n'
    + 'MRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-east-2 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS us-east-2 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-13T17:06:41Z/2024-08-22T17:08:50Z
     *   F = E9:FE:27:2A:A0:0F:CE:DF:AD:51:03:A6:94:F7:1F:6F:BD:1E:28:D3
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\n'
    + 'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n'
    + 'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n'
    + 'UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw\n'
    + 'NjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\n'
    + 'c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\n'
    + 'U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\n'
    + 'YXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n'
    + 'DwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht\n'
    + '2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC\n'
    + 'au1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI\n'
    + '8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c\n'
    + 'dbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4\n'
    + 'nS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n'
    + 'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH\n'
    + '6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n'
    + '9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8\n'
    + 'quvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ\n'
    + 'HvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2\n'
    + 'V8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv\n'
    + 'OnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92\n'
    + 'tO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-west-1 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS us-west-1 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-06T17:40:21Z/2024-08-22T17:08:50Z
     *   F = 1C:9F:DF:84:E6:13:32:F3:91:12:2D:0D:A5:9A:16:5D:AC:DC:E8:93
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\n'
    + 'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n'
    + 'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n'
    + 'UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0\n'
    + 'MDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\n'
    + 'c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\n'
    + 'U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\n'
    + 'YXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n'
    + 'DwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6\n'
    + '0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq\n'
    + '/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH\n'
    + 'uM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK\n'
    + 'AkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v\n'
    + 'l5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n'
    + 'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+\n'
    + 'T3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n'
    + '9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA\n'
    + 'PAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6\n'
    + 'tZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17\n'
    + '4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57\n'
    + 'Z6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd\n'
    + 'pFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==\n'
    + '-----END CERTIFICATE-----\n',

    /**
     * Amazon RDS us-west-2 certificate CA 2019 to 2024
     *
     *   CN = Amazon RDS us-west-2 2019 CA
     *   OU = Amazon RDS
     *   O = Amazon Web Services, Inc.
     *   L = Seattle
     *   ST = Washington
     *   C = US
     *   P = 2019-09-16T18:21:15Z/2024-08-22T17:08:50Z
     *   F = C8:DE:1D:13:AD:35:9B:3D:EA:18:2A:DC:B4:79:6D:22:47:75:3C:4A
     */
    '-----BEGIN CERTIFICATE-----\n'
    + 'MIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n'
    + 'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n'
    + 'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n'
    + 'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx\n'
    + 'MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n'
    + 'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n'
    + 'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n'
    + 'em9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n'
    + 'ADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa\n'
    + 'uVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P\n'
    + 'PvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho\n'
    + 'OiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj\n'
    + 'pvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a\n'
    + '2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n'
    + 'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu\n'
    + 'pHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n'
    + 'DQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P\n'
    + '3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7\n'
    + 'GZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q\n'
    + 'UpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb\n'
    + 'jL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6\n'
    + 'uboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW\n'
    + '-----END CERTIFICATE-----\n'
  ]
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/constants/types.js":
/***/ ((__unused_webpack_module, exports) => {

/**
 * MySQL type constants
 *
 * Extracted from version 5.7.29
 *
 * !! Generated by generate-type-constants.js, do not modify by hand !!
 */

exports.DECIMAL     = 0;
exports.TINY        = 1;
exports.SHORT       = 2;
exports.LONG        = 3;
exports.FLOAT       = 4;
exports.DOUBLE      = 5;
exports.NULL        = 6;
exports.TIMESTAMP   = 7;
exports.LONGLONG    = 8;
exports.INT24       = 9;
exports.DATE        = 10;
exports.TIME        = 11;
exports.DATETIME    = 12;
exports.YEAR        = 13;
exports.NEWDATE     = 14;
exports.VARCHAR     = 15;
exports.BIT         = 16;
exports.TIMESTAMP2  = 17;
exports.DATETIME2   = 18;
exports.TIME2       = 19;
exports.JSON        = 245;
exports.NEWDECIMAL  = 246;
exports.ENUM        = 247;
exports.SET         = 248;
exports.TINY_BLOB   = 249;
exports.MEDIUM_BLOB = 250;
exports.LONG_BLOB   = 251;
exports.BLOB        = 252;
exports.VAR_STRING  = 253;
exports.STRING      = 254;
exports.GEOMETRY    = 255;

// Lookup-by-number table
exports[0]   = 'DECIMAL';
exports[1]   = 'TINY';
exports[2]   = 'SHORT';
exports[3]   = 'LONG';
exports[4]   = 'FLOAT';
exports[5]   = 'DOUBLE';
exports[6]   = 'NULL';
exports[7]   = 'TIMESTAMP';
exports[8]   = 'LONGLONG';
exports[9]   = 'INT24';
exports[10]  = 'DATE';
exports[11]  = 'TIME';
exports[12]  = 'DATETIME';
exports[13]  = 'YEAR';
exports[14]  = 'NEWDATE';
exports[15]  = 'VARCHAR';
exports[16]  = 'BIT';
exports[17]  = 'TIMESTAMP2';
exports[18]  = 'DATETIME2';
exports[19]  = 'TIME2';
exports[245] = 'JSON';
exports[246] = 'NEWDECIMAL';
exports[247] = 'ENUM';
exports[248] = 'SET';
exports[249] = 'TINY_BLOB';
exports[250] = 'MEDIUM_BLOB';
exports[251] = 'LONG_BLOB';
exports[252] = 'BLOB';
exports[253] = 'VAR_STRING';
exports[254] = 'STRING';
exports[255] = 'GEOMETRY';


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/AuthSwitchRequestPacket.js":
/***/ ((module) => {

module.exports = AuthSwitchRequestPacket;
function AuthSwitchRequestPacket(options) {
  options = options || {};

  this.status         = 0xfe;
  this.authMethodName = options.authMethodName;
  this.authMethodData = options.authMethodData;
}

AuthSwitchRequestPacket.prototype.parse = function parse(parser) {
  this.status         = parser.parseUnsignedNumber(1);
  this.authMethodName = parser.parseNullTerminatedString();
  this.authMethodData = parser.parsePacketTerminatedBuffer();
};

AuthSwitchRequestPacket.prototype.write = function write(writer) {
  writer.writeUnsignedNumber(1, this.status);
  writer.writeNullTerminatedString(this.authMethodName);
  writer.writeBuffer(this.authMethodData);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/AuthSwitchResponsePacket.js":
/***/ ((module) => {

module.exports = AuthSwitchResponsePacket;
function AuthSwitchResponsePacket(options) {
  options = options || {};

  this.data = options.data;
}

AuthSwitchResponsePacket.prototype.parse = function parse(parser) {
  this.data = parser.parsePacketTerminatedBuffer();
};

AuthSwitchResponsePacket.prototype.write = function write(writer) {
  writer.writeBuffer(this.data);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ClientAuthenticationPacket.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);

module.exports = ClientAuthenticationPacket;
function ClientAuthenticationPacket(options) {
  options = options || {};

  this.clientFlags   = options.clientFlags;
  this.maxPacketSize = options.maxPacketSize;
  this.charsetNumber = options.charsetNumber;
  this.filler        = undefined;
  this.user          = options.user;
  this.scrambleBuff  = options.scrambleBuff;
  this.database      = options.database;
  this.protocol41    = options.protocol41;
}

ClientAuthenticationPacket.prototype.parse = function(parser) {
  if (this.protocol41) {
    this.clientFlags   = parser.parseUnsignedNumber(4);
    this.maxPacketSize = parser.parseUnsignedNumber(4);
    this.charsetNumber = parser.parseUnsignedNumber(1);
    this.filler        = parser.parseFiller(23);
    this.user          = parser.parseNullTerminatedString();
    this.scrambleBuff  = parser.parseLengthCodedBuffer();
    this.database      = parser.parseNullTerminatedString();
  } else {
    this.clientFlags   = parser.parseUnsignedNumber(2);
    this.maxPacketSize = parser.parseUnsignedNumber(3);
    this.user          = parser.parseNullTerminatedString();
    this.scrambleBuff  = parser.parseBuffer(8);
    this.database      = parser.parseLengthCodedBuffer();
  }
};

ClientAuthenticationPacket.prototype.write = function(writer) {
  if (this.protocol41) {
    writer.writeUnsignedNumber(4, this.clientFlags);
    writer.writeUnsignedNumber(4, this.maxPacketSize);
    writer.writeUnsignedNumber(1, this.charsetNumber);
    writer.writeFiller(23);
    writer.writeNullTerminatedString(this.user);
    writer.writeLengthCodedBuffer(this.scrambleBuff);
    writer.writeNullTerminatedString(this.database);
  } else {
    writer.writeUnsignedNumber(2, this.clientFlags);
    writer.writeUnsignedNumber(3, this.maxPacketSize);
    writer.writeNullTerminatedString(this.user);
    writer.writeBuffer(this.scrambleBuff);
    if (this.database && this.database.length) {
      writer.writeFiller(1);
      writer.writeBuffer(Buffer.from(this.database));
    }
  }
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ComChangeUserPacket.js":
/***/ ((module) => {

module.exports = ComChangeUserPacket;
function ComChangeUserPacket(options) {
  options = options || {};

  this.command       = 0x11;
  this.user          = options.user;
  this.scrambleBuff  = options.scrambleBuff;
  this.database      = options.database;
  this.charsetNumber = options.charsetNumber;
}

ComChangeUserPacket.prototype.parse = function(parser) {
  this.command       = parser.parseUnsignedNumber(1);
  this.user          = parser.parseNullTerminatedString();
  this.scrambleBuff  = parser.parseLengthCodedBuffer();
  this.database      = parser.parseNullTerminatedString();
  this.charsetNumber = parser.parseUnsignedNumber(1);
};

ComChangeUserPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, this.command);
  writer.writeNullTerminatedString(this.user);
  writer.writeLengthCodedBuffer(this.scrambleBuff);
  writer.writeNullTerminatedString(this.database);
  writer.writeUnsignedNumber(2, this.charsetNumber);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ComPingPacket.js":
/***/ ((module) => {

module.exports = ComPingPacket;
function ComPingPacket() {
  this.command = 0x0e;
}

ComPingPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, this.command);
};

ComPingPacket.prototype.parse = function(parser) {
  this.command = parser.parseUnsignedNumber(1);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ComQueryPacket.js":
/***/ ((module) => {

module.exports = ComQueryPacket;
function ComQueryPacket(sql) {
  this.command = 0x03;
  this.sql     = sql;
}

ComQueryPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, this.command);
  writer.writeString(this.sql);
};

ComQueryPacket.prototype.parse = function(parser) {
  this.command = parser.parseUnsignedNumber(1);
  this.sql     = parser.parsePacketTerminatedString();
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ComQuitPacket.js":
/***/ ((module) => {

module.exports = ComQuitPacket;
function ComQuitPacket() {
  this.command = 0x01;
}

ComQuitPacket.prototype.parse = function parse(parser) {
  this.command = parser.parseUnsignedNumber(1);
};

ComQuitPacket.prototype.write = function write(writer) {
  writer.writeUnsignedNumber(1, this.command);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ComStatisticsPacket.js":
/***/ ((module) => {

module.exports = ComStatisticsPacket;
function ComStatisticsPacket() {
  this.command = 0x09;
}

ComStatisticsPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, this.command);
};

ComStatisticsPacket.prototype.parse = function(parser) {
  this.command = parser.parseUnsignedNumber(1);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/EmptyPacket.js":
/***/ ((module) => {

module.exports = EmptyPacket;
function EmptyPacket() {
}

EmptyPacket.prototype.parse = function parse() {
};

EmptyPacket.prototype.write = function write() {
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/EofPacket.js":
/***/ ((module) => {

module.exports = EofPacket;
function EofPacket(options) {
  options = options || {};

  this.fieldCount   = undefined;
  this.warningCount = options.warningCount;
  this.serverStatus = options.serverStatus;
  this.protocol41   = options.protocol41;
}

EofPacket.prototype.parse = function(parser) {
  this.fieldCount   = parser.parseUnsignedNumber(1);
  if (this.protocol41) {
    this.warningCount = parser.parseUnsignedNumber(2);
    this.serverStatus = parser.parseUnsignedNumber(2);
  }
};

EofPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, 0xfe);
  if (this.protocol41) {
    writer.writeUnsignedNumber(2, this.warningCount);
    writer.writeUnsignedNumber(2, this.serverStatus);
  }
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ErrorPacket.js":
/***/ ((module) => {

module.exports = ErrorPacket;
function ErrorPacket(options) {
  options = options || {};

  this.fieldCount     = options.fieldCount;
  this.errno          = options.errno;
  this.sqlStateMarker = options.sqlStateMarker;
  this.sqlState       = options.sqlState;
  this.message        = options.message;
}

ErrorPacket.prototype.parse = function(parser) {
  this.fieldCount = parser.parseUnsignedNumber(1);
  this.errno      = parser.parseUnsignedNumber(2);

  // sqlStateMarker ('#' = 0x23) indicates error packet format
  if (parser.peak() === 0x23) {
    this.sqlStateMarker = parser.parseString(1);
    this.sqlState       = parser.parseString(5);
  }

  this.message = parser.parsePacketTerminatedString();
};

ErrorPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, 0xff);
  writer.writeUnsignedNumber(2, this.errno);

  if (this.sqlStateMarker) {
    writer.writeString(this.sqlStateMarker);
    writer.writeString(this.sqlState);
  }

  writer.writeString(this.message);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/Field.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Types = __webpack_require__("./node_modules/mysql/lib/protocol/constants/types.js");

module.exports = Field;
function Field(options) {
  options = options || {};

  this.parser = options.parser;
  this.packet = options.packet;
  this.db     = options.packet.db;
  this.table  = options.packet.table;
  this.name   = options.packet.name;
  this.type   = Types[options.packet.type];
  this.length = options.packet.length;
}

Field.prototype.string = function () {
  return this.parser.parseLengthCodedString();
};

Field.prototype.buffer = function () {
  return this.parser.parseLengthCodedBuffer();
};

Field.prototype.geometry = function () {
  return this.parser.parseGeometryValue();
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/FieldPacket.js":
/***/ ((module) => {

module.exports = FieldPacket;
function FieldPacket(options) {
  options = options || {};

  this.catalog    = options.catalog;
  this.db         = options.db;
  this.table      = options.table;
  this.orgTable   = options.orgTable;
  this.name       = options.name;
  this.orgName    = options.orgName;
  this.charsetNr  = options.charsetNr;
  this.length     = options.length;
  this.type       = options.type;
  this.flags      = options.flags;
  this.decimals   = options.decimals;
  this.default    = options.default;
  this.zeroFill   = options.zeroFill;
  this.protocol41 = options.protocol41;
}

FieldPacket.prototype.parse = function(parser) {
  if (this.protocol41) {
    this.catalog     = parser.parseLengthCodedString();
    this.db          = parser.parseLengthCodedString();
    this.table       = parser.parseLengthCodedString();
    this.orgTable    = parser.parseLengthCodedString();
    this.name        = parser.parseLengthCodedString();
    this.orgName     = parser.parseLengthCodedString();

    if (parser.parseLengthCodedNumber() !== 0x0c) {
      var err  = new TypeError('Received invalid field length');
      err.code = 'PARSER_INVALID_FIELD_LENGTH';
      throw err;
    }

    this.charsetNr   = parser.parseUnsignedNumber(2);
    this.length      = parser.parseUnsignedNumber(4);
    this.type        = parser.parseUnsignedNumber(1);
    this.flags       = parser.parseUnsignedNumber(2);
    this.decimals    = parser.parseUnsignedNumber(1);

    var filler       = parser.parseBuffer(2);
    if (filler[0] !== 0x0 || filler[1] !== 0x0) {
      var err  = new TypeError('Received invalid filler');
      err.code = 'PARSER_INVALID_FILLER';
      throw err;
    }

    // parsed flags
    this.zeroFill    = (this.flags & 0x0040 ? true : false);

    if (parser.reachedPacketEnd()) {
      return;
    }

    this.default     = parser.parseLengthCodedString();
  } else {
    this.table       = parser.parseLengthCodedString();
    this.name        = parser.parseLengthCodedString();
    this.length      = parser.parseUnsignedNumber(parser.parseUnsignedNumber(1));
    this.type        = parser.parseUnsignedNumber(parser.parseUnsignedNumber(1));
  }
};

FieldPacket.prototype.write = function(writer) {
  if (this.protocol41) {
    writer.writeLengthCodedString(this.catalog);
    writer.writeLengthCodedString(this.db);
    writer.writeLengthCodedString(this.table);
    writer.writeLengthCodedString(this.orgTable);
    writer.writeLengthCodedString(this.name);
    writer.writeLengthCodedString(this.orgName);

    writer.writeLengthCodedNumber(0x0c);
    writer.writeUnsignedNumber(2, this.charsetNr || 0);
    writer.writeUnsignedNumber(4, this.length || 0);
    writer.writeUnsignedNumber(1, this.type || 0);
    writer.writeUnsignedNumber(2, this.flags || 0);
    writer.writeUnsignedNumber(1, this.decimals || 0);
    writer.writeFiller(2);

    if (this.default !== undefined) {
      writer.writeLengthCodedString(this.default);
    }
  } else {
    writer.writeLengthCodedString(this.table);
    writer.writeLengthCodedString(this.name);
    writer.writeUnsignedNumber(1, 0x01);
    writer.writeUnsignedNumber(1, this.length);
    writer.writeUnsignedNumber(1, 0x01);
    writer.writeUnsignedNumber(1, this.type);
  }
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/HandshakeInitializationPacket.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
var Client = __webpack_require__("./node_modules/mysql/lib/protocol/constants/client.js");

module.exports = HandshakeInitializationPacket;
function HandshakeInitializationPacket(options) {
  options = options || {};

  this.protocolVersion     = options.protocolVersion;
  this.serverVersion       = options.serverVersion;
  this.threadId            = options.threadId;
  this.scrambleBuff1       = options.scrambleBuff1;
  this.filler1             = options.filler1;
  this.serverCapabilities1 = options.serverCapabilities1;
  this.serverLanguage      = options.serverLanguage;
  this.serverStatus        = options.serverStatus;
  this.serverCapabilities2 = options.serverCapabilities2;
  this.scrambleLength      = options.scrambleLength;
  this.filler2             = options.filler2;
  this.scrambleBuff2       = options.scrambleBuff2;
  this.filler3             = options.filler3;
  this.pluginData          = options.pluginData;
  this.protocol41          = options.protocol41;

  if (this.protocol41) {
    // force set the bit in serverCapabilities1
    this.serverCapabilities1 |= Client.CLIENT_PROTOCOL_41;
  }
}

HandshakeInitializationPacket.prototype.parse = function(parser) {
  this.protocolVersion     = parser.parseUnsignedNumber(1);
  this.serverVersion       = parser.parseNullTerminatedString();
  this.threadId            = parser.parseUnsignedNumber(4);
  this.scrambleBuff1       = parser.parseBuffer(8);
  this.filler1             = parser.parseFiller(1);
  this.serverCapabilities1 = parser.parseUnsignedNumber(2);
  this.serverLanguage      = parser.parseUnsignedNumber(1);
  this.serverStatus        = parser.parseUnsignedNumber(2);

  this.protocol41          = (this.serverCapabilities1 & (1 << 9)) > 0;

  if (this.protocol41) {
    this.serverCapabilities2 = parser.parseUnsignedNumber(2);
    this.scrambleLength      = parser.parseUnsignedNumber(1);
    this.filler2             = parser.parseFiller(10);
    // scrambleBuff2 should be 0x00 terminated, but sphinx does not do this
    // so we assume scrambleBuff2 to be 12 byte and treat the next byte as a
    // filler byte.
    this.scrambleBuff2       = parser.parseBuffer(12);
    this.filler3             = parser.parseFiller(1);
  } else {
    this.filler2             = parser.parseFiller(13);
  }

  if (parser.reachedPacketEnd()) {
    return;
  }

  // According to the docs this should be 0x00 terminated, but MariaDB does
  // not do this, so we assume this string to be packet terminated.
  this.pluginData = parser.parsePacketTerminatedString();

  // However, if there is a trailing '\0', strip it
  var lastChar = this.pluginData.length - 1;
  if (this.pluginData[lastChar] === '\0') {
    this.pluginData = this.pluginData.substr(0, lastChar);
  }
};

HandshakeInitializationPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, this.protocolVersion);
  writer.writeNullTerminatedString(this.serverVersion);
  writer.writeUnsignedNumber(4, this.threadId);
  writer.writeBuffer(this.scrambleBuff1);
  writer.writeFiller(1);
  writer.writeUnsignedNumber(2, this.serverCapabilities1);
  writer.writeUnsignedNumber(1, this.serverLanguage);
  writer.writeUnsignedNumber(2, this.serverStatus);
  if (this.protocol41) {
    writer.writeUnsignedNumber(2, this.serverCapabilities2);
    writer.writeUnsignedNumber(1, this.scrambleLength);
    writer.writeFiller(10);
  }
  writer.writeNullTerminatedBuffer(this.scrambleBuff2);

  if (this.pluginData !== undefined) {
    writer.writeNullTerminatedString(this.pluginData);
  }
};

HandshakeInitializationPacket.prototype.scrambleBuff = function() {
  var buffer = null;

  if (typeof this.scrambleBuff2 === 'undefined') {
    buffer = Buffer.from(this.scrambleBuff1);
  } else {
    buffer = Buffer.allocUnsafe(this.scrambleBuff1.length + this.scrambleBuff2.length);
    this.scrambleBuff1.copy(buffer, 0);
    this.scrambleBuff2.copy(buffer, this.scrambleBuff1.length);
  }

  return buffer;
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/LocalDataFilePacket.js":
/***/ ((module) => {

module.exports = LocalDataFilePacket;

/**
 * Create a new LocalDataFilePacket
 * @constructor
 * @param {Buffer} data The data contents of the packet
 * @public
 */
function LocalDataFilePacket(data) {
  this.data = data;
}

LocalDataFilePacket.prototype.write = function(writer) {
  writer.writeBuffer(this.data);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/LocalInfileRequestPacket.js":
/***/ ((module) => {

module.exports = LocalInfileRequestPacket;
function LocalInfileRequestPacket(options) {
  options = options || {};

  this.filename = options.filename;
}

LocalInfileRequestPacket.prototype.parse = function parse(parser) {
  if (parser.parseLengthCodedNumber() !== null) {
    var err  = new TypeError('Received invalid field length');
    err.code = 'PARSER_INVALID_FIELD_LENGTH';
    throw err;
  }

  this.filename = parser.parsePacketTerminatedString();
};

LocalInfileRequestPacket.prototype.write = function write(writer) {
  writer.writeLengthCodedNumber(null);
  writer.writeString(this.filename);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/OkPacket.js":
/***/ ((module) => {


// Language-neutral expression to match ER_UPDATE_INFO
var ER_UPDATE_INFO_REGEXP = /^[^:0-9]+: [0-9]+[^:0-9]+: ([0-9]+)[^:0-9]+: [0-9]+[^:0-9]*$/;

module.exports = OkPacket;
function OkPacket(options) {
  options = options || {};

  this.fieldCount   = undefined;
  this.affectedRows = undefined;
  this.insertId     = undefined;
  this.serverStatus = undefined;
  this.warningCount = undefined;
  this.message      = undefined;
  this.protocol41   = options.protocol41;
}

OkPacket.prototype.parse = function(parser) {
  this.fieldCount   = parser.parseUnsignedNumber(1);
  this.affectedRows = parser.parseLengthCodedNumber();
  this.insertId     = parser.parseLengthCodedNumber();
  if (this.protocol41) {
    this.serverStatus = parser.parseUnsignedNumber(2);
    this.warningCount = parser.parseUnsignedNumber(2);
  }
  this.message      = parser.parsePacketTerminatedString();
  this.changedRows  = 0;

  var m = ER_UPDATE_INFO_REGEXP.exec(this.message);
  if (m !== null) {
    this.changedRows = parseInt(m[1], 10);
  }
};

OkPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, 0x00);
  writer.writeLengthCodedNumber(this.affectedRows || 0);
  writer.writeLengthCodedNumber(this.insertId || 0);
  if (this.protocol41) {
    writer.writeUnsignedNumber(2, this.serverStatus || 0);
    writer.writeUnsignedNumber(2, this.warningCount || 0);
  }
  writer.writeString(this.message);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/OldPasswordPacket.js":
/***/ ((module) => {

module.exports = OldPasswordPacket;
function OldPasswordPacket(options) {
  options = options || {};

  this.scrambleBuff = options.scrambleBuff;
}

OldPasswordPacket.prototype.parse = function(parser) {
  this.scrambleBuff = parser.parsePacketTerminatedBuffer();
};

OldPasswordPacket.prototype.write = function(writer) {
  writer.writeBuffer(this.scrambleBuff);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/ResultSetHeaderPacket.js":
/***/ ((module) => {

module.exports = ResultSetHeaderPacket;
function ResultSetHeaderPacket(options) {
  options = options || {};

  this.fieldCount = options.fieldCount;
}

ResultSetHeaderPacket.prototype.parse = function(parser) {
  this.fieldCount = parser.parseLengthCodedNumber();
};

ResultSetHeaderPacket.prototype.write = function(writer) {
  writer.writeLengthCodedNumber(this.fieldCount);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/RowDataPacket.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Types                        = __webpack_require__("./node_modules/mysql/lib/protocol/constants/types.js");
var Charsets                     = __webpack_require__("./node_modules/mysql/lib/protocol/constants/charsets.js");
var Field                        = __webpack_require__("./node_modules/mysql/lib/protocol/packets/Field.js");
var IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);

module.exports = RowDataPacket;
function RowDataPacket() {
}

Object.defineProperty(RowDataPacket.prototype, 'parse', {
  configurable : true,
  enumerable   : false,
  value        : parse
});

Object.defineProperty(RowDataPacket.prototype, '_typeCast', {
  configurable : true,
  enumerable   : false,
  value        : typeCast
});

function parse(parser, fieldPackets, typeCast, nestTables, connection) {
  var self = this;
  var next = function () {
    return self._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings);
  };

  for (var i = 0; i < fieldPackets.length; i++) {
    var fieldPacket = fieldPackets[i];
    var value;

    if (typeof typeCast === 'function') {
      value = typeCast.apply(connection, [ new Field({ packet: fieldPacket, parser: parser }), next ]);
    } else {
      value = (typeCast)
        ? this._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings)
        : ( (fieldPacket.charsetNr === Charsets.BINARY)
          ? parser.parseLengthCodedBuffer()
          : parser.parseLengthCodedString() );
    }

    if (typeof nestTables === 'string' && nestTables.length) {
      this[fieldPacket.table + nestTables + fieldPacket.name] = value;
    } else if (nestTables) {
      this[fieldPacket.table] = this[fieldPacket.table] || {};
      this[fieldPacket.table][fieldPacket.name] = value;
    } else {
      this[fieldPacket.name] = value;
    }
  }
}

function typeCast(field, parser, timeZone, supportBigNumbers, bigNumberStrings, dateStrings) {
  var numberString;

  switch (field.type) {
    case Types.TIMESTAMP:
    case Types.TIMESTAMP2:
    case Types.DATE:
    case Types.DATETIME:
    case Types.DATETIME2:
    case Types.NEWDATE:
      var dateString = parser.parseLengthCodedString();

      if (typeMatch(field.type, dateStrings)) {
        return dateString;
      }

      if (dateString === null) {
        return null;
      }

      var originalString = dateString;
      if (field.type === Types.DATE) {
        dateString += ' 00:00:00';
      }

      if (timeZone !== 'local') {
        dateString += ' ' + timeZone;
      }

      var dt = new Date(dateString);
      if (isNaN(dt.getTime())) {
        return originalString;
      }

      return dt;
    case Types.TINY:
    case Types.SHORT:
    case Types.LONG:
    case Types.INT24:
    case Types.YEAR:
    case Types.FLOAT:
    case Types.DOUBLE:
      numberString = parser.parseLengthCodedString();
      return (numberString === null || (field.zeroFill && numberString[0] === '0'))
        ? numberString : Number(numberString);
    case Types.NEWDECIMAL:
    case Types.LONGLONG:
      numberString = parser.parseLengthCodedString();
      return (numberString === null || (field.zeroFill && numberString[0] === '0'))
        ? numberString
        : ((supportBigNumbers && (bigNumberStrings || (Number(numberString) >= IEEE_754_BINARY_64_PRECISION) || Number(numberString) <= -IEEE_754_BINARY_64_PRECISION))
          ? numberString
          : Number(numberString));
    case Types.BIT:
      return parser.parseLengthCodedBuffer();
    case Types.STRING:
    case Types.VAR_STRING:
    case Types.TINY_BLOB:
    case Types.MEDIUM_BLOB:
    case Types.LONG_BLOB:
    case Types.BLOB:
      return (field.charsetNr === Charsets.BINARY)
        ? parser.parseLengthCodedBuffer()
        : parser.parseLengthCodedString();
    case Types.GEOMETRY:
      return parser.parseGeometryValue();
    default:
      return parser.parseLengthCodedString();
  }
}

function typeMatch(type, list) {
  if (Array.isArray(list)) {
    return list.indexOf(Types[type]) !== -1;
  } else {
    return Boolean(list);
  }
}


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/SSLRequestPacket.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// http://dev.mysql.com/doc/internals/en/ssl.html
// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::SSLRequest

var ClientConstants = __webpack_require__("./node_modules/mysql/lib/protocol/constants/client.js");

module.exports = SSLRequestPacket;

function SSLRequestPacket(options) {
  options = options || {};
  this.clientFlags   = options.clientFlags | ClientConstants.CLIENT_SSL;
  this.maxPacketSize = options.maxPacketSize;
  this.charsetNumber = options.charsetNumber;
}

SSLRequestPacket.prototype.parse = function(parser) {
  // TODO: check SSLRequest packet v41 vs pre v41
  this.clientFlags   = parser.parseUnsignedNumber(4);
  this.maxPacketSize = parser.parseUnsignedNumber(4);
  this.charsetNumber = parser.parseUnsignedNumber(1);
};

SSLRequestPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(4, this.clientFlags);
  writer.writeUnsignedNumber(4, this.maxPacketSize);
  writer.writeUnsignedNumber(1, this.charsetNumber);
  writer.writeFiller(23);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/StatisticsPacket.js":
/***/ ((module) => {

module.exports = StatisticsPacket;
function StatisticsPacket() {
  this.message      = undefined;
}

StatisticsPacket.prototype.parse = function(parser) {
  this.message      = parser.parsePacketTerminatedString();

  var items = this.message.split(/\s\s/);
  for (var i = 0; i < items.length; i++) {
    var m = items[i].match(/^(.+)\:\s+(.+)$/);
    if (m !== null) {
      this[m[1].toLowerCase().replace(/\s/g, '_')] = Number(m[2]);
    }
  }
};

StatisticsPacket.prototype.write = function(writer) {
  writer.writeString(this.message);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/UseOldPasswordPacket.js":
/***/ ((module) => {

module.exports = UseOldPasswordPacket;
function UseOldPasswordPacket(options) {
  options = options || {};

  this.firstByte = options.firstByte || 0xfe;
}

UseOldPasswordPacket.prototype.parse = function(parser) {
  this.firstByte = parser.parseUnsignedNumber(1);
};

UseOldPasswordPacket.prototype.write = function(writer) {
  writer.writeUnsignedNumber(1, this.firstByte);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/packets/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.AuthSwitchRequestPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/AuthSwitchRequestPacket.js");
exports.AuthSwitchResponsePacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/AuthSwitchResponsePacket.js");
exports.ClientAuthenticationPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ClientAuthenticationPacket.js");
exports.ComChangeUserPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ComChangeUserPacket.js");
exports.ComPingPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ComPingPacket.js");
exports.ComQueryPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ComQueryPacket.js");
exports.ComQuitPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ComQuitPacket.js");
exports.ComStatisticsPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ComStatisticsPacket.js");
exports.EmptyPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/EmptyPacket.js");
exports.EofPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/EofPacket.js");
exports.ErrorPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ErrorPacket.js");
exports.Field = __webpack_require__("./node_modules/mysql/lib/protocol/packets/Field.js");
exports.FieldPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/FieldPacket.js");
exports.HandshakeInitializationPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/HandshakeInitializationPacket.js");
exports.LocalDataFilePacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/LocalDataFilePacket.js");
exports.LocalInfileRequestPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/LocalInfileRequestPacket.js");
exports.OkPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/OkPacket.js");
exports.OldPasswordPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/OldPasswordPacket.js");
exports.ResultSetHeaderPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/ResultSetHeaderPacket.js");
exports.RowDataPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/RowDataPacket.js");
exports.SSLRequestPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/SSLRequestPacket.js");
exports.StatisticsPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/StatisticsPacket.js");
exports.UseOldPasswordPacket = __webpack_require__("./node_modules/mysql/lib/protocol/packets/UseOldPasswordPacket.js");


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/ChangeUser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Sequence = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
var Util     = __webpack_require__("util");
var Packets  = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");
var Auth     = __webpack_require__("./node_modules/mysql/lib/protocol/Auth.js");

module.exports = ChangeUser;
Util.inherits(ChangeUser, Sequence);
function ChangeUser(options, callback) {
  Sequence.call(this, options, callback);

  this._user          = options.user;
  this._password      = options.password;
  this._database      = options.database;
  this._charsetNumber = options.charsetNumber;
  this._currentConfig = options.currentConfig;
}

ChangeUser.prototype.determinePacket = function determinePacket(firstByte) {
  switch (firstByte) {
    case 0xfe: return Packets.AuthSwitchRequestPacket;
    case 0xff: return Packets.ErrorPacket;
    default: return undefined;
  }
};

ChangeUser.prototype.start = function(handshakeInitializationPacket) {
  var scrambleBuff = handshakeInitializationPacket.scrambleBuff();
  scrambleBuff     = Auth.token(this._password, scrambleBuff);

  var packet = new Packets.ComChangeUserPacket({
    user          : this._user,
    scrambleBuff  : scrambleBuff,
    database      : this._database,
    charsetNumber : this._charsetNumber
  });

  this._currentConfig.user          = this._user;
  this._currentConfig.password      = this._password;
  this._currentConfig.database      = this._database;
  this._currentConfig.charsetNumber = this._charsetNumber;

  this.emit('packet', packet);
};

ChangeUser.prototype['AuthSwitchRequestPacket'] = function (packet) {
  var name = packet.authMethodName;
  var data = Auth.auth(name, packet.authMethodData, {
    password: this._password
  });

  if (data !== undefined) {
    this.emit('packet', new Packets.AuthSwitchResponsePacket({
      data: data
    }));
  } else {
    var err   = new Error('MySQL is requesting the ' + name + ' authentication method, which is not supported.');
    err.code  = 'UNSUPPORTED_AUTH_METHOD';
    err.fatal = true;
    this.end(err);
  }
};

ChangeUser.prototype['ErrorPacket'] = function(packet) {
  var err = this._packetToError(packet);
  err.fatal = true;
  this.end(err);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/Handshake.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Sequence        = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
var Util            = __webpack_require__("util");
var Packets         = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");
var Auth            = __webpack_require__("./node_modules/mysql/lib/protocol/Auth.js");
var ClientConstants = __webpack_require__("./node_modules/mysql/lib/protocol/constants/client.js");

module.exports = Handshake;
Util.inherits(Handshake, Sequence);
function Handshake(options, callback) {
  Sequence.call(this, options, callback);

  options = options || {};

  this._config                        = options.config;
  this._handshakeInitializationPacket = null;
}

Handshake.prototype.determinePacket = function determinePacket(firstByte, parser) {
  if (firstByte === 0xff) {
    return Packets.ErrorPacket;
  }

  if (!this._handshakeInitializationPacket) {
    return Packets.HandshakeInitializationPacket;
  }

  if (firstByte === 0xfe) {
    return (parser.packetLength() === 1)
      ? Packets.UseOldPasswordPacket
      : Packets.AuthSwitchRequestPacket;
  }

  return undefined;
};

Handshake.prototype['AuthSwitchRequestPacket'] = function (packet) {
  var name = packet.authMethodName;
  var data = Auth.auth(name, packet.authMethodData, {
    password: this._config.password
  });

  if (data !== undefined) {
    this.emit('packet', new Packets.AuthSwitchResponsePacket({
      data: data
    }));
  } else {
    var err   = new Error('MySQL is requesting the ' + name + ' authentication method, which is not supported.');
    err.code  = 'UNSUPPORTED_AUTH_METHOD';
    err.fatal = true;
    this.end(err);
  }
};

Handshake.prototype['HandshakeInitializationPacket'] = function(packet) {
  this._handshakeInitializationPacket = packet;

  this._config.protocol41 = packet.protocol41;

  var serverSSLSupport = packet.serverCapabilities1 & ClientConstants.CLIENT_SSL;

  if (this._config.ssl) {
    if (!serverSSLSupport) {
      var err = new Error('Server does not support secure connection');

      err.code = 'HANDSHAKE_NO_SSL_SUPPORT';
      err.fatal = true;

      this.end(err);
      return;
    }

    this._config.clientFlags |= ClientConstants.CLIENT_SSL;
    this.emit('packet', new Packets.SSLRequestPacket({
      clientFlags   : this._config.clientFlags,
      maxPacketSize : this._config.maxPacketSize,
      charsetNumber : this._config.charsetNumber
    }));
    this.emit('start-tls');
  } else {
    this._sendCredentials();
  }
};

Handshake.prototype._tlsUpgradeCompleteHandler = function() {
  this._sendCredentials();
};

Handshake.prototype._sendCredentials = function() {
  var packet = this._handshakeInitializationPacket;
  this.emit('packet', new Packets.ClientAuthenticationPacket({
    clientFlags   : this._config.clientFlags,
    maxPacketSize : this._config.maxPacketSize,
    charsetNumber : this._config.charsetNumber,
    user          : this._config.user,
    database      : this._config.database,
    protocol41    : packet.protocol41,
    scrambleBuff  : (packet.protocol41)
      ? Auth.token(this._config.password, packet.scrambleBuff())
      : Auth.scramble323(packet.scrambleBuff(), this._config.password)
  }));
};

Handshake.prototype['UseOldPasswordPacket'] = function() {
  if (!this._config.insecureAuth) {
    var err = new Error(
      'MySQL server is requesting the old and insecure pre-4.1 auth mechanism. ' +
      'Upgrade the user password or use the {insecureAuth: true} option.'
    );

    err.code = 'HANDSHAKE_INSECURE_AUTH';
    err.fatal = true;

    this.end(err);
    return;
  }

  this.emit('packet', new Packets.OldPasswordPacket({
    scrambleBuff: Auth.scramble323(this._handshakeInitializationPacket.scrambleBuff(), this._config.password)
  }));
};

Handshake.prototype['ErrorPacket'] = function(packet) {
  var err = this._packetToError(packet, true);
  err.fatal = true;
  this.end(err);
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/Ping.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Sequence = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
var Util     = __webpack_require__("util");
var Packets  = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");

module.exports = Ping;
Util.inherits(Ping, Sequence);

function Ping(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  Sequence.call(this, options, callback);
}

Ping.prototype.start = function() {
  this.emit('packet', new Packets.ComPingPacket());
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/Query.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ClientConstants = __webpack_require__("./node_modules/mysql/lib/protocol/constants/client.js");
var fs              = __webpack_require__("fs");
var Packets         = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");
var ResultSet       = __webpack_require__("./node_modules/mysql/lib/protocol/ResultSet.js");
var Sequence        = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
var ServerStatus    = __webpack_require__("./node_modules/mysql/lib/protocol/constants/server_status.js");
var Readable        = __webpack_require__("./node_modules/readable-stream/readable.js");
var Util            = __webpack_require__("util");

module.exports = Query;
Util.inherits(Query, Sequence);
function Query(options, callback) {
  Sequence.call(this, options, callback);

  this.sql = options.sql;
  this.values = options.values;
  this.typeCast = (options.typeCast === undefined)
    ? true
    : options.typeCast;
  this.nestTables = options.nestTables || false;

  this._resultSet = null;
  this._results   = [];
  this._fields    = [];
  this._index     = 0;
  this._loadError = null;
}

Query.prototype.start = function() {
  this.emit('packet', new Packets.ComQueryPacket(this.sql));
};

Query.prototype.determinePacket = function determinePacket(byte, parser) {
  var resultSet = this._resultSet;

  if (!resultSet) {
    switch (byte) {
      case 0x00: return Packets.OkPacket;
      case 0xfb: return Packets.LocalInfileRequestPacket;
      case 0xff: return Packets.ErrorPacket;
      default:   return Packets.ResultSetHeaderPacket;
    }
  }

  if (resultSet.eofPackets.length === 0) {
    return (resultSet.fieldPackets.length < resultSet.resultSetHeaderPacket.fieldCount)
      ? Packets.FieldPacket
      : Packets.EofPacket;
  }

  if (byte === 0xff) {
    return Packets.ErrorPacket;
  }

  if (byte === 0xfe && parser.packetLength() < 9) {
    return Packets.EofPacket;
  }

  return Packets.RowDataPacket;
};

Query.prototype['OkPacket'] = function(packet) {
  // try...finally for exception safety
  try {
    if (!this._callback) {
      this.emit('result', packet, this._index);
    } else {
      this._results.push(packet);
      this._fields.push(undefined);
    }
  } finally {
    this._index++;
    this._resultSet = null;
    this._handleFinalResultPacket(packet);
  }
};

Query.prototype['ErrorPacket'] = function(packet) {
  var err = this._packetToError(packet);

  var results = (this._results.length > 0)
    ? this._results
    : undefined;

  var fields = (this._fields.length > 0)
    ? this._fields
    : undefined;

  err.index = this._index;
  err.sql   = this.sql;

  this.end(err, results, fields);
};

Query.prototype['LocalInfileRequestPacket'] = function(packet) {
  if (this._connection.config.clientFlags & ClientConstants.CLIENT_LOCAL_FILES) {
    this._sendLocalDataFile(packet.filename);
  } else {
    this._loadError       = new Error('Load local files command is disabled');
    this._loadError.code  = 'LOCAL_FILES_DISABLED';
    this._loadError.fatal = false;

    this.emit('packet', new Packets.EmptyPacket());
  }
};

Query.prototype['ResultSetHeaderPacket'] = function(packet) {
  this._resultSet = new ResultSet(packet);
};

Query.prototype['FieldPacket'] = function(packet) {
  this._resultSet.fieldPackets.push(packet);
};

Query.prototype['EofPacket'] = function(packet) {
  this._resultSet.eofPackets.push(packet);

  if (this._resultSet.eofPackets.length === 1 && !this._callback) {
    this.emit('fields', this._resultSet.fieldPackets, this._index);
  }

  if (this._resultSet.eofPackets.length !== 2) {
    return;
  }

  if (this._callback) {
    this._results.push(this._resultSet.rows);
    this._fields.push(this._resultSet.fieldPackets);
  }

  this._index++;
  this._resultSet = null;
  this._handleFinalResultPacket(packet);
};

Query.prototype._handleFinalResultPacket = function(packet) {
  if (packet.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
    return;
  }

  var results = (this._results.length > 1)
    ? this._results
    : this._results[0];

  var fields = (this._fields.length > 1)
    ? this._fields
    : this._fields[0];

  this.end(this._loadError, results, fields);
};

Query.prototype['RowDataPacket'] = function(packet, parser, connection) {
  packet.parse(parser, this._resultSet.fieldPackets, this.typeCast, this.nestTables, connection);

  if (this._callback) {
    this._resultSet.rows.push(packet);
  } else {
    this.emit('result', packet, this._index);
  }
};

Query.prototype._sendLocalDataFile = function(path) {
  var self = this;
  var localStream = fs.createReadStream(path, {
    flag      : 'r',
    encoding  : null,
    autoClose : true
  });

  this.on('pause', function () {
    localStream.pause();
  });

  this.on('resume', function () {
    localStream.resume();
  });

  localStream.on('data', function (data) {
    self.emit('packet', new Packets.LocalDataFilePacket(data));
  });

  localStream.on('error', function (err) {
    self._loadError = err;
    localStream.emit('end');
  });

  localStream.on('end', function () {
    self.emit('packet', new Packets.EmptyPacket());
  });
};

Query.prototype.stream = function(options) {
  var self = this;

  options = options || {};
  options.objectMode = true;

  var stream = new Readable(options);

  stream._read = function() {
    self._connection && self._connection.resume();
  };

  stream.once('end', function() {
    process.nextTick(function () {
      stream.emit('close');
    });
  });

  this.on('result', function(row, i) {
    if (!stream.push(row)) self._connection.pause();
    stream.emit('result', row, i);  // replicate old emitter
  });

  this.on('error', function(err) {
    stream.emit('error', err);  // Pass on any errors
  });

  this.on('end', function() {
    stream.push(null);  // pushing null, indicating EOF
  });

  this.on('fields', function(fields, i) {
    stream.emit('fields', fields, i);  // replicate old emitter
  });

  return stream;
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/Quit.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Sequence = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
var Util     = __webpack_require__("util");
var Packets  = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");

module.exports = Quit;
Util.inherits(Quit, Sequence);
function Quit(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  Sequence.call(this, options, callback);

  this._started = false;
}

Quit.prototype.end = function end(err) {
  if (this._ended) {
    return;
  }

  if (!this._started) {
    Sequence.prototype.end.call(this, err);
    return;
  }

  if (err && err.code === 'ECONNRESET' && err.syscall === 'read') {
    // Ignore read errors after packet sent
    Sequence.prototype.end.call(this);
    return;
  }

  Sequence.prototype.end.call(this, err);
};

Quit.prototype.start = function() {
  this._started = true;
  this.emit('packet', new Packets.ComQuitPacket());
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/Sequence.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Util           = __webpack_require__("util");
var EventEmitter   = (__webpack_require__("events").EventEmitter);
var Packets        = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");
var ErrorConstants = __webpack_require__("./node_modules/mysql/lib/protocol/constants/errors.js");
var Timer          = __webpack_require__("./node_modules/mysql/lib/protocol/Timer.js");

// istanbul ignore next: Node.js < 0.10 not covered
var listenerCount = EventEmitter.listenerCount
  || function(emitter, type){ return emitter.listeners(type).length; };

var LONG_STACK_DELIMITER = '\n    --------------------\n';

module.exports = Sequence;
Util.inherits(Sequence, EventEmitter);
function Sequence(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  EventEmitter.call(this);

  options = options || {};

  this._callback = callback;
  this._callSite = null;
  this._ended    = false;
  this._timeout  = options.timeout;
  this._timer    = new Timer(this);
}

Sequence.determinePacket = function(byte) {
  switch (byte) {
    case 0x00: return Packets.OkPacket;
    case 0xfe: return Packets.EofPacket;
    case 0xff: return Packets.ErrorPacket;
    default:   return undefined;
  }
};

Sequence.prototype.hasErrorHandler = function() {
  return Boolean(this._callback) || listenerCount(this, 'error') > 1;
};

Sequence.prototype._packetToError = function(packet) {
  var code = ErrorConstants[packet.errno] || 'UNKNOWN_CODE_PLEASE_REPORT';
  var err  = new Error(code + ': ' + packet.message);
  err.code = code;
  err.errno = packet.errno;

  err.sqlMessage = packet.message;
  err.sqlState   = packet.sqlState;

  return err;
};

Sequence.prototype.end = function(err) {
  if (this._ended) {
    return;
  }

  this._ended = true;

  if (err) {
    this._addLongStackTrace(err);
  }

  // Without this we are leaking memory. This problem was introduced in
  // 8189925374e7ce3819bbe88b64c7b15abac96b16. I suspect that the error object
  // causes a cyclic reference that the GC does not detect properly, but I was
  // unable to produce a standalone version of this leak. This would be a great
  // challenge for somebody interested in difficult problems : )!
  this._callSite = null;

  // try...finally for exception safety
  try {
    if (err) {
      this.emit('error', err);
    }
  } finally {
    try {
      if (this._callback) {
        this._callback.apply(this, arguments);
      }
    } finally {
      this.emit('end');
    }
  }
};

Sequence.prototype['OkPacket'] = function(packet) {
  this.end(null, packet);
};

Sequence.prototype['ErrorPacket'] = function(packet) {
  this.end(this._packetToError(packet));
};

// Implemented by child classes
Sequence.prototype.start = function() {};

Sequence.prototype._addLongStackTrace = function _addLongStackTrace(err) {
  var callSiteStack = this._callSite && this._callSite.stack;

  if (!callSiteStack || typeof callSiteStack !== 'string') {
    // No recorded call site
    return;
  }

  if (err.stack.indexOf(LONG_STACK_DELIMITER) !== -1) {
    // Error stack already looks long
    return;
  }

  var index = callSiteStack.indexOf('\n');

  if (index !== -1) {
    // Append recorded call site
    err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);
  }
};

Sequence.prototype._onTimeout = function _onTimeout() {
  this.emit('timeout');
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/Statistics.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Sequence = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
var Util     = __webpack_require__("util");
var Packets  = __webpack_require__("./node_modules/mysql/lib/protocol/packets/index.js");

module.exports = Statistics;
Util.inherits(Statistics, Sequence);
function Statistics(options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = {};
  }

  Sequence.call(this, options, callback);
}

Statistics.prototype.start = function() {
  this.emit('packet', new Packets.ComStatisticsPacket());
};

Statistics.prototype['StatisticsPacket'] = function (packet) {
  this.end(null, packet);
};

Statistics.prototype.determinePacket = function determinePacket(firstByte) {
  if (firstByte === 0x55) {
    return Packets.StatisticsPacket;
  }

  return undefined;
};


/***/ }),

/***/ "./node_modules/mysql/lib/protocol/sequences/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.ChangeUser = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/ChangeUser.js");
exports.Handshake = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Handshake.js");
exports.Ping = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Ping.js");
exports.Query = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Query.js");
exports.Quit = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Quit.js");
exports.Sequence = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Sequence.js");
exports.Statistics = __webpack_require__("./node_modules/mysql/lib/protocol/sequences/Statistics.js");


/***/ }),

/***/ "./node_modules/knex/lib/dialects/index.js":
/***/ (() => {



/***/ }),

/***/ "./node_modules/knex/lib/migrations/migrate/Migrator.js":
/***/ (() => {



/***/ }),

/***/ "./node_modules/knex/lib/migrations/seed/Seeder.js":
/***/ (() => {



/***/ }),

/***/ "./node_modules/objection/lib/initialize.js":
/***/ ((module) => {

"use strict";


async function initialize(knex, modelClasses) {
  if (!modelClasses) {
    modelClasses = knex;
    knex = modelClasses[0].knex();
  }

  await Promise.all(modelClasses.map((modelClass) => modelClass.fetchTableMetadata({ knex })));
}

module.exports = {
  initialize,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/AjvValidator.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Ajv = __webpack_require__("./node_modules/ajv/dist/ajv.js");
const addFormats = __webpack_require__("./node_modules/ajv-formats/dist/index.js");
const { Validator } = __webpack_require__("./node_modules/objection/lib/model/Validator.js");
const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { isObject, once, cloneDeep: lodashCloneDeep, omit } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class AjvValidator extends Validator {
  static init(self, conf) {
    super.init(self, conf);

    self.ajvOptions = Object.assign({}, conf.options, {
      allErrors: true,
    });

    // Create a normal Ajv instance.
    self.ajv = new Ajv(
      Object.assign(
        {
          useDefaults: true,
        },
        self.ajvOptions,
      ),
    );

    // Create an instance that doesn't set default values. We need this one
    // to validate `patch` objects (objects that have a subset of properties).
    self.ajvNoDefaults = new Ajv(
      Object.assign({}, self.ajvOptions, {
        useDefaults: false,
      }),
    );

    // A cache for the compiled validator functions.
    self.cache = new Map();

    const setupAjv = (ajv) => {
      if (conf.onCreateAjv) {
        conf.onCreateAjv(ajv);
      }
      // Only add Ajv formats if they weren't added in user-space already
      if (!ajv.formats['date-time']) {
        addFormats(ajv);
      }
    };

    setupAjv(self.ajv);
    setupAjv(self.ajvNoDefaults);
  }

  beforeValidate({ json, model, options, ctx }) {
    ctx.jsonSchema = model.constructor.getJsonSchema();

    // Objection model's have a `$beforeValidate` hook that is allowed to modify the schema.
    // We need to clone the schema in case the function modifies it. We only do this in the
    // rare case that the given model has implemented the hook.
    if (model.$beforeValidate !== model.$objectionModelClass.prototype.$beforeValidate) {
      ctx.jsonSchema = cloneDeep(ctx.jsonSchema);
      const ret = model.$beforeValidate(ctx.jsonSchema, json, options);

      if (ret !== undefined) {
        ctx.jsonSchema = ret;
      }
    }
  }

  validate({ json, model, options, ctx }) {
    if (!ctx.jsonSchema) {
      return json;
    }

    const modelClass = model.constructor;
    const validator = this.getValidator(modelClass, ctx.jsonSchema, !!options.patch);

    // We need to clone the input json if we are about to set default values.
    if (!options.mutable && !options.patch && setsDefaultValues(ctx.jsonSchema)) {
      json = cloneDeep(json);
    }

    validator.call(model, json);
    const error = parseValidationError(validator.errors, modelClass, options, this.ajvOptions);

    if (error) {
      throw error;
    }

    return json;
  }

  getValidator(modelClass, jsonSchema, isPatchObject) {
    // Use the Ajv custom serializer if provided.
    const createCacheKey = this.ajvOptions.serialize || JSON.stringify;

    // Optimization for the common case where jsonSchema is never modified.
    // In that case we don't need to call the costly createCacheKey function.
    const cacheKey =
      jsonSchema === modelClass.getJsonSchema()
        ? modelClass.uniqueTag()
        : createCacheKey(jsonSchema);

    let validators = this.cache.get(cacheKey);
    let validator = null;

    if (!validators) {
      validators = {
        // Validator created for the schema object without `required` properties
        // using the Ajv instance that doesn't set default values.
        patchValidator: null,

        // Validator created for the unmodified schema.
        normalValidator: null,
      };

      this.cache.set(cacheKey, validators);
    }

    if (isPatchObject) {
      validator = validators.patchValidator;

      if (!validator) {
        validator = this.compilePatchValidator(jsonSchema);
        validators.patchValidator = validator;
      }
    } else {
      validator = validators.normalValidator;

      if (!validator) {
        validator = this.compileNormalValidator(jsonSchema);
        validators.normalValidator = validator;
      }
    }

    return validator;
  }

  compilePatchValidator(jsonSchema) {
    jsonSchema = jsonSchemaWithoutRequired(jsonSchema);
    // We need to use the ajv instance that doesn't set the default values.
    return this.ajvNoDefaults.compile(jsonSchema);
  }

  compileNormalValidator(jsonSchema) {
    return this.ajv.compile(jsonSchema);
  }
}

function parseValidationError(errors, modelClass, options, ajvOptions) {
  if (!errors) {
    return null;
  }

  let relationNames = modelClass.getRelationNames();
  let errorHash = {};
  let numErrors = 0;

  for (const error of errors) {
    // If additionalProperties = false, relations can pop up as additionalProperty
    // errors. Skip those.
    if (
      error.params &&
      error.params.additionalProperty &&
      relationNames.includes(error.params.additionalProperty)
    ) {
      continue;
    }

    let path = error.instancePath.replace(/\//g, '.');

    if (error.params) {
      if (error.params.missingProperty) {
        path += `.${error.params.missingProperty}`;
      } else if (error.params.additionalProperty) {
        path += `.${error.params.additionalProperty}`;
      }
    }

    const key = `${options.dataPath || ''}${path}`.substring(1);

    // More than one error can occur for the same key in Ajv, merge them in the array:
    const array = errorHash[key] || (errorHash[key] = []);

    // Prepare error object
    const errorObj = {
      message: error.message,
      keyword: error.keyword,
      params: error.params,
    };

    // Add data if verbose enabled
    if (ajvOptions.verbose) {
      errorObj.data = error.data;
    }

    // Use unshift instead of push so that the last error ends up at [0],
    // preserving previous behavior where only the last error was stored.
    array.unshift(errorObj);

    ++numErrors;
  }

  if (numErrors === 0) {
    return null;
  }

  return modelClass.createValidationError({
    type: ValidationErrorType.ModelValidation,
    data: errorHash,
  });
}

function cloneDeep(obj) {
  if (isObject(obj) && obj.$isObjectionModel) {
    return obj.$clone();
  } else {
    return lodashCloneDeep(obj);
  }
}

function setsDefaultValues(jsonSchema) {
  return jsonSchema && jsonSchema.properties && hasDefaults(jsonSchema.properties);
}

function hasDefaults(obj) {
  if (Array.isArray(obj)) {
    return arrayHasDefaults(obj);
  } else {
    return objectHasDefaults(obj);
  }
}

function arrayHasDefaults(arr) {
  for (let i = 0, l = arr.length; i < l; ++i) {
    const val = arr[i];

    if (isObject(val) && hasDefaults(val)) {
      return true;
    }
  }

  return false;
}

function objectHasDefaults(obj) {
  const keys = Object.keys(obj);

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];

    if (key === 'default') {
      return true;
    } else {
      const val = obj[key];

      if (isObject(val) && hasDefaults(val)) {
        return true;
      }
    }
  }

  return false;
}

function jsonSchemaWithoutRequired(jsonSchema) {
  const subSchemaProps = ['anyOf', 'oneOf', 'allOf', 'not', 'then', 'else', 'properties'];
  return Object.assign(
    omit(jsonSchema, ['required', ...subSchemaProps]),
    ...subSchemaProps.map((prop) => subSchemaWithoutRequired(jsonSchema, prop)),
    jsonSchema && jsonSchema.definitions && Object.keys(jsonSchema.definitions).length > 0
      ? {
          definitions: Object.assign(
            ...Object.keys(jsonSchema.definitions).map((prop) => ({
              [prop]: jsonSchemaWithoutRequired(jsonSchema.definitions[prop]),
            })),
          ),
        }
      : {},
    jsonSchema.discriminator && jsonSchema.discriminator.propertyName
      ? { required: [jsonSchema.discriminator.propertyName] }
      : {},
  );
}

function subSchemaWithoutRequired(jsonSchema, prop) {
  if (jsonSchema[prop]) {
    if (Array.isArray(jsonSchema[prop])) {
      const schemaArray = jsonSchemaArrayWithoutRequired(jsonSchema[prop]);

      if (schemaArray.length !== 0) {
        return {
          [prop]: schemaArray,
        };
      } else {
        return {};
      }
    } else if (jsonSchema.type === 'object' && prop === 'properties') {
      return {
        [prop]: Object.fromEntries(
          Object.entries(jsonSchema[prop]).map(([key, schema]) => [
            key,
            jsonSchemaWithoutRequired(schema),
          ]),
        ),
      };
    } else {
      return {
        [prop]: jsonSchemaWithoutRequired(jsonSchema[prop]),
      };
    }
  } else {
    return {};
  }
}

function jsonSchemaArrayWithoutRequired(jsonSchemaArray) {
  return jsonSchemaArray.map(jsonSchemaWithoutRequired).filter(isNotEmptyObject);
}

function isNotEmptyObject(obj) {
  return Object.keys(obj).length !== 0;
}

module.exports = {
  AjvValidator,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/Model.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { clone } = __webpack_require__("./node_modules/objection/lib/model/modelClone.js");
const { bindKnex } = __webpack_require__("./node_modules/objection/lib/model/modelBindKnex.js");
const { validate } = __webpack_require__("./node_modules/objection/lib/model/modelValidate.js");
const { isMsSql } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { visitModels } = __webpack_require__("./node_modules/objection/lib/model/modelVisitor.js");
const { hasId, getSetId } = __webpack_require__("./node_modules/objection/lib/model/modelId.js");
const { map: promiseMap } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { toJson, toDatabaseJson } = __webpack_require__("./node_modules/objection/lib/model/modelToJson.js");
const { values, propKey, hasProps } = __webpack_require__("./node_modules/objection/lib/model/modelValues.js");
const { defineNonEnumerableProperty } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { parseRelationsIntoModelInstances } = __webpack_require__("./node_modules/objection/lib/model/modelParseRelations.js");
const { fetchTableMetadata, tableMetadata } = __webpack_require__("./node_modules/objection/lib/model/modelTableMetadata.js");
const { asArray, isFunction, isString, asSingle } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { setJson, setFast, setRelated, appendRelated, setDatabaseJson } = __webpack_require__("./node_modules/objection/lib/model/modelSet.js");
const {
  getJsonAttributes,
  parseJsonAttributes,
  formatJsonAttributes,
} = __webpack_require__("./node_modules/objection/lib/model/modelJsonAttributes.js");
const { columnNameToPropertyName, propertyNameToColumnName } = __webpack_require__("./node_modules/objection/lib/model/modelColPropMap.js");

const { raw } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RawBuilder.js");
const { ref } = __webpack_require__("./node_modules/objection/lib/queryBuilder/ReferenceBuilder.js");
const { fn } = __webpack_require__("./node_modules/objection/lib/queryBuilder/FunctionBuilder.js");

const { AjvValidator } = __webpack_require__("./node_modules/objection/lib/model/AjvValidator.js");
const { QueryBuilder } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilder.js");
const { NotFoundError } = __webpack_require__("./node_modules/objection/lib/model/NotFoundError.js");
const { ValidationError } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { ModifierNotFoundError } = __webpack_require__("./node_modules/objection/lib/model/ModifierNotFoundError.js");
const { RelationProperty } = __webpack_require__("./node_modules/objection/lib/relations/RelationProperty.js");
const { RelationOwner } = __webpack_require__("./node_modules/objection/lib/relations/RelationOwner.js");

const { HasOneRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasOne/HasOneRelation.js");
const { HasManyRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasMany/HasManyRelation.js");
const { ManyToManyRelation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyRelation.js");
const { BelongsToOneRelation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelation.js");
const { HasOneThroughRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasOneThrough/HasOneThroughRelation.js");

const { InstanceFindOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InstanceFindOperation.js");
const { InstanceInsertOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InstanceInsertOperation.js");
const { InstanceUpdateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InstanceUpdateOperation.js");
const { InstanceDeleteOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InstanceDeleteOperation.js");

class Model {
  get $modelClass() {
    return this.constructor;
  }

  $id(maybeId) {
    return getSetId(this, maybeId);
  }

  $hasId() {
    return hasId(this);
  }

  $hasProps(props) {
    return hasProps(this, props);
  }

  $query(trx) {
    return instanceQuery({
      instance: this,
      transaction: trx,
    });
  }

  $relatedQuery(relationName, trx) {
    return relatedQuery({
      modelClass: this.constructor,
      relationName,
      transaction: trx,
      alwaysReturnArray: false,
    }).for(this);
  }

  $fetchGraph(relationExpression, options) {
    return this.constructor.fetchGraph(this, relationExpression, options);
  }

  $beforeValidate(jsonSchema, json, options) {
    /* istanbul ignore next */
    return jsonSchema;
  }

  $validate(json, options) {
    return validate(this, json, options);
  }

  $afterValidate(json, options) {
    // Do nothing by default.
  }

  $parseDatabaseJson(json) {
    const columnNameMappers = this.constructor.getColumnNameMappers();

    if (columnNameMappers) {
      json = columnNameMappers.parse(json);
    }

    return parseJsonAttributes(json, this.constructor);
  }

  $formatDatabaseJson(json) {
    const columnNameMappers = this.constructor.getColumnNameMappers();

    json = formatJsonAttributes(json, this.constructor);

    if (columnNameMappers) {
      json = columnNameMappers.format(json);
    }

    return json;
  }

  $parseJson(json, options) {
    return json;
  }

  $formatJson(json) {
    return json;
  }

  $setJson(json, options) {
    return setJson(this, json, options);
  }

  $setDatabaseJson(json) {
    return setDatabaseJson(this, json);
  }

  $set(obj) {
    return setFast(this, obj);
  }

  $setRelated(relation, models) {
    return setRelated(this, relation, models);
  }

  $appendRelated(relation, models) {
    return appendRelated(this, relation, models);
  }

  $toJson(opt) {
    return toJson(this, opt);
  }

  toJSON(opt) {
    return this.$toJson(opt);
  }

  $toDatabaseJson(builder) {
    return toDatabaseJson(this, builder);
  }

  $beforeInsert(queryContext) {
    // Do nothing by default.
  }

  $afterInsert(queryContext) {
    // Do nothing by default.
  }

  $beforeUpdate(opt, queryContext) {
    // Do nothing by default.
  }

  $afterUpdate(opt, queryContext) {
    // Do nothing by default.
  }

  $afterFind(queryContext) {
    // Do nothing by default.
  }

  $beforeDelete(queryContext) {
    // Do nothing by default.
  }

  $afterDelete(queryContext) {
    // Do nothing by default.
  }

  $values(props) {
    return values(this, props);
  }

  $propKey(props) {
    return propKey(this, props);
  }

  $idKey() {
    return this.$propKey(this.constructor.getIdPropertyArray());
  }

  $clone(opt) {
    return clone(this, !!(opt && opt.shallow), false);
  }

  $traverse(filterConstructor, callback) {
    if (callback === undefined) {
      callback = filterConstructor;
      filterConstructor = null;
    }

    this.constructor.traverse(filterConstructor, this, callback);
    return this;
  }

  $traverseAsync(filterConstructor, callback) {
    if (callback === undefined) {
      callback = filterConstructor;
      filterConstructor = null;
    }

    return this.constructor.traverseAsync(filterConstructor, this, callback);
  }

  $omitFromJson(...props) {
    if (arguments.length === 0) {
      return this.$$omitFromJson;
    } else {
      if (!this.hasOwnProperty('$$omitFromJson')) {
        defineNonEnumerableProperty(this, '$$omitFromJson', []);
      }
      this.$$omitFromJson = this.$$omitFromJson.concat(asPropsArray(props));
      return this;
    }
  }

  $omitFromDatabaseJson(...props) {
    if (arguments.length === 0) {
      return this.$$omitFromDatabaseJson;
    } else {
      if (!this.hasOwnProperty('$$omitFromDatabaseJson')) {
        defineNonEnumerableProperty(this, '$$omitFromDatabaseJson', []);
      }
      this.$$omitFromDatabaseJson = this.$$omitFromDatabaseJson.concat(asPropsArray(props));
      return this;
    }
  }

  $knex() {
    return this.constructor.knex();
  }

  $transaction(...args) {
    return this.constructor.transaction(...args);
  }

  get $ref() {
    return this.constructor.ref;
  }

  static get objectionModelClass() {
    return Model;
  }

  static fromJson(json, options) {
    const model = new this();
    model.$setJson(json || {}, options);
    return model;
  }

  static fromDatabaseJson(json) {
    const model = new this();
    model.$setDatabaseJson(json || {});
    return model;
  }

  static onCreateQuery(builder) {
    // Do nothing by default.
  }

  static beforeFind(args) {
    // Do nothing by default.
  }

  static afterFind(args) {
    // Do nothing by default.
  }

  static beforeInsert(args) {
    // Do nothing by default.
  }

  static afterInsert(args) {
    // Do nothing by default.
  }

  static beforeUpdate(args) {
    // Do nothing by default.
  }

  static afterUpdate(args) {
    // Do nothing by default.
  }

  static beforeDelete(args) {
    // Do nothing by default.
  }

  static afterDelete(args) {
    // Do nothing by default.
  }

  static omitImpl(obj, prop) {
    delete obj[prop];
  }

  static joinTableAlias(relationPath) {
    return `${relationPath}_join`;
  }

  static createValidator() {
    return new AjvValidator({
      options: {
        allErrors: true,
        validateSchema: false,
        ownProperties: true,
        v5: true,
      },
    });
  }

  static modifierNotFound(builder, modifier) {
    throw new this.ModifierNotFoundError(modifier);
  }

  static createNotFoundError(queryContext, props) {
    return new this.NotFoundError({ ...props, modelClass: this });
  }

  static createValidationError(props) {
    return new this.ValidationError({ ...props, modelClass: this });
  }

  static getTableName() {
    let tableName = this.tableName;

    if (isFunction(tableName)) {
      tableName = this.tableName();
    }

    if (!isString(tableName)) {
      throw new Error(`Model ${this.name} must have a static property tableName`);
    }

    return tableName;
  }

  static getIdColumn() {
    let idColumn = this.idColumn;

    if (isFunction(idColumn)) {
      idColumn = this.idColumn();
    }

    return idColumn;
  }

  static getValidator() {
    return cachedGet(this, '$$validator', getValidator);
  }

  static getJsonSchema() {
    return cachedGet(this, '$$jsonSchema', getJsonSchema);
  }

  static getJsonAttributes() {
    return cachedGet(this, '$$jsonAttributes', getJsonAttributes);
  }

  static getColumnNameMappers() {
    return cachedGet(this, '$$columnNameMappers', getColumnNameMappers);
  }

  static getConcurrency(knex) {
    const DEFAULT_CONCURRENCY = 4;

    if (this.concurrency === null) {
      if (!knex) {
        return DEFAULT_CONCURRENCY;
      }

      // The mssql driver is shit, and we cannot have concurrent queries.
      if (isMsSql(knex)) {
        return 1;
      } else {
        return DEFAULT_CONCURRENCY;
      }
    } else {
      if (isFunction(this.concurrency)) {
        return this.concurrency();
      } else {
        return this.concurrency;
      }
    }
  }

  static getModifiers() {
    return this.modifiers || {};
  }

  static columnNameToPropertyName(columnName) {
    let colToProp = cachedGet(this, '$$colToProp', () => new Map());
    let propertyName = colToProp.get(columnName);

    if (!propertyName) {
      propertyName = columnNameToPropertyName(this, columnName);
      colToProp.set(columnName, propertyName);
    }

    return propertyName;
  }

  static propertyNameToColumnName(propertyName) {
    let propToCol = cachedGet(this, '$$propToCol', () => new Map());
    let columnName = propToCol.get(propertyName);

    if (!columnName) {
      columnName = propertyNameToColumnName(this, propertyName);
      propToCol.set(propertyName, columnName);
    }

    return columnName;
  }

  static getReadOnlyAttributes() {
    return cachedGet(this, '$$readOnlyAttributes', getReadOnlyAttributes);
  }

  static getIdRelationProperty() {
    return cachedGet(this, '$$idRelationProperty', getIdRelationProperty);
  }

  static getIdColumnArray() {
    return this.getIdRelationProperty().cols;
  }

  static getIdPropertyArray() {
    return this.getIdRelationProperty().props;
  }

  static getIdProperty() {
    const idProps = this.getIdPropertyArray();

    if (idProps.length === 1) {
      return idProps[0];
    } else {
      return idProps;
    }
  }

  static getRelationMappings() {
    return cachedGet(this, '$$relationMappings', getRelationMappings);
  }

  static getRelations() {
    const relations = Object.create(null);

    for (const relationName of this.getRelationNames()) {
      relations[relationName] = this.getRelation(relationName);
    }

    return relations;
  }

  static getRelationNames() {
    return cachedGet(this, '$$relationNames', getRelationNames);
  }

  static getVirtualAttributes() {
    return cachedGet(this, '$$virtualAttributes', getVirtualAttributes);
  }

  static getDefaultGraphOptions() {
    return this.defaultGraphOptions;
  }

  static getRelatedFindQueryMutates() {
    return this.relatedFindQueryMutates;
  }

  static getRelatedInsertQueryMutates() {
    return this.relatedInsertQueryMutates;
  }

  static query(trx) {
    const query = this.QueryBuilder.forClass(this).transacting(trx);
    this.onCreateQuery(query);
    return query;
  }

  static relatedQuery(relationName, trx) {
    return relatedQuery({
      modelClass: this,
      relationName,
      transaction: trx,
      alwaysReturnArray: true,
    });
  }

  static fetchTableMetadata(opt) {
    return fetchTableMetadata(this, opt);
  }

  static tableMetadata(opt) {
    return tableMetadata(this, opt);
  }

  static knex(...args) {
    if (args.length) {
      defineNonEnumerableProperty(this, '$$knex', args[0]);
    } else {
      return this.$$knex;
    }
  }

  static transaction(knexOrTrx, cb) {
    if (!cb) {
      cb = knexOrTrx;
      knexOrTrx = null;
    }

    return (knexOrTrx || this.knex()).transaction(cb);
  }

  static startTransaction(knexOrTrx) {
    const { transaction } = __webpack_require__("./node_modules/objection/lib/transaction.js");
    return transaction.start(knexOrTrx || this.knex());
  }

  static get raw() {
    return raw;
  }

  static get ref() {
    return (...args) => {
      return ref(...args).model(this);
    };
  }

  static get fn() {
    return fn;
  }

  static knexQuery() {
    return this.knex().table(this.getTableName());
  }

  static uniqueTag() {
    if (this.name) {
      return `${this.getTableName()}_${this.name}`;
    } else {
      return this.getTableName();
    }
  }

  static bindKnex(knex) {
    return bindKnex(this, knex);
  }

  static bindTransaction(trx) {
    return bindKnex(this, trx);
  }

  static ensureModel(model, options) {
    const modelClass = this;

    if (!model) {
      return null;
    }

    if (model instanceof modelClass) {
      return parseRelationsIntoModelInstances(model, model, options);
    } else {
      return modelClass.fromJson(model, options);
    }
  }

  static ensureModelArray(input, options) {
    if (!input) {
      return [];
    }

    if (Array.isArray(input)) {
      const models = new Array(input.length);

      for (let i = 0, l = input.length; i < l; ++i) {
        models[i] = this.ensureModel(input[i], options);
      }

      return models;
    } else {
      return [this.ensureModel(input, options)];
    }
  }

  static getRelationUnsafe(name) {
    const mapping = this.getRelationMappings()[name];

    if (!mapping) {
      return null;
    }

    if (!this.hasOwnProperty('$$relations')) {
      defineNonEnumerableProperty(this, '$$relations', Object.create(null));
    }

    if (!this.$$relations[name]) {
      this.$$relations[name] = new mapping.relation(name, this);
      this.$$relations[name].setMapping(mapping);
    }

    return this.$$relations[name];
  }

  static getRelation(name) {
    const relation = this.getRelationUnsafe(name);

    if (!relation) {
      throw new Error(`A model class ${this.name} doesn't have relation ${name}`);
    }

    return relation;
  }

  static fetchGraph($models, expression, options = {}) {
    return this.query(options.transaction)
      .resolve(this.ensureModelArray($models))
      .findOptions({ dontCallFindHooks: true })
      .withGraphFetched(expression, options)
      .runAfter((models) => (Array.isArray($models) ? models : models[0]));
  }

  static traverse(...args) {
    const { traverser, models, filterConstructor } = getTraverseArgs(...args);

    if (!asSingle(models)) {
      return;
    }

    const modelClass = asSingle(models).constructor;

    visitModels(models, modelClass, (model, _, parent, relation) => {
      if (!filterConstructor || model instanceof filterConstructor) {
        traverser(model, parent, relation && relation.name);
      }
    });

    return this;
  }

  static traverseAsync(...args) {
    const { traverser, models, filterConstructor } = getTraverseArgs(...args);

    if (!asSingle(models)) {
      return Promise.resolve();
    }

    const modelClass = asSingle(models).constructor;
    const promises = [];

    visitModels(models, modelClass, (model, _, parent, relation) => {
      if (!filterConstructor || model instanceof filterConstructor) {
        const maybePromise = traverser(model, parent, relation && relation.name);
        promises.push(maybePromise);
      }
    });

    return promiseMap(promises, (it) => it, { concurrency: this.getConcurrency(this.knex()) });
  }
}

Object.defineProperties(Model, {
  isObjectionModelClass: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

Object.defineProperties(Model.prototype, {
  $isObjectionModel: {
    enumerable: false,
    writable: false,
    value: true,
  },

  $objectionModelClass: {
    enumerable: false,
    writable: false,
    value: Model,
  },
});

Model.QueryBuilder = QueryBuilder;

Model.HasOneRelation = HasOneRelation;
Model.HasManyRelation = HasManyRelation;
Model.ManyToManyRelation = ManyToManyRelation;
Model.BelongsToOneRelation = BelongsToOneRelation;
Model.HasOneThroughRelation = HasOneThroughRelation;

Model.JoinEagerAlgorithm = 'JoinEagerAlgorithm';
Model.NaiveEagerAlgorithm = 'NaiveEagerAlgorithm';
Model.WhereInEagerAlgorithm = 'WhereInEagerAlgorithm';

Model.ValidationError = ValidationError;
Model.NotFoundError = NotFoundError;
Model.ModifierNotFoundError = ModifierNotFoundError;

Model.tableName = null;
Model.jsonSchema = null;
Model.idColumn = 'id';
Model.uidProp = '#id';
Model.uidRefProp = '#ref';
Model.dbRefProp = '#dbRef';
Model.propRefRegex = /#ref{([^\.]+)\.([^}]+)}/g;
Model.jsonAttributes = null;
Model.cloneObjectAttributes = true;
Model.virtualAttributes = null;
Model.relationMappings = null;
Model.modelPaths = [];
Model.pickJsonSchemaProperties = false;
Model.defaultGraphOptions = null;
Model.defaultFindOptions = Object.freeze({});
Model.modifiers = null;
Model.useLimitInFirst = false;
Model.columnNameMappers = null;
Model.relatedFindQueryMutates = false;
Model.relatedInsertQueryMutates = false;
Model.concurrency = null;

function instanceQuery({ instance, transaction }) {
  const modelClass = instance.constructor;

  return modelClass
    .query(transaction)
    .findOperationFactory(() => {
      return new InstanceFindOperation('find', { instance });
    })
    .insertOperationFactory(() => {
      return new InstanceInsertOperation('insert', { instance });
    })
    .updateOperationFactory(() => {
      return new InstanceUpdateOperation('update', { instance });
    })
    .patchOperationFactory(() => {
      return new InstanceUpdateOperation('patch', {
        instance,
        modelOptions: { patch: true },
      });
    })
    .deleteOperationFactory(() => {
      return new InstanceDeleteOperation('delete', { instance });
    })
    .relateOperationFactory(() => {
      throw new Error('`relate` makes no sense in this context');
    })
    .unrelateOperationFactory(() => {
      throw new Error('`unrelate` makes no sense in this context');
    });
}

function relatedQuery({ modelClass, relationName, transaction, alwaysReturnArray } = {}) {
  const relation = modelClass.getRelation(relationName);
  const relatedModelClass = relation.relatedModelClass;

  return relatedModelClass
    .query(transaction)
    .findOperationFactory((builder) => {
      const isSubQuery = !builder.for();
      const owner = isSubQuery
        ? RelationOwner.createParentReference(builder, relation)
        : RelationOwner.create(builder.for());

      const operation = relation.find(builder, owner);

      operation.assignResultToOwner = modelClass.getRelatedFindQueryMutates();
      operation.alwaysReturnArray = alwaysReturnArray;
      operation.alias = isSubQuery ? relation.name : null;

      return operation;
    })
    .insertOperationFactory((builder) => {
      const owner = RelationOwner.create(builder.for());
      const operation = relation.insert(builder, owner);

      operation.assignResultToOwner = modelClass.getRelatedInsertQueryMutates();
      return operation;
    })
    .updateOperationFactory((builder) => {
      const owner = RelationOwner.create(builder.for());
      return relation.update(builder, owner);
    })
    .patchOperationFactory((builder) => {
      const owner = RelationOwner.create(builder.for());
      return relation.patch(builder, owner);
    })
    .deleteOperationFactory((builder) => {
      const owner = RelationOwner.create(builder.for());
      return relation.delete(builder, owner);
    })
    .relateOperationFactory((builder) => {
      const owner = RelationOwner.create(builder.for());
      return relation.relate(builder, owner);
    })
    .unrelateOperationFactory((builder) => {
      const owner = RelationOwner.create(builder.for());
      return relation.unrelate(builder, owner);
    });
}

function cachedGet(target, hiddenPropertyName, creator) {
  if (!target.hasOwnProperty(hiddenPropertyName)) {
    defineNonEnumerableProperty(target, hiddenPropertyName, creator(target));
  }

  return target[hiddenPropertyName];
}

function getValidator(modelClass) {
  return modelClass.createValidator();
}

function getJsonSchema(modelClass) {
  return modelClass.jsonSchema;
}

function getColumnNameMappers(modelClass) {
  return modelClass.columnNameMappers;
}

function getIdRelationProperty(modelClass) {
  const idColumn = asArray(modelClass.getIdColumn());

  return new RelationProperty(
    idColumn.map((idCol) => `${modelClass.getTableName()}.${idCol}`),
    () => modelClass,
  );
}

function getReadOnlyAttributes(modelClass) {
  return [...new Set(getReadOnlyAttributesRecursively(modelClass))];
}

function getReadOnlyAttributesRecursively(modelClass) {
  if (modelClass === Model || modelClass.prototype == undefined) {
    // Stop recursion to the model class or its prototype is null or undefined.
    return [];
  }

  const propertyNames = Object.getOwnPropertyNames(modelClass.prototype);

  return [
    ...getReadOnlyAttributes(Object.getPrototypeOf(modelClass)),
    ...propertyNames.filter((propName) => {
      const desc = Object.getOwnPropertyDescriptor(modelClass.prototype, propName);
      return (desc.get && !desc.set) || desc.writable === false || isFunction(desc.value);
    }),
  ];
}

function getRelationMappings(modelClass) {
  let relationMappings = modelClass.relationMappings;

  if (isFunction(relationMappings)) {
    relationMappings = relationMappings.call(modelClass);
  }

  return relationMappings || {};
}

function getRelationNames(modelClass) {
  return Object.keys(modelClass.getRelationMappings());
}

function getVirtualAttributes(modelClass) {
  return modelClass.virtualAttributes || [];
}

function getTraverseArgs(filterConstructor, models, traverser) {
  filterConstructor = filterConstructor || null;

  if (traverser === undefined) {
    traverser = models;
    models = filterConstructor;
    filterConstructor = null;
  }

  if (!isFunction(traverser)) {
    throw new Error('traverser must be a function');
  }

  return {
    traverser,
    models,
    filterConstructor,
  };
}

function asPropsArray(props) {
  if (props.length === 1) {
    const arg = props[0];
    if (Array.isArray(arg)) {
      return arg;
    } else if (arg && typeof arg === 'object') {
      return Object.entries(arg)
        .filter(([, value]) => value)
        .map(([key]) => key);
    }
  }
  return props;
}

module.exports = {
  Model,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/ModifierNotFoundError.js":
/***/ ((module) => {

"use strict";


class ModifierNotFoundError extends Error {
  constructor(modifierName) {
    super(`Unable to determine modify function from provided value: "${modifierName}".`);
    this.modifierName = modifierName;
  }
}

module.exports = {
  ModifierNotFoundError,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/NotFoundError.js":
/***/ ((module) => {

"use strict";


class NotFoundError extends Error {
  constructor({ modelClass, data = {}, statusCode = 404, ...rest } = {}) {
    super(rest.message || 'NotFoundError');

    this.type = 'NotFound';
    this.name = this.constructor.name;
    this.data = { ...rest, ...data };
    this.statusCode = statusCode;

    // Add as non-enumerable in case people are passing instances of
    // this error directly to `JSON.stringify`.
    Object.defineProperty(this, 'modelClass', {
      value: modelClass,
      enumerable: false,
    });
  }
}

module.exports = {
  NotFoundError,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/RelationDoesNotExistError.js":
/***/ ((module) => {

"use strict";


class RelationDoesNotExistError extends Error {
  constructor(relationName) {
    super(`unknown relation "${relationName}" in a relation expression`);

    this.name = this.constructor.name;
    this.relationName = relationName;
  }
}

module.exports = {
  RelationDoesNotExistError,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/ValidationError.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray, isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

const ValidationErrorType = {
  ModelValidation: 'ModelValidation',
  RelationExpression: 'RelationExpression',
  UnallowedRelation: 'UnallowedRelation',
  InvalidGraph: 'InvalidGraph',
};

class ValidationError extends Error {
  static get Type() {
    return ValidationErrorType;
  }

  constructor({ type, message, modelClass, data = {}, statusCode = 400 }) {
    super(message || errorsToMessage(data));

    this.name = this.constructor.name;
    this.type = type;
    this.data = data;
    this.statusCode = statusCode;

    // Add as non-enumerable in case people are passing instances of
    // this error directly to `JSON.stringify`.
    Object.defineProperty(this, 'modelClass', {
      value: modelClass,
      enumerable: false,
    });
  }
}

function errorsToMessage(data) {
  return Object.keys(data)
    .reduce((messages, key) => {
      messages.push(`${key}: ${asArray(data[key]).map(message).join(', ')}`);
      return messages;
    }, [])
    .join(', ');
}

function message(it) {
  if (isString(it)) {
    return it;
  } else {
    return it.message;
  }
}

module.exports = {
  ValidationError,
  ValidationErrorType,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/Validator.js":
/***/ ((module) => {

"use strict";


class Validator {
  constructor(...args) {
    this.constructor.init(this, ...args);
  }

  static init() {}

  beforeValidate({ model, json, options }) {
    model.$beforeValidate(null, json, options);
  }

  validate() {
    /* istanbul ignore next */
    throw new Error('not implemented');
  }

  afterValidate({ model, json, options }) {
    model.$afterValidate(json, options);
  }
}

module.exports = {
  Validator,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/getModel.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A small helper method for cached lazy-importing of the Model class.
let Model;
const getModel = () => Model || (Model = (__webpack_require__("./node_modules/objection/lib/model/Model.js").Model));

module.exports = {
  getModel,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/graph/ModelGraph.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ModelGraphBuilder } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphBuilder.js");
const NOT_CALCULATED = {};

class ModelGraph {
  constructor(nodes, edges) {
    this.nodes = nodes;
    this.edges = edges;

    // These are calculated lazily.
    this._nodesByObjects = NOT_CALCULATED;
    this._nodesByIdPathKeys = NOT_CALCULATED;
  }

  static create(rootModelClass, roots) {
    const builder = ModelGraphBuilder.buildGraph(rootModelClass, roots);
    return new ModelGraph(builder.nodes, builder.edges);
  }

  static createEmpty() {
    return new ModelGraph([], []);
  }

  get rootObjects() {
    return this.nodes.filter((node) => !node.parentEdge).map((node) => node.obj);
  }

  nodeForObject(obj) {
    if (!obj) {
      return null;
    }

    if (this._nodesByObjects === NOT_CALCULATED) {
      this._nodesByObjects = createNodesByObjectsMap(this.nodes);
    }

    return this._nodesByObjects.get(obj) || null;
  }

  nodeForNode(node) {
    if (!node) {
      return null;
    }

    if (this._nodesByIdPathKeys === NOT_CALCULATED) {
      this._nodesByIdPathKeys = createNodesByIdPathKeysMap(this.nodes);
    }

    return this._nodesByIdPathKeys.get(node.idPathKey) || null;
  }
}

function createNodesByObjectsMap(nodes) {
  const nodesByObjects = new Map();

  for (const node of nodes) {
    nodesByObjects.set(node.obj, node);
  }

  return nodesByObjects;
}

function createNodesByIdPathKeysMap(nodes) {
  const nodesByIdPathKeys = new Map();

  for (const node of nodes) {
    const idPathKey = node.idPathKey;

    if (idPathKey !== null) {
      nodesByIdPathKeys.set(idPathKey, node);
    }
  }

  return nodesByIdPathKeys;
}

module.exports = {
  ModelGraph,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/graph/ModelGraphBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, isString, asArray, asSingle } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { ModelGraphNode } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphNode.js");
const { ModelGraphEdge } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphEdge.js");

class ModelGraphBuilder {
  constructor() {
    this.nodes = [];
    this.edges = [];
  }

  static buildGraph(rootModelClass, roots) {
    const builder = new this();
    builder._buildGraph(rootModelClass, roots);

    return builder;
  }

  _buildGraph(rootModelClass, roots) {
    if (roots) {
      if (Array.isArray(roots)) {
        this._buildNodes(rootModelClass, roots);
      } else if (isObject(roots)) {
        this._buildNode(rootModelClass, roots);
      } else {
        throw createNotModelError(rootModelClass, roots);
      }
    }

    this._buildReferences();
  }

  _buildNodes(modelClass, objs, parentNode = null, relation = null) {
    objs = asArray(objs);

    objs.forEach((obj, index) => {
      this._buildNode(modelClass, obj, parentNode, relation, index);
    });
  }

  _buildNode(modelClass, obj, parentNode = null, relation = null, index = null) {
    obj = asSingle(obj);

    if (!isObject(obj) || !obj.$isObjectionModel) {
      throw createNotModelError(modelClass, obj);
    }

    const node = new ModelGraphNode(modelClass, obj);
    this.nodes.push(node);

    if (parentNode) {
      const edge = new ModelGraphEdge(
        ModelGraphEdge.Type.Relation,
        parentNode,
        node,
        relation,
        index,
      );

      node.parentEdge = edge;
      this._addEdge(parentNode, node, edge);
    }

    this._buildRelationNodes(node);
  }

  _buildRelationNodes(node) {
    for (const relationName of node.modelClass.getRelationNames()) {
      const relatedObjects = node.obj[relationName];

      if (!relatedObjects) {
        continue;
      }

      const relation = node.modelClass.getRelation(relationName);

      if (relation.isOneToOne()) {
        this._buildNode(relation.relatedModelClass, relatedObjects, node, relation);
      } else {
        this._buildNodes(relation.relatedModelClass, relatedObjects, node, relation);
      }
    }
  }

  _buildReferences() {
    const nodesByUid = this._nodesByUid();

    this._buildObjectReferences(nodesByUid);
    this._buildPropertyReferences(nodesByUid);
  }

  _nodesByUid() {
    const nodesByUid = new Map();

    for (const node of this.nodes) {
      const uid = node.uid;

      if (uid === undefined) {
        continue;
      }

      nodesByUid.set(uid, node);
    }

    return nodesByUid;
  }

  _buildObjectReferences(nodesByUid) {
    for (const node of this.nodes) {
      const ref = node.reference;

      if (ref === undefined) {
        continue;
      }

      const refNode = nodesByUid.get(ref);

      if (!refNode) {
        throw createReferenceNotFoundError(ref);
      }

      const edge = new ModelGraphEdge(ModelGraphEdge.Type.Reference, node, refNode);
      edge.refType = ModelGraphEdge.ReferenceType.Object;

      this._addEdge(node, refNode, edge);
    }
  }

  _buildPropertyReferences(nodesByUid) {
    for (const node of this.nodes) {
      forEachPropertyReference(node.obj, ({ path, refMatch, ref, refPath }) => {
        const refNode = nodesByUid.get(ref);

        if (!refNode) {
          throw createReferenceNotFoundError(ref);
        }

        const edge = new ModelGraphEdge(ModelGraphEdge.Type.Reference, node, refNode);

        edge.refType = ModelGraphEdge.ReferenceType.Property;
        edge.refMatch = refMatch;
        edge.refOwnerDataPath = path.slice();
        edge.refRelatedDataPath = refPath;

        this._addEdge(node, refNode, edge);
      });
    }
  }

  _addEdge(ownerNode, relatedNode, edge) {
    this.edges.push(edge);

    ownerNode.edges.push(edge);
    relatedNode.edges.push(edge);

    if (edge.type === ModelGraphEdge.Type.Reference) {
      ownerNode.refEdges.push(edge);
      relatedNode.refEdges.push(edge);
    }
  }
}

function forEachPropertyReference(obj, callback) {
  const modelClass = obj.constructor;
  const relationNames = modelClass.getRelationNames();

  for (const prop of Object.keys(obj)) {
    if (relationNames.includes(prop)) {
      continue;
    }

    visitStrings(obj[prop], [prop], (str, path) => {
      forEachMatch(modelClass.propRefRegex, str, (match) => {
        const [refMatch, ref, refPath] = match;
        callback({ path, refMatch, ref, refPath: refPath.trim().split('.') });
      });
    });
  }
}

function visitStrings(value, path, visit) {
  if (Array.isArray(value)) {
    visitStringsInArray(value, path, visit);
  } else if (isObject(value) && !Buffer.isBuffer(value)) {
    visitStringsInObject(value, path, visit);
  } else if (isString(value)) {
    visit(value, path);
  }
}

function visitStringsInArray(value, path, visit) {
  for (let i = 0; i < value.length; ++i) {
    path.push(i);
    visitStrings(value[i], path, visit);
    path.pop();
  }
}

function visitStringsInObject(value, path, visit) {
  for (const prop of Object.keys(value)) {
    path.push(prop);
    visitStrings(value[prop], path, visit);
    path.pop();
  }
}

function forEachMatch(regex, str, cb) {
  let matchResult = regex.exec(str);

  while (matchResult) {
    cb(matchResult);
    matchResult = regex.exec(str);
  }
}

function createReferenceNotFoundError(ref) {
  return new Error(
    [
      `could not resolve reference ${ref} in a graph.`,
      `If you are sure the #id exist in the same graph,`,
      `this may be due to a limitation that a subgraph under a related item`,
      `cannot reference an item in a subgraph under another related item.`,
      `If you run into this limitation, please open an issue in objection github.`,
    ].join(' '),
  );
}

function createNotModelError(modelClass, value) {
  throw modelClass.createValidationError({
    type: ValidationErrorType.InvalidGraph,
    message: `expected value "${value}" to be an instance of ${modelClass.name}`,
  });
}

module.exports = {
  ModelGraphBuilder,
  createNotModelError,
  forEachPropertyReference,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/graph/ModelGraphEdge.js":
/***/ ((module) => {

"use strict";


const Type = {
  Relation: 'Relation',
  Reference: 'Reference',
};

const ReferenceType = {
  Object: 'Object',
  Property: 'Property',
};

class ModelGraphEdge {
  constructor(type, ownerNode, relatedNode, relation = null, relationIndex = null) {
    this.type = type;

    this.ownerNode = ownerNode;
    this.relatedNode = relatedNode;
    this.relation = relation;
    this.relationIndex = relationIndex;

    this.refType = null;
    this.refMatch = null;

    this.refOwnerDataPath = null;
    this.refRelatedDataPath = null;
  }

  static get Type() {
    return Type;
  }

  static get ReferenceType() {
    return ReferenceType;
  }

  getOtherNode(node) {
    return this.isOwnerNode(node) ? this.relatedNode : this.ownerNode;
  }

  isOwnerNode(node) {
    return node === this.ownerNode;
  }

  isRelatedNode(node) {
    return node === this.relatedNode;
  }
}

module.exports = {
  ModelGraphEdge,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/graph/ModelGraphNode.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ModelGraphEdge } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphEdge.js");
const { isNumber } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

const NOT_CALCULATED = {};

class ModelGraphNode {
  constructor(modelClass, obj) {
    this.modelClass = modelClass;
    this.obj = obj;
    this.edges = [];
    this.userData = {};
    this.hasId = obj.$hasId();
    this.uid = obj[modelClass.uidProp];

    // These are also included in `edges`. These are simply
    // shortcuts for commonly used edges.
    this.refEdges = [];
    this.parentEdge = null;

    // These are calculated lazily.
    this._relationPath = NOT_CALCULATED;
    this._relationPathKey = NOT_CALCULATED;

    this._dataPath = NOT_CALCULATED;
    this._dataPathKey = NOT_CALCULATED;

    this._idPath = NOT_CALCULATED;
    this._idPathKey = NOT_CALCULATED;
  }

  get isReference() {
    return this.reference !== undefined;
  }

  get isDbReference() {
    return this.dbReference !== undefined;
  }

  get reference() {
    return this.obj[this.modelClass.uidRefProp];
  }

  get dbReference() {
    return this.obj[this.modelClass.dbRefProp];
  }

  get parentNode() {
    if (this.parentEdge) {
      return this.parentEdge.ownerNode;
    } else {
      return null;
    }
  }

  get indexInRelation() {
    if (this.parentEdge) {
      return this.parentEdge.relationIndex;
    } else {
      return null;
    }
  }

  get relationName() {
    if (this.parentEdge) {
      return this.parentEdge.relation.name;
    } else {
      return null;
    }
  }

  get relationPath() {
    if (this._relationPath === NOT_CALCULATED) {
      this._relationPath = this._createRelationPath();
    }

    return this._relationPath;
  }

  get relationPathKey() {
    if (this._relationPathKey === NOT_CALCULATED) {
      this._relationPathKey = this._createRelationPathKey();
    }

    return this._relationPathKey;
  }

  get dataPath() {
    if (this._dataPath === NOT_CALCULATED) {
      this._dataPath = this._createDataPath();
    }

    return this._dataPath;
  }

  get dataPathKey() {
    if (this._dataPathKey === NOT_CALCULATED) {
      this._dataPathKey = this._createDataPathKey();
    }

    return this._dataPathKey;
  }

  get idPath() {
    if (this._idPath === NOT_CALCULATED) {
      this._idPath = this._createIdPath();
    }

    return this._idPath;
  }

  get idPathKey() {
    if (this._idPathKey === NOT_CALCULATED) {
      this._idPathKey = this._createIdPathKey();
    }

    return this._idPathKey;
  }

  /**
   * If this node is a reference, returns the referred node.
   */
  get referencedNode() {
    for (const edge of this.refEdges) {
      if (edge.refType === ModelGraphEdge.ReferenceType.Object && edge.isOwnerNode(this)) {
        return edge.relatedNode;
      }
    }

    return null;
  }

  /**
   * Returns all nodes that are references to this node.
   */
  get referencingNodes() {
    const nodes = [];

    for (const edge of this.refEdges) {
      if (edge.refType === ModelGraphEdge.ReferenceType.Object && edge.isRelatedNode(this)) {
        nodes.push(edge.ownerNode);
      }
    }

    return nodes;
  }

  get descendantRelationNodes() {
    return this._collectDescendantRelationNodes([]);
  }

  removeEdge(edge) {
    // Don't allow removing parent edges for now. It would
    // cause all kinds of cache invalidation.
    if (edge === this.parentEdge) {
      throw new Error('cannot remove parent edge');
    }

    this.edges = this.edges.filter((it) => it !== edge);
    this.refEdges = this.refEdges.filter((it) => it !== edge);
  }

  _collectDescendantRelationNodes(nodes) {
    for (const edge of this.edges) {
      if (edge.type === ModelGraphEdge.Type.Relation && edge.isOwnerNode(this)) {
        nodes.push(edge.relatedNode);
        edge.relatedNode._collectDescendantRelationNodes(nodes);
      }
    }

    return nodes;
  }

  _createRelationPath() {
    if (this.parentNode === null) {
      return [];
    } else {
      return [...this.parentNode.relationPath, this.relationName];
    }
  }

  _createRelationPathKey() {
    return this.relationPath.join('.');
  }

  _createDataPath() {
    if (this.parentEdge === null) {
      return [];
    } else if (this.parentEdge.relation.isOneToOne()) {
      return [...this.parentNode.dataPath, this.relationName];
    } else {
      return [...this.parentNode.dataPath, this.relationName, this.indexInRelation];
    }
  }

  _createDataPathKey() {
    const dataPathKey = this.dataPath.reduce((key, it) => {
      if (isNumber(it)) {
        return `${key}[${it}]`;
      } else {
        return key ? `${key}.${it}` : it;
      }
    }, '');

    return dataPathKey ? '.' + dataPathKey : dataPathKey;
  }

  _createIdPath() {
    if (!this.obj.$hasId()) {
      return null;
    }

    if (this.parentEdge === null) {
      return [this.obj.$idKey()];
    } else {
      const path = this.parentNode.idPath;

      if (path === null) {
        return null;
      }

      return [...path, this.relationName, this.obj.$idKey()];
    }
  }

  _createIdPathKey() {
    const idPath = this.idPath;

    if (idPath) {
      return this.idPath.join('.');
    } else {
      return null;
    }
  }
}

module.exports = {
  ModelGraphNode,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/inheritModel.js":
/***/ ((module) => {

"use strict";


const cache = new Map();

function inheritModel(modelClass) {
  let inherit = cache.get(modelClass.name);

  if (!inherit) {
    inherit = createClassInheritor(modelClass.name);
    cache.set(modelClass.name, inherit);
  }

  return inherit(modelClass);
}

function createClassInheritor(className) {
  return new Function(
    'BaseClass',
    `
    'use strict';
    return class ${className} extends BaseClass {}
  `,
  );
}

module.exports = {
  inheritModel,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelBindKnex.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { inheritModel } = __webpack_require__("./node_modules/objection/lib/model/inheritModel.js");
const { staticHiddenProps } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { defineNonEnumerableProperty } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");

function bindKnex(modelClass, knex) {
  let BoundModelClass = getBoundModelFromCache(modelClass, knex);

  if (BoundModelClass === null) {
    BoundModelClass = inheritModel(modelClass);
    BoundModelClass = copyHiddenProperties(modelClass, BoundModelClass);

    BoundModelClass.knex(knex);

    BoundModelClass = putBoundModelToCache(modelClass, BoundModelClass, knex);
    BoundModelClass = bindRelations(modelClass, BoundModelClass, knex);
  }

  return BoundModelClass;
}

function getBoundModelFromCache(modelClass, knex) {
  const cache = getCache(knex);
  const cacheKey = modelClass.uniqueTag();

  return cache.get(cacheKey) || null;
}

function getCache(knex) {
  if (!knex.$$objection) {
    createCache(knex);
  }

  return knex.$$objection.boundModels;
}

function createCache(knex) {
  defineNonEnumerableProperty(knex, '$$objection', {
    boundModels: new Map(),
  });
}

function copyHiddenProperties(modelClass, BoundModelClass) {
  for (const prop of staticHiddenProps) {
    // $$relations and $$relationArray are handled in separately.
    if (modelClass.hasOwnProperty(prop) && prop !== '$$relations' && prop !== '$$relationArray') {
      defineNonEnumerableProperty(BoundModelClass, prop, modelClass[prop]);
    }
  }

  return BoundModelClass;
}

function putBoundModelToCache(modelClass, BoundModelClass, knex) {
  const cache = getCache(knex);
  const cacheKey = modelClass.uniqueTag();

  cache.set(cacheKey, BoundModelClass);
  return BoundModelClass;
}

function bindRelations(modelClass, BoundModelClass, knex) {
  const boundRelations = Object.create(null);
  const boundRelationArray = [];

  for (const relationName of modelClass.getRelationNames()) {
    const relation = modelClass.getRelation(relationName);
    const boundRelation = relation.bindKnex(knex);

    boundRelations[relation.name] = boundRelation;
    boundRelationArray.push(boundRelation);
  }

  defineNonEnumerableProperty(BoundModelClass, '$$relations', boundRelations);
  defineNonEnumerableProperty(BoundModelClass, '$$relationArray', boundRelationArray);

  return BoundModelClass;
}

module.exports = {
  bindKnex,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelClone.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, cloneDeep } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { hiddenProps } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { defineNonEnumerableProperty } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { isInternalProp } = __webpack_require__("./node_modules/objection/lib/utils/internalPropUtils.js");

function clone(model, shallow, stripInternal) {
  let clone = null;

  const omitFromJson = model.$omitFromJson();
  const omitFromDatabaseJson = model.$omitFromDatabaseJson();

  if (!shallow && !stripInternal) {
    clone = cloneSimple(model);
  } else {
    clone = cloneWithOpt(model, shallow, stripInternal);
  }

  if (omitFromJson) {
    clone.$omitFromJson(omitFromJson);
  }

  if (omitFromDatabaseJson) {
    clone.$omitFromDatabaseJson(omitFromDatabaseJson);
  }

  clone = copyHiddenProps(model, clone);
  return clone;
}

function cloneSimple(model) {
  const clone = new model.constructor();
  const keys = Object.keys(model);

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];
    const value = model[key];

    if (isObject(value)) {
      clone[key] = cloneObject(value);
    } else {
      clone[key] = value;
    }
  }

  return clone;
}

function cloneWithOpt(model, shallow, stripInternal) {
  const clone = new model.constructor();
  const keys = Object.keys(model);
  const relationNames = model.constructor.getRelationNames();

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];
    const value = model[key];

    if (shallow && relationNames.includes(key)) {
      // The constructor may have given default values for relations.
      delete clone[key];
      continue;
    }

    if (stripInternal && isInternalProp(key)) {
      continue;
    }

    if (isObject(value)) {
      clone[key] = cloneObject(value);
    } else {
      clone[key] = value;
    }
  }

  return clone;
}

function cloneObject(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  } else if (value.$isObjectionModel) {
    return clone(value, false, false);
  } else if (Buffer.isBuffer(value)) {
    return new Buffer(value);
  } else {
    return cloneDeep(value);
  }
}

function cloneArray(value) {
  const ret = new Array(value.length);

  for (let i = 0, l = ret.length; i < l; ++i) {
    const item = value[i];

    if (isObject(item)) {
      ret[i] = cloneObject(item);
    } else {
      ret[i] = item;
    }
  }

  return ret;
}

function copyHiddenProps(model, clone) {
  for (let i = 0, l = hiddenProps.length; i < l; ++i) {
    const prop = hiddenProps[i];

    if (model.hasOwnProperty(prop)) {
      defineNonEnumerableProperty(clone, prop, model[prop]);
    }
  }

  return clone;
}

module.exports = {
  clone,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelColPropMap.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { difference } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function columnNameToPropertyName(modelClass, columnName) {
  const model = new modelClass();
  const addedProps = Object.keys(model.$parseDatabaseJson({}));

  const row = {};
  row[columnName] = null;

  const props = Object.keys(model.$parseDatabaseJson(row));
  const propertyName = difference(props, addedProps)[0];

  return propertyName || columnName;
}

function propertyNameToColumnName(modelClass, propertyName) {
  const model = new modelClass();
  const addedCols = Object.keys(model.$formatDatabaseJson({}));

  const obj = {};
  obj[propertyName] = null;

  const cols = Object.keys(model.$formatDatabaseJson(obj));
  const columnName = difference(cols, addedCols)[0];

  return columnName || propertyName;
}

module.exports = {
  columnNameToPropertyName,
  propertyNameToColumnName,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelId.js":
/***/ ((module) => {

"use strict";


function getSetId(model, maybeId) {
  if (maybeId !== undefined) {
    return setId(model, maybeId);
  } else {
    return getId(model);
  }
}

function hasId(model) {
  return model.$hasProps(model.constructor.getIdPropertyArray());
}

function setId(model, id) {
  const idProp = model.constructor.getIdProperty();
  const isCompositeId = Array.isArray(idProp);

  if (Array.isArray(id)) {
    if (isCompositeId) {
      if (id.length !== idProp.length) {
        throw new Error('trying to set an invalid identifier for a model');
      }

      for (let i = 0; i < id.length; ++i) {
        model[idProp[i]] = id[i];
      }
    } else {
      if (id.length !== 1) {
        throw new Error('trying to set an invalid identifier for a model');
      }

      model[idProp] = id[0];
    }
  } else {
    if (isCompositeId) {
      if (idProp.length > 1) {
        throw new Error('trying to set an invalid identifier for a model');
      }

      model[idProp[0]] = id;
    } else {
      model[idProp] = id;
    }
  }
}

function getId(model) {
  const idProp = model.constructor.getIdProperty();
  const isCompositeId = Array.isArray(idProp);

  if (isCompositeId) {
    return model.$values(idProp);
  } else {
    return model[idProp];
  }
}

module.exports = {
  getSetId,
  hasId,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelJsonAttributes.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray, isObject, flatten, isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function parseJsonAttributes(json, modelClass) {
  const jsonAttr = modelClass.getJsonAttributes();

  if (jsonAttr.length) {
    // JSON attributes may be returned as strings depending on the database and
    // the database client. Convert them to objects here.
    for (let i = 0, l = jsonAttr.length; i < l; ++i) {
      const attr = jsonAttr[i];
      const value = json[attr];

      if (isString(value)) {
        const parsed = tryParseJson(value);

        // tryParseJson returns undefined if parsing failed.
        if (parsed !== undefined) {
          json[attr] = parsed;
        }
      }
    }
  }

  return json;
}

function formatJsonAttributes(json, modelClass) {
  const jsonAttr = modelClass.getJsonAttributes();

  if (jsonAttr.length) {
    // All database clients want JSON columns as strings. Do the conversion here.
    for (let i = 0, l = jsonAttr.length; i < l; ++i) {
      const attr = jsonAttr[i];
      const value = json[attr];

      if (value != null) {
        json[attr] = JSON.stringify(value);
      }
    }
  }

  return json;
}

function getJsonAttributes(modelClass) {
  let jsonAttributes = modelClass.jsonAttributes;

  if (Array.isArray(jsonAttributes)) {
    return jsonAttributes;
  }

  jsonAttributes = [];

  if (modelClass.getJsonSchema()) {
    const props = modelClass.getJsonSchema().properties || {};

    for (const propName of Object.keys(props)) {
      const prop = props[propName];
      let types = asArray(prop.type).filter((it) => !!it);

      if (types.length === 0 && Array.isArray(prop.anyOf)) {
        types = flatten(prop.anyOf.map((it) => it.type));
      }

      if (types.length === 0 && Array.isArray(prop.oneOf)) {
        types = flatten(prop.oneOf.map((it) => it.type));
      }

      if (types.indexOf('object') !== -1 || types.indexOf('array') !== -1) {
        jsonAttributes.push(propName);
      }
    }
  }

  return jsonAttributes;
}

function tryParseJson(maybeJsonStr) {
  try {
    return JSON.parse(maybeJsonStr);
  } catch (err) {
    return undefined;
  }
}

module.exports = {
  parseJsonAttributes,
  formatJsonAttributes,
  getJsonAttributes,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelParseRelations.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function parseRelationsIntoModelInstances(model, json, options = {}) {
  if (!options.cache) {
    options = Object.assign({}, options, {
      cache: new Map(),
    });
  }

  options.cache.set(json, model);

  for (const relationName of model.constructor.getRelationNames()) {
    const relationJson = json[relationName];

    if (relationJson !== undefined) {
      const relation = model.constructor.getRelation(relationName);
      const relationModel = parseRelation(relationJson, relation, options);

      if (relationModel !== relationJson) {
        model[relation.name] = relationModel;
      }
    }
  }

  return model;
}

function parseRelation(json, relation, options) {
  if (Array.isArray(json)) {
    return parseRelationArray(json, relation, options);
  } else if (json) {
    return parseRelationObject(json, relation, options);
  } else {
    return null;
  }
}

function parseRelationArray(json, relation, options) {
  const models = new Array(json.length);
  let didChange = false;

  for (let i = 0, l = json.length; i < l; ++i) {
    const model = parseRelationObject(json[i], relation, options);

    if (model !== json[i]) {
      didChange = true;
    }

    models[i] = model;
  }

  if (didChange) {
    return models;
  } else {
    return json;
  }
}

function parseRelationObject(json, relation, options) {
  if (isObject(json)) {
    const modelClass = relation.relatedModelClass;
    let model = options.cache.get(json);

    if (model === undefined) {
      if (json instanceof modelClass) {
        model = parseRelationsIntoModelInstances(json, json, options);
      } else {
        model = modelClass.fromJson(json, options);
      }
    }

    return model;
  } else {
    return json;
  }
}

module.exports = {
  parseRelationsIntoModelInstances,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelQueryProps.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { defineNonEnumerableProperty } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { isKnexRaw, isKnexQueryBuilder } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");

const QUERY_PROPS_PROPERTY = '$$queryProps';

// Removes query properties from `json` and stores them into a hidden property
// inside `model` so that they can be later merged back to `json`.
function splitQueryProps(model, json) {
  const keys = Object.keys(json);

  if (hasQueryProps(json, keys)) {
    const queryProps = {};
    const modelProps = {};

    for (let i = 0, l = keys.length; i < l; ++i) {
      const key = keys[i];
      const value = json[key];

      if (isQueryProp(value)) {
        queryProps[key] = value;
      } else {
        modelProps[key] = value;
      }
    }

    defineNonEnumerableProperty(model, QUERY_PROPS_PROPERTY, queryProps);

    return modelProps;
  } else {
    return json;
  }
}

function hasQueryProps(json, keys) {
  for (let i = 0, l = keys.length; i < l; ++i) {
    if (isQueryProp(json[keys[i]])) {
      return true;
    }
  }

  return false;
}

function isQueryProp(value) {
  if (!isObject(value)) {
    return false;
  }

  return (
    isKnexQueryBuilder(value) ||
    isKnexRaw(value) ||
    isKnexRawConvertable(value) ||
    value.isObjectionQueryBuilderBase
  );
}

// Merges and converts `model`'s query properties into `json`.
function mergeQueryProps(model, json, omitProps, builder) {
  json = convertExistingQueryProps(json, builder);
  json = convertAndMergeHiddenQueryProps(model, json, omitProps, builder);

  return json;
}

// Converts the query properties in `json` to knex raw instances.
// `json` may have query properties even though we removed them.
// For example they may have been added in lifecycle hooks.
function convertExistingQueryProps(json, builder) {
  const keys = Object.keys(json);

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];
    const value = json[key];

    if (isQueryProp(value)) {
      json[key] = queryPropToKnexRaw(value, builder);
    }
  }

  return json;
}

// Converts and merges the query props that were split from the model
// and stored into QUERY_PROPS_PROPERTY.
function convertAndMergeHiddenQueryProps(model, json, omitProps, builder) {
  const queryProps = model[QUERY_PROPS_PROPERTY];

  if (!queryProps) {
    // The model has no query properties.
    return json;
  }

  const modelClass = model.constructor;
  const keys = Object.keys(queryProps);

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];

    if (!omitProps || !omitProps.includes(key)) {
      const queryProp = queryPropToKnexRaw(queryProps[key], builder);
      json[modelClass.propertyNameToColumnName(key)] = queryProp;
    }
  }

  return json;
}

// Converts a query property into a knex `raw` instance.
function queryPropToKnexRaw(queryProp, builder) {
  if (!queryProp) {
    return queryProp;
  }

  if (queryProp.isObjectionQueryBuilderBase) {
    return buildObjectionQueryBuilder(queryProp, builder);
  } else if (isKnexRawConvertable(queryProp)) {
    return buildKnexRawConvertable(queryProp, builder);
  } else {
    return queryProp;
  }
}

function buildObjectionQueryBuilder(builder, parentBuilder) {
  return builder.subqueryOf(parentBuilder).toKnexQuery();
}

function buildKnexRawConvertable(convertable, builder) {
  if (!builder) {
    throw new Error(
      'toDatabaseJson called without a query builder instance for a model with query properties',
    );
  }

  return convertable.toKnexRaw(builder);
}

function isKnexRawConvertable(queryProp) {
  return isFunction(queryProp.toKnexRaw);
}

module.exports = {
  splitQueryProps,
  mergeQueryProps,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelSet.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isInternalProp } = __webpack_require__("./node_modules/objection/lib/utils/internalPropUtils.js");
const { splitQueryProps } = __webpack_require__("./node_modules/objection/lib/model/modelQueryProps.js");
const { isFunction, isString, isPlainObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { parseRelationsIntoModelInstances } = __webpack_require__("./node_modules/objection/lib/model/modelParseRelations.js");

function setJson(model, json, options) {
  json = json || {};
  options = options || {};

  if (Object.prototype.toString.call(json) !== '[object Object]') {
    throw new Error(
      'You should only pass objects to $setJson method. ' +
        '$setJson method was given an invalid value ' +
        json,
    );
  }

  if (!json.$isObjectionModel) {
    // json can contain "query properties" like `raw` instances, query builders etc.
    // We take them out of `json` and store them to a hidden property $$queryProps
    // in the model instance for later use.
    json = splitQueryProps(model, json);
  }

  json = model.$parseJson(json, options);
  json = model.$validate(json, options);

  model.$set(json);

  if (!options.skipParseRelations) {
    parseRelationsIntoModelInstances(model, json, options);
  }

  return model;
}

function setDatabaseJson(model, json) {
  json = model.$parseDatabaseJson(json);

  if (json) {
    const keys = Object.keys(json);

    for (let i = 0, l = keys.length; i < l; ++i) {
      const key = keys[i];
      model[key] = json[key];
    }
  }

  return model;
}

function setFast(model, obj) {
  if (obj) {
    // Don't try to set read-only properties. They can easily get here
    // through `fromJson` when parsing an object that was previously
    // serialized from a model instance.
    const readOnlyAttr = model.constructor.getReadOnlyAttributes();
    const keys = Object.keys(obj);

    for (let i = 0, l = keys.length; i < l; ++i) {
      const key = keys[i];
      const value = obj[key];

      if (
        (value !== undefined || isPlainObject(obj)) &&
        !isInternalProp(key) &&
        !isFunction(value) &&
        !readOnlyAttr.includes(key)
      ) {
        model[key] = value;
      }
    }
  }

  return model;
}

function setRelated(model, relation, models) {
  relation = ensureRelation(model, relation);

  if (relation.isOneToOne()) {
    if (Array.isArray(models)) {
      if (models.length === 0) {
        model[relation.name] = null;
      } else {
        model[relation.name] = models[0] || null;
      }
    } else {
      model[relation.name] = models || null;
    }
  } else {
    if (!models) {
      model[relation.name] = [];
    } else if (Array.isArray(models)) {
      model[relation.name] = models;
    } else {
      model[relation.name] = [models];
    }
  }

  return model;
}

function appendRelated(model, relation, models) {
  relation = ensureRelation(model, relation);

  if (!model[relation.name] || relation.isOneToOne()) {
    return model.$setRelated(relation, models);
  } else {
    if (Array.isArray(models)) {
      models.forEach((it) => model[relation.name].push(it));
    } else if (models) {
      model[relation.name].push(models);
    }
  }

  return model;
}

function ensureRelation(model, relation) {
  if (isString(relation)) {
    return model.constructor.getRelation(relation);
  } else {
    return relation;
  }
}

module.exports = {
  setFast,
  setJson,
  setDatabaseJson,
  setRelated,
  appendRelated,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelTableMetadata.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { defineNonEnumerableProperty } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

const TABLE_METADATA = '$$tableMetadata';

function fetchTableMetadata(
  modelClass,
  { parentBuilder = null, knex = null, force = false, table = null } = {},
) {
  // The table isn't necessarily same as `modelClass.getTableName()` for example if
  // a view is queried instead.
  if (!table) {
    if (parentBuilder) {
      table = parentBuilder.tableNameFor(modelClass);
    } else {
      table = modelClass.getTableName();
    }
  }

  // Call tableMetadata first instead of accessing the cache directly beause
  // tableMetadata may have been overriden.
  let metadata = modelClass.tableMetadata({ table });

  if (!force && metadata) {
    return Promise.resolve(metadata);
  }

  // Memoize metadata but only for modelClass. The hasOwnProperty check
  // will fail for subclasses and the value gets recreated.
  if (!modelClass.hasOwnProperty(TABLE_METADATA)) {
    defineNonEnumerableProperty(modelClass, TABLE_METADATA, new Map());
  }

  // The cache needs to be checked in addition to calling tableMetadata
  // because the cache may contain a temporary promise in which case
  // tableMetadata returns null.
  metadata = modelClass[TABLE_METADATA].get(table);

  if (!force && metadata) {
    return Promise.resolve(metadata);
  } else {
    const promise = modelClass
      .query(knex)
      .childQueryOf(parentBuilder)
      .columnInfo({ table })
      .then((columnInfo) => {
        const metadata = {
          columns: Object.keys(columnInfo),
        };

        modelClass[TABLE_METADATA].set(table, metadata);
        return metadata;
      })
      .catch((err) => {
        modelClass[TABLE_METADATA].delete(table);
        throw err;
      });

    modelClass[TABLE_METADATA].set(table, promise);
    return promise;
  }
}

function tableMetadata(modelClass, { table } = {}) {
  if (modelClass.hasOwnProperty(TABLE_METADATA)) {
    const metadata = modelClass[TABLE_METADATA].get(table || modelClass.getTableName());

    if (isPromise(metadata)) {
      return null;
    } else {
      return metadata;
    }
  } else {
    return null;
  }
}

module.exports = {
  fetchTableMetadata,
  tableMetadata,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelToJson.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isInternalProp } = __webpack_require__("./node_modules/objection/lib/utils/internalPropUtils.js");
const { mergeQueryProps } = __webpack_require__("./node_modules/objection/lib/model/modelQueryProps.js");
const { isObject, cloneDeep, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const EMPTY_ARRAY = [];

function toJson(model, optIn) {
  const modelClass = model.constructor;

  const opt = {
    virtuals: getVirtuals(optIn),
    shallow: isShallow(optIn),
    omit: getOmit(optIn, modelClass),
    pick: null,
    omitFromJson: model.$omitFromJson() || null,
    cloneObjects: modelClass.cloneObjectAttributes,
  };

  let json = toExternalJsonImpl(model, opt);
  json = model.$formatJson(json);

  return json;
}

function toDatabaseJson(model, builder) {
  const modelClass = model.constructor;

  const opt = {
    virtuals: false,
    shallow: true,
    omit: modelClass.getRelationNames(),
    pick: getPick(modelClass),
    omitFromJson: model.$omitFromDatabaseJson() || null,
    cloneObjects: modelClass.cloneObjectAttributes,
  };

  let json = toDatabaseJsonImpl(model, opt);
  json = model.$formatDatabaseJson(json);

  return mergeQueryProps(model, json, opt.omitFromJson, builder);
}

function getVirtuals(opt) {
  if (!opt) {
    return true;
  } else if (Array.isArray(opt.virtuals)) {
    return opt.virtuals;
  } else {
    return opt.virtuals !== false;
  }
}

function isShallow(opt) {
  return !!opt && !!opt.shallow;
}

function getOmit(opt, modelClass) {
  return isShallow(opt) ? modelClass.getRelationNames() : null;
}

function getPick(modelClass) {
  const jsonSchema = modelClass.getJsonSchema();
  return (jsonSchema && modelClass.pickJsonSchemaProperties && jsonSchema.properties) || null;
}

function toExternalJsonImpl(model, opt) {
  const json = {};
  const keys = Object.keys(model);
  const vAttr = getVirtualAttributes(model, opt);

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];
    const value = model[key];

    assignJsonValue(json, key, value, opt);
  }

  if (vAttr.length !== 0) {
    assignVirtualAttributes(json, model, vAttr, opt);
  }

  return json;
}

function getVirtualAttributes(model, opt) {
  if (Array.isArray(opt.virtuals)) {
    return opt.virtuals;
  } else if (opt.virtuals === true) {
    return model.constructor.getVirtualAttributes();
  } else {
    return EMPTY_ARRAY;
  }
}

function toDatabaseJsonImpl(model, opt) {
  const json = {};
  const keys = Object.keys(model);

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];
    const value = model[key];

    assignJsonValue(json, key, value, opt);
  }

  return json;
}

function assignJsonValue(json, key, value, opt) {
  const type = typeof value;

  if (
    type !== 'function' &&
    type !== 'undefined' &&
    !isInternalProp(key) &&
    !shouldOmit(opt, key) &&
    shouldPick(opt, key)
  ) {
    if (isObject(value)) {
      json[key] = toJsonObject(value, opt);
    } else {
      json[key] = value;
    }
  }
}

function shouldOmit(opt, key) {
  return (
    (opt.omit !== null && opt.omit.includes(key)) ||
    (opt.omitFromJson !== null && opt.omitFromJson.includes(key))
  );
}

function shouldPick(opt, key) {
  return opt.pick === null || key in opt.pick;
}

function assignVirtualAttributes(json, model, vAttr, opt) {
  for (let i = 0, l = vAttr.length; i < l; ++i) {
    const key = vAttr[i];
    let value = model[key];

    if (isFunction(value)) {
      value = value.call(model);
    }

    assignJsonValue(json, key, value, opt);
  }
}

function toJsonObject(value, opt) {
  if (Array.isArray(value)) {
    return toJsonArray(value, opt);
  } else if (value.$isObjectionModel) {
    // No branch for $toDatabaseJson here since there is never a need
    // to have nested models in database rows.
    return value.$toJson(opt);
  } else if (Buffer.isBuffer(value)) {
    return value;
  } else if (opt.cloneObjects) {
    return cloneDeep(value);
  } else {
    return value;
  }
}

function toJsonArray(value, opt) {
  const ret = new Array(value.length);

  for (let i = 0, l = ret.length; i < l; ++i) {
    const item = value[i];

    if (isObject(item)) {
      ret[i] = toJsonObject(item, opt);
    } else {
      ret[i] = item;
    }
  }

  return ret;
}

module.exports = {
  toJson,
  toDatabaseJson,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelUtils.js":
/***/ ((module) => {

"use strict";


const hiddenProps = ['$$queryProps'];

const staticHiddenProps = [
  '$$knex',
  '$$validator',
  '$$jsonSchema',
  '$$colToProp',
  '$$propToCol',
  '$$relationMappings',
  '$$relations',
  '$$relationNames',
  '$$jsonAttributes',
  '$$columnNameMappers',
  '$$tableMetadata',
  '$$readOnlyAttributes',
  '$$idRelationProperty',
  '$$virtualAttributes',
];

function defineNonEnumerableProperty(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    enumerable: false,
    writable: true,
    configurable: true,
    value,
  });
}

function keyByProps(models, props) {
  const map = new Map();

  for (let i = 0, l = models.length; i < l; ++i) {
    const model = models[i];
    map.set(model.$propKey(props), model);
  }

  return map;
}

module.exports = {
  hiddenProps,
  staticHiddenProps,
  defineNonEnumerableProperty,
  keyByProps,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelValidate.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { clone } = __webpack_require__("./node_modules/objection/lib/model/modelClone.js");

function validate(model, json, options = {}) {
  json = json || model;

  const inputJson = json;
  const validatingModelInstance = inputJson && inputJson.$isObjectionModel;

  if (options.skipValidation) {
    return json;
  }

  if (validatingModelInstance) {
    // Strip away relations and other internal stuff.
    // TODO 1: This should use `json.$toJson()` since we always validate the input representation!
    // TODO 2: This should also keep the relations in the object because some validators may
    //         depend on the relations.
    json = clone(json, true, true);
    // We can mutate `json` now that we took a copy of it.
    options = Object.assign({}, options, { mutable: true });
  }

  const modelClass = model.constructor;
  const validator = modelClass.getValidator();
  const args = {
    options,
    model,
    json,
    ctx: Object.create(null),
  };

  validator.beforeValidate(args);
  json = validator.validate(args);
  validator.afterValidate(args);

  if (validatingModelInstance) {
    // If we cloned `json`, we need to copy the possible default values.
    return inputJson.$set(json);
  } else {
    return json;
  }
}

module.exports = {
  validate,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelValues.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

// Property keys needs to be prefixed with a non-numeric character so that
// they are not considered indexes when used as object keys.
const PROP_KEY_PREFIX = 'k_';

function values(model, args) {
  switch (args.length) {
    case 1:
      return values1(model, args);
    case 2:
      return values2(model, args);
    case 3:
      return values3(model, args);
    default:
      return valuesN(model, args);
  }
}

function propKey(model, props) {
  switch (props.length) {
    case 1:
      return propKey1(model, props);
    case 2:
      return propKey2(model, props);
    case 3:
      return propKey3(model, props);
    default:
      return propKeyN(model, props);
  }
}

function hasProps(model, props) {
  for (let i = 0; i < props.length; ++i) {
    const value = model[props[i]];

    if (isNullOrUndefined(value)) {
      return false;
    }
  }

  return true;
}

function values1(model, args) {
  return [model[args[0]]];
}

function values2(model, args) {
  return [model[args[0]], model[args[1]]];
}

function values3(model, args) {
  return [model[args[0]], model[args[1]], model[args[2]]];
}

function valuesN(model, args) {
  const ret = new Array(args.length);

  for (let i = 0, l = args.length; i < l; ++i) {
    ret[i] = model[args[i]];
  }

  return ret;
}

function propKey1(model, props) {
  return PROP_KEY_PREFIX + propToStr(model[props[0]]);
}

function propKey2(model, props) {
  return PROP_KEY_PREFIX + propToStr(model[props[0]]) + ',' + propToStr(model[props[1]]);
}

function propKey3(model, props) {
  return (
    PROP_KEY_PREFIX +
    propToStr(model[props[0]]) +
    ',' +
    propToStr(model[props[1]]) +
    ',' +
    propToStr(model[props[2]])
  );
}

function propKeyN(model, props) {
  let key = PROP_KEY_PREFIX;

  for (let i = 0, l = props.length; i < l; ++i) {
    key += propToStr(model[props[i]]);

    if (i < l - 1) {
      key += ',';
    }
  }

  return key;
}

function propToStr(value) {
  if (value === null) {
    return 'null';
  } else if (value === undefined) {
    return 'undefined';
  } else if (Buffer.isBuffer(value)) {
    return value.toString('hex');
  } else if (isObject(value)) {
    return JSON.stringify(value);
  } else {
    return `${value}`;
  }
}

function isNullOrUndefined(val) {
  return val === null || val === undefined;
}

module.exports = {
  PROP_KEY_PREFIX,
  propToStr,
  values,
  hasProps,
  propKey,
};


/***/ }),

/***/ "./node_modules/objection/lib/model/modelVisitor.js":
/***/ ((module) => {

"use strict";


function visitModels(models, modelClass, visitor) {
  doVisit(models, modelClass, null, null, visitor);
}

function doVisit(models, modelClass, parent, rel, visitor) {
  if (Array.isArray(models)) {
    visitMany(models, modelClass, parent, rel, visitor);
  } else if (models) {
    visitOne(models, modelClass, parent, rel, visitor);
  }
}

function visitMany(models, modelClass, parent, rel, visitor) {
  for (let i = 0, l = models.length; i < l; ++i) {
    visitOne(models[i], modelClass, parent, rel, visitor);
  }
}

function visitOne(model, modelClass, parent, rel, visitor) {
  if (model) {
    visitor(model, modelClass, parent, rel);
  }

  const relationNames = modelClass.getRelationNames();

  for (let i = 0, l = relationNames.length; i < l; ++i) {
    const relationName = relationNames[i];
    const relatedObj = model[relationName];

    if (relatedObj) {
      const relation = modelClass.getRelation(relationName);
      doVisit(relatedObj, relation.relatedModelClass, model, relation, visitor);
    }
  }
}

module.exports = {
  visitModels,
};


/***/ }),

/***/ "./node_modules/objection/lib/objection.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  DBError,
  UniqueViolationError,
  NotNullViolationError,
  ForeignKeyViolationError,
  ConstraintViolationError,
  CheckViolationError,
  DataError,
} = __webpack_require__("./node_modules/db-errors/lib/dbErrors.js");
const { Model: NativeModel } = __webpack_require__("./node_modules/objection/lib/model/Model.js");
const { QueryBuilder: NativeQueryBuilder } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilder.js");
const { QueryBuilderBase } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderBase.js");
const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");
const { ValidationError } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { NotFoundError } = __webpack_require__("./node_modules/objection/lib/model/NotFoundError.js");
const { AjvValidator: NativeAjvValidator } = __webpack_require__("./node_modules/objection/lib/model/AjvValidator.js");
const { Validator: NativeValidator } = __webpack_require__("./node_modules/objection/lib/model/Validator.js");
const { Relation } = __webpack_require__("./node_modules/objection/lib/relations/Relation.js");
const { HasOneRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasOne/HasOneRelation.js");
const { HasManyRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasMany/HasManyRelation.js");
const { BelongsToOneRelation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelation.js");
const { HasOneThroughRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasOneThrough/HasOneThroughRelation.js");
const { ManyToManyRelation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyRelation.js");
const { transaction } = __webpack_require__("./node_modules/objection/lib/transaction.js");
const { initialize } = __webpack_require__("./node_modules/objection/lib/initialize.js");

const {
  snakeCaseMappers,
  knexSnakeCaseMappers,
  knexIdentifierMapping,
} = __webpack_require__("./node_modules/objection/lib/utils/identifierMapping.js");
const { compose, mixin } = __webpack_require__("./node_modules/objection/lib/utils/mixin.js");
const { ref } = __webpack_require__("./node_modules/objection/lib/queryBuilder/ReferenceBuilder.js");
const { val } = __webpack_require__("./node_modules/objection/lib/queryBuilder/ValueBuilder.js");
const { raw } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RawBuilder.js");
const { fn } = __webpack_require__("./node_modules/objection/lib/queryBuilder/FunctionBuilder.js");
const { inherit } = __webpack_require__("./node_modules/objection/lib/utils/classUtils.js");

// We need to wrap the classes, that people can inherit, with ES5 classes
// so that babel is able to use ES5 inheritance. sigh... Maybe people
// should stop transpiling node apps to ES5 in the year 2019? Node 6
// with full class support was released three years ago.

function Model() {
  // Nothing to do here.
}

function QueryBuilder(...args) {
  NativeQueryBuilder.init(this, ...args);
}

function Validator(...args) {
  NativeValidator.init(this, ...args);
}

function AjvValidator(...args) {
  NativeAjvValidator.init(this, ...args);
}

inherit(Model, NativeModel);
inherit(QueryBuilder, NativeQueryBuilder);
inherit(Validator, NativeValidator);
inherit(AjvValidator, NativeAjvValidator);

Model.QueryBuilder = QueryBuilder;

module.exports = {
  Model,
  QueryBuilder,
  QueryBuilderBase,
  QueryBuilderOperation,
  RelationExpression,
  ValidationError,
  NotFoundError,
  AjvValidator,
  Validator,
  Relation,
  HasOneRelation,
  HasManyRelation,
  BelongsToOneRelation,
  HasOneThroughRelation,
  ManyToManyRelation,

  transaction,
  initialize,
  compose,
  mixin,
  ref,
  val,
  raw,
  fn,
  snakeCaseMappers,
  knexSnakeCaseMappers,
  knexIdentifierMapping,

  DBError,
  UniqueViolationError,
  NotNullViolationError,
  ForeignKeyViolationError,
  ConstraintViolationError,
  CheckViolationError,
  DataError,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/FunctionBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RawBuilder, normalizeRawArgs } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RawBuilder.js");
const { asSingle, isNumber } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class FunctionBuilder extends RawBuilder {}

function fn(...argsIn) {
  const { sql, args } = normalizeRawArgs(argsIn);
  return new FunctionBuilder(`${sql}(${args.map(() => '?').join(', ')})`, args);
}

for (const func of ['coalesce', 'concat', 'sum', 'avg', 'min', 'max', 'count', 'upper', 'lower']) {
  fn[func] = (...args) => fn(func.toUpperCase(), args);
}

fn.now = (precision) => {
  precision = parseInt(asSingle(precision), 10);

  if (isNaN(precision) || !isNumber(precision)) {
    precision = 6;
  }

  // We need to use a literal precision instead of a binding here
  // for the CURRENT_TIMESTAMP to work. This is okay here since we
  // make sure `precision` is a number. There's no chance of SQL
  // injection here.
  return new FunctionBuilder(`CURRENT_TIMESTAMP(${precision})`, []);
};

module.exports = {
  FunctionBuilder,
  fn,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/InternalOptions.js":
/***/ ((module) => {

"use strict";


class InternalOptions {
  constructor() {
    this.skipUndefined = false;
    this.keepImplicitJoinProps = false;
    this.returnImmediatelyValue = undefined;
    this.isInternalQuery = false;
    this.debug = false;
    this.schema = undefined;
  }

  clone() {
    const copy = new this.constructor();

    copy.skipUndefined = this.skipUndefined;
    copy.keepImplicitJoinProps = this.keepImplicitJoinProps;
    copy.returnImmediatelyValue = this.returnImmediatelyValue;
    copy.isInternalQuery = this.isInternalQuery;
    copy.debug = this.debug;
    copy.schema = this.schema;

    return copy;
  }
}

module.exports = {
  InternalOptions,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/JoinBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperationSupport } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderOperationSupport.js");
const { KnexOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/KnexOperation.js");

class JoinBuilder extends QueryBuilderOperationSupport {
  using(...args) {
    return this.addOperation(new KnexOperation('using'), args);
  }

  on(...args) {
    return this.addOperation(new KnexOperation('on'), args);
  }

  orOn(...args) {
    return this.addOperation(new KnexOperation('orOn'), args);
  }

  onBetween(...args) {
    return this.addOperation(new KnexOperation('onBetween'), args);
  }

  onNotBetween(...args) {
    return this.addOperation(new KnexOperation('onNotBetween'), args);
  }

  orOnBetween(...args) {
    return this.addOperation(new KnexOperation('orOnBetween'), args);
  }

  orOnNotBetween(...args) {
    return this.addOperation(new KnexOperation('orOnNotBetween'), args);
  }

  onIn(...args) {
    return this.addOperation(new KnexOperation('onIn'), args);
  }

  onNotIn(...args) {
    return this.addOperation(new KnexOperation('onNotIn'), args);
  }

  orOnIn(...args) {
    return this.addOperation(new KnexOperation('orOnIn'), args);
  }

  orOnNotIn(...args) {
    return this.addOperation(new KnexOperation('orOnNotIn'), args);
  }

  onNull(...args) {
    return this.addOperation(new KnexOperation('onNull'), args);
  }

  orOnNull(...args) {
    return this.addOperation(new KnexOperation('orOnNull'), args);
  }

  onNotNull(...args) {
    return this.addOperation(new KnexOperation('onNotNull'), args);
  }

  orOnNotNull(...args) {
    return this.addOperation(new KnexOperation('orOnNotNull'), args);
  }

  onExists(...args) {
    return this.addOperation(new KnexOperation('onExists'), args);
  }

  orOnExists(...args) {
    return this.addOperation(new KnexOperation('orOnExists'), args);
  }

  onNotExists(...args) {
    return this.addOperation(new KnexOperation('onNotExists'), args);
  }

  orOnNotExists(...args) {
    return this.addOperation(new KnexOperation('orOnNotExists'), args);
  }

  type(...args) {
    return this.addOperation(new KnexOperation('type'), args);
  }

  andOn(...args) {
    return this.addOperation(new KnexOperation('andOn'), args);
  }

  andOnIn(...args) {
    return this.addOperation(new KnexOperation('andOnIn'), args);
  }

  andOnNotIn(...args) {
    return this.addOperation(new KnexOperation('andOnNotIn'), args);
  }

  andOnNull(...args) {
    return this.addOperation(new KnexOperation('andOnNull'), args);
  }

  andOnNotNull(...args) {
    return this.addOperation(new KnexOperation('andOnNotNull'), args);
  }

  andOnExists(...args) {
    return this.addOperation(new KnexOperation('andOnExists'), args);
  }

  andOnNotExists(...args) {
    return this.addOperation(new KnexOperation('andOnNotExists'), args);
  }

  andOnBetween(...args) {
    return this.addOperation(new KnexOperation('andOnBetween'), args);
  }

  andOnNotBetween(...args) {
    return this.addOperation(new KnexOperation('andOnNotBetween'), args);
  }

  andOnJsonPathEquals(...args) {
    return this.addOperation(new KnexOperation('andOnJsonPathEquals'), args);
  }

  onVal(...args) {
    return this.addOperation(new KnexOperation('onVal'), args);
  }

  andOnVal(...args) {
    return this.addOperation(new KnexOperation('andOnVal'), args);
  }

  orOnVal(...args) {
    return this.addOperation(new KnexOperation('orOnVal'), args);
  }
}

module.exports = {
  JoinBuilder,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/QueryBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { wrapError } = __webpack_require__("./node_modules/db-errors/lib/dbErrors.js");

const { raw } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RawBuilder.js");
const { createModifier } = __webpack_require__("./node_modules/objection/lib/utils/createModifier.js");
const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { isObject, isString, isFunction, last, flatten } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { RelationExpression, DuplicateRelationError } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");
const { assertIdNotUndefined } = __webpack_require__("./node_modules/objection/lib/utils/assert.js");

const { Selection } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/select/Selection.js");

const { QueryBuilderContext } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderContext.js");
const { QueryBuilderBase } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderBase.js");

const { FindOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FindOperation.js");
const { DeleteOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DeleteOperation.js");
const { UpdateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js");
const { InsertOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertOperation.js");
const { RelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RelateOperation.js");
const { UnrelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UnrelateOperation.js");

const { JoinEagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/JoinEagerOperation.js");
const { NaiveEagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/NaiveEagerOperation.js");
const { WhereInEagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/WhereInEagerOperation.js");

const { InsertGraphAndFetchOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertGraphAndFetchOperation.js");
const { UpsertGraphAndFetchOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpsertGraphAndFetchOperation.js");
const { InsertAndFetchOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertAndFetchOperation.js");
const { UpdateAndFetchOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateAndFetchOperation.js");
const { JoinRelatedOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/JoinRelatedOperation.js");
const { OnBuildKnexOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/OnBuildKnexOperation.js");
const { InsertGraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertGraphOperation.js");
const { UpsertGraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpsertGraphOperation.js");
const { RunBeforeOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RunBeforeOperation.js");
const { RunAfterOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RunAfterOperation.js");
const { FindByIdOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FindByIdOperation.js");
const { FindByIdsOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FindByIdsOperation.js");
const { OnBuildOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/OnBuildOperation.js");
const { OnErrorOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/OnErrorOperation.js");
const { SelectOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/select/SelectOperation.js");
const { EagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/EagerOperation.js");
const { RangeOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RangeOperation.js");
const { FirstOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FirstOperation.js");
const { FromOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FromOperation.js");
const { KnexOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/KnexOperation.js");

class QueryBuilder extends QueryBuilderBase {
  static init(self, modelClass) {
    super.init(self, modelClass);

    self._resultModelClass = null;
    self._explicitRejectValue = null;
    self._explicitResolveValue = null;
    self._modifiers = {};

    self._allowedGraphExpression = null;
    self._findOperationOptions = modelClass.defaultFindOptions;
    self._relatedQueryFor = null;

    self._findOperationFactory = findOperationFactory;
    self._insertOperationFactory = insertOperationFactory;
    self._updateOperationFactory = updateOperationFactory;
    self._patchOperationFactory = patchOperationFactory;
    self._relateOperationFactory = relateOperationFactory;
    self._unrelateOperationFactory = unrelateOperationFactory;
    self._deleteOperationFactory = deleteOperationFactory;
  }

  static get QueryBuilderContext() {
    return QueryBuilderContext;
  }

  static parseRelationExpression(expr) {
    return RelationExpression.create(expr).toPojo();
  }

  tableNameFor(modelClassOrTableName, newTableName) {
    return super.tableNameFor(getTableName(modelClassOrTableName), newTableName);
  }

  tableName(newTableName) {
    return this.tableNameFor(this.modelClass().getTableName(), newTableName);
  }

  tableRef() {
    return this.tableRefFor(this.modelClass().getTableName());
  }

  aliasFor(modelClassOrTableName, alias) {
    return super.aliasFor(getTableName(modelClassOrTableName), alias);
  }

  alias(alias) {
    return this.aliasFor(this.modelClass().getTableName(), alias);
  }

  fullIdColumnFor(modelClass) {
    const tableName = this.tableRefFor(modelClass);
    const idColumn = modelClass.getIdColumn();

    if (Array.isArray(idColumn)) {
      return idColumn.map((col) => `${tableName}.${col}`);
    } else {
      return `${tableName}.${idColumn}`;
    }
  }

  fullIdColumn() {
    return this.fullIdColumnFor(this.modelClass());
  }

  modifiers(modifiers) {
    if (arguments.length === 0) {
      return { ...this._modifiers };
    } else {
      this._modifiers = { ...this._modifiers, ...modifiers };
      return this;
    }
  }

  modify(modifier, ...args) {
    if (!modifier) {
      return this;
    }

    modifier = createModifier({
      modifier,
      modelClass: this.modelClass(),
      modifiers: this._modifiers,
    });

    modifier(this, ...args);
    return this;
  }

  reject(error) {
    this._explicitRejectValue = error;
    return this;
  }

  resolve(value) {
    this._explicitResolveValue = value;
    return this;
  }

  isExplicitlyResolvedOrRejected() {
    return !!(this._explicitRejectValue || this._explicitResolveValue);
  }

  isExecutable() {
    return !this.isExplicitlyResolvedOrRejected() && !findQueryExecutorOperation(this);
  }

  findOperationFactory(factory) {
    this._findOperationFactory = factory;
    return this;
  }

  insertOperationFactory(factory) {
    this._insertOperationFactory = factory;
    return this;
  }

  updateOperationFactory(factory) {
    this._updateOperationFactory = factory;
    return this;
  }

  patchOperationFactory(factory) {
    this._patchOperationFactory = factory;
    return this;
  }

  deleteOperationFactory(factory) {
    this._deleteOperationFactory = factory;
    return this;
  }

  relateOperationFactory(factory) {
    this._relateOperationFactory = factory;
    return this;
  }

  unrelateOperationFactory(factory) {
    this._unrelateOperationFactory = factory;
    return this;
  }

  withGraphFetched(exp, options = {}) {
    return this._withGraph(exp, options, getWhereInEagerAlgorithm(this));
  }

  withGraphJoined(exp, options = {}) {
    return this._withGraph(exp, options, getJoinEagerAlgorithm(this));
  }

  _withGraph(exp, options, algorithm) {
    const eagerOp = ensureEagerOperation(this, algorithm);
    const parsedExp = parseRelationExpression(this.modelClass(), exp);

    eagerOp.expression = eagerOp.expression.merge(parsedExp);
    eagerOp.graphOptions = { ...eagerOp.graphOptions, ...options };

    checkEager(this);
    return this;
  }

  allowGraph(exp) {
    const currentExpr = this._allowedGraphExpression || RelationExpression.create();

    this._allowedGraphExpression = currentExpr.merge(
      parseRelationExpression(this.modelClass(), exp),
    );

    checkEager(this);
    return this;
  }

  allowedGraphExpression() {
    return this._allowedGraphExpression;
  }

  graphExpressionObject() {
    const eagerOp = this.findOperation(EagerOperation);

    if (eagerOp && !eagerOp.expression.isEmpty) {
      return eagerOp.expression.toPojo();
    } else {
      return null;
    }
  }

  graphModifiersAtPath() {
    const eagerOp = this.findOperation(EagerOperation);

    if (eagerOp && !eagerOp.expression.isEmpty) {
      return eagerOp.modifiersAtPath.map((it) => Object.assign({}, it));
    } else {
      return [];
    }
  }

  modifyGraph(path, modifier) {
    const eagerOp = ensureEagerOperation(this);
    eagerOp.modifiersAtPath.push({ path, modifier });
    return this;
  }

  findOptions(opt) {
    if (arguments.length !== 0) {
      this._findOperationOptions = Object.assign({}, this._findOperationOptions, opt);
      return this;
    } else {
      return this._findOperationOptions;
    }
  }

  resultModelClass() {
    return this._resultModelClass || this.modelClass();
  }

  isFind() {
    return !(
      this.isInsert() ||
      this.isUpdate() ||
      this.isDelete() ||
      this.isRelate() ||
      this.isUnrelate()
    );
  }

  isInsert() {
    return this.has(InsertOperation);
  }

  isUpdate() {
    return this.has(UpdateOperation);
  }

  isDelete() {
    return this.has(DeleteOperation);
  }

  isRelate() {
    return this.has(RelateOperation);
  }

  isUnrelate() {
    return this.has(UnrelateOperation);
  }

  hasWheres() {
    const queryWithoutGraph = this.clone().clearWithGraph();
    return prebuildQuery(queryWithoutGraph).has(QueryBuilderBase.WhereSelector);
  }

  hasSelects() {
    return this.has(QueryBuilderBase.SelectSelector);
  }

  hasWithGraph() {
    const eagerOp = this.findOperation(EagerOperation);
    return !!eagerOp && !eagerOp.expression.isEmpty;
  }

  isSelectAll() {
    if (this._operations.length === 0) {
      return true;
    }

    const tableRef = this.tableRef();
    const tableName = this.tableName();

    return this.everyOperation((op) => {
      if (op.constructor === SelectOperation) {
        // SelectOperations with zero selections are the ones that only have
        // raw items or other non-trivial selections.
        return (
          op.selections.length > 0 &&
          op.selections.every((select) => {
            return (!select.table || select.table === tableRef) && select.column === '*';
          })
        );
      } else if (op.constructor === FromOperation) {
        return op.table === tableName;
      } else if (op.name === 'as' || op.is(FindOperation) || op.is(OnErrorOperation)) {
        return true;
      } else {
        return false;
      }
    });
  }

  toString() {
    return '[object QueryBuilder]';
  }

  clone() {
    const builder = this.emptyInstance();

    // Call the super class's clone implementation.
    this.baseCloneInto(builder);

    builder._resultModelClass = this._resultModelClass;

    builder._explicitRejectValue = this._explicitRejectValue;
    builder._explicitResolveValue = this._explicitResolveValue;
    builder._modifiers = { ...this._modifiers };

    builder._allowedGraphExpression = this._allowedGraphExpression;
    builder._findOperationOptions = this._findOperationOptions;
    builder._relatedQueryFor = this._relatedQueryFor;

    return builder;
  }

  emptyInstance() {
    const builder = new this.constructor(this.modelClass());

    builder._findOperationFactory = this._findOperationFactory;
    builder._insertOperationFactory = this._insertOperationFactory;
    builder._updateOperationFactory = this._updateOperationFactory;
    builder._patchOperationFactory = this._patchOperationFactory;
    builder._relateOperationFactory = this._relateOperationFactory;
    builder._unrelateOperationFactory = this._unrelateOperationFactory;
    builder._deleteOperationFactory = this._deleteOperationFactory;
    builder._relatedQueryFor = this._relatedQueryFor;

    return builder;
  }

  clearWithGraph() {
    this.clear(EagerOperation);
    return this;
  }

  clearWithGraphFetched() {
    this.clear(WhereInEagerOperation);
    return this;
  }

  clearAllowGraph() {
    this._allowedGraphExpression = null;
    return this;
  }

  clearModifiers() {
    this._modifiers = {};
    return this;
  }

  clearReject() {
    this._explicitRejectValue = null;
    return this;
  }

  clearResolve() {
    this._explicitResolveValue = null;
    return this;
  }

  castTo(modelClass) {
    this._resultModelClass = modelClass || null;
    return this;
  }

  then(...args) {
    const promise = this.execute();
    return promise.then(...args);
  }

  catch(...args) {
    const promise = this.execute();
    return promise.catch(...args);
  }

  async resultSize() {
    const knex = this.knex();
    const builder = this.clone().clear(/orderBy|offset|limit/);

    const countQuery = knex.count('* as count').from((knexBuilder) => {
      builder.toKnexQuery(knexBuilder).as('temp');
    });

    if (this.internalOptions().debug) {
      countQuery.debug();
    }

    const result = await countQuery;
    return result[0] && result[0].count ? parseInt(result[0].count) : 0;
  }

  toKnexQuery(knexBuilder = this.knex().queryBuilder()) {
    const prebuiltQuery = prebuildQuery(this.clone());
    return buildKnexQuery(prebuiltQuery, knexBuilder);
  }

  async execute() {
    // Take a clone so that we don't modify this instance during execution.
    const builder = this.clone();

    try {
      await beforeExecute(builder);
      const result = await doExecute(builder);
      return await afterExecute(builder, result);
    } catch (error) {
      return await handleExecuteError(builder, error);
    }
  }

  throwIfNotFound(data = {}) {
    return this.runAfter((result) => {
      if (
        (Array.isArray(result) && result.length === 0) ||
        result === null ||
        result === undefined ||
        result === 0
      ) {
        throw this.modelClass().createNotFoundError(this.context(), data);
      } else {
        return result;
      }
    });
  }

  findSelection(selection, explicit = false) {
    let noSelectStatements = true;
    let selectionInstance = null;

    this.forEachOperation(true, (op) => {
      if (op.constructor === SelectOperation) {
        selectionInstance = op.findSelection(this, selection);
        noSelectStatements = false;

        if (selectionInstance) {
          return false;
        }
      }
    });

    if (selectionInstance) {
      return selectionInstance;
    }

    if (noSelectStatements && !explicit) {
      const selectAll = new Selection(this.tableRef(), '*');

      if (Selection.doesSelect(this, selectAll, selection)) {
        return selectAll;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }

  findAllSelections() {
    let allSelections = [];

    this.forEachOperation(true, (op) => {
      if (op.constructor === SelectOperation) {
        allSelections = allSelections.concat(op.selections);
      }
    });

    return allSelections;
  }

  hasSelection(selection, explicit) {
    return this.findSelection(selection, explicit) !== null;
  }

  hasSelectionAs(selection, alias, explicit) {
    selection = Selection.create(selection);
    const foundSelection = this.findSelection(selection, explicit);

    if (foundSelection === null) {
      return false;
    } else {
      if (foundSelection.column === '*') {
        // * selects the columns with their column names as aliases.
        return selection.column === alias;
      } else {
        return foundSelection.name === alias;
      }
    }
  }

  traverse(modelClass, traverser) {
    if (typeof traverser === 'undefined') {
      traverser = modelClass;
      modelClass = null;
    }

    return this.runAfter((result) => {
      this.resultModelClass().traverse(modelClass, result, traverser);
      return result;
    });
  }

  page(page, pageSize) {
    return this.range(+page * +pageSize, (+page + 1) * +pageSize - 1);
  }

  columnInfo({ table = null } = {}) {
    table = table || this.tableName();

    const knex = this.knex();
    const tableParts = table.split('.');
    const columnInfoQuery = knex(last(tableParts)).columnInfo();
    const schema = this.internalOptions().schema;

    if (schema) {
      columnInfoQuery.withSchema(schema);
    } else if (tableParts.length > 1) {
      columnInfoQuery.withSchema(tableParts[0]);
    }

    if (this.internalOptions().debug) {
      columnInfoQuery.debug();
    }

    return columnInfoQuery;
  }

  withSchema(schema) {
    this.internalOptions().schema = schema;
    this.internalContext().onBuild.push((builder) => {
      if (!builder.has(/withSchema/)) {
        // Need to push this operation to the front because knex doesn't use the
        // schema for operations called before `withSchema`.
        builder.addOperationToFront(new KnexOperation('withSchema'), [schema]);
      }
    });

    return this;
  }

  debug /* istanbul ignore next */() {
    this.internalOptions().debug = true;
    this.internalContext().onBuild.push((builder) => {
      builder.addOperation(new KnexOperation('debug'), []);
    });

    return this;
  }

  insert(modelsOrObjects) {
    return writeOperation(this, () => {
      const insertOperation = this._insertOperationFactory(this);

      this.addOperation(insertOperation, [modelsOrObjects]);
    });
  }

  insertAndFetch(modelsOrObjects) {
    return writeOperation(this, () => {
      const insertOperation = this._insertOperationFactory(this);

      const insertAndFetchOperation = new InsertAndFetchOperation('insertAndFetch', {
        delegate: insertOperation,
      });

      this.addOperation(insertAndFetchOperation, [modelsOrObjects]);
    });
  }

  insertGraph(modelsOrObjects, opt) {
    return writeOperation(this, () => {
      const insertOperation = this._insertOperationFactory(this);

      const insertGraphOperation = new InsertGraphOperation('insertGraph', {
        delegate: insertOperation,
        opt,
      });

      this.addOperation(insertGraphOperation, [modelsOrObjects]);
    });
  }

  insertGraphAndFetch(modelsOrObjects, opt) {
    return writeOperation(this, () => {
      const insertOperation = this._insertOperationFactory(this);

      const insertGraphOperation = new InsertGraphOperation('insertGraph', {
        delegate: insertOperation,
        opt,
      });

      const insertGraphAndFetchOperation = new InsertGraphAndFetchOperation('insertGraphAndFetch', {
        delegate: insertGraphOperation,
      });

      return this.addOperation(insertGraphAndFetchOperation, [modelsOrObjects]);
    });
  }

  update(modelOrObject) {
    return writeOperation(this, () => {
      const updateOperation = this._updateOperationFactory(this);

      this.addOperation(updateOperation, [modelOrObject]);
    });
  }

  updateAndFetch(modelOrObject) {
    return writeOperation(this, () => {
      const updateOperation = this._updateOperationFactory(this);

      if (!(updateOperation.instance instanceof this.modelClass())) {
        throw new Error('updateAndFetch can only be called for instance operations');
      }

      const updateAndFetch = new UpdateAndFetchOperation('updateAndFetch', {
        delegate: updateOperation,
      });

      // patchOperation is an instance update operation that already adds the
      // required "where id = $" clause.
      updateAndFetch.skipIdWhere = true;

      this.addOperation(updateAndFetch, [updateOperation.instance.$id(), modelOrObject]);
    });
  }

  updateAndFetchById(id, modelOrObject) {
    return writeOperation(this, () => {
      const updateOperation = this._updateOperationFactory(this);

      const updateAndFetch = new UpdateAndFetchOperation('updateAndFetch', {
        delegate: updateOperation,
      });

      this.addOperation(updateAndFetch, [id, modelOrObject]);
    });
  }

  upsertGraph(modelsOrObjects, upsertOptions) {
    return writeOperation(this, () => {
      const upsertGraphOperation = new UpsertGraphOperation('upsertGraph', {
        upsertOptions,
      });

      this.addOperation(upsertGraphOperation, [modelsOrObjects]);
    });
  }

  upsertGraphAndFetch(modelsOrObjects, upsertOptions) {
    return writeOperation(this, () => {
      const upsertGraphOperation = new UpsertGraphOperation('upsertGraph', {
        upsertOptions,
      });

      const upsertGraphAndFetchOperation = new UpsertGraphAndFetchOperation('upsertGraphAndFetch', {
        delegate: upsertGraphOperation,
      });

      return this.addOperation(upsertGraphAndFetchOperation, [modelsOrObjects]);
    });
  }

  patch(modelOrObject) {
    return writeOperation(this, () => {
      const patchOperation = this._patchOperationFactory(this);

      this.addOperation(patchOperation, [modelOrObject]);
    });
  }

  patchAndFetch(modelOrObject) {
    return writeOperation(this, () => {
      const patchOperation = this._patchOperationFactory(this);

      if (!(patchOperation.instance instanceof this.modelClass())) {
        throw new Error('patchAndFetch can only be called for instance operations');
      }

      const patchAndFetch = new UpdateAndFetchOperation('patchAndFetch', {
        delegate: patchOperation,
      });

      // patchOperation is an instance update operation that already adds the
      // required "where id = $" clause.
      patchAndFetch.skipIdWhere = true;

      this.addOperation(patchAndFetch, [patchOperation.instance.$id(), modelOrObject]);
    });
  }

  patchAndFetchById(id, modelOrObject) {
    return writeOperation(this, () => {
      const patchOperation = this._patchOperationFactory(this);

      const patchAndFetch = new UpdateAndFetchOperation('patchAndFetch', {
        delegate: patchOperation,
      });

      this.addOperation(patchAndFetch, [id, modelOrObject]);
    });
  }

  delete(...args) {
    return writeOperation(this, () => {
      if (args.length) {
        throw new Error(
          `Don't pass arguments to delete(). You should use it like this: delete().where('foo', 'bar').andWhere(...)`,
        );
      }

      const deleteOperation = this._deleteOperationFactory(this);
      this.addOperation(deleteOperation, args);
    });
  }

  del(...args) {
    return this.delete(...args);
  }

  relate(...args) {
    return writeOperation(this, () => {
      const relateOperation = this._relateOperationFactory(this);

      this.addOperation(relateOperation, args);
    });
  }

  unrelate(...args) {
    return writeOperation(this, () => {
      if (args.length) {
        throw new Error(
          `Don't pass arguments to unrelate(). You should use it like this: unrelate().where('foo', 'bar').andWhere(...)`,
        );
      }

      const unrelateOperation = this._unrelateOperationFactory(this);
      this.addOperation(unrelateOperation, args);
    });
  }

  increment(propertyName, howMuch) {
    const columnName = this.modelClass().propertyNameToColumnName(propertyName);

    return this.patch({
      [columnName]: raw('?? + ?', [columnName, howMuch]),
    });
  }

  decrement(propertyName, howMuch) {
    const columnName = this.modelClass().propertyNameToColumnName(propertyName);

    return this.patch({
      [columnName]: raw('?? - ?', [columnName, howMuch]),
    });
  }

  findOne(...args) {
    return this.where.apply(this, args).first();
  }

  range(...args) {
    return this.clear(RangeOperation).addOperation(new RangeOperation('range'), args);
  }

  first(...args) {
    return this.addOperation(new FirstOperation('first'), args);
  }

  joinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'innerJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  innerJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'innerJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  outerJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'outerJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  fullOuterJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'fullOuterJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  leftJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'leftJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  leftOuterJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'leftOuterJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  rightJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'rightJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  rightOuterJoinRelated(expression, options) {
    ensureJoinRelatedOperation(this, 'rightOuterJoin').addCall({
      expression,
      options,
    });

    return this;
  }

  deleteById(id) {
    return this.findById(id)
      .delete()
      .runBefore((_, builder) => {
        if (!builder.internalOptions().skipUndefined) {
          assertIdNotUndefined(id, `undefined was passed to deleteById`);
        }
      });
  }

  findById(...args) {
    return this.addOperation(new FindByIdOperation('findById'), args).first();
  }

  findByIds(...args) {
    return this.addOperation(new FindByIdsOperation('findByIds'), args);
  }

  runBefore(...args) {
    return this.addOperation(new RunBeforeOperation('runBefore'), args);
  }

  onBuild(...args) {
    return this.addOperation(new OnBuildOperation('onBuild'), args);
  }

  onBuildKnex(...args) {
    return this.addOperation(new OnBuildKnexOperation('onBuildKnex'), args);
  }

  runAfter(...args) {
    return this.addOperation(new RunAfterOperation('runAfter'), args);
  }

  onError(...args) {
    return this.addOperation(new OnErrorOperation('onError'), args);
  }

  from(...args) {
    return this.addOperation(new FromOperation('from'), args);
  }

  table(...args) {
    return this.addOperation(new FromOperation('table'), args);
  }

  for(relatedQueryFor) {
    if (arguments.length === 0) {
      return this._relatedQueryFor;
    } else {
      this._relatedQueryFor = relatedQueryFor;
      return this;
    }
  }
}

Object.defineProperties(QueryBuilder.prototype, {
  isObjectionQueryBuilder: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

function getTableName(modelClassOrTableName) {
  if (isString(modelClassOrTableName)) {
    return modelClassOrTableName;
  } else {
    return modelClassOrTableName.getTableName();
  }
}

function ensureEagerOperation(builder, algorithm = null) {
  const modelClass = builder.modelClass();
  const defaultGraphOptions = modelClass.getDefaultGraphOptions();
  const eagerOp = builder.findOperation(EagerOperation);

  if (algorithm) {
    const EagerOperationClass = getOperationClassForEagerAlgorithm(builder, algorithm);

    if (eagerOp instanceof EagerOperationClass) {
      return eagerOp;
    } else {
      const newEagerOp = new EagerOperationClass('eager', {
        defaultGraphOptions,
      });

      if (eagerOp) {
        newEagerOp.cloneFrom(eagerOp);
      }

      builder.clear(EagerOperation);
      builder.addOperation(newEagerOp);

      return newEagerOp;
    }
  } else {
    if (eagerOp) {
      return eagerOp;
    } else {
      const EagerOperationClass = getOperationClassForEagerAlgorithm(
        builder,
        getWhereInEagerAlgorithm(builder),
      );

      const newEagerOp = new EagerOperationClass('eager', {
        defaultGraphOptions,
      });

      builder.addOperation(newEagerOp);

      return newEagerOp;
    }
  }
}

function getWhereInEagerAlgorithm(builder) {
  return builder.modelClass().WhereInEagerAlgorithm;
}

function getJoinEagerAlgorithm(builder) {
  return builder.modelClass().JoinEagerAlgorithm;
}

function getNaiveEagerAlgorithm(builder) {
  return builder.modelClass().NaiveEagerAlgorithm;
}

function getOperationClassForEagerAlgorithm(builder, algorithm) {
  if (algorithm === getJoinEagerAlgorithm(builder)) {
    return JoinEagerOperation;
  } else if (algorithm === getNaiveEagerAlgorithm(builder)) {
    return NaiveEagerOperation;
  } else {
    return WhereInEagerOperation;
  }
}

function parseRelationExpression(modelClass, exp) {
  try {
    return RelationExpression.create(exp);
  } catch (err) {
    if (err instanceof DuplicateRelationError) {
      throw modelClass.createValidationError({
        type: ValidationErrorType.RelationExpression,
        message: `Duplicate relation name "${err.relationName}" in relation expression "${exp}". For example, use "${err.relationName}.[foo, bar]" instead of "[${err.relationName}.foo, ${err.relationName}.bar]".`,
      });
    } else {
      throw modelClass.createValidationError({
        type: ValidationErrorType.RelationExpression,
        message: `Invalid relation expression "${exp}"`,
      });
    }
  }
}

function checkEager(builder) {
  const eagerOp = builder.findOperation(EagerOperation);

  if (!eagerOp) {
    return;
  }

  const expr = eagerOp.expression;
  const allowedExpr = builder.allowedGraphExpression();

  if (expr.numChildren > 0 && allowedExpr && !allowedExpr.isSubExpression(expr)) {
    const modelClass = builder.modelClass();

    builder.reject(
      modelClass.createValidationError({
        type: ValidationErrorType.UnallowedRelation,
        message: 'eager expression not allowed',
      }),
    );
  }
}

function findQueryExecutorOperation(builder) {
  return builder.findOperation((op) => op.hasQueryExecutor());
}

function beforeExecute(builder) {
  let promise = Promise.resolve();

  builder = addImplicitOperations(builder);

  // Resolve all before hooks before building and executing the query
  // and the rest of the hooks.
  promise = chainOperationHooks(promise, builder, 'onBefore1');
  promise = chainOperationHooks(promise, builder, 'onBefore2');

  promise = chainHooks(promise, builder, builder.context().runBefore);
  promise = chainHooks(promise, builder, builder.internalContext().runBefore);

  promise = chainOperationHooks(promise, builder, 'onBefore3');

  return promise;
}

function doExecute(builder) {
  let promise = Promise.resolve();

  builder = callOnBuildHooks(builder);
  const queryExecutorOperation = findQueryExecutorOperation(builder);

  const explicitRejectValue = builder._explicitRejectValue;
  const explicitResolveValue = builder._explicitResolveValue;

  if (explicitRejectValue !== null) {
    promise = Promise.reject(explicitRejectValue);
  } else if (explicitResolveValue !== null) {
    promise = Promise.resolve(explicitResolveValue);
  } else if (queryExecutorOperation !== null) {
    promise = Promise.resolve(queryExecutorOperation.queryExecutor(builder));
  } else {
    promise = Promise.resolve(buildKnexQuery(builder));

    promise = chainOperationHooks(promise, builder, 'onRawResult');
    promise = promise.then((result) => createModels(result, builder));
  }

  return promise;
}

function afterExecute(builder, result) {
  let promise = Promise.resolve(result);

  promise = chainOperationHooks(promise, builder, 'onAfter1');
  promise = chainOperationHooks(promise, builder, 'onAfter2');

  promise = chainHooks(promise, builder, builder.context().runAfter);
  promise = chainHooks(promise, builder, builder.internalContext().runAfter);

  promise = chainOperationHooks(promise, builder, 'onAfter3');

  return promise;
}

class ReturnImmediatelyException {
  constructor(value) {
    this.value = value;
  }
}

function handleReturnImmediatelyValue(builder) {
  const { returnImmediatelyValue } = builder.internalOptions();
  if (returnImmediatelyValue !== undefined) {
    throw new ReturnImmediatelyException(returnImmediatelyValue);
  }
}

function handleExecuteError(builder, err) {
  if (err instanceof ReturnImmediatelyException) {
    return Promise.resolve(err.value);
  }

  let promise = Promise.reject(wrapError(err));

  builder.forEachOperation(true, (op) => {
    if (op.hasOnError()) {
      promise = promise.catch((err) =>
        builder.callAsyncOperationMethod(op, 'onError', [builder, err]),
      );
    }
  });

  return promise;
}

function chainOperationHooks(promise, builder, hookName) {
  return promise.then((result) => {
    let promise = Promise.resolve(result);

    builder.forEachOperation(true, (op) => {
      if (op.hasHook(hookName)) {
        promise = promise.then((result) => {
          const res = builder.callAsyncOperationMethod(op, hookName, [builder, result]);
          handleReturnImmediatelyValue(builder);
          return res;
        });
      }
    });

    return promise;
  });
}

function ensureJoinRelatedOperation(builder, joinOperation) {
  const opName = joinOperation + 'Relation';
  let op = builder.findOperation(opName);

  if (!op) {
    op = new JoinRelatedOperation(opName, { joinOperation });
    builder.addOperation(op);
  }

  return op;
}

function prebuildQuery(builder) {
  builder = addImplicitOperations(builder);
  builder = callOnBuildHooks(builder);

  const queryExecutorOperation = findQueryExecutorOperation(builder);

  if (queryExecutorOperation) {
    return prebuildQuery(queryExecutorOperation.queryExecutor(builder));
  } else {
    return builder;
  }
}

function addImplicitOperations(builder) {
  if (builder.isFind()) {
    // If no write operations have been called at this point this query is a
    // find query and we need to call the custom find implementation.
    addFindOperation(builder);
  }

  if (builder.hasWithGraph()) {
    moveEagerOperationToEnd(builder);
  }

  return builder;
}

function addFindOperation(builder) {
  if (!builder.has(FindOperation)) {
    const operation = builder._findOperationFactory(builder);
    builder.addOperationToFront(operation, []);
  }
}

function moveEagerOperationToEnd(builder) {
  const eagerOp = builder.findOperation(EagerOperation);

  builder.clear(EagerOperation);
  builder.addOperation(eagerOp);
}

function callOnBuildHooks(builder) {
  callOnBuildFuncs(builder, builder.context().onBuild);
  callOnBuildFuncs(builder, builder.internalContext().onBuild);

  builder.executeOnBuild();
  return builder;
}

function callOnBuildFuncs(builder, func) {
  if (isFunction(func)) {
    func.call(builder, builder);
  } else if (Array.isArray(func)) {
    func.forEach((func) => callOnBuildFuncs(builder, func));
  }
}

function buildKnexQuery(builder, knexBuilder = builder.knex().queryBuilder()) {
  knexBuilder = builder.executeOnBuildKnex(knexBuilder);

  const fromOperation = builder.findLastOperation(QueryBuilderBase.FromSelector);

  if (!builder.isPartial()) {
    // Set the table only if it hasn't been explicitly set yet.
    if (!fromOperation) {
      knexBuilder = setDefaultTable(builder, knexBuilder);
    }

    // Only add `table.*` select if there are no explicit selects
    // and `from` is a table name and not a subquery.
    if (!builder.hasSelects() && (!fromOperation || fromOperation.table)) {
      knexBuilder = setDefaultSelect(builder, knexBuilder);
    }
  }

  return knexBuilder;
}

function setDefaultTable(builder, knexBuilder) {
  const table = builder.tableName();
  const tableRef = builder.tableRef();

  if (table === tableRef) {
    return knexBuilder.table(table);
  } else {
    return knexBuilder.table(`${table} as ${tableRef}`);
  }
}

function setDefaultSelect(builder, knexBuilder) {
  const tableRef = builder.tableRef();

  return knexBuilder.select(`${tableRef}.*`);
}

async function chainHooks(promise, builder, func) {
  return promise.then((result) => {
    let promise = Promise.resolve(result);

    if (isFunction(func)) {
      promise = promise.then((result) => {
        const res = func.call(builder, result, builder);
        handleReturnImmediatelyValue(builder);
        return res;
      });
    } else if (Array.isArray(func)) {
      func.forEach((func) => {
        promise = chainHooks(promise, builder, func);
      });
    }

    return promise;
  });
}

function createModels(result, builder) {
  if (result === null || result === undefined) {
    return null;
  }

  if (builder.isInsert()) {
    // results are applied to input models in `InsertOperation.onAfter1` instead.
    return result;
  }

  const modelClass = builder.resultModelClass();

  if (Array.isArray(result)) {
    if (result.length && shouldBeConvertedToModel(result[0], modelClass)) {
      for (let i = 0, l = result.length; i < l; ++i) {
        result[i] = modelClass.fromDatabaseJson(result[i]);
      }
    }
  } else if (shouldBeConvertedToModel(result, modelClass)) {
    result = modelClass.fromDatabaseJson(result);
  }

  return result;
}

function shouldBeConvertedToModel(obj, modelClass) {
  return isObject(obj) && !(obj instanceof modelClass);
}

function writeOperation(builder, cb) {
  if (!builder.isFind()) {
    return builder.reject(
      new Error(
        'Double call to a write method. ' +
          'You can only call one of the write methods ' +
          '(insert, update, patch, delete, relate, unrelate, increment, decrement) ' +
          'and only once per query builder.',
      ),
    );
  }

  try {
    cb();
    return builder;
  } catch (err) {
    return builder.reject(err);
  }
}

function findOperationFactory() {
  return new FindOperation('find');
}

function insertOperationFactory() {
  return new InsertOperation('insert');
}

function updateOperationFactory() {
  return new UpdateOperation('update');
}

function patchOperationFactory() {
  return new UpdateOperation('patch', {
    modelOptions: { patch: true },
  });
}

function relateOperationFactory() {
  return new RelateOperation('relate', {});
}

function unrelateOperationFactory() {
  return new UnrelateOperation('unrelate', {});
}

function deleteOperationFactory() {
  return new DeleteOperation('delete');
}

module.exports = {
  QueryBuilder,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/QueryBuilderBase.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperationSupport } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderOperationSupport.js");
const { isSqlite, isMsSql } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");

const { KnexOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/KnexOperation.js");
const { MergeOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/MergeOperation.js");
const { SelectOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/select/SelectOperation.js");
const { ReturningOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ReturningOperation.js");
const { WhereCompositeOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/WhereCompositeOperation.js");
const { WhereJsonPostgresOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonPostgresOperation.js");

const {
  WhereInCompositeOperation,
} = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeOperation.js");
const {
  WhereInCompositeSqliteOperation,
} = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeSqliteOperation.js");
const {
  WhereInCompositeMsSqlOperation,
} = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeMsSqlOperation.js");
const {
  WhereJsonHasPostgresOperation,
} = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonHasPostgresOperation.js");
const {
  WhereJsonNotObjectPostgresOperation,
} = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonNotObjectPostgresOperation.js");

class QueryBuilderBase extends QueryBuilderOperationSupport {
  modify(...args) {
    const func = args[0];

    if (!func) {
      return this;
    }

    if (args.length === 1) {
      func.call(this, this);
    } else {
      args[0] = this;
      func(...args);
    }

    return this;
  }

  transacting(trx) {
    this._context.knex = trx || null;
    return this;
  }

  select(...args) {
    return this.addOperation(new SelectOperation('select'), args);
  }

  insert(...args) {
    return this.addOperation(new KnexOperation('insert'), args);
  }

  update(...args) {
    return this.addOperation(new KnexOperation('update'), args);
  }

  delete(...args) {
    return this.addOperation(new KnexOperation('delete'), args);
  }

  del(...args) {
    return this.delete(...args);
  }

  forUpdate(...args) {
    return this.addOperation(new KnexOperation('forUpdate'), args);
  }

  forShare(...args) {
    return this.addOperation(new KnexOperation('forShare'), args);
  }

  forNoKeyUpdate(...args) {
    return this.addOperation(new KnexOperation('forNoKeyUpdate'), args);
  }

  forKeyShare(...args) {
    return this.addOperation(new KnexOperation('forKeyShare'), args);
  }

  skipLocked(...args) {
    return this.addOperation(new KnexOperation('skipLocked'), args);
  }

  noWait(...args) {
    return this.addOperation(new KnexOperation('noWait'), args);
  }

  as(...args) {
    return this.addOperation(new KnexOperation('as'), args);
  }

  columns(...args) {
    return this.addOperation(new SelectOperation('columns'), args);
  }

  column(...args) {
    return this.addOperation(new SelectOperation('column'), args);
  }

  from(...args) {
    return this.addOperation(new KnexOperation('from'), args);
  }

  fromJS(...args) {
    return this.addOperation(new KnexOperation('fromJS'), args);
  }

  fromRaw(...args) {
    return this.addOperation(new KnexOperation('fromRaw'), args);
  }

  into(...args) {
    return this.addOperation(new KnexOperation('into'), args);
  }

  withSchema(...args) {
    return this.addOperation(new KnexOperation('withSchema'), args);
  }

  table(...args) {
    return this.addOperation(new KnexOperation('table'), args);
  }

  distinct(...args) {
    return this.addOperation(new SelectOperation('distinct'), args);
  }

  distinctOn(...args) {
    return this.addOperation(new SelectOperation('distinctOn'), args);
  }

  join(...args) {
    return this.addOperation(new KnexOperation('join'), args);
  }

  joinRaw(...args) {
    return this.addOperation(new KnexOperation('joinRaw'), args);
  }

  innerJoin(...args) {
    return this.addOperation(new KnexOperation('innerJoin'), args);
  }

  leftJoin(...args) {
    return this.addOperation(new KnexOperation('leftJoin'), args);
  }

  leftOuterJoin(...args) {
    return this.addOperation(new KnexOperation('leftOuterJoin'), args);
  }

  rightJoin(...args) {
    return this.addOperation(new KnexOperation('rightJoin'), args);
  }

  rightOuterJoin(...args) {
    return this.addOperation(new KnexOperation('rightOuterJoin'), args);
  }

  outerJoin(...args) {
    return this.addOperation(new KnexOperation('outerJoin'), args);
  }

  fullOuterJoin(...args) {
    return this.addOperation(new KnexOperation('fullOuterJoin'), args);
  }

  crossJoin(...args) {
    return this.addOperation(new KnexOperation('crossJoin'), args);
  }

  where(...args) {
    return this.addOperation(new KnexOperation('where'), args);
  }

  andWhere(...args) {
    return this.addOperation(new KnexOperation('andWhere'), args);
  }

  orWhere(...args) {
    return this.addOperation(new KnexOperation('orWhere'), args);
  }

  whereNot(...args) {
    return this.addOperation(new KnexOperation('whereNot'), args);
  }

  andWhereNot(...args) {
    return this.addOperation(new KnexOperation('andWhereNot'), args);
  }

  orWhereNot(...args) {
    return this.addOperation(new KnexOperation('orWhereNot'), args);
  }

  whereRaw(...args) {
    return this.addOperation(new KnexOperation('whereRaw'), args);
  }

  andWhereRaw(...args) {
    return this.addOperation(new KnexOperation('andWhereRaw'), args);
  }

  orWhereRaw(...args) {
    return this.addOperation(new KnexOperation('orWhereRaw'), args);
  }

  whereWrapped(...args) {
    return this.addOperation(new KnexOperation('whereWrapped'), args);
  }

  havingWrapped(...args) {
    return this.addOperation(new KnexOperation('havingWrapped'), args);
  }

  whereExists(...args) {
    return this.addOperation(new KnexOperation('whereExists'), args);
  }

  orWhereExists(...args) {
    return this.addOperation(new KnexOperation('orWhereExists'), args);
  }

  whereNotExists(...args) {
    return this.addOperation(new KnexOperation('whereNotExists'), args);
  }

  orWhereNotExists(...args) {
    return this.addOperation(new KnexOperation('orWhereNotExists'), args);
  }

  whereIn(...args) {
    return this.addOperation(new KnexOperation('whereIn'), args);
  }

  orWhereIn(...args) {
    return this.addOperation(new KnexOperation('orWhereIn'), args);
  }

  whereNotIn(...args) {
    return this.addOperation(new KnexOperation('whereNotIn'), args);
  }

  orWhereNotIn(...args) {
    return this.addOperation(new KnexOperation('orWhereNotIn'), args);
  }

  whereNull(...args) {
    return this.addOperation(new KnexOperation('whereNull'), args);
  }

  orWhereNull(...args) {
    return this.addOperation(new KnexOperation('orWhereNull'), args);
  }

  whereNotNull(...args) {
    return this.addOperation(new KnexOperation('whereNotNull'), args);
  }

  orWhereNotNull(...args) {
    return this.addOperation(new KnexOperation('orWhereNotNull'), args);
  }

  whereBetween(...args) {
    return this.addOperation(new KnexOperation('whereBetween'), args);
  }

  andWhereBetween(...args) {
    return this.addOperation(new KnexOperation('andWhereBetween'), args);
  }

  whereNotBetween(...args) {
    return this.addOperation(new KnexOperation('whereNotBetween'), args);
  }

  andWhereNotBetween(...args) {
    return this.addOperation(new KnexOperation('andWhereNotBetween'), args);
  }

  orWhereBetween(...args) {
    return this.addOperation(new KnexOperation('orWhereBetween'), args);
  }

  orWhereNotBetween(...args) {
    return this.addOperation(new KnexOperation('orWhereNotBetween'), args);
  }

  whereLike(...args) {
    return this.addOperation(new KnexOperation('whereLike'), args);
  }

  andWhereLike(...args) {
    return this.addOperation(new KnexOperation('andWhereLike'), args);
  }

  orWhereLike(...args) {
    return this.addOperation(new KnexOperation('orWhereLike'), args);
  }

  whereILike(...args) {
    return this.addOperation(new KnexOperation('whereILike'), args);
  }

  andWhereILike(...args) {
    return this.addOperation(new KnexOperation('andWhereILike'), args);
  }

  orWhereILike(...args) {
    return this.addOperation(new KnexOperation('orWhereILike'), args);
  }

  groupBy(...args) {
    return this.addOperation(new KnexOperation('groupBy'), args);
  }

  groupByRaw(...args) {
    return this.addOperation(new KnexOperation('groupByRaw'), args);
  }

  orderBy(...args) {
    return this.addOperation(new KnexOperation('orderBy'), args);
  }

  orderByRaw(...args) {
    return this.addOperation(new KnexOperation('orderByRaw'), args);
  }

  union(...args) {
    return this.addOperation(new KnexOperation('union'), args);
  }

  unionAll(...args) {
    return this.addOperation(new KnexOperation('unionAll'), args);
  }

  intersect(...args) {
    return this.addOperation(new KnexOperation('intersect'), args);
  }

  except(...args) {
    return this.addOperation(new KnexOperation('except'), args);
  }

  having(...args) {
    return this.addOperation(new KnexOperation('having'), args);
  }

  clearHaving(...args) {
    return this.addOperation(new KnexOperation('clearHaving'), args);
  }

  clearGroup(...args) {
    return this.addOperation(new KnexOperation('clearGroup'), args);
  }

  orHaving(...args) {
    return this.addOperation(new KnexOperation('orHaving'), args);
  }

  havingIn(...args) {
    return this.addOperation(new KnexOperation('havingIn'), args);
  }

  orHavingIn(...args) {
    return this.addOperation(new KnexOperation('havingIn'), args);
  }

  havingNotIn(...args) {
    return this.addOperation(new KnexOperation('havingNotIn'), args);
  }

  orHavingNotIn(...args) {
    return this.addOperation(new KnexOperation('orHavingNotIn'), args);
  }

  havingNull(...args) {
    return this.addOperation(new KnexOperation('havingNull'), args);
  }

  orHavingNull(...args) {
    return this.addOperation(new KnexOperation('orHavingNull'), args);
  }

  havingNotNull(...args) {
    return this.addOperation(new KnexOperation('havingNotNull'), args);
  }

  orHavingNotNull(...args) {
    return this.addOperation(new KnexOperation('orHavingNotNull'), args);
  }

  havingExists(...args) {
    return this.addOperation(new KnexOperation('havingExists'), args);
  }

  orHavingExists(...args) {
    return this.addOperation(new KnexOperation('orHavingExists'), args);
  }

  havingNotExists(...args) {
    return this.addOperation(new KnexOperation('havingNotExists'), args);
  }

  orHavingNotExists(...args) {
    return this.addOperation(new KnexOperation('orHavingNotExists'), args);
  }

  havingBetween(...args) {
    return this.addOperation(new KnexOperation('havingBetween'), args);
  }

  orHavingBetween(...args) {
    return this.addOperation(new KnexOperation('havingBetween'), args);
  }

  havingNotBetween(...args) {
    return this.addOperation(new KnexOperation('havingNotBetween'), args);
  }

  orHavingNotBetween(...args) {
    return this.addOperation(new KnexOperation('havingNotBetween'), args);
  }

  havingRaw(...args) {
    return this.addOperation(new KnexOperation('havingRaw'), args);
  }

  orHavingRaw(...args) {
    return this.addOperation(new KnexOperation('orHavingRaw'), args);
  }

  offset(...args) {
    return this.addOperation(new KnexOperation('offset'), args);
  }

  limit(...args) {
    return this.addOperation(new KnexOperation('limit'), args);
  }

  count(...args) {
    return this.addOperation(new SelectOperation('count'), args);
  }

  countDistinct(...args) {
    return this.addOperation(new SelectOperation('countDistinct'), args);
  }

  min(...args) {
    return this.addOperation(new SelectOperation('min'), args);
  }

  max(...args) {
    return this.addOperation(new SelectOperation('max'), args);
  }

  sum(...args) {
    return this.addOperation(new SelectOperation('sum'), args);
  }

  sumDistinct(...args) {
    return this.addOperation(new SelectOperation('sumDistinct'), args);
  }

  avg(...args) {
    return this.addOperation(new SelectOperation('avg'), args);
  }

  avgDistinct(...args) {
    return this.addOperation(new SelectOperation('avgDistinct'), args);
  }

  debug(...args) {
    return this.addOperation(new KnexOperation('debug'), args);
  }

  returning(...args) {
    return this.addOperation(new ReturningOperation('returning'), args);
  }

  truncate(...args) {
    return this.addOperation(new KnexOperation('truncate'), args);
  }

  connection(...args) {
    return this.addOperation(new KnexOperation('connection'), args);
  }

  options(...args) {
    return this.addOperation(new KnexOperation('options'), args);
  }

  columnInfo(...args) {
    return this.addOperation(new KnexOperation('columnInfo'), args);
  }

  off(...args) {
    return this.addOperation(new KnexOperation('off'), args);
  }

  timeout(...args) {
    return this.addOperation(new KnexOperation('timeout'), args);
  }

  with(...args) {
    return this.addOperation(new KnexOperation('with'), args);
  }

  withWrapped(...args) {
    return this.addOperation(new KnexOperation('withWrapped'), args);
  }

  withRecursive(...args) {
    return this.addOperation(new KnexOperation('withRecursive'), args);
  }

  withMaterialized(...args) {
    return this.addOperation(new KnexOperation('withMaterialized'), args);
  }

  withNotMaterialized(...args) {
    return this.addOperation(new KnexOperation('withNotMaterialized'), args);
  }

  whereComposite(...args) {
    return this.addOperation(new WhereCompositeOperation('whereComposite'), args);
  }

  whereInComposite(...args) {
    let operation = null;

    if (isSqlite(this.knex())) {
      operation = new WhereInCompositeSqliteOperation('whereInComposite');
    } else if (isMsSql(this.knex())) {
      operation = new WhereInCompositeMsSqlOperation('whereInComposite');
    } else {
      operation = new WhereInCompositeOperation('whereInComposite');
    }

    return this.addOperation(operation, args);
  }

  whereNotInComposite(...args) {
    let operation = null;

    if (isSqlite(this.knex())) {
      operation = new WhereInCompositeSqliteOperation('whereNotInComposite', { prefix: 'not' });
    } else if (isMsSql(this.knex())) {
      operation = new WhereInCompositeMsSqlOperation('whereNotInComposite', { prefix: 'not' });
    } else {
      operation = new WhereInCompositeOperation('whereNotInComposite', { prefix: 'not' });
    }

    return this.addOperation(operation, args);
  }

  jsonExtract(...args) {
    return this.addOperation(new KnexOperation('jsonExtract'), args);
  }

  jsonSet(...args) {
    return this.addOperation(new KnexOperation('jsonSet'), args);
  }

  jsonInsert(...args) {
    return this.addOperation(new KnexOperation('jsonInsert'), args);
  }

  jsonRemove(...args) {
    return this.addOperation(new KnexOperation('jsonRemove'), args);
  }

  whereJsonObject(...args) {
    return this.addOperation(new KnexOperation('whereJsonObject'), args);
  }

  orWhereJsonObject(...args) {
    return this.addOperation(new KnexOperation('orWhereJsonObject'), args);
  }

  andWhereJsonObject(...args) {
    return this.addOperation(new KnexOperation('andWhereJsonObject'), args);
  }

  whereNotJsonObject(...args) {
    return this.addOperation(new KnexOperation('whereNotJsonObject'), args);
  }

  orWhereNotJsonObject(...args) {
    return this.addOperation(new KnexOperation('orWhereNotJsonObject'), args);
  }

  andWhereNotJsonObject(...args) {
    return this.addOperation(new KnexOperation('andWhereNotJsonObject'), args);
  }

  whereJsonPath(...args) {
    return this.addOperation(new KnexOperation('whereJsonPath'), args);
  }

  orWhereJsonPath(...args) {
    return this.addOperation(new KnexOperation('orWhereJsonPath'), args);
  }

  andWhereJsonPath(...args) {
    return this.addOperation(new KnexOperation('andWhereJsonPath'), args);
  }

  // whereJson(Not)SupersetOf / whereJson(Not)SubsetOf are now supported by knex >= 1.0, but for now
  // objection handles them differently and only for postgres.
  // Changing them to utilize knex methods directly may require a major version bump and upgrade guide.
  whereJsonSupersetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('whereJsonSupersetOf', { operator: '@>', bool: 'and' }),
      args,
    );
  }

  andWhereJsonSupersetOf(...args) {
    return this.whereJsonSupersetOf(...args);
  }

  orWhereJsonSupersetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('orWhereJsonSupersetOf', { operator: '@>', bool: 'or' }),
      args,
    );
  }

  whereJsonNotSupersetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('whereJsonNotSupersetOf', {
        operator: '@>',
        bool: 'and',
        prefix: 'not',
      }),
      args,
    );
  }

  andWhereJsonNotSupersetOf(...args) {
    return this.andWhereJsonNotSupersetOf(...args);
  }

  orWhereJsonNotSupersetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('orWhereJsonNotSupersetOf', {
        operator: '@>',
        bool: 'or',
        prefix: 'not',
      }),
      args,
    );
  }

  whereJsonSubsetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('whereJsonSubsetOf', { operator: '<@', bool: 'and' }),
      args,
    );
  }

  andWhereJsonSubsetOf(...args) {
    return this.whereJsonSubsetOf(...args);
  }

  orWhereJsonSubsetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('orWhereJsonSubsetOf', { operator: '<@', bool: 'or' }),
      args,
    );
  }

  whereJsonNotSubsetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('whereJsonNotSubsetOf', {
        operator: '<@',
        bool: 'and',
        prefix: 'not',
      }),
      args,
    );
  }

  andWhereJsonNotSubsetOf(...args) {
    return this.whereJsonNotSubsetOf(...args);
  }

  orWhereJsonNotSubsetOf(...args) {
    return this.addOperation(
      new WhereJsonPostgresOperation('orWhereJsonNotSubsetOf', {
        operator: '<@',
        bool: 'or',
        prefix: 'not',
      }),
      args,
    );
  }

  whereJsonNotArray(...args) {
    return this.addOperation(
      new WhereJsonNotObjectPostgresOperation('whereJsonNotArray', {
        bool: 'and',
        compareValue: [],
      }),
      args,
    );
  }

  orWhereJsonNotArray(...args) {
    return this.addOperation(
      new WhereJsonNotObjectPostgresOperation('orWhereJsonNotArray', {
        bool: 'or',
        compareValue: [],
      }),
      args,
    );
  }

  whereJsonNotObject(...args) {
    return this.addOperation(
      new WhereJsonNotObjectPostgresOperation('whereJsonNotObject', {
        bool: 'and',
        compareValue: {},
      }),
      args,
    );
  }

  orWhereJsonNotObject(...args) {
    return this.addOperation(
      new WhereJsonNotObjectPostgresOperation('orWhereJsonNotObject', {
        bool: 'or',
        compareValue: {},
      }),
      args,
    );
  }

  whereJsonHasAny(...args) {
    return this.addOperation(
      new WhereJsonHasPostgresOperation('whereJsonHasAny', { bool: 'and', operator: '?|' }),
      args,
    );
  }

  orWhereJsonHasAny(...args) {
    return this.addOperation(
      new WhereJsonHasPostgresOperation('orWhereJsonHasAny', { bool: 'or', operator: '?|' }),
      args,
    );
  }

  whereJsonHasAll(...args) {
    return this.addOperation(
      new WhereJsonHasPostgresOperation('whereJsonHasAll', { bool: 'and', operator: '?&' }),
      args,
    );
  }

  orWhereJsonHasAll(...args) {
    return this.addOperation(
      new WhereJsonHasPostgresOperation('orWhereJsonHasAll', { bool: 'or', operator: '?&' }),
      args,
    );
  }

  whereJsonIsArray(fieldExpression) {
    return this.whereJsonSupersetOf(fieldExpression, []);
  }

  orWhereJsonIsArray(fieldExpression) {
    return this.orWhereJsonSupersetOf(fieldExpression, []);
  }

  whereJsonIsObject(fieldExpression) {
    return this.whereJsonSupersetOf(fieldExpression, {});
  }

  orWhereJsonIsObject(fieldExpression) {
    return this.orWhereJsonSupersetOf(fieldExpression, {});
  }

  whereColumn(...args) {
    return this.addOperation(new KnexOperation('whereColumn'), args);
  }

  andWhereColumn(...args) {
    return this.addOperation(new KnexOperation('andWhereColumn'), args);
  }

  orWhereColumn(...args) {
    return this.addOperation(new KnexOperation('orWhereColumn'), args);
  }

  whereNotColumn(...args) {
    return this.addOperation(new KnexOperation('whereNotColumn'), args);
  }

  andWhereNotColumn(...args) {
    return this.addOperation(new KnexOperation('andWhereNotColumn'), args);
  }

  orWhereNotColumn(...args) {
    return this.addOperation(new KnexOperation('orWhereNotColumn'), args);
  }

  onConflict(...args) {
    return this.addOperation(new KnexOperation('onConflict'), args);
  }

  ignore(...args) {
    return this.addOperation(new KnexOperation('ignore'), args);
  }

  merge(...args) {
    return this.addOperation(new MergeOperation('merge'), args);
  }
}

Object.defineProperties(QueryBuilderBase.prototype, {
  isObjectionQueryBuilderBase: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

module.exports = {
  QueryBuilderBase,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/QueryBuilderContext.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderContextBase } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderContextBase.js");

class QueryBuilderContext extends QueryBuilderContextBase {
  constructor(builder) {
    super(builder);

    this.runBefore = [];
    this.runAfter = [];
    this.onBuild = [];
  }

  clone() {
    const ctx = super.clone();

    ctx.runBefore = this.runBefore.slice();
    ctx.runAfter = this.runAfter.slice();
    ctx.onBuild = this.onBuild.slice();

    return ctx;
  }
}

module.exports = {
  QueryBuilderContext,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/QueryBuilderContextBase.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InternalOptions } = __webpack_require__("./node_modules/objection/lib/queryBuilder/InternalOptions.js");

class QueryBuilderContextBase {
  constructor(builder) {
    this.userContext = builder ? new builder.constructor.QueryBuilderUserContext(builder) : null;
    this.options = builder ? new this.constructor.InternalOptions() : null;
    this.knex = null;

    this.aliasMap = null;
    this.tableMap = null;
  }

  static get InternalOptions() {
    return InternalOptions;
  }

  clone() {
    const ctx = new this.constructor();

    ctx.userContext = this.userContext;
    ctx.options = this.options.clone();
    ctx.knex = this.knex;

    ctx.aliasMap = this.aliasMap;
    ctx.tableMap = this.tableMap;

    return ctx;
  }
}

module.exports = {
  QueryBuilderContextBase,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/QueryBuilderOperationSupport.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isString, isFunction, isRegExp, mergeMaps, last } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { QueryBuilderContextBase } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderContextBase.js");
const { QueryBuilderUserContext } = __webpack_require__("./node_modules/objection/lib/queryBuilder/QueryBuilderUserContext.js");
const { deprecate } = __webpack_require__("./node_modules/objection/lib/utils/deprecate.js");

const AllSelector = () => true;
const SelectSelector =
  /^(select|columns|column|distinct|count|countDistinct|min|max|sum|sumDistinct|avg|avgDistinct)$/;
const WhereSelector = /^(where|orWhere|andWhere|find\w+)/;
const OnSelector = /^(on|orOn|andOn)/;
const OrderBySelector = /orderBy/;
const JoinSelector = /(join|joinRaw|joinRelated)$/i;
const FromSelector = /^(from|fromRaw|into|table)$/;

class QueryBuilderOperationSupport {
  constructor(...args) {
    this.constructor.init(this, ...args);
  }

  static init(self, modelClass) {
    self._modelClass = modelClass;
    self._operations = [];
    self._context = new this.QueryBuilderContext(self);
    self._parentQuery = null;
    self._isPartialQuery = false;
    self._activeOperations = [];
  }

  static forClass(modelClass) {
    return new this(modelClass);
  }

  static get AllSelector() {
    return AllSelector;
  }

  static get QueryBuilderContext() {
    return QueryBuilderContextBase;
  }

  static get QueryBuilderUserContext() {
    return QueryBuilderUserContext;
  }

  static get SelectSelector() {
    return SelectSelector;
  }

  static get WhereSelector() {
    return WhereSelector;
  }

  static get OnSelector() {
    return OnSelector;
  }

  static get JoinSelector() {
    return JoinSelector;
  }

  static get FromSelector() {
    return FromSelector;
  }

  static get OrderBySelector() {
    return OrderBySelector;
  }

  modelClass() {
    return this._modelClass;
  }

  context(obj) {
    const ctx = this._context;

    if (arguments.length === 0) {
      return ctx.userContext;
    } else {
      ctx.userContext = ctx.userContext.newMerge(this, obj);
      return this;
    }
  }

  clearContext() {
    const ctx = this._context;
    ctx.userContext = new this.constructor.QueryBuilderUserContext(this);
    return this;
  }

  internalContext(ctx) {
    if (arguments.length === 0) {
      return this._context;
    } else {
      this._context = ctx;
      return this;
    }
  }

  internalOptions(opt) {
    if (arguments.length === 0) {
      return this._context.options;
    } else {
      const oldOpt = this._context.options;
      this._context.options = Object.assign(oldOpt, opt);
      return this;
    }
  }

  isPartial(isPartial) {
    if (arguments.length === 0) {
      return this._isPartialQuery;
    } else {
      this._isPartialQuery = isPartial;
      return this;
    }
  }

  isInternal() {
    return this.internalOptions().isInternalQuery;
  }

  tableNameFor(tableName, newTableName) {
    const ctx = this.internalContext();
    const tableMap = ctx.tableMap;

    if (isString(newTableName)) {
      ctx.tableMap = tableMap || new Map();
      ctx.tableMap.set(tableName, newTableName);
      return this;
    } else {
      return (tableMap && tableMap.get(tableName)) || tableName;
    }
  }

  aliasFor(tableName, alias) {
    const ctx = this.internalContext();
    const aliasMap = ctx.aliasMap;

    if (isString(alias)) {
      ctx.aliasMap = aliasMap || new Map();
      ctx.aliasMap.set(tableName, alias);
      return this;
    } else {
      return (aliasMap && aliasMap.get(tableName)) || null;
    }
  }

  tableRefFor(tableName) {
    return this.aliasFor(tableName) || this.tableNameFor(tableName);
  }

  childQueryOf(query, { fork, isInternalQuery } = {}) {
    if (query) {
      let currentCtx = this.context();
      let ctx = query.internalContext();

      if (fork) {
        ctx = ctx.clone();
      }

      if (isInternalQuery) {
        ctx.options.isInternalQuery = true;
      }

      this._parentQuery = query;
      this.internalContext(ctx);
      this.context(currentCtx);

      // Use the parent's knex if there was no knex in `ctx`.
      if (this.unsafeKnex() === null) {
        this.knex(query.unsafeKnex());
      }
    }

    return this;
  }

  subqueryOf(query) {
    if (query) {
      if (this._isPartialQuery) {
        // Merge alias and table name maps for "partial" subqueries.
        const ctx = this.internalContext();

        ctx.aliasMap = mergeMaps(query.internalContext().aliasMap, ctx.aliasMap);
        ctx.tableMap = mergeMaps(query.internalContext().tableMap, ctx.tableMap);
      }

      this._parentQuery = query;

      if (this.unsafeKnex() === null) {
        this.knex(query.unsafeKnex());
      }
    }

    return this;
  }

  parentQuery() {
    return this._parentQuery;
  }

  knex(...args) {
    if (args.length === 0) {
      const knex = this.unsafeKnex();

      if (!knex) {
        throw new Error(
          `no database connection available for a query. You need to bind the model class or the query to a knex instance.`,
        );
      }

      return knex;
    } else {
      this._context.knex = args[0];
      return this;
    }
  }

  unsafeKnex() {
    return this._context.knex || this._modelClass.knex() || null;
  }

  clear(operationSelector) {
    const operationsToRemove = new Set();

    this.forEachOperation(operationSelector, (op) => {
      // If an ancestor operation has already been removed,
      // there's no need to remove the children anymore.
      if (!op.isAncestorInSet(operationsToRemove)) {
        operationsToRemove.add(op);
      }
    });

    for (const op of operationsToRemove) {
      this.removeOperation(op);
    }

    return this;
  }

  toFindQuery() {
    const findQuery = this.clone();
    const operationsToReplace = [];
    const operationsToRemove = [];

    findQuery.forEachOperation(
      (op) => op.hasToFindOperation(),
      (op) => {
        const findOp = op.toFindOperation(findQuery);

        if (!findOp) {
          operationsToRemove.push(op);
        } else {
          operationsToReplace.push({ op, findOp });
        }
      },
    );

    for (const op of operationsToRemove) {
      findQuery.removeOperation(op);
    }

    for (const { op, findOp } of operationsToReplace) {
      findQuery.replaceOperation(op, findOp);
    }

    return findQuery;
  }

  clearSelect() {
    return this.clear(SelectSelector);
  }

  clearWhere() {
    return this.clear(WhereSelector);
  }

  clearOrder() {
    return this.clear(OrderBySelector);
  }

  copyFrom(queryBuilder, operationSelector) {
    const operationsToAdd = new Set();

    queryBuilder.forEachOperation(operationSelector, (op) => {
      // If an ancestor operation has already been added,
      // there is no need to add
      if (!op.isAncestorInSet(operationsToAdd)) {
        operationsToAdd.add(op);
      }
    });

    for (const op of operationsToAdd) {
      const opClone = op.clone();

      // We may be moving nested operations to the root. Clear
      // any links to the parent operations.
      opClone.parentOperation = null;
      opClone.adderHookName = null;

      // We don't use `addOperation` here because we don't what to
      // call `onAdd` or add these operations as child operations.
      this._operations.push(opClone);
    }

    return this;
  }

  has(operationSelector) {
    return !!this.findOperation(operationSelector);
  }

  forEachOperation(operationSelector, callback, match = true) {
    const selector = buildFunctionForOperationSelector(operationSelector);

    for (const op of this._operations) {
      if (selector(op) === match && callback(op) === false) {
        break;
      }

      const childRes = op.forEachDescendantOperation((op) => {
        if (selector(op) === match && callback(op) === false) {
          return false;
        }
      });

      if (childRes === false) {
        break;
      }
    }

    return this;
  }

  findOperation(operationSelector) {
    let op = null;

    this.forEachOperation(operationSelector, (it) => {
      op = it;
      return false;
    });

    return op;
  }

  findLastOperation(operationSelector) {
    let op = null;

    this.forEachOperation(operationSelector, (it) => {
      op = it;
    });

    return op;
  }

  everyOperation(operationSelector) {
    let every = true;

    this.forEachOperation(
      operationSelector,
      () => {
        every = false;
        return false;
      },
      false,
    );

    return every;
  }

  callOperationMethod(operation, hookName, args) {
    try {
      operation.removeChildOperationsByHookName(hookName);

      this._activeOperations.push({
        operation,
        hookName,
      });

      return operation[hookName](...args);
    } finally {
      this._activeOperations.pop();
    }
  }

  async callAsyncOperationMethod(operation, hookName, args) {
    operation.removeChildOperationsByHookName(hookName);

    this._activeOperations.push({
      operation,
      hookName,
    });

    try {
      return await operation[hookName](...args);
    } finally {
      this._activeOperations.pop();
    }
  }

  addOperation(operation, args) {
    const ret = this.addOperationUsingMethod('push', operation, args);
    return ret;
  }

  addOperationToFront(operation, args) {
    return this.addOperationUsingMethod('unshift', operation, args);
  }

  addOperationUsingMethod(arrayMethod, operation, args) {
    const shouldAdd = this.callOperationMethod(operation, 'onAdd', [this, args]);

    if (shouldAdd) {
      if (this._activeOperations.length) {
        const { operation: parentOperation, hookName } = last(this._activeOperations);
        parentOperation.addChildOperation(hookName, operation);
      } else {
        this._operations[arrayMethod](operation);
      }
    }

    return this;
  }

  removeOperation(operation) {
    if (operation.parentOperation) {
      operation.parentOperation.removeChildOperation(operation);
    } else {
      const index = this._operations.indexOf(operation);

      if (index !== -1) {
        this._operations.splice(index, 1);
      }
    }

    return this;
  }

  replaceOperation(operation, newOperation) {
    if (operation.parentOperation) {
      operation.parentOperation.replaceChildOperation(operation, newOperation);
    } else {
      const index = this._operations.indexOf(operation);

      if (index !== -1) {
        this._operations[index] = newOperation;
      }
    }

    return this;
  }

  clone() {
    return this.baseCloneInto(new this.constructor(this.unsafeKnex()));
  }

  baseCloneInto(builder) {
    builder._modelClass = this._modelClass;
    builder._operations = this._operations.map((it) => it.clone());
    builder._context = this._context.clone();
    builder._parentQuery = this._parentQuery;
    builder._isPartialQuery = this._isPartialQuery;

    // Don't copy the active operation stack. We never continue (nor can we)
    // a query from the exact mid-hook-call state.
    builder._activeOperations = [];

    return builder;
  }

  toKnexQuery(knexBuilder = this.knex().queryBuilder()) {
    this.executeOnBuild();
    return this.executeOnBuildKnex(knexBuilder);
  }

  executeOnBuild() {
    this.forEachOperation(true, (op) => {
      if (op.hasOnBuild()) {
        this.callOperationMethod(op, 'onBuild', [this]);
      }
    });
  }

  executeOnBuildKnex(knexBuilder) {
    this.forEachOperation(true, (op) => {
      if (op.hasOnBuildKnex()) {
        const newKnexBuilder = this.callOperationMethod(op, 'onBuildKnex', [knexBuilder, this]);
        // Default to the input knex builder for backwards compatibility
        // with QueryBuilder.onBuildKnex hooks.
        knexBuilder = newKnexBuilder || knexBuilder;
      }
    });

    return knexBuilder;
  }

  toString() {
    return this.toKnexQuery().toString();
  }

  toSql() {
    return this.toString();
  }

  skipUndefined() {
    deprecate('skipUndefined() is deprecated and will be removed in objection 4.0');
    this.internalOptions().skipUndefined = true;
    return this;
  }
}

function buildFunctionForOperationSelector(operationSelector) {
  if (operationSelector === true) {
    return AllSelector;
  } else if (isRegExp(operationSelector)) {
    return (op) => operationSelector.test(op.name);
  } else if (isString(operationSelector)) {
    return (op) => op.name === operationSelector;
  } else if (
    isFunction(operationSelector) &&
    operationSelector.isObjectionQueryBuilderOperationClass
  ) {
    return (op) => op.is(operationSelector);
  } else if (isFunction(operationSelector)) {
    return operationSelector;
  } else {
    return () => false;
  }
}

module.exports = {
  QueryBuilderOperationSupport,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/QueryBuilderUserContext.js":
/***/ ((module) => {

"use strict";


const SYMBOL_BUILDER = Symbol();

class QueryBuilderUserContext {
  constructor(builder) {
    // This should never ever be accessed outside this class. We only
    // store it so that we can access builder.knex() lazily.
    this[SYMBOL_BUILDER] = builder;
  }

  get transaction() {
    return this[SYMBOL_BUILDER].knex();
  }

  newFromObject(builder, obj) {
    const ctx = new this.constructor(builder);
    Object.assign(ctx, obj);
    return ctx;
  }

  newMerge(builder, obj) {
    const ctx = new this.constructor(builder);
    Object.assign(ctx, this, obj);
    return ctx;
  }
}

module.exports = {
  QueryBuilderUserContext,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/RawBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPlainObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { buildArg } = __webpack_require__("./node_modules/objection/lib/utils/buildUtils.js");

class RawBuilder {
  constructor(sql, args) {
    this._sql = `${sql}`;
    this._args = args;
    this._as = null;
  }

  get alias() {
    return this._as;
  }

  as(as) {
    this._as = as;
    return this;
  }

  toKnexRaw(builder) {
    let args = null;
    let sql = this._sql;

    if (this._args.length === 1 && isPlainObject(this._args[0])) {
      args = buildObject(this._args[0], builder);

      if (this._as) {
        args.__alias__ = this._as;
        sql += ' as :__alias__:';
      }
    } else {
      args = buildArray(this._args, builder);

      if (this._as) {
        args.push(this._as);
        sql += ' as ??';
      }
    }

    return builder.knex().raw(sql, args);
  }
}

Object.defineProperties(RawBuilder.prototype, {
  isObjectionRawBuilder: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

function buildArray(arr, builder) {
  return arr.map((it) => buildArg(it, builder));
}

function buildObject(obj, builder) {
  return Object.keys(obj).reduce((args, key) => {
    args[key] = buildArg(obj[key], builder);
    return args;
  }, {});
}

function normalizeRawArgs(argsIn) {
  const [sql, ...restArgs] = argsIn;

  if (restArgs.length === 1 && Array.isArray(restArgs[0])) {
    return {
      sql,
      args: restArgs[0],
    };
  } else {
    return {
      sql,
      args: restArgs,
    };
  }
}

function raw(...argsIn) {
  const { sql, args } = normalizeRawArgs(argsIn);
  return new RawBuilder(sql, args);
}

module.exports = {
  RawBuilder,
  normalizeRawArgs,
  raw,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/ReferenceBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { parseFieldExpression } = __webpack_require__("./node_modules/objection/lib/utils/parseFieldExpression.js");
const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class ReferenceBuilder {
  constructor(expr) {
    this._expr = expr;
    this._parsedExpr = null;
    this._column = null;
    this._table = null;
    this._cast = null;
    this._toJson = false;
    this._table = null;
    this._alias = null;
    this._modelClass = null;

    // This `if` makes it possible for `clone` to skip
    // parsing the expression again.
    if (expr !== null) {
      this._parseExpression(expr);
    }
  }

  get parsedExpr() {
    return this._parsedExpr;
  }

  get column() {
    return this._column;
  }

  set column(column) {
    this._column = column;
  }

  get alias() {
    return this._alias;
  }

  set alias(alias) {
    this._alias = alias;
  }

  get tableName() {
    return this._table;
  }

  set tableName(table) {
    this._table = table;
  }

  get modelClass() {
    return this._modelClass;
  }

  set modelClass(modelClass) {
    this._modelClass = modelClass;
  }

  get isPlainColumnRef() {
    return (
      (!this._parsedExpr || this._parsedExpr.access.length === 0) && !this._cast && !this._toJson
    );
  }

  get expression() {
    return this._expr;
  }

  get cast() {
    return this._cast;
  }

  fullColumn(builder) {
    const table = this.tableName
      ? this.tableName
      : this.modelClass
        ? builder.tableRefFor(this.modelClass)
        : null;

    if (table) {
      return `${table}.${this.column}`;
    } else {
      return this.column;
    }
  }

  castText() {
    return this.castTo('text');
  }

  castInt() {
    return this.castTo('integer');
  }

  castBigInt() {
    return this.castTo('bigint');
  }

  castFloat() {
    return this.castTo('float');
  }

  castDecimal() {
    return this.castTo('decimal');
  }

  castReal() {
    return this.castTo('real');
  }

  castBool() {
    return this.castTo('boolean');
  }

  castJson() {
    this._toJson = true;
    return this;
  }

  castTo(sqlType) {
    this._cast = sqlType;
    return this;
  }

  from(table) {
    this._table = table;
    return this;
  }

  table(table) {
    this._table = table;
    return this;
  }

  model(modelClass) {
    this._modelClass = modelClass;
    return this;
  }

  as(alias) {
    this._alias = alias;
    return this;
  }

  clone() {
    const clone = new this.constructor(null);

    clone._expr = this._expr;
    clone._parsedExpr = this._parsedExpr;
    clone._column = this._column;
    clone._table = this._table;
    clone._cast = this._cast;
    clone._toJson = this._toJson;
    clone._alias = this._alias;
    clone._modelClass = this._modelClass;

    return clone;
  }

  toKnexRaw(builder) {
    return builder.knex().raw(...this._createRawArgs(builder));
  }

  _parseExpression(expr) {
    this._parsedExpr = parseFieldExpression(expr);
    this._column = this._parsedExpr.column;
    this._table = this._parsedExpr.table;
  }

  _createRawArgs(builder) {
    let bindings = [];
    let sql = this._createReferenceSql(builder, bindings);

    sql = this._maybeCast(sql, bindings);
    sql = this._maybeToJsonb(sql, bindings);
    sql = this._maybeAlias(sql, bindings);

    return [sql, bindings];
  }

  _createReferenceSql(builder, bindings) {
    bindings.push(this.fullColumn(builder));

    if (this._parsedExpr.access.length > 0) {
      const extractor = this._cast ? '#>>' : '#>';
      const jsonFieldRef = this._parsedExpr.access.map((field) => field.ref).join(',');
      return `??${extractor}'{${jsonFieldRef}}'`;
    } else {
      return '??';
    }
  }

  _maybeCast(sql) {
    if (this._cast) {
      return `CAST(${sql} AS ${this._cast})`;
    } else {
      return sql;
    }
  }

  _maybeToJsonb(sql) {
    if (this._toJson) {
      return `to_jsonb(${sql})`;
    } else {
      return sql;
    }
  }

  _maybeAlias(sql, bindings) {
    if (this._shouldAlias()) {
      bindings.push(this._alias);
      return `${sql} as ??`;
    } else {
      return sql;
    }
  }

  _shouldAlias() {
    if (!this._alias) {
      return false;
    } else if (!this.isPlainColumnRef) {
      return true;
    } else {
      // No need to alias if we are dealing with a simple column reference
      // and the alias is the same as the column name.
      return this._alias !== this._column;
    }
  }
}

Object.defineProperties(ReferenceBuilder.prototype, {
  isObjectionReferenceBuilder: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

const ref = (reference) => {
  if (isObject(reference) && reference.isObjectionReferenceBuilder) {
    return reference;
  } else {
    return new ReferenceBuilder(reference);
  }
};

module.exports = {
  ReferenceBuilder,
  ref,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/RelationExpression.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const parser = __webpack_require__("./node_modules/objection/lib/queryBuilder/parsers/relationExpressionParser.js");
const { isObject, isNumber, isString, union } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { RelationDoesNotExistError } = __webpack_require__("./node_modules/objection/lib/model/RelationDoesNotExistError.js");

class RelationExpressionParseError extends Error {}
class DuplicateRelationError extends RelationExpressionParseError {
  constructor(relationName) {
    super();
    this.relationName = relationName;
  }
}

class RelationExpression {
  constructor(node = newNode(), recursionDepth = 0) {
    this.node = node;
    this.recursionDepth = recursionDepth;
  }

  // Create a relation expression from a string, a pojo or another
  // RelationExpression instance.
  static create(expr) {
    if (isObject(expr)) {
      if (expr.isObjectionRelationExpression) {
        return expr;
      } else {
        return new RelationExpression(normalizeNode(expr));
      }
    } else if (isString(expr)) {
      if (expr.trim().length === 0) {
        return new RelationExpression();
      } else {
        try {
          return new RelationExpression(parse(expr));
        } catch (err) {
          if (err.duplicateRelationName) {
            throw new DuplicateRelationError(err.duplicateRelationName);
          } else {
            throw new RelationExpressionParseError(err.message);
          }
        }
      }
    } else {
      return new RelationExpression();
    }
  }

  // Create a relation expression from a model graph.
  static fromModelGraph(graph) {
    if (!graph) {
      return new RelationExpression();
    } else {
      return new RelationExpression(modelGraphToNode(graph, newNode()));
    }
  }

  get maxRecursionDepth() {
    if (isNumber(this.node.$recursive)) {
      return this.node.$recursive;
    } else {
      return this.node.$recursive ? Number.MAX_SAFE_INTEGER : 0;
    }
  }

  get numChildren() {
    return this.node.$childNames.length;
  }

  get isEmpty() {
    return this.numChildren === 0;
  }

  // Merges this relation expression with another. `expr` can be a string,
  // a pojo, or a RelationExpression instance.
  merge(expr) {
    expr = RelationExpression.create(expr);

    if (this.isEmpty) {
      // Nothing to merge.
      return expr;
    }

    return new RelationExpression(mergeNodes(this.node, expr.node));
  }

  // Returns true if `expr` is contained by this expression. For example
  // `a.b` is contained by `a.[b, c]`.
  isSubExpression(expr) {
    expr = RelationExpression.create(expr);

    if (this.node.$allRecursive) {
      return true;
    }

    if (expr.node.$allRecursive) {
      return this.node.$allRecursive;
    }

    if (this.node.$relation !== expr.node.$relation) {
      return false;
    }

    const maxRecursionDepth = expr.maxRecursionDepth;

    if (maxRecursionDepth > 0) {
      return this.node.$allRecursive || this.maxRecursionDepth >= maxRecursionDepth;
    }

    for (const childName of expr.node.$childNames) {
      const ownSubExpression = this.childExpression(childName);
      const subExpression = expr.childExpression(childName);

      if (!ownSubExpression || !ownSubExpression.isSubExpression(subExpression)) {
        return false;
      }
    }

    return true;
  }

  // Returns a RelationExpression for a child node or null if there
  // is no child with the given name `childName`.
  childExpression(childName) {
    if (
      this.node.$allRecursive ||
      (childName === this.node.$name && this.recursionDepth < this.maxRecursionDepth - 1)
    ) {
      return new RelationExpression(this.node, this.recursionDepth + 1);
    }

    const child = this.node[childName];

    if (child) {
      return new RelationExpression(child);
    } else {
      return null;
    }
  }

  // Loops throught all first level children.
  forEachChildExpression(modelClass, cb) {
    const maxRecursionDepth = this.maxRecursionDepth;

    if (this.node.$allRecursive) {
      for (const relationName of modelClass.getRelationNames()) {
        const node = newNode(relationName, true);
        const relation = modelClass.getRelationUnsafe(relationName);
        const childExpr = new RelationExpression(node);

        cb(childExpr, relation);
      }
    } else if (this.recursionDepth < maxRecursionDepth - 1) {
      const relation = modelClass.getRelationUnsafe(this.node.$relation) || null;
      const childExpr = new RelationExpression(this.node, this.recursionDepth + 1);

      cb(childExpr, relation);
    } else if (maxRecursionDepth === 0) {
      for (const childName of this.node.$childNames) {
        const node = this.node[childName];
        const relation = modelClass.getRelationUnsafe(node.$relation);

        if (!relation) {
          throw new RelationDoesNotExistError(node.$relation);
        }

        const childExpr = new RelationExpression(node);

        cb(childExpr, relation);
      }
    }
  }

  expressionsAtPath(path) {
    return findExpressionsAtPath(this, RelationExpression.create(path), []);
  }

  clone() {
    return new RelationExpression(cloneNode(this.node), this.recursionDepth);
  }

  toString() {
    return toString(this.node);
  }

  toPojo() {
    return cloneNode(this.node);
  }

  toJSON() {
    return this.toPojo();
  }
}

const parseCache = new Map();
function parse(str) {
  const cachedNode = parseCache.get(str);

  if (cachedNode) {
    return cloneNode(cachedNode);
  } else {
    const node = parser.parse(str);
    parseCache.set(str, cloneNode(node));
    return node;
  }
}

// All enumerable properties of a node that don't start with `$`
// are child nodes.
function getChildNames(node) {
  if (!node) {
    return [];
  }

  const childNames = [];

  for (const key of Object.keys(node)) {
    if (key[0] !== '$') {
      childNames.push(key);
    }
  }

  return childNames;
}

function toString(node) {
  const childNames = node.$childNames;

  let childExpr = childNames.map((childName) => node[childName]).map(toString);
  let str = node.$relation;

  if (node.$recursive) {
    if (isNumber(node.$recursive)) {
      str += '.^' + node.$recursive;
    } else {
      str += '.^';
    }
  } else if (node.$allRecursive) {
    str += '.*';
  }

  if (childExpr.length > 1) {
    childExpr = `[${childExpr.join(', ')}]`;
  } else {
    childExpr = childExpr[0];
  }

  if (node.$modify.length) {
    str += `(${node.$modify.join(', ')})`;
  }

  if (node.$name !== node.$relation) {
    str += ` as ${node.$name}`;
  }

  if (childExpr) {
    if (str) {
      return `${str}.${childExpr}`;
    } else {
      return childExpr;
    }
  } else {
    return str;
  }
}

function cloneNode(node) {
  return normalizeNode(node);
}

function modelGraphToNode(models, node) {
  if (!models) {
    return;
  }

  if (Array.isArray(models)) {
    for (let i = 0, l = models.length; i < l; ++i) {
      modelToNode(models[i], node);
    }
  } else {
    modelToNode(models, node);
  }

  return node;
}

function modelToNode(model, node) {
  const modelClass = model.constructor;
  const relationNames = modelClass.getRelationNames();

  for (let r = 0, lr = relationNames.length; r < lr; ++r) {
    const relName = relationNames[r];

    if (model[relName] !== undefined) {
      let childNode = node[relName];

      if (!childNode) {
        childNode = newNode(relName);
        node[relName] = childNode;
        node.$childNames.push(relName);
      }

      modelGraphToNode(model[relName], childNode);
    }
  }
}

function newNode(name = null, allRecusive = false) {
  return normalizeNode(null, name, allRecusive);
}

function normalizeNode(node = null, name = null, allRecusive = false) {
  const normalized = {
    $name: normalizeName(node, name),
    $relation: normalizeRelation(node, name),
    $modify: normalizeModify(node),
    $recursive: normalizeRecursive(node),
    $allRecursive: normalizeAllRecursive(node, allRecusive),
    $childNames: normalizeChildNames(node),
  };

  for (const childName of normalized.$childNames) {
    const childNode = node[childName];

    if (isObject(childNode) || childNode === true) {
      normalized[childName] = normalizeNode(childNode, childName);
    }
  }

  return normalized;
}

function normalizeName(node, name) {
  return (node && node.$name) || name || null;
}

function normalizeRelation(node, name) {
  return (node && node.$relation) || name || null;
}

function normalizeModify(node) {
  if (!node || !node.$modify) {
    return [];
  }

  return Array.isArray(node.$modify) ? node.$modify.slice() : [node.$modify];
}

function normalizeRecursive(node) {
  return (node && node.$recursive) || false;
}

function normalizeAllRecursive(node, allRecusive) {
  return (node && node.$allRecursive) || allRecusive || false;
}

function normalizeChildNames(node) {
  return (node && node.$childNames && node.$childNames.slice()) || getChildNames(node);
}

function findExpressionsAtPath(target, path, results) {
  if (path.node.$childNames.length == 0) {
    // Path leaf reached, add target node to result set.
    results.push(target);
  } else {
    for (const childName of path.node.$childNames) {
      const pathChild = path.childExpression(childName);
      const targetChild = target.childExpression(childName);

      if (targetChild) {
        findExpressionsAtPath(targetChild, pathChild, results);
      }
    }
  }

  return results;
}

function mergeNodes(node1, node2) {
  const node = {
    $name: node1.$name,
    $relation: node1.$relation,
    $modify: union(node1.$modify, node2.$modify),
    $recursive: mergeRecursion(node1.$recursive, node2.$recursive),
    $allRecursive: node1.$allRecursive || node2.$allRecursive,
    $childNames: null,
  };

  if (!node.$recursive && !node.$allRecursive) {
    node.$childNames = union(node1.$childNames, node2.$childNames);

    for (const childName of node.$childNames) {
      const child1 = node1[childName];
      const child2 = node2[childName];

      if (child1 && child2) {
        node[childName] = mergeNodes(child1, child2);
      } else {
        node[childName] = child1 || child2;
      }
    }
  } else {
    node.$childNames = [];
  }

  return node;
}

function mergeRecursion(rec1, rec2) {
  if (rec1 === true || rec2 === true) {
    return true;
  } else if (isNumber(rec1) && isNumber(rec2)) {
    return Math.max(rec1, rec2);
  } else {
    return rec1 || rec2;
  }
}

Object.defineProperties(RelationExpression.prototype, {
  isObjectionRelationExpression: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

module.exports = {
  RelationExpression,
  RelationExpressionParseError,
  DuplicateRelationError,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/StaticHookArguments.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

const BUILDER_SYMBOL = Symbol();

class StaticHookArguments {
  constructor({ builder, result = null }) {
    // The builder should never be accessed through the arguments.
    // Hide it as well as possible to discourage people from
    // digging it out.
    Object.defineProperty(this, BUILDER_SYMBOL, {
      value: builder,
    });

    Object.defineProperty(this, 'result', {
      value: asArray(result),
    });
  }

  static create(args) {
    return new StaticHookArguments(args);
  }

  get asFindQuery() {
    return () => {
      return this[BUILDER_SYMBOL].toFindQuery().clearWithGraphFetched().runAfter(asArray);
    };
  }

  get context() {
    return this[BUILDER_SYMBOL].context();
  }

  get transaction() {
    return this[BUILDER_SYMBOL].unsafeKnex();
  }

  get relation() {
    const op = this[BUILDER_SYMBOL].findOperation(hasRelation);

    if (op) {
      return getRelation(op);
    } else {
      return undefined;
    }
  }

  get modelOptions() {
    const op = this[BUILDER_SYMBOL].findOperation(hasModelOptions);

    if (op) {
      return getModelOptions(op);
    } else {
      return undefined;
    }
  }

  get items() {
    const op = this[BUILDER_SYMBOL].findOperation(hasItems);

    if (op) {
      return asArray(getItems(op));
    } else {
      return [];
    }
  }

  get inputItems() {
    const op = this[BUILDER_SYMBOL].findOperation(hasInputItems);

    if (op) {
      return asArray(getInputItems(op));
    } else {
      return [];
    }
  }

  get cancelQuery() {
    const args = this;

    return (cancelValue) => {
      const builder = this[BUILDER_SYMBOL];

      if (cancelValue === undefined) {
        if (builder.isInsert()) {
          cancelValue = args.inputItems;
        } else if (builder.isFind()) {
          cancelValue = [];
        } else {
          cancelValue = 0;
        }
      }

      builder.resolve(cancelValue);
    };
  }
}

function getRelation(op) {
  return op.relation;
}

function hasRelation(op) {
  return !!getRelation(op);
}

function getModelOptions(op) {
  return op.modelOptions;
}

function hasModelOptions(op) {
  return !!getModelOptions(op);
}

function getItems(op) {
  return op.instance || (op.owner && op.owner.isModels && op.owner.modelArray);
}

function hasItems(op) {
  return !!getItems(op);
}

function getInputItems(op) {
  return op.models || op.model;
}

function hasInputItems(op) {
  return !!getInputItems(op);
}

module.exports = {
  StaticHookArguments,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/ValueBuilder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray, isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { buildArg } = __webpack_require__("./node_modules/objection/lib/utils/buildUtils.js");

class ValueBuilder {
  constructor(value) {
    this._value = value;
    this._cast = null;
    // Cast objects and arrays to json by default.
    this._toJson = isObject(value);
    this._toArray = false;
    this._alias = null;
  }

  get cast() {
    return this._cast;
  }

  castText() {
    return this.castTo('text');
  }

  castInt() {
    return this.castTo('integer');
  }

  castBigInt() {
    return this.castTo('bigint');
  }

  castFloat() {
    return this.castTo('float');
  }

  castDecimal() {
    return this.castTo('decimal');
  }

  castReal() {
    return this.castTo('real');
  }

  castBool() {
    return this.castTo('boolean');
  }

  castJson() {
    this._toArray = false;
    this._toJson = true;
    this._cast = 'jsonb';
    return this;
  }

  castTo(sqlType) {
    this._cast = sqlType;
    return this;
  }

  asArray() {
    this._toJson = false;
    this._toArray = true;
    return this;
  }

  as(alias) {
    this._alias = alias;
    return this;
  }

  toKnexRaw(builder) {
    return builder.knex().raw(...this._createRawArgs(builder));
  }

  _createRawArgs(builder) {
    let sql = null;
    let bindings = [];

    if (this._toJson) {
      bindings.push(JSON.stringify(this._value));
      sql = '?';
    } else if (this._toArray) {
      const values = asArray(this._value);
      bindings.push(...values.map((it) => buildArg(it, builder)));
      sql = `ARRAY[${values.map(() => '?').join(', ')}]`;
    } else {
      bindings.push(this._value);
      sql = '?';
    }

    if (this._cast) {
      sql = `CAST(${sql} AS ${this._cast})`;
    }

    if (this._alias) {
      bindings.push(this._alias);
      sql = `${sql} as ??`;
    }

    return [sql, bindings];
  }
}

function val(val) {
  return new ValueBuilder(val);
}

module.exports = {
  ValueBuilder,
  val,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphAction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPostgres } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");

const POSTGRES_MAX_INSERT_BATCH_SIZE = 100;
const MAX_CONCURRENCY = 100;

class GraphAction {
  constructor(graphData) {
    this.graphData = graphData;
  }

  static get ReturningAllSelector() {
    return (op) => {
      // Only select `returning('*')` operation.
      return op.name === 'returning' && op.args.includes('*');
    };
  }

  static getConcurrency(builder, nodes) {
    return nodes.reduce((minConcurrency, node) => {
      return Math.min(minConcurrency, node.modelClass.getConcurrency(builder.unsafeKnex()));
    }, MAX_CONCURRENCY);
  }

  get graph() {
    return this.graphData.graph;
  }

  get currentGraph() {
    return this.graphData.currentGraph;
  }

  get graphOptions() {
    return this.graphData.graphOptions;
  }

  run(builder) {
    return null;
  }

  _getConcurrency(builder, nodes) {
    return GraphAction.getConcurrency(builder, nodes);
  }

  _getBatchSize(builder) {
    return isPostgres(builder.unsafeKnex()) ? POSTGRES_MAX_INSERT_BATCH_SIZE : 1;
  }

  _resolveReferences(node) {
    if (node.isReference) {
      this._resolveReference(node);
    }
  }

  _resolveReference(node) {
    const refNode = node.referencedNode;

    for (const prop of Object.keys(refNode.obj)) {
      if (!node.obj.hasOwnProperty(prop)) {
        node.obj[prop] = refNode.obj[prop];
      }
    }
  }
}

module.exports = {
  GraphAction,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphData.js":
/***/ ((module) => {

"use strict";


class GraphData {
  constructor({ graph, currentGraph, graphOptions, nodeDbExistence }) {
    this.graph = graph;
    this.currentGraph = currentGraph;
    this.graphOptions = graphOptions;
    this.nodeDbExistence = nodeDbExistence;
  }
}

module.exports = {
  GraphData,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphFetcher.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray, groupBy } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { ModelGraph } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraph.js");
const { FetchStrategy } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphOptions.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");

class GraphFetcher {
  /**
   * Given a graph and options, fetches the current state of that graph
   * from the database and returns it as a ModelGraph instance.
   */
  static async fetchCurrentGraph({ builder, graph, graphOptions }) {
    const { rootObjects } = graph;

    const rootIds = getRootIds(rootObjects);
    const modelClass = builder.modelClass();

    if (rootIds.length === 0) {
      return Promise.resolve(ModelGraph.create(modelClass, []));
    }

    const eagerExpr = RelationExpression.fromModelGraph(rootObjects);
    const models = await modelClass
      .query()
      .childQueryOf(builder, childQueryOptions())
      .modify(propagateMethodCallsFromQuery(builder))
      .modify(buildFetchQuerySelects(graph, graphOptions, eagerExpr))
      .findByIds(rootIds)
      .withGraphFetched(eagerExpr)
      .internalOptions(fetchQueryInternalOptions());

    return ModelGraph.create(modelClass, models);
  }
}

function getRootIds(rootObjects) {
  return asArray(rootObjects)
    .filter((it) => it.$hasId())
    .map((root) => root.$id());
}

function propagateMethodCallsFromQuery(builder) {
  return (fetchBuilder) => {
    // Propagate some method calls from the root query.
    for (const method of ['forUpdate', 'forShare', 'forNoKeyUpdate', 'forKeyShare']) {
      if (builder.has(method)) {
        fetchBuilder[method]();
      }
    }
  };
}

function buildFetchQuerySelects(graph, graphOptions, eagerExpr) {
  return (builder) => {
    const nodesByRelationPath = groupNodesByRelationPath(graph, eagerExpr);

    for (const [relationPath, nodes] of nodesByRelationPath.entries()) {
      const selectModifier = createFetchSelectModifier(nodes, graphOptions);

      if (!relationPath) {
        builder.modify(selectModifier);
      } else {
        builder.modifyGraph(relationPath, selectModifier);
      }
    }
  };
}

function groupNodesByRelationPath(graph, eagerExpr) {
  const nodesByRelationPath = groupBy(graph.nodes, (node) => node.relationPathKey);

  // Not all relation paths have nodes. Relations with nulls or empty arrays
  // don't have nodes, but will still need to be fetched. Add these to the
  // map as empty arrays.
  forEachPath(eagerExpr.node, (relationPath) => {
    if (!nodesByRelationPath.has(relationPath)) {
      nodesByRelationPath.set(relationPath, []);
    }
  });

  return nodesByRelationPath;
}

function createFetchSelectModifier(nodes, graphOptions) {
  if (graphOptions.isFetchStrategy(FetchStrategy.OnlyIdentifiers)) {
    return createIdentifierSelector();
  } else if (graphOptions.isFetchStrategy(FetchStrategy.OnlyNeeded)) {
    return createInputColumnSelector(nodes);
  } else {
    return () => {};
  }
}

// Returns a function that only selects the id column.
function createIdentifierSelector() {
  return (builder) => {
    builder.select(builder.fullIdColumn());
  };
}

// Returns a function that only selects the columns that exist in the input.
function createInputColumnSelector(nodes) {
  return (builder) => {
    const selects = new Map();

    for (const node of nodes) {
      const databaseJson = node.obj.$toDatabaseJson(builder);

      for (const column of Object.keys(databaseJson)) {
        if (!shouldSelectColumn(column, selects, node)) {
          continue;
        }

        const selection =
          createManyToManyExtraSelectionIfNeeded(builder, column, node) ||
          createSelection(builder, column, node);

        selects.set(column, selection);
      }
    }

    const selectArr = Array.from(selects.values());
    const idColumns = asArray(builder.fullIdColumn());

    for (const idColumn of idColumns) {
      if (!selectArr.includes(idColumn)) {
        // Always select the identifers.
        selectArr.push(idColumn);
      }
    }

    builder.select(selectArr);
  };
}

function shouldSelectColumn(column, selects, node) {
  const modelClass = node.modelClass;

  return (
    !selects.has(column) &&
    column !== modelClass.propertyNameToColumnName(modelClass.dbRefProp) &&
    column !== modelClass.propertyNameToColumnName(modelClass.uidRefProp) &&
    column !== modelClass.propertyNameToColumnName(modelClass.uidProp)
  );
}

function createManyToManyExtraSelectionIfNeeded(builder, column, node) {
  if (node.parentEdge && node.parentEdge.relation.isObjectionManyToManyRelation) {
    const relation = node.parentEdge.relation;
    const extra = relation.joinTableExtras.find((extra) => extra.aliasCol === column);

    if (extra) {
      return `${builder.tableRefFor(relation.joinModelClass)}.${extra.joinTableCol} as ${
        extra.aliasCol
      }`;
    }
  }

  return null;
}

function createSelection(builder, column, node) {
  return `${builder.tableRefFor(node.modelClass)}.${column}`;
}

function childQueryOptions() {
  return {
    fork: true,
    isInternalQuery: true,
  };
}

function fetchQueryInternalOptions() {
  return {
    keepImplicitJoinProps: true,
  };
}

function forEachPath(eagerExprNode, cb, path = []) {
  for (const relation of eagerExprNode.$childNames) {
    path.push(relation);
    cb(path.join('.'));
    forEachPath(eagerExprNode[relation], cb, path);
    path.pop();
  }
}

module.exports = {
  GraphFetcher,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphNodeDbExistence.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphData } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphData.js");
const { GraphAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphAction.js");
const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

/**
 * This weird little class is responsible for checking (and maintaining information)
 * whether certain nodes exist in the database.
 *
 * Note that this information is only calculated for nodes for which `insertMissing`
 * option is true.
 */
class GraphNodeDbExistence {
  static createEveryNodeExistsExistence() {
    return new GraphNodeDbExistence(new Map());
  }

  /**
   * Goes through the graphs and identifies nodes that may not exist in the db
   * (nodes that have an id, but are not found in `currentGraph`) and
   * creates an instance of GraphNodeDbExistence that can be used to
   * synchronously check if a node exist in the database.
   */
  static async create({ builder, graph, graphOptions, currentGraph }) {
    if (graphOptions.isInsertOnly()) {
      // With insertGraph, we never want to do anything but inserts.
      return GraphNodeDbExistence.createEveryNodeExistsExistence();
    }

    const graphData = new GraphData({
      graph,
      graphOptions,
      currentGraph,
      // We don't yet have an instance of GraphNodeDbExistence since we are
      // creating one. We can (and should) safely use an instance that
      // assumes that all nodes exist in the db for the purposes of this
      // method.
      nodeDbExistence: GraphNodeDbExistence.createEveryNodeExistsExistence(),
    });

    const { mayNotExist, mayNotExistNodes } = createMayNotExistMap(graphData);

    if (mayNotExist.size == 0) {
      // Early exit if we found no items for which we should check their
      // existence in the db.
      return GraphNodeDbExistence.createEveryNodeExistsExistence();
    }

    const dontExist = await createDontExistMap({ builder, mayNotExist, mayNotExistNodes });

    return new GraphNodeDbExistence(dontExist);
  }

  constructor(dontExist) {
    this.dontExist = dontExist;
  }

  doesNodeExistInDb(node) {
    const idMap = this.dontExist.get(node.modelClass);

    if (!idMap) {
      return true;
    }

    return !idMap.has(node.obj.$idKey());
  }
}

function createMayNotExistMap(graphData) {
  const { graph, currentGraph, graphOptions } = graphData;

  const mayNotExist = new Map();
  const mayNotExistNodes = [];

  for (const node of graph.nodes) {
    if (
      // As an optimization, only consider nodes for which `insertMissing` is true.
      // We only need the information for those nodes.
      graphOptions.shouldInsertMissing(node) &&
      // Only consider nodes that will be related. We don't consider nodes that
      // would get inserted with an id. Those will still result in a unique
      // constraint error.
      graphOptions.shouldRelate(node, graphData) &&
      // Relate nodes may not have an id if they are `#ref` nodes. Only consider
      // nodes that have an id so that we can check the existence.
      node.hasId &&
      // We can ignore nodes if they are found anywhere in the graph. `shouldRelate`
      // only checks if the node is found in the same relation.
      !hasNodeById(currentGraph, node)
    ) {
      if (!mayNotExist.has(node.modelClass)) {
        mayNotExist.set(node.modelClass, new Map());
      }

      mayNotExist.get(node.modelClass).set(node.obj.$idKey(), node.obj.$id());
      mayNotExistNodes.push(node);
    }
  }

  return {
    mayNotExist,
    mayNotExistNodes,
  };
}

function hasNodeById(currentGraph, nodeToFind) {
  const { modelClass } = nodeToFind;

  const tableToFind = modelClass.getTableName();
  const idProps = modelClass.getIdPropertyArray();

  return currentGraph.nodes.some((node) => {
    return (
      node.modelClass.getTableName() === tableToFind &&
      idProps.every((idProp) => node.obj[idProp] === nodeToFind.obj[idProp])
    );
  });
}

async function createDontExistMap({ builder, mayNotExist, mayNotExistNodes }) {
  const dontExist = cloneExistenceMap(mayNotExist);
  const existenceCheckQueries = createExistenceCheckQueries({ builder, mayNotExist });

  const results = await promiseUtils.map(existenceCheckQueries, (builder) => builder.execute(), {
    concurrency: GraphAction.getConcurrency(builder, mayNotExistNodes),
  });

  // Remove all items from the mayNotExist map that we have just proven to exist
  // by executing the existenceCheckQueries.
  for (const modelResult of results) {
    for (const item of modelResult) {
      const modelClass = item.constructor;
      const idMap = dontExist.get(modelClass);
      // Exist, remove from the map.
      idMap.delete(item.$idKey());
    }
  }

  // Now only items that don't exist in the db are left in this map.
  return dontExist;
}

function createExistenceCheckQueries({ builder, mayNotExist }) {
  const builders = [];

  for (const [modelClass, idMap] of mayNotExist.entries()) {
    const ids = Array.from(idMap.values());

    // Create one query per model class (table) to fetch the identifiers
    // of the nodes that may not exist. These queries should be super fast
    // since they come straight from the index.
    builders.push(
      modelClass
        .query()
        .childQueryOf(builder, childQueryOptions())
        .findByIds(ids)
        .select(modelClass.getIdColumnArray()),
    );
  }

  return builders;
}

function childQueryOptions() {
  return {
    fork: true,
    isInternalQuery: true,
  };
}

function cloneExistenceMap(exixtenseMap) {
  const clone = new Map(exixtenseMap);

  for (const modelClass of clone.keys()) {
    clone.set(modelClass, new Map(clone.get(modelClass)));
  }

  return clone;
}

module.exports = {
  GraphNodeDbExistence,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphOperation.js":
/***/ ((module) => {

"use strict";


class GraphOperation {
  constructor(graphData) {
    this.graphData = graphData;
  }

  get graph() {
    return this.graphData.graph;
  }

  get currentGraph() {
    return this.graphData.currentGraph;
  }

  get graphOptions() {
    return this.graphData.graphOptions;
  }

  createActions() {
    return [];
  }
}

module.exports = {
  GraphOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphOptions.js":
/***/ ((module) => {

"use strict";


const NO_RELATE = 'noRelate';
const NO_UNRELATE = 'noUnrelate';
const NO_INSERT = 'noInsert';
const NO_UPDATE = 'noUpdate';
const NO_DELETE = 'noDelete';

const UPDATE = 'update';
const RELATE = 'relate';
const UNRELATE = 'unrelate';
const INSERT_MISSING = 'insertMissing';
const FETCH_STRATEGY = 'fetchStrategy';
const ALLOW_REFS = 'allowRefs';

const FetchStrategy = {
  OnlyIdentifiers: 'OnlyIdentifiers',
  Everything: 'Everything',
  OnlyNeeded: 'OnlyNeeded',
};

class GraphOptions {
  constructor(options) {
    if (options instanceof GraphOptions) {
      this.options = options.options;
    } else {
      this.options = options;
    }
  }

  isFetchStrategy(strategy) {
    if (!FetchStrategy[strategy]) {
      throw new Error(`unknown strategy "${strategy}"`);
    }

    if (!this.options[FETCH_STRATEGY]) {
      return strategy === FetchStrategy.OnlyNeeded;
    } else {
      return this.options[FETCH_STRATEGY] === strategy;
    }
  }

  isInsertOnly() {
    // NO_RELATE is not in the list, since the `insert only` mode does
    // relate things that can be related using inserts.
    // TODO: Use a special key for this.
    return [NO_DELETE, NO_UPDATE, NO_UNRELATE, INSERT_MISSING].every((opt) => {
      return this.options[opt] === true;
    });
  }

  // Like `shouldRelate` but ignores settings that explicitly disable relate operations.
  shouldRelateIgnoreDisable(node, graphData) {
    if (node.isReference || node.isDbReference) {
      return true;
    }

    return (
      this._hasOption(node, RELATE) &&
      !getCurrentNode(node, graphData) &&
      !!node.parentEdge &&
      !!node.parentEdge.relation &&
      node.parentEdge.relation.hasRelateProp(node.obj) &&
      graphData.nodeDbExistence.doesNodeExistInDb(node)
    );
  }

  shouldRelate(node, graphData) {
    return !this._hasOption(node, NO_RELATE) && this.shouldRelateIgnoreDisable(node, graphData);
  }

  // Like `shouldInsert` but ignores settings that explicitly disable insert operations.
  shouldInsertIgnoreDisable(node, graphData) {
    return (
      !getCurrentNode(node, graphData) &&
      !this.shouldRelateIgnoreDisable(node, graphData) &&
      (!node.hasId || this.shouldInsertMissing(node))
    );
  }

  shouldInsert(node, graphData) {
    return !this._hasOption(node, NO_INSERT) && this.shouldInsertIgnoreDisable(node, graphData);
  }

  shouldInsertMissing(node) {
    return this._hasOption(node, INSERT_MISSING);
  }

  // Like `shouldPatch() || shouldUpdate()` but ignores settings that explicitly disable
  // update or patch operations.
  shouldPatchOrUpdateIgnoreDisable(node, graphData) {
    if (this.shouldRelate(node, graphData)) {
      // We should update all nodes that are going to be related. Note that
      // we don't actually update anything unless there is something to update
      // so this is just a preliminary test.
      return true;
    }

    return !!getCurrentNode(node, graphData);
  }

  shouldPatch(node, graphData) {
    return (
      this.shouldPatchOrUpdateIgnoreDisable(node, graphData) &&
      !this._hasOption(node, NO_UPDATE) &&
      !this._hasOption(node, UPDATE)
    );
  }

  shouldUpdate(node, graphData) {
    return (
      this.shouldPatchOrUpdateIgnoreDisable(node, graphData) &&
      !this._hasOption(node, NO_UPDATE) &&
      this._hasOption(node, UPDATE)
    );
  }

  // Like `shouldUnrelate` but ignores settings that explicitly disable unrelate operations.
  shouldUnrelateIgnoreDisable(currentNode) {
    return this._hasOption(currentNode, UNRELATE);
  }

  shouldUnrelate(currentNode, graphData) {
    return (
      !getNode(currentNode, graphData.graph) &&
      !this._hasOption(currentNode, NO_UNRELATE) &&
      this.shouldUnrelateIgnoreDisable(currentNode)
    );
  }

  shouldDelete(currentNode, graphData) {
    return (
      !getNode(currentNode, graphData.graph) &&
      !this._hasOption(currentNode, NO_DELETE) &&
      !this.shouldUnrelateIgnoreDisable(currentNode)
    );
  }

  shouldInsertOrRelate(node, graphData) {
    return this.shouldInsert(node, graphData) || this.shouldRelate(node, graphData);
  }

  shouldDeleteOrUnrelate(currentNode, graphData) {
    return this.shouldDelete(currentNode, graphData) || this.shouldUnrelate(currentNode, graphData);
  }

  allowRefs() {
    return !!this.options[ALLOW_REFS];
  }

  rebasedOptions(newRoot) {
    const newOpt = {};
    const newRootRelationPath = newRoot.relationPathKey;

    for (const name of Object.keys(this.options)) {
      const value = this.options[name];

      if (Array.isArray(value)) {
        newOpt[name] = value
          .filter((it) => it.startsWith(newRootRelationPath))
          .map((it) => it.slice(newRootRelationPath.length + 1))
          .filter((it) => !!it);
      } else {
        newOpt[name] = value;
      }
    }

    return new GraphOptions(newOpt);
  }

  _hasOption(node, optionName) {
    const option = this.options[optionName];

    if (Array.isArray(option)) {
      return option.indexOf(node.relationPathKey) !== -1;
    } else if (typeof option === 'boolean') {
      return option;
    } else if (option === undefined) {
      return false;
    } else {
      throw new Error(
        `expected ${optionName} option value "${option}" to be an instance of boolean or array of strings`,
      );
    }
  }
}

function getCurrentNode(node, graphData) {
  if (!graphData || !node) {
    return null;
  }

  return graphData.currentGraph.nodeForNode(node);
}

function getNode(currentNode, graph) {
  if (!graph || !currentNode) {
    return null;
  }

  return graph.nodeForNode(currentNode);
}

module.exports = {
  GraphOptions,
  FetchStrategy,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/GraphUpsert.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ModelGraph } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraph.js");
const { ModelGraphEdge } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphEdge.js");
const { createNotModelError } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphBuilder.js");
const { GraphFetcher } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphFetcher.js");
const { GraphInsert } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/insert/GraphInsert.js");
const { GraphPatch } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/patch/GraphPatch.js");
const { GraphDelete } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/delete/GraphDelete.js");
const { GraphRecursiveUpsert } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/recursiveUpsert/GraphRecursiveUpsert.js");
const { GraphOptions } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphOptions.js");
const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");
const { GraphNodeDbExistence } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphNodeDbExistence.js");
const { GraphData } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphData.js");
const { uniqBy, asArray, isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class GraphUpsert {
  constructor({ rootModelClass, objects, upsertOptions }) {
    checkCanBeConvertedToModels(rootModelClass, objects);

    this.objects = rootModelClass.ensureModelArray(objects, GraphUpsert.modelOptions);
    this.isArray = Array.isArray(objects);
    this.upsertOpt = upsertOptions;
  }

  static get modelOptions() {
    return { skipValidation: true };
  }

  run(builder) {
    const modelClass = builder.modelClass();
    const graphOptions = new GraphOptions(this.upsertOpt);

    const graph = ModelGraph.create(modelClass, this.objects);
    assignDbRefsAsRelateProps(graph);

    return createGraphData(builder, graphOptions, graph)
      .then(checkForErrors(builder))
      .then(pruneGraphs())
      .then(executeOperations(builder))
      .then(returnResult(this.objects, this.isArray));
  }
}

function checkCanBeConvertedToModels(modelClass, objects) {
  asArray(objects).forEach((obj) => {
    if (!isObject(obj)) {
      throw createNotModelError(modelClass, obj);
    }
  });
}

function assignDbRefsAsRelateProps(graph) {
  for (const node of graph.nodes) {
    if (!node.parentEdge || !node.parentEdge.relation || !node.isDbReference) {
      continue;
    }

    node.parentEdge.relation.setRelateProp(node.obj, asArray(node.dbReference));
  }
}

async function createGraphData(builder, graphOptions, graph) {
  const currentGraph = await fetchCurrentGraph(builder, graphOptions, graph);

  const nodeDbExistence = await GraphNodeDbExistence.create({
    builder,
    graph,
    graphOptions,
    currentGraph,
  });

  return new GraphData({ graph, currentGraph, graphOptions, nodeDbExistence });
}

function fetchCurrentGraph(builder, graphOptions, graph) {
  if (graphOptions.isInsertOnly()) {
    return Promise.resolve(ModelGraph.createEmpty());
  } else {
    return GraphFetcher.fetchCurrentGraph({ builder, graph, graphOptions });
  }
}

// Remove branches from the graph that require no operations. For example
// we never want to do anything for descendant nodes of a node that is
// deleted or unrelated. We never delete recursively.
function pruneGraphs() {
  return (graphData) => {
    pruneRelatedBranches(graphData);

    if (!graphData.graphOptions.isInsertOnly()) {
      pruneDeletedBranches(graphData);
    }

    return graphData;
  };
}

function pruneRelatedBranches(graphData) {
  const relateNodes = graphData.graph.nodes.filter((node) => {
    return (
      !graphData.currentGraph.nodeForNode(node) &&
      !graphData.graphOptions.shouldInsertIgnoreDisable(node, graphData)
    );
  });

  removeBranchesFromGraph(findRoots(relateNodes), graphData.graph);
}

function pruneDeletedBranches(graphData) {
  const { graph, currentGraph } = graphData;

  const deleteNodes = currentGraph.nodes.filter((currentNode) => !graph.nodeForNode(currentNode));
  const roots = findRoots(deleteNodes);

  // Don't delete relations the current graph doesn't even mention.
  // So if the parent node doesn't even have the relation, it's not
  // supposed to be deleted.
  const rootsNotInRelation = roots.filter((deleteRoot) => {
    if (!deleteRoot.parentNode) {
      return false;
    }

    const { relation } = deleteRoot.parentEdge;
    const parentNode = graph.nodeForNode(deleteRoot.parentNode);

    if (!parentNode) {
      return false;
    }

    return parentNode.obj[relation.name] === undefined;
  });

  removeBranchesFromGraph(roots, currentGraph);
  removeNodesFromGraph(new Set(rootsNotInRelation), currentGraph);
}

function findRoots(nodes) {
  const nodeSet = new Set(nodes);

  return uniqBy(
    nodes.filter((node) => {
      let parentNode = node.parentNode;

      while (parentNode) {
        if (nodeSet.has(parentNode)) {
          return false;
        }

        parentNode = parentNode.parentNode;
      }

      return true;
    }),
  );
}

function removeBranchesFromGraph(branchRoots, graph) {
  const nodesToRemove = new Set(
    branchRoots.reduce(
      (nodesToRemove, node) => [...nodesToRemove, ...node.descendantRelationNodes],
      [],
    ),
  );

  removeNodesFromGraph(nodesToRemove, graph);
}

function removeNodesFromGraph(nodesToRemove, graph) {
  const edgesToRemove = new Set();

  for (const node of nodesToRemove) {
    for (const edge of node.edges) {
      const otherNode = edge.getOtherNode(node);

      if (!nodesToRemove.has(otherNode)) {
        otherNode.removeEdge(edge);
        edgesToRemove.add(edge);
      }
    }
  }

  graph.nodes = graph.nodes.filter((node) => !nodesToRemove.has(node));
  graph.edges = graph.edges.filter((edge) => !edgesToRemove.has(edge));

  return graph;
}

function checkForErrors(builder) {
  return (graphData) => {
    checkForNotFoundErrors(graphData, builder);
    checkForUnallowedRelationErrors(graphData, builder);
    checkForUnallowedReferenceErrors(graphData, builder);

    if (graphData.graphOptions.isInsertOnly()) {
      checkForHasManyRelateErrors(graphData);
    }

    return graphData;
  };
}

function checkForNotFoundErrors(graphData, builder) {
  const { graphOptions, currentGraph, graph } = graphData;

  for (const node of graph.nodes) {
    if (
      node.obj.$hasId() &&
      !graphOptions.shouldInsertIgnoreDisable(node, graphData) &&
      !graphOptions.shouldRelateIgnoreDisable(node, graphData) &&
      !currentGraph.nodeForNode(node)
    ) {
      if (!node.parentNode) {
        throw node.modelClass.createNotFoundError(builder.context(), {
          message: `root model (id=${node.obj.$id()}) does not exist. If you want to insert it with an id, use the insertMissing option`,
          dataPath: node.dataPath,
        });
      } else {
        throw node.modelClass.createNotFoundError(builder.context(), {
          message: `model (id=${node.obj.$id()}) is not a child of model (id=${node.parentNode.obj.$id()}). If you want to relate it, use the relate option. If you want to insert it with an id, use the insertMissing option`,
          dataPath: node.dataPath,
        });
      }
    }
  }
}

function checkForUnallowedRelationErrors(graphData, builder) {
  const { graph } = graphData;
  const allowedExpression = builder.allowedGraphExpression();

  if (allowedExpression) {
    const rootsObjs = graph.nodes.filter((node) => !node.parentEdge).map((node) => node.obj);
    const expression = RelationExpression.fromModelGraph(rootsObjs);

    if (!allowedExpression.isSubExpression(expression)) {
      throw builder.modelClass().createValidationError({
        type: ValidationErrorType.UnallowedRelation,
        message: 'trying to upsert an unallowed relation',
      });
    }
  }
}

function checkForUnallowedReferenceErrors(graphData, builder) {
  const { graph, graphOptions } = graphData;

  if (graphOptions.allowRefs()) {
    return;
  }

  if (graph.edges.some((edge) => edge.type === ModelGraphEdge.Type.Reference)) {
    throw builder.modelClass().createValidationError({
      type: ValidationErrorType.InvalidGraph,
      message:
        '#ref references are not allowed in a graph by default. see the allowRefs insert/upsert graph option',
    });
  }
}

function checkForHasManyRelateErrors(graphData) {
  const { graph, graphOptions } = graphData;

  for (const node of graph.nodes) {
    if (
      graphOptions.shouldRelate(node, graphData) &&
      node.parentEdge.relation.isObjectionHasManyRelation
    ) {
      throw new Error(
        'You cannot relate HasManyRelation or HasOneRelation using insertGraph, because those require update operations. Consider using upsertGraph instead.',
      );
    }
  }
}

function executeOperations(builder) {
  return (graphData) => {
    const operations = graphData.graphOptions.isInsertOnly()
      ? [GraphInsert]
      : [GraphDelete, GraphInsert, GraphPatch, GraphRecursiveUpsert];

    return operations.reduce((promise, Operation) => {
      const operation = new Operation(graphData);
      const actions = operation.createActions();

      return promise.then(() => executeActions(builder, actions));
    }, Promise.resolve());
  };
}

function executeActions(builder, actions) {
  return actions.reduce(
    (promise, action) => promise.then(() => action.run(builder)),
    Promise.resolve(),
  );
}

function returnResult(objects, isArray) {
  return () => (isArray ? objects : objects[0]);
}

module.exports = {
  GraphUpsert,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/delete/GraphDelete.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphOperation.js");
const { GraphDeleteAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/delete/GraphDeleteAction.js");

class GraphDelete extends GraphOperation {
  createActions() {
    return [
      new GraphDeleteAction(this.graphData, {
        nodes: this.currentGraph.nodes.filter((currentNode) =>
          this.graphOptions.shouldDeleteOrUnrelate(currentNode, this.graphData),
        ),
      }),
    ];
  }
}

module.exports = {
  GraphDelete,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/delete/GraphDeleteAction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphAction.js");
const { groupBy } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

class GraphDeleteAction extends GraphAction {
  constructor(graphData, { nodes }) {
    super(graphData);
    // Nodes to delete.
    this.nodes = nodes;
  }

  run(builder) {
    const nodesTodelete = this._filterOutBelongsToOneRelationUnrelates(this.nodes);
    const builders = this._createDeleteBuilders(builder, nodesTodelete);

    return promiseUtils.map(builders, (builder) => builder.execute(), {
      concurrency: this._getConcurrency(builder, nodesTodelete),
    });
  }

  _filterOutBelongsToOneRelationUnrelates(nodes) {
    // `BelongsToOneRelation` unrelate is handled by `GraphPatch` because
    // unrelating a `BelongsToOneRelation` is just a matter of updating
    // one field of the parent node.
    return nodes.filter((node) => {
      return !(
        this.graphOptions.shouldUnrelate(node, this.graphData) &&
        node.parentEdge.relation.isObjectionBelongsToOneRelation
      );
    });
  }

  _createDeleteBuilders(parentBuilder, nodesTodelete) {
    const nodesByRelation = groupBy(nodesTodelete, getRelation);
    const builders = [];

    nodesByRelation.forEach((nodes, relation) => {
      const nodesByParent = groupBy(nodes, getParent);

      nodesByParent.forEach((nodes, parentNode) => {
        const shouldUnrelate = this.graphOptions.shouldUnrelate(nodes[0], this.graphData);

        const builder = parentNode.obj.$relatedQuery(relation.name).childQueryOf(parentBuilder);

        if (!relation.isObjectionBelongsToOneRelation) {
          // This is useless in case of BelongsToOneRelation.
          builder.findByIds(nodes.map((node) => node.obj.$id()));
        }

        for (const node of nodes) {
          node.userData.deleted = true;
        }

        builders.push(shouldUnrelate ? builder.unrelate() : builder.delete());
      });
    });

    return builders;
  }
}

function getRelation(node) {
  return node.parentEdge.relation;
}

function getParent(node) {
  return node.parentNode;
}

module.exports = {
  GraphDeleteAction,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/insert/GraphInsert.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { JoinRowGraphInsertAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/insert/JoinRowGraphInsertAction.js");
const { GraphInsertAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/insert/GraphInsertAction.js");
const { GraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphOperation.js");
const { ModelGraphEdge } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphEdge.js");

class GraphInsert extends GraphOperation {
  constructor(...args) {
    super(...args);
    this.dependencies = this._createDependencyMap();
  }

  createActions() {
    return [...this._createNormalActions(), ...this._createJoinRowActions()];
  }

  _createDependencyMap() {
    const dependencies = new Map();

    for (const edge of this.graph.edges) {
      if (edge.type == ModelGraphEdge.Type.Relation) {
        this._createRelationDependency(edge, dependencies);
      } else {
        this._createReferenceDependency(edge, dependencies);
      }
    }

    return dependencies;
  }

  _createRelationDependency(edge, dependencies) {
    if (edge.relation.isObjectionHasManyRelation) {
      // In case of HasManyRelation the related node depends on the owner node
      // because the related node has the foreign key.
      this._addDependency(edge.relatedNode, edge, dependencies);
    } else if (edge.relation.isObjectionBelongsToOneRelation) {
      // In case of BelongsToOneRelation the owner node depends on the related
      // node because the owner node has the foreign key.
      this._addDependency(edge.ownerNode, edge, dependencies);
    }
  }

  _createReferenceDependency(edge, dependencies) {
    this._addDependency(edge.ownerNode, edge, dependencies);
  }

  _addDependency(node, edge, dependencies) {
    let edges = dependencies.get(node);

    if (!edges) {
      edges = [];
      dependencies.set(node, edges);
    }

    edges.push(edge);
  }

  _createNormalActions() {
    const handledNodes = new Set();
    const actions = [];

    while (true) {
      // At this point, don't care if the nodes have already been inserted before
      // given to this class. `GraphInsertAction` will test that and only insert
      // new ones. We need to pass all nodes to `GraphInsertActions` so that we
      // can resolve all dependencies.
      const nodesToInsert = this.graph.nodes.filter((node) => {
        return !this._isHandled(node, handledNodes) && !this._hasDependencies(node, handledNodes);
      });

      if (nodesToInsert.length === 0) {
        break;
      }

      actions.push(
        new GraphInsertAction(this.graphData, {
          nodes: nodesToInsert,
          dependencies: this.dependencies,
        }),
      );

      for (const node of nodesToInsert) {
        this._markHandled(node, handledNodes);
      }
    }

    if (handledNodes.size !== this.graph.nodes.length) {
      throw new Error('the object graph contains cyclic references');
    }

    return actions;
  }

  _isHandled(node, handledNodes) {
    return handledNodes.has(node);
  }

  _hasDependencies(node, handledNodes) {
    if (!this.dependencies.has(node)) {
      return false;
    }

    for (const edge of this.dependencies.get(node)) {
      const dependencyNode = edge.getOtherNode(node);

      if (!handledNodes.has(dependencyNode) && !this.currentGraph.nodeForNode(dependencyNode)) {
        return true;
      }
    }

    return false;
  }

  _markHandled(node, handledNodes) {
    handledNodes.add(node);

    // The referencing nodes are all references that don't
    // represent any real entity. They are simply intermediate nodes
    // that depend on this node. Once this node is handled, we can
    // also mark those nodes as handled as there is nothing to actually
    // insert.
    for (const refNode of node.referencingNodes) {
      this._markHandled(refNode, handledNodes);
    }
  }

  _createJoinRowActions() {
    return [
      new JoinRowGraphInsertAction(this.graphData, {
        nodes: this.graph.nodes.filter((node) => {
          return (
            this.currentGraph.nodeForNode(node) === null &&
            node.parentEdge &&
            node.parentEdge.relation.isObjectionManyToManyRelation
          );
        }),
      }),
    ];
  }
}

module.exports = {
  GraphInsert,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/insert/GraphInsertAction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphAction.js");
const { groupBy, chunk, get, set } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { ModelGraphEdge } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphEdge.js");
const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

/**
 * Inserts a batch of nodes for a GraphInsert.
 *
 * One of these is created for each batch of nodes that can be inserted at once.
 * However, the nodes can have a different table and not all databases support
 * batch inserts, so this class splits the inserts into further sub batches
 * when needed.
 */
class GraphInsertAction extends GraphAction {
  constructor(graphData, { nodes, dependencies }) {
    super(graphData);

    // Nodes to insert.
    this.nodes = nodes;
    this.dependencies = dependencies;
  }

  run(builder) {
    const batches = this._createInsertBatches(builder);
    const concurrency = this._getConcurrency(builder, this.nodes);

    return promiseUtils.map(batches, (batch) => this._insertBatch(builder, batch), { concurrency });
  }

  _createInsertBatches(builder) {
    const batches = [];
    const batchSize = this._getBatchSize(builder);
    const nodesByModelClass = groupBy(this.nodes, getModelClass);

    for (const nodes of nodesByModelClass.values()) {
      for (const nodeBatch of chunk(nodes, batchSize)) {
        batches.push(nodeBatch);
      }
    }

    return batches;
  }

  async _insertBatch(parentBuilder, nodes) {
    await this._beforeInsert(nodes);
    await this._insert(parentBuilder, nodes);
    await this._afterInsert(nodes);
  }

  _beforeInsert(nodes) {
    this._resolveDependencies(nodes);
    this._omitManyToManyExtraProps(nodes);
    this._copyRelationPropsFromCurrentIfNeeded(nodes);

    return Promise.resolve();
  }

  _resolveDependencies(nodes) {
    for (const node of nodes) {
      const edges = this.dependencies.get(node);

      if (edges) {
        for (const edge of edges) {
          // `node` needs `dependencyNode` to have been inserted (and it has been).
          const dependencyNode = edge.getOtherNode(node);

          this._resolveDependency(dependencyNode, edge);
        }
      }
    }
  }

  _resolveDependency(dependencyNode, edge) {
    if (edge.type === ModelGraphEdge.Type.Relation && !edge.relation.joinTable) {
      this._resolveRelationDependency(dependencyNode, edge);
    } else if (edge.refType === ModelGraphEdge.ReferenceType.Property) {
      this._resolvePropertyReferenceNode(dependencyNode, edge);
    }
  }

  _resolveRelationDependency(dependencyNode, edge) {
    const dependentNode = edge.getOtherNode(dependencyNode);

    let sourceProp;
    let targetProp;

    if (edge.isOwnerNode(dependencyNode)) {
      sourceProp = edge.relation.ownerProp;
      targetProp = edge.relation.relatedProp;
    } else {
      targetProp = edge.relation.ownerProp;
      sourceProp = edge.relation.relatedProp;
    }

    this._resolveReferences(dependencyNode);

    targetProp.forEach((i) => {
      targetProp.setProp(dependentNode.obj, i, sourceProp.getProp(dependencyNode.obj, i));
    });
  }

  _resolvePropertyReferenceNode(dependencyNode, edge) {
    const dependentNode = edge.getOtherNode(dependencyNode);

    let sourcePath;
    let targetPath;

    if (edge.isOwnerNode(dependencyNode)) {
      sourcePath = edge.refOwnerDataPath;
      targetPath = edge.refRelatedDataPath;
    } else {
      targetPath = edge.refOwnerDataPath;
      sourcePath = edge.refRelatedDataPath;
    }

    const sourceValue = get(dependencyNode.obj, sourcePath);
    const targetValue = get(dependentNode.obj, targetPath);

    if (targetValue === edge.refMatch) {
      set(dependentNode.obj, targetPath, sourceValue);
    } else {
      set(dependentNode.obj, targetPath, targetValue.replace(edge.refMatch, sourceValue));
    }
  }

  _omitManyToManyExtraProps(nodes) {
    for (const node of nodes) {
      if (
        node.parentEdge &&
        node.parentEdge.type === ModelGraphEdge.Type.Relation &&
        node.parentEdge.relation.joinTableExtras.length > 0
      ) {
        node.parentEdge.relation.omitExtraProps([node.obj]);
      }
    }
  }

  _copyRelationPropsFromCurrentIfNeeded(nodes) {
    for (const node of nodes) {
      const currentNode = this.currentGraph.nodeForNode(node);

      if (!currentNode) {
        continue;
      }

      for (const edge of node.edges) {
        if (edge.type !== ModelGraphEdge.Type.Relation) {
          continue;
        }

        const prop = edge.isOwnerNode(node) ? edge.relation.ownerProp : edge.relation.relatedProp;

        prop.forEach((i) => {
          const value = prop.getProp(node.obj, i);

          if (value !== undefined) {
            return;
          }

          prop.setProp(node.obj, i, prop.getProp(currentNode.obj, i));
        });
      }
    }
  }

  _insert(parentBuilder, nodes) {
    const [{ modelClass }] = nodes;

    nodes = nodes.filter((node) => {
      return this.graphOptions.shouldInsert(node, this.graphData);
    });

    for (const node of nodes) {
      delete node.obj[modelClass.uidProp];
      node.obj.$validate(null, { dataPath: node.dataPathKey });
    }

    if (nodes.length === 0) {
      return;
    }

    for (const node of nodes) {
      node.userData.inserted = true;
    }

    return this._runRelationBeforeInsertMethods(parentBuilder, nodes).then(() => {
      return modelClass
        .query()
        .insert(nodes.map((node) => node.obj))
        .childQueryOf(parentBuilder)
        .copyFrom(parentBuilder, GraphAction.ReturningAllSelector)
        .execute();
    });
  }

  _runRelationBeforeInsertMethods(parentBuilder, nodes) {
    return Promise.all(
      nodes.map((node) => {
        if (node.parentEdge) {
          return node.parentEdge.relation.beforeInsert(node.obj, parentBuilder.context());
        } else {
          return null;
        }
      }),
    );
  }

  _afterInsert(nodes) {
    for (const node of nodes) {
      for (const refNode of node.referencingNodes) {
        this._resolveDependency(refNode, refNode.parentEdge);
      }
    }
  }
}

function getModelClass(node) {
  return node.modelClass;
}

module.exports = {
  GraphInsertAction,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/insert/JoinRowGraphInsertAction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphAction.js");
const { groupBy, chunk } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

class JoinRowGraphInsertAction extends GraphAction {
  constructor(graphData, { nodes }) {
    super(graphData);
    this.nodes = nodes;
  }

  run(builder) {
    const batches = this._createInsertBatches(builder);
    const concurrency = this._getConcurrency(builder, this.nodes);

    return promiseUtils.map(batches, (batch) => this._insertBatch(builder, batch), { concurrency });
  }

  _createInsertBatches(builder) {
    const batches = [];
    const batchSize = this._getBatchSize(builder);
    const nodesByModel = groupBy(this.nodes, (node) => getJoinTableModel(builder, node));

    for (const [joinTableModelClass, nodes] of nodesByModel.entries()) {
      for (const nodeBatch of chunk(nodes, batchSize)) {
        batches.push(this._createBatch(joinTableModelClass, nodeBatch));
      }
    }

    return batches;
  }

  _createBatch(joinTableModelClass, nodes) {
    return nodes
      .filter((node) => {
        return this.graphOptions.shouldRelate(node, this.graphData) || node.userData.inserted;
      })
      .map((node) => ({
        node,
        joinTableModelClass,
        joinTableObj: this._createJoinTableObj(joinTableModelClass, node),
      }));
  }

  _createJoinTableObj(joinTableModelClass, node) {
    const { parentEdge, parentNode } = node;
    const { relation } = parentEdge;

    this._resolveReferences(node);

    return joinTableModelClass.fromJson(
      relation.createJoinModel(relation.ownerProp.getProps(parentNode.obj), node.obj),
    );
  }

  _insertBatch(parentBuilder, batch) {
    return this._beforeInsert(parentBuilder, batch).then(() => this._insert(parentBuilder, batch));
  }

  _beforeInsert(parentBuilder, batch) {
    return Promise.all(
      batch.map(({ node, joinTableObj }) => {
        if (node.parentEdge) {
          return node.parentEdge.relation.joinTableBeforeInsert(
            joinTableObj,
            parentBuilder.context(),
          );
        } else {
          return null;
        }
      }),
    );
  }

  _insert(parentBuilder, batch) {
    if (batch.length > 0) {
      return batch[0].joinTableModelClass
        .query()
        .childQueryOf(parentBuilder)
        .insert(batch.map((it) => it.joinTableObj));
    }
  }
}

function getJoinTableModel(builder, node) {
  return node.parentEdge.relation.getJoinModelClass(builder.unsafeKnex());
}

module.exports = {
  JoinRowGraphInsertAction,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/patch/GraphPatch.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphOperation.js");
const { GraphPatchAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/patch/GraphPatchAction.js");

class GraphPatch extends GraphOperation {
  createActions() {
    return [
      new GraphPatchAction(this.graphData, {
        nodes: this.graph.nodes.filter((node) =>
          this.graphOptions.shouldPatchOrUpdateIgnoreDisable(node, this.graphData),
        ),
      }),
    ];
  }
}

module.exports = {
  GraphPatch,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/patch/GraphPatchAction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { getModel } = __webpack_require__("./node_modules/objection/lib/model/getModel.js");
const { GraphAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphAction.js");
const { isInternalProp } = __webpack_require__("./node_modules/objection/lib/utils/internalPropUtils.js");
const { difference, isObject, jsonEquals } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

class GraphPatchAction extends GraphAction {
  constructor(graphData, { nodes }) {
    super(graphData);
    // Nodes to patch.
    this.nodes = nodes;
  }

  run(builder) {
    return promiseUtils.map(this.nodes, (node) => this._runForNode(builder, node), {
      concurrency: this._getConcurrency(builder, this.nodes),
    });
  }

  _runForNode(builder, node) {
    const shouldPatch = this.graphOptions.shouldPatch(node, this.graphData);
    const shouldUpdate = this.graphOptions.shouldUpdate(node, this.graphData);

    // BelongsToOneRelation inserts and relates change the parent object's
    // properties. That's why we handle them here.
    const changedPropsBecauseOfBelongsToOneInsert = this._handleBelongsToOneInserts(node);

    // BelongsToOneRelation deletes and unrelates change the parent object's
    // properties. That's why we handle them here.
    const changePropsBecauseOfBelongsToOneDelete = this._handleBelongsToOneDeletes(node);

    const handleUpdate = () => {
      const { changedProps, unchangedProps } = this._findChanges(node);
      const allProps = [...changedProps, ...unchangedProps];

      const propsToUpdate = difference(
        shouldPatch || shouldUpdate
          ? changedProps
          : [...changedPropsBecauseOfBelongsToOneInsert, ...changePropsBecauseOfBelongsToOneDelete],

        // Remove id properties from the props to update. With upsertGraph
        // it never makes sense to change the id.
        node.modelClass.getIdPropertyArray(),
      );

      const update = propsToUpdate.length > 0;
      if (update) {
        // Don't update the fields that we know not to change.
        node.obj.$omitFromDatabaseJson(difference(allProps, propsToUpdate));
        node.userData.updated = true;
      }

      return update;
    };

    const Model = getModel();
    // See if the model defines a beforeUpdate or $beforeUpdate hook. If it does
    // not, we can check for updated properties now and drop out immediately if
    // there is nothing to update. Otherwise, we need to wait for the hook to be
    // called before calling handleUpdate, but only if the node contains changes
    // that aren't id properties (relates). See issues #2233, #2605.
    const hasBeforeUpdate =
      node.obj.constructor.beforeUpdate !== Model.beforeUpdate ||
      node.obj.$beforeUpdate !== Model.prototype.$beforeUpdate;

    if (
      (hasBeforeUpdate && !this._hasNonIdPropertyChanges(node)) ||
      (!hasBeforeUpdate && !handleUpdate())
    ) {
      return null;
    }

    delete node.obj[node.modelClass.uidProp];
    delete node.obj[node.modelClass.uidRefProp];
    delete node.obj[node.modelClass.dbRefProp];

    node.obj.$validate(null, {
      dataPath: node.dataPathKey,
      patch: shouldPatch || (!shouldPatch && !shouldUpdate),
    });

    const updateBuilder = this._createBuilder(node)
      .childQueryOf(builder, childQueryOptions())
      .copyFrom(builder, GraphAction.ReturningAllSelector);

    if (hasBeforeUpdate) {
      updateBuilder.internalContext().runBefore.push((result, builder) => {
        // Call handleUpdate in the runBefore hook which runs after the
        // $beforeUpdate hook, allowing it to modify the object before the
        // updated properties are determined. See issue #2233.
        if (hasBeforeUpdate && !handleUpdate()) {
          builder.internalOptions().returnImmediatelyValue = null;
        }
        return result;
      });
    }

    if (shouldPatch) {
      updateBuilder.patch(node.obj);
    } else {
      updateBuilder.update(node.obj);
    }

    return updateBuilder.execute().then((result) => {
      if (isObject(result) && result.$isObjectionModel) {
        // Handle returning('*').
        node.obj.$set(result);
      }

      return result;
    });
  }

  _handleBelongsToOneInserts(node) {
    const currentNode = this.currentGraph.nodeForNode(node);
    const updatedProps = [];

    for (const edge of node.edges) {
      if (
        edge.isOwnerNode(node) &&
        edge.relation &&
        edge.relation.isObjectionBelongsToOneRelation &&
        edge.relation.relatedProp.hasProps(edge.relatedNode.obj)
      ) {
        const { relation } = edge;

        relation.ownerProp.forEach((i) => {
          const currentValue = currentNode && relation.ownerProp.getProp(currentNode.obj, i);
          const relatedValue = relation.relatedProp.getProp(edge.relatedNode.obj, i);

          if (currentValue != relatedValue) {
            relation.ownerProp.setProp(node.obj, i, relatedValue);
            updatedProps.push(relation.ownerProp.props[i]);
          }
        });
      }
    }

    return updatedProps;
  }

  _handleBelongsToOneDeletes(node) {
    const currentNode = this.currentGraph.nodeForNode(node);
    const updatedProps = [];

    if (!currentNode) {
      return updatedProps;
    }

    for (const edge of currentNode.edges) {
      if (
        edge.isOwnerNode(currentNode) &&
        edge.relation.isObjectionBelongsToOneRelation &&
        node.obj[edge.relation.name] === null &&
        this.graphOptions.shouldDeleteOrUnrelate(edge.relatedNode, this.graphData)
      ) {
        const { relation } = edge;

        relation.ownerProp.forEach((i) => {
          const currentValue = relation.ownerProp.getProp(currentNode.obj, i);

          if (currentValue != null) {
            relation.ownerProp.setProp(node.obj, i, null);
            updatedProps.push(relation.ownerProp.props[i]);
          }
        });
      }
    }

    return updatedProps;
  }

  _findChanges(node) {
    const obj = node.obj;
    const currentNode = this.currentGraph.nodeForNode(node);
    const currentObj = (currentNode && currentNode.obj) || {};
    const relationNames = node.modelClass.getRelationNames();

    const unchangedProps = [];
    const changedProps = [];

    for (const prop of Object.keys(obj)) {
      if (isInternalProp(prop) || relationNames.includes(prop)) {
        continue;
      }

      const value = obj[prop];
      const currentValue = currentObj[prop];

      // If the current object doesn't have the property, we have to assume
      // it changes (we cannot know if it will). If the object does have the
      // property, we test non-strict equality. See issue #732.
      if (currentValue === undefined || !nonStrictEquals(currentValue, value)) {
        changedProps.push(prop);
      } else {
        unchangedProps.push(prop);
      }
    }

    // We cannot know if the query properties cause changes to the values.
    // We must assume that they do.
    if (obj.$$queryProps) {
      changedProps.push(...Object.keys(obj.$$queryProps));
    }

    return {
      changedProps,
      unchangedProps,
    };
  }

  _hasNonIdPropertyChanges(node) {
    const idProps = node.modelClass.getIdPropertyArray();
    return this._findChanges(node).changedProps.some((prop) => !idProps.includes(prop));
  }

  _createBuilder(node) {
    if (node.parentEdge && !node.parentEdge.relation.isObjectionHasManyRelation) {
      return this._createRelatedBuilder(node);
    } else {
      return this._createRootBuilder(node);
    }
  }

  _createRelatedBuilder(node) {
    return node.parentNode.obj
      .$relatedQuery(node.parentEdge.relation.name)
      .findById(node.obj.$id());
  }

  _createRootBuilder(node) {
    return node.obj.$query();
  }
}

function childQueryOptions() {
  return {
    fork: true,
    isInternalQuery: true,
  };
}

function nonStrictEquals(val1, val2) {
  if (val1 == val2) {
    return true;
  }

  return jsonEquals(val1, val2);
}

module.exports = {
  GraphPatchAction,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/recursiveUpsert/GraphRecursiveUpsert.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphOperation.js");
const { GraphRecursiveUpsertAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/recursiveUpsert/GraphRecursiveUpsertAction.js");

class GraphRecursiveUpsert extends GraphOperation {
  createActions() {
    return [
      new GraphRecursiveUpsertAction(this.graphData, {
        nodes: this.graph.nodes.filter((node) => {
          const shouldRelate = this.graphOptions.shouldRelate(node, this.graphData);
          return shouldRelate && hasRelations(node.obj);
        }),
      }),
    ];
  }
}

function hasRelations(obj) {
  for (const relationName of obj.constructor.getRelationNames()) {
    if (obj[relationName] !== undefined) {
      return true;
    }
  }

  return false;
}

module.exports = {
  GraphRecursiveUpsert,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/graph/recursiveUpsert/GraphRecursiveUpsertAction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { GraphAction } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphAction.js");
const { groupBy, get, set } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { forEachPropertyReference } = __webpack_require__("./node_modules/objection/lib/model/graph/ModelGraphBuilder.js");
const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

class GraphRecursiveUpsertAction extends GraphAction {
  constructor(graphData, { nodes }) {
    super(graphData);
    // Nodes to upsert.
    this.nodes = nodes;
  }

  run(builder) {
    const builders = this._createUpsertBuilders(builder, this.nodes);

    return promiseUtils.map(builders, (builder) => builder.execute(), {
      concurrency: this._getConcurrency(builder, this.nodes),
    });
  }

  _createUpsertBuilders(parentBuilder, nodesToUpsert) {
    const nodesByRelation = groupBy(nodesToUpsert, getRelation);
    const builders = [];

    nodesByRelation.forEach((nodes) => {
      const nodesByParent = groupBy(nodes, getParent);

      nodesByParent.forEach((nodes) => {
        for (const node of nodes) {
          this._resolveReferences(node);
          node.userData.upserted = true;
        }

        builders.push(
          nodes[0].modelClass
            .query()
            .childQueryOf(parentBuilder)
            .copyFrom(parentBuilder, GraphAction.ReturningAllSelector)
            .upsertGraph(
              nodes.map((node) => node.obj),
              this.graphOptions.rebasedOptions(nodes[0]),
            ),
        );
      });
    });

    return builders;
  }

  /**
   * The nodes inside the subgraph we are about to recursively upsert may
   * have references outside that graph that won't be available during the
   * recursive upsertGraph call. This method resolves the references.
   *
   * TODO: This doesn't work if a recursively upserted node refers to
   *       a node inside another recursively upsertable graph.
   */
  _resolveReferences(node) {
    node.obj.$traverse((obj) => this._resolveReferencesForObject(obj));
  }

  _resolveReferencesForObject(obj) {
    this._resolveObjectReference(obj);
    this._resolvePropertyReferences(obj);
  }

  _resolveObjectReference(obj) {
    const modelClass = obj.constructor;
    const ref = obj[modelClass.uidRefProp];

    if (!ref) {
      return;
    }

    const referencedNode = this.graph.nodes.find((it) => it.uid === ref);

    if (!referencedNode) {
      return;
    }

    const relationNames = referencedNode.modelClass.getRelationNames();

    for (const prop of Object.keys(referencedNode.obj)) {
      if (relationNames.includes(prop)) {
        continue;
      }

      obj[prop] = referencedNode.obj[prop];
    }

    delete obj[modelClass.uidRefProp];
  }

  _resolvePropertyReferences(obj) {
    forEachPropertyReference(obj, ({ path, refMatch, ref, refPath }) => {
      const referencedNode = this.graph.nodes.find((it) => it.uid === ref);

      if (!referencedNode) {
        return;
      }

      const referencedValue = get(referencedNode.obj, refPath);
      const value = get(obj, path);

      if (value === refMatch) {
        set(obj, path, referencedValue);
      } else {
        set(obj, path, value.replace(refMatch, referencedValue));
      }
    });
  }
}

function getRelation(node) {
  return node.parentEdge.relation;
}

function getParent(node) {
  return node.parentNode;
}

module.exports = {
  GraphRecursiveUpsertAction,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/join/JoinResultColumn.js":
/***/ ((module) => {

"use strict";


class JoinResultColumn {
  constructor({ columnAlias, tableNode, name }) {
    this.columnAlias = columnAlias;
    this.tableNode = tableNode;
    this.name = name;
  }

  static create({ tableTree, columnAlias }) {
    const tableNode = tableTree.getNodeForColumnAlias(columnAlias);

    return new JoinResultColumn({
      columnAlias,
      tableNode,
      name: tableNode.getColumnForColumnAlias(columnAlias),
    });
  }
}

module.exports = {
  JoinResultColumn,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/join/JoinResultParser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { JoinResultColumn } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/JoinResultColumn.js");
const { groupBy } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class JoinResultParser {
  constructor({ tableTree, omitColumnAliases = [] }) {
    this.tableTree = tableTree;
    this.omitColumnAliases = new Set(omitColumnAliases);

    this.columnsByTableNode = null;
    this.parentMap = null;
    this.rootModels = null;
  }

  static create(args) {
    return new JoinResultParser(args);
  }

  parse(flatRows) {
    if (!Array.isArray(flatRows) || flatRows.length === 0) {
      return flatRows;
    }

    this.columnsByTableNode = this._createColumns(flatRows[0]);
    this.parentMap = new Map();
    this.rootModels = [];

    for (const flatRow of flatRows) {
      this._parseNode(this.tableTree.rootNode, flatRow);
    }

    return this.rootModels;
  }

  _parseNode(tableNode, flatRow, parentModel = null, parentKey = null) {
    const id = tableNode.getIdFromFlatRow(flatRow);

    if (id === null) {
      return;
    }

    const key = getKey(parentKey, id, tableNode);
    let model = this.parentMap.get(key);

    if (!model) {
      model = this._createModel(tableNode, flatRow);

      this._addToParent(tableNode, model, parentModel);
      this.parentMap.set(key, model);
    }

    for (const childNode of tableNode.childNodes) {
      this._parseNode(childNode, flatRow, model, key);
    }
  }

  _createModel(tableNode, flatRow) {
    const row = {};
    const columns = this.columnsByTableNode.get(tableNode);

    if (columns) {
      for (const column of columns) {
        if (!this.omitColumnAliases.has(column.columnAlias)) {
          row[column.name] = flatRow[column.columnAlias];
        }
      }
    }

    const model = tableNode.modelClass.fromDatabaseJson(row);

    for (const childNode of tableNode.childNodes) {
      if (childNode.relation.isOneToOne()) {
        model[childNode.relationProperty] = null;
      } else {
        model[childNode.relationProperty] = [];
      }
    }

    return model;
  }

  _addToParent(tableNode, model, parentModel) {
    if (tableNode.parentNode) {
      if (tableNode.relation.isOneToOne()) {
        parentModel[tableNode.relationProperty] = model;
      } else {
        parentModel[tableNode.relationProperty].push(model);
      }
    } else {
      // Root model. Add to root list.
      this.rootModels.push(model);
    }
  }

  _createColumns(row) {
    const columns = Object.keys(row).map((columnAlias) =>
      JoinResultColumn.create({ tableTree: this.tableTree, columnAlias }),
    );

    return groupBy(columns, getTableNode);
  }
}

function getTableNode(column) {
  return column.tableNode;
}

function getKey(parentKey, id, tableNode) {
  if (parentKey !== null) {
    return `${parentKey}/${tableNode.relationProperty}/${id}`;
  } else {
    return `/${id}`;
  }
}

module.exports = {
  JoinResultParser,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/join/RelationJoiner.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { uniqBy } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { Selection } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/select/Selection.js");
const { createModifier } = __webpack_require__("./node_modules/objection/lib/utils/createModifier.js");
const { map: mapPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");

const { TableTree } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/TableTree.js");
const { JoinResultParser } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/JoinResultParser.js");
const { ID_LENGTH_LIMIT } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/utils.js");

/**
 * Given a relation expression, builds a query using joins to fetch it.
 */
class RelationJoiner {
  constructor({ modelClass }) {
    this.rootModelClass = modelClass;

    // The relation expression to join.
    this.expression = null;

    // Explicit modifiers for the relation expression.
    this.modifiers = null;

    this.options = defaultOptions();
    this.tableTree = null;
    this.internalSelections = null;
  }

  setExpression(expression) {
    if (!this.expression) {
      this.expression = expression;
    }

    return this;
  }

  setModifiers(modifiers) {
    if (!this.modifiers) {
      this.modifiers = modifiers;
    }

    return this;
  }

  setOptions(options) {
    this.options = Object.assign(this.options, options);
    return this;
  }

  /**
   * Fetches the column information needed for building the select clauses.
   *
   * This must be called before calling `build(builder, true)`. `build(builder, false)`
   * can be called without this since it doesn't build selects.
   */
  fetchColumnInfo(builder) {
    const tableTree = this._getTableTree(builder);
    const allModelClasses = new Set(tableTree.nodes.map((node) => node.modelClass));

    return mapPromise(
      Array.from(allModelClasses),
      (modelClass) => modelClass.fetchTableMetadata({ parentBuilder: builder }),
      {
        concurrency: this.rootModelClass.getConcurrency(builder.unsafeKnex()),
      },
    );
  }

  build(builder, buildSelects = true) {
    const rootTableNode = this._getTableTree(builder).rootNode;
    const userSelectQueries = new Map([[rootTableNode, builder]]);

    for (const tableNode of rootTableNode.childNodes) {
      this._buildJoinsForNode({ builder, tableNode, userSelectQueries });
    }

    if (buildSelects) {
      this._buildSelects({ builder, tableNode: rootTableNode, userSelectQueries });
    }
  }

  parseResult(builder, flatRows) {
    const parser = JoinResultParser.create({
      tableTree: this._getTableTree(builder),
      omitColumnAliases: this.internalSelections.map((it) => it.alias),
    });

    return parser.parse(flatRows);
  }

  _getTableTree(builder) {
    if (!this.tableTree) {
      // Create the table tree lazily.
      this.tableTree = TableTree.create({
        rootModelClass: this.rootModelClass,
        rootTableAlias: builder.tableRef(),
        expression: this.expression,
        options: this.options,
      });
    }

    return this.tableTree;
  }

  _buildJoinsForNode({ builder, tableNode, userSelectQueries }) {
    const subqueryToJoin = createSubqueryToJoin({
      builder,
      tableNode,
      modifiers: this.modifiers,
    });

    const userSelectQuery = subqueryToJoin.clone();

    // relation.join applies the relation modifier that can
    // also contain selects.
    userSelectQuery.modify(tableNode.relation.modify);

    // Save the query that contains the user specified selects
    // for later use.
    userSelectQueries.set(tableNode, userSelectQuery);

    tableNode.relation.join(builder, {
      joinOperation: this.options.joinOperation,

      ownerTable: tableNode.parentNode.alias,
      relatedTableAlias: tableNode.alias,
      joinTableAlias: tableNode.getJoinTableAlias(builder),

      relatedJoinSelectQuery: ensureIdAndRelationPropsAreSelected({
        builder: subqueryToJoin,
        tableNode,
      }),
    });

    for (const childNode of tableNode.childNodes) {
      this._buildJoinsForNode({ builder, tableNode: childNode, userSelectQueries });
    }
  }

  _buildSelects({ builder, tableNode, userSelectQueries }) {
    const { selections, internalSelections } = getSelectionsForNode({
      builder,
      tableNode,
      userSelectQueries,
    });

    for (const selection of selections) {
      checkAliasLength(tableNode.modelClass, selection.name);
    }

    // Save the selections that were added internally (not by the user)
    // so that we can later remove the corresponding properties when
    // parsing the result.
    this.internalSelections = internalSelections;

    builder.select(selectionsToStrings(selections));
  }
}

function defaultOptions() {
  return {
    joinOperation: 'leftJoin',
    minimize: false,
    separator: ':',
    aliases: {},
  };
}

function createSubqueryToJoin({ builder, tableNode, modifiers }) {
  const { relation, expression, modelClass } = tableNode;
  const modifierQuery = modelClass.query().childQueryOf(builder);

  for (const modifierName of expression.node.$modify) {
    const modifier = createModifier({
      modifier: modifierName,
      modelClass,
      modifiers,
    });

    try {
      modifier(modifierQuery);
    } catch (err) {
      if (err instanceof modelClass.ModifierNotFoundError) {
        throw modelClass.createValidationError({
          type: ValidationErrorType.RelationExpression,
          message: `could not find modifier "${modifierName}" for relation "${relation.name}"`,
        });
      } else {
        throw err;
      }
    }
  }

  return modifierQuery;
}

function ensureIdAndRelationPropsAreSelected({ builder, tableNode }) {
  const tableRef = builder.tableRef();

  const cols = [
    ...builder.modelClass().getIdColumnArray(),
    ...tableNode.relation.relatedProp.cols,
    ...tableNode.childNodes.reduce(
      (cols, childNode) => [...cols, ...childNode.relation.ownerProp.cols],
      [],
    ),
  ];

  const selectStrings = uniqBy(cols)
    .filter((col) => !builder.hasSelectionAs(col, col))
    .map((col) => `${tableRef}.${col}`);

  return builder.select(selectStrings);
}

function getSelectionsForNode({ builder, tableNode, userSelectQueries }) {
  const userSelectQuery = userSelectQueries.get(tableNode);
  const userSelections = userSelectQuery.findAllSelections();
  const userSelectedAllColumns = isSelectAllSelectionSet(userSelections);

  let selections = [];
  let internalSelections = [];

  if (tableNode.parentNode) {
    selections = mapUserSelectionsFromSubqueryToMainQuery({ userSelections, tableNode });

    if (userSelectedAllColumns && tableNode.relation.isObjectionManyToManyRelation) {
      const extraSelections = getJoinTableExtraSelectionsForNode({ builder, tableNode });
      selections = selections.concat(extraSelections);
    }
  }

  if (userSelectedAllColumns) {
    const allColumnSelections = getAllColumnSelectionsForNode({ builder, tableNode });
    selections = allColumnSelections.concat(selections);
  } else {
    const idSelections = getIdSelectionsForNode({ tableNode });

    for (const idSelection of idSelections) {
      if (!userSelectQuery.hasSelectionAs(idSelection.column, idSelection.column)) {
        selections.push(idSelection);
        internalSelections.push(idSelection);
      }
    }
  }

  for (const childNode of tableNode.childNodes) {
    const childResult = getSelectionsForNode({ builder, tableNode: childNode, userSelectQueries });

    selections = selections.concat(childResult.selections);
    internalSelections = internalSelections.concat(childResult.internalSelections);
  }

  return {
    selections,
    internalSelections,
  };
}

function mapUserSelectionsFromSubqueryToMainQuery({ userSelections, tableNode }) {
  return userSelections.filter(isNotSelectAll).map((selection) => {
    return new Selection(
      tableNode.alias,
      selection.name,
      tableNode.getColumnAliasForColumn(selection.name),
    );
  });
}

function getJoinTableExtraSelectionsForNode({ builder, tableNode }) {
  return tableNode.relation.joinTableExtras.map((extra) => {
    return new Selection(
      tableNode.getJoinTableAlias(builder),
      extra.joinTableCol,
      tableNode.getColumnAliasForColumn(extra.aliasCol),
    );
  });
}

function getAllColumnSelectionsForNode({ builder, tableNode }) {
  const table = builder.tableNameFor(tableNode.modelClass);
  const tableMeta = tableNode.modelClass.tableMetadata({ table });

  if (!tableMeta) {
    throw new Error(
      `table metadata has not been fetched for table '${table}'. Are you trying to call toKnexQuery() for a withGraphJoined query? To make sure the table metadata is fetched see the objection.initialize function.`,
    );
  }

  return tableMeta.columns.map((columnName) => {
    return new Selection(
      tableNode.alias,
      columnName,
      tableNode.getColumnAliasForColumn(columnName),
    );
  });
}

function getIdSelectionsForNode({ tableNode }) {
  return tableNode.modelClass.getIdColumnArray().map((columnName) => {
    return new Selection(
      tableNode.alias,
      columnName,
      tableNode.getColumnAliasForColumn(columnName),
    );
  });
}

function selectionsToStrings(selections) {
  return selections.map((selection) => {
    const selectStr = `${selection.table}.${selection.column}`;
    return `${selectStr} as ${selection.alias}`;
  });
}

function isSelectAll(selection) {
  return selection.column === '*';
}

function isNotSelectAll(selection) {
  return selection.column !== '*';
}

function isSelectAllSelectionSet(selections) {
  return selections.length === 0 || selections.some(isSelectAll);
}

function checkAliasLength(modelClass, alias) {
  if (alias.length > ID_LENGTH_LIMIT) {
    throw modelClass.createValidationError({
      type: ValidationErrorType.RelationExpression,
      message: `identifier ${alias} is over ${ID_LENGTH_LIMIT} characters long and would be truncated by the database engine.`,
    });
  }
}

module.exports = {
  RelationJoiner,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/join/TableNode.js":
/***/ ((module) => {

"use strict";


class TableNode {
  constructor({ tableTree, modelClass, expression, parentNode = null, relation = null }) {
    this.tableTree = tableTree;
    this.modelClass = modelClass;
    this.parentNode = parentNode;
    this.relation = relation;
    this.expression = expression;
    this.childNodes = [];

    this.alias = this._calculateAlias();
    this.idGetter = this._createIdGetter();
  }

  static create(args) {
    const node = new TableNode(args);

    if (node.parentNode) {
      node.parentNode.childNodes.push(node);
    }

    return node;
  }

  get options() {
    return this.tableTree.options;
  }

  get relationProperty() {
    return this.expression.node.$name;
  }

  getReferenceForColumn(column) {
    return `${this.alias}.${column}`;
  }

  getColumnAliasForColumn(column) {
    if (this.parentNode) {
      return `${this.alias}${this.options.separator}${column}`;
    } else {
      return column;
    }
  }

  getColumnForColumnAlias(columnAlias) {
    const lastSepIndex = columnAlias.lastIndexOf(this.options.separator);

    if (lastSepIndex === -1) {
      return columnAlias;
    } else {
      return columnAlias.slice(lastSepIndex + this.options.separator.length);
    }
  }

  getIdFromFlatRow(flatRow) {
    return this.idGetter(flatRow);
  }

  getJoinTableAlias(builder) {
    if (this.relation.isObjectionManyToManyRelation) {
      return (
        builder.aliasFor(this.relation.joinTableModelClass) ||
        this.modelClass.joinTableAlias(this.alias)
      );
    } else {
      return undefined;
    }
  }

  _calculateAlias() {
    if (this.parentNode) {
      const relationName = this.expression.node.$name;
      const alias = this.options.aliases[relationName] || relationName;

      if (this.options.minimize) {
        return `_t${this.tableTree.createNextUid()}`;
      } else if (this.parentNode.parentNode) {
        return `${this.parentNode.alias}${this.options.separator}${alias}`;
      } else {
        return alias;
      }
    } else {
      return this.tableTree.rootTableAlias;
    }
  }

  _createIdGetter() {
    const idColumns = this.modelClass.getIdColumnArray();
    const columnAliases = idColumns.map((column) => this.getColumnAliasForColumn(column));

    if (idColumns.length === 1) {
      return createIdGetter(columnAliases);
    } else {
      return createCompositeIdGetter(columnAliases);
    }
  }
}

function createIdGetter(columnAliases) {
  const columnAlias = columnAliases[0];

  return (flatRow) => {
    const id = flatRow[columnAlias];

    if (id === null) {
      return null;
    }

    return `${id}`;
  };
}

function createCompositeIdGetter(columnAliases) {
  if (columnAliases.length === 2) {
    return createTwoIdGetter(columnAliases);
  } else {
    return createMultiIdGetter(columnAliases);
  }
}

function createTwoIdGetter(columnAliases) {
  const columnAlias1 = columnAliases[0];
  const columnAlias2 = columnAliases[1];

  return (flatRow) => {
    const id1 = flatRow[columnAlias1];
    const id2 = flatRow[columnAlias2];

    if (id1 === null || id2 === null) {
      return null;
    }

    return `${id1},${id2}`;
  };
}

function createMultiIdGetter(columnAliases) {
  return (flatRow) => {
    let idStr = '';

    for (let i = 0, l = columnAliases.length; i < l; ++i) {
      const columnAlias = columnAliases[i];
      const id = flatRow[columnAlias];

      if (id === null) {
        return null;
      }

      idStr += id;

      if (i !== l - 1) {
        idStr += ',';
      }
    }

    return idStr;
  };
}

module.exports = {
  TableNode,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/join/TableTree.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { forEachChildExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/utils.js");
const { TableNode } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/TableNode.js");

class TableTree {
  constructor({ expression, rootModelClass, rootTableAlias, options }) {
    this.options = options;
    this.rootModelClass = rootModelClass;
    this.rootTableAlias = rootTableAlias;
    this.nodes = [];
    this.nodesByAlias = new Map();
    this.uidCounter = 0;

    this._createNodes({ expression, modelClass: rootModelClass });
  }

  static create(args) {
    return new TableTree(args);
  }

  get rootNode() {
    return this.nodes[0];
  }

  getNodeForColumnAlias(columnAlias) {
    const lastSepIndex = columnAlias.lastIndexOf(this.options.separator);

    if (lastSepIndex === -1) {
      return this.rootNode;
    } else {
      const tableAlias = columnAlias.slice(0, lastSepIndex);
      return this.nodesByAlias.get(tableAlias);
    }
  }

  createNextUid() {
    return this.uidCounter++;
  }

  _createNodes({ expression, modelClass }) {
    const rootNode = this._createRootNode({ expression, modelClass });
    this._createChildNodes({ expression, modelClass, parentNode: rootNode });

    for (const node of this.nodes) {
      this.nodesByAlias.set(node.alias, node);
    }
  }

  _createRootNode({ expression, modelClass }) {
    const node = TableNode.create({
      tableTree: this,
      modelClass,
      expression,
    });

    this.nodes.push(node);
    return node;
  }

  _createChildNodes({ expression, modelClass, parentNode }) {
    forEachChildExpression(expression, modelClass, (childExpr, relation) => {
      const node = TableNode.create({
        tableTree: this,
        modelClass: relation.relatedModelClass,
        expression: childExpr,

        parentNode,
        relation,
      });

      this.nodes.push(node);

      this._createChildNodes({
        expression: childExpr,
        modelClass: relation.relatedModelClass,
        parentNode: node,
      });
    });
  }
}

module.exports = {
  TableTree,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/join/utils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");

const ID_LENGTH_LIMIT = 63;
const RELATION_RECURSION_LIMIT = 64;

// Given a relation expression, goes through all first level children.
function forEachChildExpression(expr, modelClass, callback) {
  if (expr.node.$allRecursive || expr.maxRecursionDepth > RELATION_RECURSION_LIMIT) {
    throw modelClass.createValidationError({
      type: ValidationErrorType.RelationExpression,
      message: `recursion depth of eager expression ${expr.toString()} too big for JoinEagerAlgorithm`,
    });
  }

  expr.forEachChildExpression(modelClass, callback);
}

module.exports = {
  ID_LENGTH_LIMIT,
  RELATION_RECURSION_LIMIT,

  forEachChildExpression,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

// Operation that simply delegates all calls to the operation passed
// to to the constructor in `opt.delegate`.
class DelegateOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);

    this.delegate = opt.delegate;
  }

  is(OperationClass) {
    return super.is(OperationClass) || this.delegate.is(OperationClass);
  }

  onAdd(builder, args) {
    return this.delegate.onAdd(builder, args);
  }

  onBefore1(builder, result) {
    return this.delegate.onBefore1(builder, result);
  }

  hasOnBefore1() {
    return this.onBefore1 !== DelegateOperation.prototype.onBefore1 || this.delegate.hasOnBefore1();
  }

  onBefore2(builder, result) {
    return this.delegate.onBefore2(builder, result);
  }

  hasOnBefore2() {
    return this.onBefore2 !== DelegateOperation.prototype.onBefore2 || this.delegate.hasOnBefore2();
  }

  onBefore3(builder, result) {
    return this.delegate.onBefore3(builder, result);
  }

  hasOnBefore3() {
    return this.onBefore3 !== DelegateOperation.prototype.onBefore3 || this.delegate.hasOnBefore3();
  }

  onBuild(builder) {
    return this.delegate.onBuild(builder);
  }

  hasOnBuild() {
    return this.onBuild !== DelegateOperation.prototype.onBuild || this.delegate.hasOnBuild();
  }

  onBuildKnex(knexBuilder, builder) {
    return this.delegate.onBuildKnex(knexBuilder, builder);
  }

  hasOnBuildKnex() {
    return (
      this.onBuildKnex !== DelegateOperation.prototype.onBuildKnex || this.delegate.hasOnBuildKnex()
    );
  }

  onRawResult(builder, result) {
    return this.delegate.onRawResult(builder, result);
  }

  hasOnRawResult() {
    return (
      this.onRawResult !== DelegateOperation.prototype.onRawResult || this.delegate.hasOnRawResult()
    );
  }

  onAfter1(builder, result) {
    return this.delegate.onAfter1(builder, result);
  }

  hasOnAfter1() {
    return this.onAfter1 !== DelegateOperation.prototype.onAfter1 || this.delegate.hasOnAfter1();
  }

  onAfter2(builder, result) {
    return this.delegate.onAfter2(builder, result);
  }

  hasOnAfter2() {
    return this.onAfter2 !== DelegateOperation.prototype.onAfter2 || this.delegate.hasOnAfter2();
  }

  onAfter3(builder, result) {
    return this.delegate.onAfter3(builder, result);
  }

  hasOnAfter3() {
    return this.onAfter3 !== DelegateOperation.prototype.onAfter3 || this.delegate.hasOnAfter3();
  }

  queryExecutor(builder) {
    return this.delegate.queryExecutor(builder);
  }

  hasQueryExecutor() {
    return (
      this.queryExecutor !== DelegateOperation.prototype.queryExecutor ||
      this.delegate.hasQueryExecutor()
    );
  }

  onError(builder, error) {
    return this.delegate.onError(builder, error);
  }

  hasOnError() {
    return this.onError !== DelegateOperation.prototype.onError || this.delegate.hasOnError();
  }

  toFindOperation(builder) {
    return this.delegate.toFindOperation(builder);
  }

  hasToFindOperation() {
    return (
      this.hasToFindOperation !== DelegateOperation.prototype.hasToFindOperation ||
      this.delegate.hasToFindOperation()
    );
  }

  clone() {
    const clone = super.clone();
    clone.delegate = this.delegate && this.delegate.clone();
    return clone;
  }
}

module.exports = {
  DelegateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/DeleteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { StaticHookArguments } = __webpack_require__("./node_modules/objection/lib/queryBuilder/StaticHookArguments.js");

class DeleteOperation extends QueryBuilderOperation {
  async onBefore2(builder, result) {
    await callBeforeDelete(builder);
    return result;
  }

  onBuildKnex(knexBuilder) {
    return knexBuilder.delete();
  }

  onAfter2(builder, result) {
    return callAfterDelete(builder, result);
  }

  toFindOperation() {
    return null;
  }
}

function callBeforeDelete(builder) {
  return callStaticBeforeDelete(builder);
}

function callStaticBeforeDelete(builder) {
  const args = StaticHookArguments.create({ builder });
  return builder.modelClass().beforeDelete(args);
}

function callAfterDelete(builder, result) {
  return callStaticAfterDelete(builder, result);
}

async function callStaticAfterDelete(builder, result) {
  const args = StaticHookArguments.create({ builder, result });
  const maybeResult = await builder.modelClass().afterDelete(args);

  if (maybeResult === undefined) {
    return result;
  } else {
    return maybeResult;
  }
}

module.exports = {
  DeleteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/FindByIdOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { assertIdNotUndefined } = __webpack_require__("./node_modules/objection/lib/utils/assert.js");

class FindByIdOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.id = this.opt.id;
  }

  onAdd(builder, args) {
    if (this.id === null || this.id === undefined) {
      this.id = args[0];
    }

    return super.onAdd(builder, args);
  }

  onBuild(builder) {
    if (!builder.internalOptions().skipUndefined) {
      assertIdNotUndefined(this.id, `undefined was passed to ${this.name}`);
    }

    builder.whereComposite(builder.fullIdColumn(), this.id);
  }

  clone() {
    const clone = super.clone();
    clone.id = this.id;
    return clone;
  }
}

module.exports = {
  FindByIdOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/FindByIdsOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class FindByIdsOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.ids = null;
  }

  onAdd(builder, args) {
    this.ids = args[0];
    return super.onAdd(builder, args);
  }

  onBuild(builder) {
    builder.whereInComposite(builder.fullIdColumn(), this.ids);
  }

  clone() {
    const clone = super.clone();
    clone.ids = this.ids;
    return clone;
  }
}

module.exports = {
  FindByIdsOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/FindOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { StaticHookArguments } = __webpack_require__("./node_modules/objection/lib/queryBuilder/StaticHookArguments.js");
const { isPromise, after, afterReturn } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class FindOperation extends QueryBuilderOperation {
  onBefore2(builder, result) {
    return afterReturn(callStaticBeforeFind(builder), result);
  }

  onAfter3(builder, results) {
    const opt = builder.findOptions();

    if (opt.dontCallFindHooks) {
      return results;
    } else {
      return callAfterFind(builder, results);
    }
  }
}

function callStaticBeforeFind(builder) {
  const args = StaticHookArguments.create({ builder });
  return builder.modelClass().beforeFind(args);
}

function callAfterFind(builder, result) {
  const opt = builder.findOptions();
  const maybePromise = callInstanceAfterFind(builder.context(), result, opt.callAfterFindDeeply);

  return after(maybePromise, () => callStaticAfterFind(builder, result));
}

function callStaticAfterFind(builder, result) {
  const args = StaticHookArguments.create({ builder, result });
  const maybePromise = builder.modelClass().afterFind(args);

  return after(maybePromise, (maybeResult) => {
    if (maybeResult === undefined) {
      return result;
    } else {
      return maybeResult;
    }
  });
}

function callInstanceAfterFind(ctx, results, deep) {
  if (Array.isArray(results)) {
    if (results.length === 1) {
      return callAfterFindForOne(ctx, results[0], results, deep);
    } else {
      return callAfterFindArray(ctx, results, deep);
    }
  } else {
    return callAfterFindForOne(ctx, results, results, deep);
  }
}

function callAfterFindArray(ctx, results, deep) {
  if (results.length === 0 || !isObject(results[0])) {
    return results;
  }

  const mapped = new Array(results.length);
  let containsPromise = false;

  for (let i = 0, l = results.length; i < l; ++i) {
    mapped[i] = callAfterFindForOne(ctx, results[i], results[i], deep);

    if (isPromise(mapped[i])) {
      containsPromise = true;
    }
  }

  if (containsPromise) {
    return Promise.all(mapped);
  } else {
    return mapped;
  }
}

function callAfterFindForOne(ctx, model, result, deep) {
  if (!isObject(model) || !model.$isObjectionModel) {
    return result;
  }

  if (deep) {
    const results = [];
    const containsPromise = callAfterFindForRelations(ctx, model, results);

    if (containsPromise) {
      return Promise.all(results).then(() => {
        return doCallAfterFind(ctx, model, result);
      });
    } else {
      return doCallAfterFind(ctx, model, result);
    }
  } else {
    return doCallAfterFind(ctx, model, result);
  }
}

function callAfterFindForRelations(ctx, model, results) {
  const keys = Object.keys(model);
  let containsPromise = false;

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];
    const value = model[key];

    if (isRelation(value)) {
      const maybePromise = callInstanceAfterFind(ctx, value, true);

      if (isPromise(maybePromise)) {
        containsPromise = true;
      }

      results.push(maybePromise);
    }
  }

  return containsPromise;
}

function isRelation(value) {
  return (
    (isObject(value) && value.$isObjectionModel) ||
    (isNonEmptyObjectArray(value) && value[0].$isObjectionModel)
  );
}

function isNonEmptyObjectArray(value) {
  return Array.isArray(value) && value.length > 0 && isObject(value[0]);
}

function doCallAfterFind(ctx, model, result) {
  const afterFind = getAfterFindHook(model);

  if (afterFind !== null) {
    const maybePromise = afterFind.call(model, ctx);

    if (isPromise(maybePromise)) {
      return maybePromise.then(() => result);
    } else {
      return result;
    }
  } else {
    return result;
  }
}

function getAfterFindHook(model) {
  if (model.$afterFind !== model.$objectionModelClass.prototype.$afterFind) {
    return model.$afterFind;
  } else {
    return null;
  }
}

module.exports = {
  FindOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/FirstOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class FirstOperation extends QueryBuilderOperation {
  onBuildKnex(knexBuilder, builder) {
    const modelClass = builder.modelClass();

    if (builder.isFind() && modelClass.useLimitInFirst) {
      knexBuilder = knexBuilder.limit(1);
    }

    return knexBuilder;
  }

  onAfter3(_, result) {
    if (Array.isArray(result)) {
      return result[0];
    } else {
      return result;
    }
  }
}

module.exports = {
  FirstOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/FromOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");
const { isPlainObject, isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

const ALIAS_REGEX = /\s+as\s+/i;

// FromOperation corresponds to a `.from(args)` call. The call is delegated to
// knex, but we first try to parse the arguments so that we can determine which
// tables have been mentioned in a query's from clause. We only parse string
// references and not `raw` or `ref` etc. references at this point thouhg.
class FromOperation extends ObjectionToKnexConvertingOperation {
  constructor(name, opt) {
    super(name, opt);

    this.table = null;
    this.alias = null;
  }

  onAdd(builder, args) {
    const ret = super.onAdd(builder, args);
    const parsed = parseTableAndAlias(this.args[0], builder);

    if (parsed.table) {
      builder.tableName(parsed.table);
      this.table = parsed.table;
    }

    if (parsed.alias) {
      builder.aliasFor(builder.modelClass().getTableName(), parsed.alias);
      this.alias = parsed.alias;
    }

    return ret;
  }

  onBuildKnex(knexBuilder, builder) {
    // Simply call knex's from method with the converted arguments.
    return knexBuilder.from.apply(knexBuilder, this.getKnexArgs(builder));
  }

  clone() {
    const clone = super.clone();

    clone.table = this.table;
    clone.alias = this.alias;

    return clone;
  }
}

function parseTableAndAlias(arg, builder) {
  if (isString(arg)) {
    return parseTableAndAliasFromString(arg);
  } else if (isPlainObject(arg)) {
    return parseTableAndAliasFromObject(arg, builder);
  } else {
    // Could not parse table and alias from the arguments.
    return {
      table: null,
      alias: null,
    };
  }
}

function parseTableAndAliasFromString(arg) {
  if (ALIAS_REGEX.test(arg)) {
    const parts = arg.split(ALIAS_REGEX);

    return {
      table: parts[0].trim(),
      alias: parts[1].trim(),
    };
  } else {
    return {
      table: arg.trim(),
      alias: null,
    };
  }
}

function parseTableAndAliasFromObject(arg, builder) {
  for (const alias of Object.keys(arg)) {
    const table = arg[alias].trim();

    if (table === builder.modelClass().getTableName()) {
      return {
        alias,
        table,
      };
    }
  }

  throw new Error(
    `one of the tables in ${JSON.stringify(arg)} must be the query's model class's table.`,
  );
}

module.exports = {
  FromOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InsertAndFetchOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InsertOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertOperation.js");
const { DelegateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js");
const { keyByProps } = __webpack_require__("./node_modules/objection/lib/model/modelUtils.js");
const { asArray } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class InsertAndFetchOperation extends DelegateOperation {
  constructor(name, opt) {
    super(name, opt);

    if (!this.delegate.is(InsertOperation)) {
      throw new Error('Invalid delegate');
    }
  }

  get models() {
    return this.delegate.models;
  }

  async onAfter2(builder, inserted) {
    const modelClass = builder.modelClass();
    const insertedModels = await super.onAfter2(builder, inserted);

    const insertedModelArray = asArray(insertedModels);
    const idProps = modelClass.getIdPropertyArray();
    const ids = insertedModelArray.map((model) => model.$id());

    const fetchedModels = await modelClass
      .query()
      .childQueryOf(builder)
      .findByIds(ids)
      .castTo(builder.resultModelClass());

    const modelsById = keyByProps(fetchedModels, idProps);

    // Instead of returning the freshly fetched models, update the input
    // models with the fresh values.
    insertedModelArray.forEach((insertedModel) => {
      insertedModel.$set(modelsById.get(insertedModel.$propKey(idProps)));
    });

    return insertedModels;
  }
}

module.exports = {
  InsertAndFetchOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InsertGraphAndFetchOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DelegateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js");
const { InsertGraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertGraphOperation.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");

class InsertGraphAndFetchOperation extends DelegateOperation {
  constructor(name, opt) {
    super(name, opt);

    if (!this.delegate.is(InsertGraphOperation)) {
      throw new Error('Invalid delegate');
    }
  }

  get models() {
    return this.delegate.models;
  }

  get isArray() {
    return this.delegate.isArray;
  }

  async onAfter2(builder) {
    if (this.models.length === 0) {
      return this.isArray ? [] : null;
    }

    const eager = RelationExpression.fromModelGraph(this.models);
    const modelClass = this.models[0].constructor;
    const ids = this.models.map((model) => model.$id());

    const models = await modelClass
      .query()
      .childQueryOf(builder)
      .findByIds(ids)
      .withGraphFetched(eager);

    return this.isArray ? models : models[0] || null;
  }
}

module.exports = {
  InsertGraphAndFetchOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InsertGraphOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DelegateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js");
const { InsertOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertOperation.js");
const { GraphUpsert } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphUpsert.js");

class InsertGraphOperation extends DelegateOperation {
  constructor(name, opt = null) {
    super(name, opt);

    if (!this.delegate.is(InsertOperation)) {
      throw new Error('Invalid delegate');
    }

    Object.assign(this.delegate.modelOptions, GraphUpsert.modelOptions);
    this.upsertOptions = opt.opt || {};
    this.upsert = null;
  }

  get models() {
    return this.delegate.models;
  }

  get isArray() {
    return this.delegate.isArray;
  }

  get relation() {
    return this.delegate.relation;
  }

  onAdd(builder, args) {
    const retVal = super.onAdd(builder, args);

    this.upsert = new GraphUpsert({
      objects: this.models,
      rootModelClass: builder.modelClass(),

      upsertOptions: Object.assign({}, this.upsertOptions, {
        noUpdate: true,
        noDelete: true,
        noUnrelate: true,
        insertMissing: true,
      }),
    });

    // We resolve this query here and will not execute it. This is because the root
    // value may depend on other models in the graph and cannot be inserted first.
    builder.resolve([]);

    return retVal;
  }

  onBefore1(_, result) {
    // Do nothing.
    return result;
  }

  onBefore2(builder, result) {
    // We override this with empty implementation so that the $beforeInsert()
    // hooks are not called twice for the root models.

    if (this.relation) {
      // We still need to call the relation before insert hook if the the
      // delegate operation is a RelationInsertOperation.
      return this.relation.executeBeforeInsert(this.models, builder.context(), result);
    } else {
      return result;
    }
  }

  onBefore3(_, result) {
    // Do nothing.
    return result;
  }

  onBuild() {
    // Do nothing.
  }

  onBuildKnex(knexBuilder) {
    // Do nothing.
    return knexBuilder;
  }

  // We overrode all other hooks but this one and do all the work in here.
  // This is a bit hacky.
  async onAfter1(builder, ...restArgs) {
    await this.upsert.run(builder);
    return await super.onAfter1(builder, ...restArgs);
  }

  onAfter2() {
    // We override this with empty implementation so that the $afterInsert() hooks
    // are not called twice for the root models.
    return this.isArray ? this.models : this.models[0] || null;
  }

  clone() {
    const clone = super.clone();
    clone.upsert = this.upsert;
    return clone;
  }
}

module.exports = {
  InsertGraphOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InsertOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { StaticHookArguments } = __webpack_require__("./node_modules/objection/lib/queryBuilder/StaticHookArguments.js");
const { after, mapAfterAllReturn } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { isPostgres, isSqlite, isMySql, isMsSql } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

// Base class for all insert operations.
class InsertOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);

    this.models = null;
    this.isArray = false;
    this.modelOptions = Object.assign({}, this.opt.modelOptions || {});
  }

  onAdd(builder, args) {
    const json = args[0];
    const modelClass = builder.modelClass();

    this.isArray = Array.isArray(json);
    this.models = modelClass.ensureModelArray(json, this.modelOptions);

    return true;
  }

  async onBefore2(builder, result) {
    if (this.models.length > 1 && !isPostgres(builder.knex()) && !isMsSql(builder.knex())) {
      throw new Error('batch insert only works with Postgresql and SQL Server');
    } else {
      await callBeforeInsert(builder, this.models);
      return result;
    }
  }

  onBuildKnex(knexBuilder, builder) {
    if (!isSqlite(builder.knex()) && !isMySql(builder.knex()) && !builder.has(/returning/)) {
      // If the user hasn't specified a `returning` clause, we make sure
      // that at least the identifier is returned.
      knexBuilder = knexBuilder.returning(builder.modelClass().getIdColumn());
    }

    return knexBuilder.insert(this.models.map((model) => model.$toDatabaseJson(builder)));
  }

  onAfter1(_, ret) {
    if (!Array.isArray(ret) || !ret.length || ret === this.models) {
      // Early exit if there is nothing to do.
      return this.models;
    }

    if (isObject(ret[0])) {
      // If the user specified a `returning` clause the result may be an array of objects.
      // Merge all values of the objects to our models.
      for (let i = 0, l = this.models.length; i < l; ++i) {
        this.models[i].$setDatabaseJson(ret[i]);
      }
    } else {
      // If the return value is not an array of objects, we assume it is an array of identifiers.
      for (let i = 0, l = this.models.length; i < l; ++i) {
        const model = this.models[i];

        // Don't set the id if the model already has one. MySQL and Sqlite don't return the correct
        // primary key value if the id is not generated in db, but given explicitly.
        if (!model.$id()) {
          model.$id(ret[i]);
        }
      }
    }

    return this.models;
  }

  onAfter2(builder, models) {
    const result = this.isArray ? models : models[0] || null;
    return callAfterInsert(builder, this.models, result);
  }

  toFindOperation() {
    return null;
  }

  clone() {
    const clone = super.clone();

    clone.models = this.models;
    clone.isArray = this.isArray;

    return clone;
  }
}

function callBeforeInsert(builder, models) {
  const maybePromise = callInstanceBeforeInsert(builder, models);
  return after(maybePromise, () => callStaticBeforeInsert(builder));
}

function callInstanceBeforeInsert(builder, models) {
  return mapAfterAllReturn(models, (model) => model.$beforeInsert(builder.context()), models);
}

function callStaticBeforeInsert(builder) {
  const args = StaticHookArguments.create({ builder });
  return builder.modelClass().beforeInsert(args);
}

function callAfterInsert(builder, models, result) {
  const maybePromise = callInstanceAfterInsert(builder, models);
  return after(maybePromise, () => callStaticAfterInsert(builder, result));
}

function callInstanceAfterInsert(builder, models) {
  return mapAfterAllReturn(models, (model) => model.$afterInsert(builder.context()), models);
}

function callStaticAfterInsert(builder, result) {
  const args = StaticHookArguments.create({ builder, result });
  const maybePromise = builder.modelClass().afterInsert(args);

  return after(maybePromise, (maybeResult) => {
    if (maybeResult === undefined) {
      return result;
    } else {
      return maybeResult;
    }
  });
}

module.exports = {
  InsertOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InstanceDeleteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DeleteOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DeleteOperation.js");
const { InstanceFindOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InstanceFindOperation.js");
const { assertHasId } = __webpack_require__("./node_modules/objection/lib/utils/assert.js");

class InstanceDeleteOperation extends DeleteOperation {
  constructor(name, opt) {
    super(name, opt);
    this.instance = opt.instance;
  }

  async onBefore2(builder, result) {
    await this.instance.$beforeDelete(builder.context());
    await super.onBefore2(builder, result);
    return result;
  }

  onBuild(builder) {
    super.onBuild(builder);

    assertHasId(this.instance);
    builder.findById(this.instance.$id());
  }

  async onAfter2(builder, result) {
    // The result may be an object if `returning` was used.
    if (Array.isArray(result)) {
      result = result[0];
    }

    await this.instance.$afterDelete(builder.context());
    return super.onAfter2(builder, result);
  }

  toFindOperation() {
    return new InstanceFindOperation('find', {
      instance: this.instance,
    });
  }
}

module.exports = {
  InstanceDeleteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InstanceFindOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { FindOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FindOperation.js");
const { assertHasId } = __webpack_require__("./node_modules/objection/lib/utils/assert.js");

class InstanceFindOperation extends FindOperation {
  constructor(name, opt) {
    super(name, opt);
    this.instance = opt.instance;
  }

  onBuild(builder) {
    assertHasId(this.instance);
    builder.findById(this.instance.$id());
  }
}

module.exports = {
  InstanceFindOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InstanceInsertOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InsertOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertOperation.js");

class InstanceInsertOperation extends InsertOperation {
  constructor(name, opt) {
    super(name, opt);
    this.instance = opt.instance;
  }

  onAdd(builder, args) {
    if (!args || args.length === 0) {
      args = [this.instance];
    } else {
      args[0] = this.instance;
    }

    return super.onAdd(builder, args);
  }
}

module.exports = {
  InstanceInsertOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/InstanceUpdateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UpdateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js");
const { InstanceFindOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InstanceFindOperation.js");
const { assertHasId } = __webpack_require__("./node_modules/objection/lib/utils/assert.js");
const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class InstanceUpdateOperation extends UpdateOperation {
  constructor(name, opt) {
    super(name, opt);

    this.instance = opt.instance;
    this.modelOptions.old = opt.instance;
  }

  onAdd(builder, args) {
    const retVal = super.onAdd(builder, args);

    if (!this.model) {
      this.model = this.instance;
    }

    return retVal;
  }

  onBuild(builder) {
    super.onBuild(builder);

    assertHasId(this.instance);
    builder.findById(this.instance.$id());
  }

  async onAfter2(builder, result) {
    // The result may be an object if `returning` was used.
    if (Array.isArray(result)) {
      result = result[0];
    }

    result = await super.onAfter2(builder, result);
    this.instance.$set(this.model);

    if (isObject(result)) {
      this.instance.$set(result);
    }

    return result;
  }

  toFindOperation() {
    return new InstanceFindOperation('find', {
      instance: this.instance,
    });
  }
}

module.exports = {
  InstanceUpdateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/JoinRelatedOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");
const { RelationJoiner } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/RelationJoiner.js");
const { isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class JoinRelatedOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.calls = [];
  }

  get joinOperation() {
    return this.opt.joinOperation;
  }

  addCall(call) {
    this.calls.push(call);
  }

  onBuild(builder) {
    const modelClass = builder.modelClass();
    const joinOperation = this.joinOperation;
    let mergedExpr = RelationExpression.create();

    for (const call of this.calls) {
      const expr = RelationExpression.create(call.expression).toPojo();
      const childNames = expr.$childNames;
      const options = call.options || {};

      if (childNames.length === 1) {
        applyAlias(expr, modelClass, builder, options);
      }

      if (options.aliases) {
        applyAliases(expr, modelClass, options);
      }

      mergedExpr = mergedExpr.merge(expr);
    }

    const joiner = new RelationJoiner({
      modelClass,
    });

    joiner.setOptions({ joinOperation });
    joiner.setExpression(mergedExpr);
    joiner.setModifiers(builder.modifiers());
    joiner.build(builder, false);
  }

  clone() {
    const clone = super.clone();
    clone.calls = this.calls.slice();
    return clone;
  }
}

function applyAlias(expr, modelClass, builder, options) {
  const childNames = expr.$childNames;
  const childName = childNames[0];
  const childExpr = expr[childName];
  const relation = modelClass.getRelation(childExpr.$relation);

  let alias = childName;

  if (options.alias === false) {
    alias = builder.tableRefFor(relation.relatedModelClass);
  } else if (isString(options.alias)) {
    alias = options.alias;
  }

  if (childName !== alias) {
    renameRelationExpressionNode(expr, childName, alias);
  }
}

function applyAliases(expr, modelClass, options) {
  for (const childName of expr.$childNames) {
    const childExpr = expr[childName];
    const relation = modelClass.getRelation(childExpr.$relation);
    const alias = options.aliases[childExpr.$relation];

    if (alias && alias !== childName) {
      renameRelationExpressionNode(expr, childName, alias);
    }

    applyAliases(childExpr, relation.relatedModelClass, options);
  }
}

function renameRelationExpressionNode(expr, oldName, newName) {
  const childExpr = expr[oldName];
  delete expr[oldName];
  expr[newName] = childExpr;
  childExpr.$name = newName;
  expr.$childNames = expr.$childNames.map((it) => (it === oldName ? newName : it));
}

module.exports = {
  JoinRelatedOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/KnexOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");

// An operation that simply calls the equivalent knex method.
class KnexOperation extends ObjectionToKnexConvertingOperation {
  onBuildKnex(knexBuilder, builder) {
    return knexBuilder[this.name].apply(knexBuilder, this.getKnexArgs(builder));
  }
}

module.exports = {
  KnexOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/MergeOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isFunction, isEmpty, isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { convertFieldExpressionsToRaw } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js");

class MergeOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.model = null;
    this.args = null;
  }

  onAdd(builder, args) {
    this.args = args;

    if (!isEmpty(args) && isObject(args[0]) && !Array.isArray(args[0])) {
      const json = args[0];
      const modelClass = builder.modelClass();

      this.model = modelClass.ensureModel(json, { patch: true });
    }

    return true;
  }

  onBuildKnex(knexBuilder, builder) {
    if (!isFunction(knexBuilder.merge)) {
      throw new Error('merge method can only be chained right after onConflict method');
    }

    if (this.model) {
      const json = this.model.$toDatabaseJson(builder);
      const convertedJson = convertFieldExpressionsToRaw(builder, this.model, json);

      return knexBuilder.merge(convertedJson);
    }

    return knexBuilder.merge(...this.args);
  }

  toFindOperation() {
    return null;
  }

  clone() {
    const clone = super.clone();
    clone.model = this.model;
    clone.args = this.args;
    return clone;
  }
}

module.exports = {
  MergeOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { isPlainObject, isObject, isFunction, once } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { isKnexQueryBuilder, isKnexJoinBuilder } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { transformation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/transformations/index.js");
const getJoinBuilder = once(() => (__webpack_require__("./node_modules/objection/lib/queryBuilder/JoinBuilder.js").JoinBuilder));

// An abstract operation base class that converts all arguments from objection types
// to knex types. For example objection query builders are converted into knex query
// builders and objection RawBuilder instances are converted into knex Raw instances.
class ObjectionToKnexConvertingOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.args = null;
  }

  getKnexArgs(builder) {
    return convertArgs(this.name, builder, this.args);
  }

  onAdd(builder, args) {
    this.args = Array.from(args);
    return shouldBeAdded(this.name, builder, this.args);
  }

  clone() {
    const clone = super.clone();
    clone.args = this.args;
    return clone;
  }
}

function shouldBeAdded(opName, builder, args) {
  const skipUndefined = builder.internalOptions().skipUndefined;

  for (let i = 0, l = args.length; i < l; ++i) {
    const arg = args[i];

    if (isUndefined(arg)) {
      if (skipUndefined) {
        return false;
      } else {
        throw new Error(
          `undefined passed as argument #${i} for '${opName}' operation. Call skipUndefined() method to ignore the undefined values.`,
        );
      }
    }
  }

  return true;
}

function convertArgs(opName, builder, args) {
  const skipUndefined = builder.internalOptions().skipUndefined;

  return args.map((arg, i) => {
    if (hasToKnexRawMethod(arg)) {
      return convertToKnexRaw(arg, builder);
    } else if (isObjectionQueryBuilderBase(arg)) {
      return convertQueryBuilderBase(arg, builder);
    } else if (isArray(arg)) {
      return convertArray(arg, builder, i, opName, skipUndefined);
    } else if (isFunction(arg)) {
      return convertFunction(arg, builder);
    } else if (isModel(arg)) {
      return convertModel(arg);
    } else if (isPlainObject(arg)) {
      return convertPlainObject(arg, builder, i, opName, skipUndefined);
    } else {
      return arg;
    }
  });
}

function isUndefined(item) {
  return item === undefined;
}

function hasToKnexRawMethod(item) {
  return isObject(item) && isFunction(item.toKnexRaw);
}

function convertToKnexRaw(item, builder) {
  return item.toKnexRaw(builder);
}

function isObjectionQueryBuilderBase(item) {
  return isObject(item) && item.isObjectionQueryBuilderBase === true;
}

function convertQueryBuilderBase(item, builder) {
  item = transformation.onConvertQueryBuilderBase(item, builder);
  return item.subqueryOf(builder).toKnexQuery();
}

function isArray(item) {
  return Array.isArray(item);
}

function convertArray(arr, builder, i, opName, skipUndefined) {
  return arr.map((item) => {
    if (item === undefined) {
      if (!skipUndefined) {
        throw new Error(
          `undefined passed as an item in argument #${i} for '${opName}' operation. Call skipUndefined() method to ignore the undefined values.`,
        );
      }
    } else if (hasToKnexRawMethod(item)) {
      return convertToKnexRaw(item, builder);
    } else if (isObjectionQueryBuilderBase(item)) {
      return convertQueryBuilderBase(item, builder);
    } else {
      return item;
    }
  });
}

function convertFunction(func, builder) {
  return function convertedKnexArgumentFunction(...args) {
    if (isKnexQueryBuilder(this)) {
      convertQueryBuilderFunction(this, func, builder);
    } else if (isKnexJoinBuilder(this)) {
      convertJoinBuilderFunction(this, func, builder);
    } else {
      return func.apply(this, args);
    }
  };
}

function convertQueryBuilderFunction(knexQueryBuilder, func, builder) {
  const convertedQueryBuilder = builder.constructor.forClass(builder.modelClass());

  convertedQueryBuilder.isPartial(true).subqueryOf(builder);
  func.call(convertedQueryBuilder, convertedQueryBuilder);

  convertedQueryBuilder.toKnexQuery(knexQueryBuilder);
}

function convertJoinBuilderFunction(knexJoinBuilder, func, builder) {
  const JoinBuilder = getJoinBuilder();
  const joinClauseBuilder = JoinBuilder.forClass(builder.modelClass());

  joinClauseBuilder.isPartial(true).subqueryOf(builder);
  func.call(joinClauseBuilder, joinClauseBuilder);

  joinClauseBuilder.toKnexQuery(knexJoinBuilder);
}

function isModel(item) {
  return isObject(item) && item.$isObjectionModel;
}

function convertModel(model) {
  return model.$toDatabaseJson();
}

function convertPlainObject(obj, builder, i, opName, skipUndefined) {
  return Object.keys(obj).reduce((out, key) => {
    const item = obj[key];

    if (item === undefined) {
      if (!skipUndefined) {
        throw new Error(
          `undefined passed as a property in argument #${i} for '${opName}' operation. Call skipUndefined() method to ignore the undefined values.`,
        );
      }
    } else if (hasToKnexRawMethod(item)) {
      out[key] = convertToKnexRaw(item, builder);
    } else if (isObjectionQueryBuilderBase(item)) {
      out[key] = convertQueryBuilderBase(item, builder);
    } else {
      out[key] = item;
    }

    return out;
  }, {});
}

module.exports = {
  ObjectionToKnexConvertingOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/OnBuildKnexOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class OnBuildKnexOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.func = null;
  }

  onAdd(_, args) {
    this.func = args[0];
    return true;
  }

  onBuildKnex(knexBuilder, builder) {
    return this.func.call(knexBuilder, knexBuilder, builder);
  }

  clone() {
    const clone = super.clone();
    clone.func = this.func;
    return clone;
  }
}

module.exports = {
  OnBuildKnexOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/OnBuildOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class OnBuildOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.func = null;
  }

  onAdd(_, args) {
    this.func = args[0];
    return true;
  }

  onBuild(builder) {
    return this.func.call(builder, builder);
  }

  clone() {
    const clone = super.clone();
    clone.func = this.func;
    return clone;
  }
}

module.exports = {
  OnBuildOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/OnErrorOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class OnErrorOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.func = null;
  }

  onAdd(_, args) {
    this.func = args[0];
    return true;
  }

  onError(builder, error) {
    return this.func.call(builder, error, builder);
  }

  clone() {
    const clone = super.clone();
    clone.func = this.func;
    return clone;
  }
}

module.exports = {
  OnErrorOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js":
/***/ ((module) => {

"use strict";


const hookNameToHasMethodName = {
  onAdd: 'hasOnAdd',
  onBefore1: 'hasOnBefore1',
  onBefore2: 'hasOnBefore2',
  onBefore3: 'hasOnBefore3',
  onBuild: 'hasOnBuild',
  onBuildKnex: 'hasOnBuildKnex',
  onRawResult: 'hasOnRawResult',
  queryExecutor: 'hasQueryExecutor',
  onAfter1: 'hasOnAfter1',
  onAfter2: 'hasOnAfter2',
  onAfter3: 'hasOnAfter3',
  onError: 'hasOnError',
};

// An abstract base class for all query builder operations. QueryBuilderOperations almost always
// correspond to a single query builder method call. For example SelectOperation could be added when
// a `select` method is called.
//
// QueryBuilderOperation is just a bunch of query execution lifecycle hooks that subclasses
// can (but don't have to) implement.
//
// Basically a query builder is nothing but an array of QueryBuilderOperations. When the query is
// executed the hooks are called in the order explained below. The hooks are called so that a
// certain hook is called for _all_ operations before the next hook is called. For example if
// a builder has 5 operations, onBefore1 hook is called for each of them (and their results are awaited)
// before onBefore2 hook is called for any of the operations.
class QueryBuilderOperation {
  constructor(name = null, opt = {}) {
    this.name = name;
    this.opt = opt;

    // From which hook was this operation added as a child
    // operation.
    this.adderHookName = null;

    // The parent operation that added this operation.
    this.parentOperation = null;

    // Operations this operation added in any of its hooks.
    this.childOperations = [];
  }

  is(OperationClass) {
    return this instanceof OperationClass;
  }

  hasHook(hookName) {
    return this[hookNameToHasMethodName[hookName]]();
  }

  // This is called immediately when a query builder method is called.
  //
  // This method must be synchronous.
  // This method should never call any methods that add operations to the builder.
  onAdd(builder, args) {
    return true;
  }
  hasOnAdd() {
    return true;
  }

  // This is called as the first thing when the query is executed but before
  // the actual database operation (knex query) is executed.
  //
  // This method can be asynchronous.
  // You may call methods that add operations to to the builder.
  onBefore1(builder, result) {}
  hasOnBefore1() {
    return this.onBefore1 !== QueryBuilderOperation.prototype.onBefore1;
  }

  // This is called as the second thing when the query is executed but before
  // the actual database operation (knex query) is executed.
  //
  // This method can be asynchronous.
  // You may call methods that add operations to to the builder.
  onBefore2(builder, result) {}
  hasOnBefore2() {
    return this.onBefore2 !== QueryBuilderOperation.prototype.onBefore2;
  }

  // This is called as the third thing when the query is executed but before
  // the actual database operation (knex query) is executed.
  //
  // This method can be asynchronous.
  // You may call methods that add operations to to the builder.
  onBefore3(builder, result) {}
  hasOnBefore3() {
    return this.onBefore3 !== QueryBuilderOperation.prototype.onBefore3;
  }

  // This is called as the last thing when the query is executed but before
  // the actual database operation (knex query) is executed. If your operation
  // needs to call other query building operations (methods that add QueryBuilderOperations)
  // this is the best and last place to do it.
  //
  // This method must be synchronous.
  // You may call methods that add operations to to the builder.
  onBuild(builder) {}
  hasOnBuild() {
    return this.onBuild !== QueryBuilderOperation.prototype.onBuild;
  }

  // This is called when the knex query is built. Here you should only call knex
  // methods. You may call getters and other immutable methods of the `builder`
  // but you should never call methods that add QueryBuilderOperations.
  //
  // This method must be synchronous.
  // This method should never call any methods that add operations to the builder.
  // This method should always return the knex query builder.
  onBuildKnex(knexBuilder, builder) {
    return knexBuilder;
  }
  hasOnBuildKnex() {
    return this.onBuildKnex !== QueryBuilderOperation.prototype.onBuildKnex;
  }

  // The raw knex result is passed to this method right after the database query
  // has finished. This method may modify it and return the modified rows. The
  // rows are automatically converted to models (if possible) after this hook
  // is called.
  //
  // This method can be asynchronous.
  onRawResult(builder, rows) {
    return rows;
  }
  hasOnRawResult() {
    return this.onRawResult !== QueryBuilderOperation.prototype.onRawResult;
  }

  // This is called as the first thing after the query has been executed and
  // rows have been converted to model instances.
  //
  // This method can be asynchronous.
  onAfter1(builder, result) {
    return result;
  }
  hasOnAfter1() {
    return this.onAfter1 !== QueryBuilderOperation.prototype.onAfter1;
  }

  // This is called as the second thing after the query has been executed and
  // rows have been converted to model instances.
  //
  // This method can be asynchronous.
  onAfter2(builder, result) {
    return result;
  }
  hasOnAfter2() {
    return this.onAfter2 !== QueryBuilderOperation.prototype.onAfter2;
  }

  // This is called as the third thing after the query has been executed and
  // rows have been converted to model instances.
  //
  // This method can be asynchronous.
  onAfter3(builder, result) {
    return result;
  }
  hasOnAfter3() {
    return this.onAfter3 !== QueryBuilderOperation.prototype.onAfter3;
  }

  // This method can be implemented to return another operation that will replace
  // this one. This method is called after all `onBeforeX` and `onBuildX` hooks
  // but before the database query is executed.
  //
  // This method must return a QueryBuilder instance.
  queryExecutor(builder) {}
  hasQueryExecutor() {
    return this.queryExecutor !== QueryBuilderOperation.prototype.queryExecutor;
  }

  // This is called if an error occurs in the query execution.
  //
  // This method must return a QueryBuilder instance.
  onError(builder, error) {}
  hasOnError() {
    return this.onError !== QueryBuilderOperation.prototype.onError;
  }

  // Returns the "find" equivalent of this operation.
  //
  // For example an operation that finds an item and updates it
  // should return an operation that simply finds the item but
  // doesn't update anything. An insert operation should return
  // null since there is no find equivalent for it etc.
  toFindOperation(builder) {
    return this;
  }
  hasToFindOperation() {
    return this.toFindOperation !== QueryBuilderOperation.prototype.toFindOperation;
  }

  // Given a set of operations, returns true if any of this operation's
  // ancestor operations are included in the set.
  isAncestorInSet(operationSet) {
    let ancestor = this.parentOperation;

    while (ancestor) {
      if (operationSet.has(ancestor)) {
        return true;
      }

      ancestor = ancestor.parentOperation;
    }

    return false;
  }

  // Takes a deep clone of this operation.
  clone() {
    const clone = new this.constructor(this.name, this.opt);

    clone.adderHookName = this.adderHookName;
    clone.parentOperation = this.parentOperation;

    clone.childOperations = this.childOperations.map((childOp) => {
      const childOpClone = childOp.clone();

      childOpClone.parentOperation = clone;
      return childOpClone;
    });

    return clone;
  }

  // Add an operation as a child operation. `hookName` must be the
  // name of the parent operation's hook that called this method.
  addChildOperation(hookName, operation) {
    operation.adderHookName = hookName;
    operation.parentOperation = this;

    this.childOperations.push(operation);
  }

  // Removes a single child operation.
  removeChildOperation(operation) {
    const index = this.childOperations.indexOf(operation);

    if (index !== -1) {
      operation.parentOperation = null;
      this.childOperations.splice(index, 1);
    }
  }

  // Replaces a single child operation.
  replaceChildOperation(operation, newOperation) {
    const index = this.childOperations.indexOf(operation);

    if (index !== -1) {
      newOperation.adderHookName = operation.adderHookName;
      newOperation.parentOperation = this;
      operation.parentOperation = null;
      this.childOperations[index] = newOperation;
    }
  }

  // Removes all child operations that were added from the `hookName` hook.
  removeChildOperationsByHookName(hookName) {
    this.childOperations = this.childOperations.filter((op) => op.adderHookName !== hookName);
  }

  // Iterates through all descendant operations recursively.
  forEachDescendantOperation(callback) {
    for (const operation of this.childOperations) {
      if (callback(operation) === false) {
        return false;
      }

      if (operation.forEachDescendantOperation(callback) === false) {
        return false;
      }
    }

    return true;
  }
}

Object.defineProperties(QueryBuilderOperation, {
  isObjectionQueryBuilderOperationClass: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

module.exports = {
  QueryBuilderOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/RangeOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class RangeOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.resultSizeBuilder = null;
  }

  onAdd(builder, args) {
    if (args.length === 2) {
      const start = args[0];
      const end = args[1];

      // Need to set these here instead of `onBuildKnex` so that they
      // don't end up in the resultSize query.
      builder.limit(end - start + 1).offset(start);
    }

    return true;
  }

  onBefore1(builder, result) {
    this.resultSizeBuilder = builder.clone();
    return super.onBefore1(builder, result);
  }

  async onAfter3(_, results) {
    const resultSize = await this.resultSizeBuilder.resultSize();

    return {
      results,
      total: parseInt(resultSize),
    };
  }

  clone() {
    const clone = super.clone();
    clone.resultSizeBuilder = this.resultSizeBuilder;
    return clone;
  }
}

module.exports = {
  RangeOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/RelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class RelateOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
    this.input = null;
    this.ids = null;
  }

  clone() {
    const clone = super.clone();

    clone.input = this.input;
    clone.ids = this.ids;

    return clone;
  }
}

module.exports = {
  RelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/ReturningOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { flatten } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");

// This class's only purpose is to normalize the arguments into an array.
//
// In knex, if a single column is given to `returning` it returns an array with the that column's value
// in it. If an array is given with a one item inside, the return value is an object.
class ReturningOperation extends ObjectionToKnexConvertingOperation {
  onAdd(builder, args) {
    args = flatten(args);

    // Don't add an empty returning list.
    if (args.length === 0) {
      return false;
    }

    return super.onAdd(builder, args);
  }

  onBuildKnex(knexBuilder, builder) {
    // Always pass an array of columns to knex.returning.
    return knexBuilder.returning(this.getKnexArgs(builder));
  }
}

module.exports = {
  ReturningOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/RunAfterOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class RunAfterOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.func = null;
  }

  onAdd(_, args) {
    this.func = args[0];
    return true;
  }

  onAfter3(builder, result) {
    return this.func.call(builder, result, builder);
  }

  clone() {
    const clone = super.clone();
    clone.func = this.func;
    return clone;
  }
}

module.exports = {
  RunAfterOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/RunBeforeOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class RunBeforeOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);
    this.func = null;
  }

  onAdd(_, args) {
    this.func = args[0];
    return true;
  }

  onBefore1(builder, result) {
    return this.func.call(builder, result, builder);
  }

  clone() {
    const clone = super.clone();
    clone.func = this.func;
    return clone;
  }
}

module.exports = {
  RunBeforeOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/UnrelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");

class UnrelateOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
    this.ids = null;
  }

  clone() {
    const clone = super.clone();
    clone.ids = this.ids;
    return clone;
  }
}

module.exports = {
  UnrelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/UpdateAndFetchOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DelegateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js");
const { FindByIdOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FindByIdOperation.js");
const { UpdateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js");

class UpdateAndFetchOperation extends DelegateOperation {
  constructor(name, opt) {
    super(name, opt);

    if (!this.delegate.is(UpdateOperation)) {
      throw new Error('Invalid delegate');
    }

    this.id = null;
    this.skipIdWhere = false;
  }

  get model() {
    return this.delegate.model;
  }

  onAdd(builder, args) {
    this.id = args[0];
    return this.delegate.onAdd(builder, args.slice(1));
  }

  onBuild(builder) {
    if (!this.skipIdWhere) {
      builder.findById(this.id);
    }

    super.onBuild(builder);
  }

  async onAfter2(builder, numUpdated) {
    if (numUpdated == 0) {
      // If nothing was updated, we should fetch nothing.
      await super.onAfter2(builder, numUpdated);
      return undefined;
    }

    const fetched = await builder
      .emptyInstance()
      .childQueryOf(builder)
      .modify((builder) => {
        if (!this.skipIdWhere) {
          builder.findById(this.id);
        }
      })
      .castTo(builder.resultModelClass());

    if (fetched) {
      this.model.$set(fetched);
    }

    await super.onAfter2(builder, numUpdated);
    return fetched ? this.model : undefined;
  }

  toFindOperation() {
    return new FindByIdOperation('findById', {
      id: this.id,
    });
  }

  clone() {
    const clone = super.clone();

    clone.id = this.id;
    clone.skipIdWhere = this.skipIdWhere;

    return clone;
  }
}

module.exports = {
  UpdateAndFetchOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ref } = __webpack_require__("./node_modules/objection/lib/queryBuilder/ReferenceBuilder.js");
const { isEmpty } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { isKnexRaw, isKnexQueryBuilder } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { StaticHookArguments } = __webpack_require__("./node_modules/objection/lib/queryBuilder/StaticHookArguments.js");

class UpdateOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);

    this.model = null;
    this.modelOptions = Object.assign({}, this.opt.modelOptions || {});
  }

  onAdd(builder, args) {
    const json = args[0];
    const modelClass = builder.modelClass();

    this.model = modelClass.ensureModel(json, this.modelOptions);
    return true;
  }

  async onBefore2(builder, result) {
    await callBeforeUpdate(builder, this.model, this.modelOptions);
    return result;
  }

  onBefore3(builder) {
    const row = this.model.$toDatabaseJson(builder);

    if (isEmpty(row)) {
      // Resolve the query if there is nothing to update.
      builder.resolve(0);
    }
  }

  onBuildKnex(knexBuilder, builder) {
    const json = this.model.$toDatabaseJson(builder);
    const convertedJson = convertFieldExpressionsToRaw(builder, this.model, json);

    return knexBuilder.update(convertedJson);
  }

  onAfter2(builder, numUpdated) {
    return callAfterUpdate(builder, this.model, this.modelOptions, numUpdated);
  }

  toFindOperation() {
    return null;
  }

  clone() {
    const clone = super.clone();
    clone.model = this.model;
    return clone;
  }
}

async function callBeforeUpdate(builder, model, modelOptions) {
  await callInstanceBeforeUpdate(builder, model, modelOptions);
  return callStaticBeforeUpdate(builder);
}

function callInstanceBeforeUpdate(builder, model, modelOptions) {
  return model.$beforeUpdate(modelOptions, builder.context());
}

function callStaticBeforeUpdate(builder) {
  const args = StaticHookArguments.create({ builder });
  return builder.modelClass().beforeUpdate(args);
}

async function callAfterUpdate(builder, model, modelOptions, result) {
  await callInstanceAfterUpdate(builder, model, modelOptions);
  return callStaticAfterUpdate(builder, result);
}

function callInstanceAfterUpdate(builder, model, modelOptions) {
  return model.$afterUpdate(modelOptions, builder.context());
}

async function callStaticAfterUpdate(builder, result) {
  const args = StaticHookArguments.create({ builder, result });
  const maybeResult = await builder.modelClass().afterUpdate(args);

  if (maybeResult === undefined) {
    return result;
  } else {
    return maybeResult;
  }
}

function convertFieldExpressionsToRaw(builder, model, json) {
  const knex = builder.knex();
  const convertedJson = {};

  for (const key of Object.keys(json)) {
    let val = json[key];

    if (key.indexOf(':') > -1) {
      // 'col:attr' : ref('other:lol') is transformed to
      // "col" : raw(`jsonb_set("col", '{attr}', to_jsonb("other"#>'{lol}'), true)`)

      let parsed = ref(key);
      let jsonRefs = '{' + parsed.parsedExpr.access.map((it) => it.ref).join(',') + '}';
      let valuePlaceholder = '?';

      if (isKnexQueryBuilder(val) || isKnexRaw(val)) {
        valuePlaceholder = 'to_jsonb(?)';
      } else {
        val = JSON.stringify(val);
      }

      convertedJson[parsed.column] = knex.raw(
        `jsonb_set(??, '${jsonRefs}', ${valuePlaceholder}, true)`,
        [convertedJson[parsed.column] || parsed.column, val],
      );

      delete model[key];
    } else {
      convertedJson[key] = val;
    }
  }

  return convertedJson;
}

module.exports = {
  UpdateOperation,
  convertFieldExpressionsToRaw,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/UpsertGraphAndFetchOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DelegateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js");
const { UpsertGraphOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpsertGraphOperation.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");

class UpsertGraphAndFetchOperation extends DelegateOperation {
  constructor(name, opt) {
    super(name, opt);

    if (!this.delegate.is(UpsertGraphOperation)) {
      throw new Error('Invalid delegate');
    }
  }

  get models() {
    return this.delegate.models;
  }

  get isArray() {
    return this.delegate.isArray;
  }

  async onAfter3(builder) {
    if (this.models.length === 0) {
      return this.isArray ? [] : null;
    }

    const eager = RelationExpression.fromModelGraph(this.models);
    const modelClass = this.models[0].constructor;
    const ids = this.models.map((model) => model.$id());

    const models = await modelClass
      .query()
      .childQueryOf(builder)
      .findByIds(ids)
      .withGraphFetched(eager);

    return this.isArray ? models : models[0] || null;
  }
}

module.exports = {
  UpsertGraphAndFetchOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/UpsertGraphOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { GraphUpsert } = __webpack_require__("./node_modules/objection/lib/queryBuilder/graph/GraphUpsert.js");
const { RelationFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationFindOperation.js");

class UpsertGraphOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(
      name,
      Object.assign({}, opt, {
        upsertOptions: {},
      }),
    );

    this.upsertOptions = opt.upsertOptions || {};
    this.upsert = null;
  }

  get models() {
    return this.upsert.objects;
  }

  get isArray() {
    return this.upsert.isArray;
  }

  onAdd(builder, args) {
    const [objects] = args;

    this.upsert = new GraphUpsert({
      objects,
      rootModelClass: builder.modelClass(),
      upsertOptions: this.upsertOptions,
    });

    // Never execute this builder.
    builder.resolve([]);

    return true;
  }

  onAfter1(builder) {
    if (hasOtherSqlModifyingQueryBuilderCalls(builder)) {
      throw new Error(
        'upsertGraph query should contain no other query builder calls like `findById`, `where` or `$relatedQuery` that would affect the SQL. They have no effect.',
      );
    }

    return this.upsert.run(builder);
  }

  clone() {
    const clone = super.clone();
    clone.upsert = this.upsert;
    return clone;
  }
}

function hasOtherSqlModifyingQueryBuilderCalls(builder) {
  return builder.has(/where/) || builder.has(RelationFindOperation);
}

module.exports = {
  UpsertGraphOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/WhereCompositeOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");
const { asSingle } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class WhereCompositeOperation extends ObjectionToKnexConvertingOperation {
  onBuildKnex(knexBuilder, builder) {
    const args = this.getKnexArgs(builder);

    if (args.length === 2) {
      // Convert whereComposite('foo', 1) into whereComposite('foo', '=', 1)
      args.splice(1, 0, '=');
    } else if (args.length !== 3) {
      throw new Error(`invalid number of arguments ${args.length}`);
    }

    return knexBuilder.where(...buildWhereArgs(...args));
  }
}

function buildWhereArgs(cols, op, values) {
  if (isNormalWhere(cols, values)) {
    return buildNormalWhereArgs(cols, op, values);
  } else if (isCompositeWhere(cols, values)) {
    return buildCompositeWhereArgs(cols, op, values);
  } else {
    throw new Error(`both cols and values must have same dimensions`);
  }
}

function isNormalWhere(cols, values) {
  return (
    (!Array.isArray(cols) || cols.length === 1) && (!Array.isArray(values) || values.length === 1)
  );
}

function buildNormalWhereArgs(cols, op, values) {
  return [asSingle(cols), op, asSingle(values)];
}

function isCompositeWhere(cols, values) {
  return Array.isArray(cols) && Array.isArray(values) && cols.length === values.length;
}

function buildCompositeWhereArgs(cols, op, values) {
  return [
    (builder) => {
      for (let i = 0, l = cols.length; i < l; ++i) {
        builder.where(cols[i], op, values[i]);
      }
    },
  ];
}

module.exports = {
  WhereCompositeOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/eager/EagerOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryBuilderOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js");
const { RelationExpression } = __webpack_require__("./node_modules/objection/lib/queryBuilder/RelationExpression.js");

class EagerOperation extends QueryBuilderOperation {
  constructor(name, opt) {
    super(name, opt);

    this.expression = RelationExpression.create();
    this.modifiersAtPath = [];
    this.graphOptions = this.opt.defaultGraphOptions;
  }

  buildFinalExpression() {
    const expression = this.expression.clone();

    this.modifiersAtPath.forEach((modifier, i) => {
      const modifierName = getModifierName(i);

      expression.expressionsAtPath(modifier.path).forEach((expr) => {
        expr.node.$modify.push(modifierName);
      });
    });

    return expression;
  }

  buildFinalModifiers(builder) {
    // `modifiers()` returns a clone so we can modify it.
    const modifiers = builder.modifiers();

    this.modifiersAtPath.forEach((modifier, i) => {
      const modifierName = getModifierName(i);

      modifiers[modifierName] = modifier.modifier;
    });

    return modifiers;
  }

  cloneFrom(eagerOp) {
    this.expression = eagerOp.expression.clone();
    this.modifiersAtPath = eagerOp.modifiersAtPath.slice();
    this.graphOptions = Object.assign({}, eagerOp.graphOptions);
  }

  clone() {
    const clone = super.clone();
    clone.cloneFrom(this);
    return clone;
  }
}

function getModifierName(index) {
  return `_f${index}_`;
}

module.exports = {
  EagerOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/eager/JoinEagerOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/EagerOperation.js");
const { RelationJoiner } = __webpack_require__("./node_modules/objection/lib/queryBuilder/join/RelationJoiner.js");

class JoinEagerOperation extends EagerOperation {
  constructor(name, opt) {
    super(name, opt);
    this.joiner = null;
  }

  onAdd(builder) {
    builder.findOptions({ callAfterFindDeeply: true });

    this.joiner = new RelationJoiner({
      modelClass: builder.modelClass(),
    });

    return true;
  }

  onBefore3(builder) {
    return this.joiner
      .setExpression(this.buildFinalExpression())
      .setModifiers(this.buildFinalModifiers(builder))
      .setOptions(this.graphOptions)
      .fetchColumnInfo(builder);
  }

  onBuild(builder) {
    this.joiner
      .setExpression(this.buildFinalExpression())
      .setModifiers(this.buildFinalModifiers(builder))
      .setOptions(this.graphOptions)
      .build(builder);
  }

  onRawResult(builder, rows) {
    return this.joiner.parseResult(builder, rows);
  }

  clone() {
    const clone = super.clone();
    clone.joiner = this.joiner;
    return clone;
  }
}

module.exports = {
  JoinEagerOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/eager/NaiveEagerOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { WhereInEagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/WhereInEagerOperation.js");

class NaiveEagerOperation extends WhereInEagerOperation {
  batchSize() {
    return 1;
  }
}

module.exports = {
  NaiveEagerOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/eager/WhereInEagerOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");

const { EagerOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/eager/EagerOperation.js");
const { isMsSql, isOracle, isSqlite } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { isObject, asArray, flatten, chunk } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { ValidationErrorType } = __webpack_require__("./node_modules/objection/lib/model/ValidationError.js");
const { createModifier } = __webpack_require__("./node_modules/objection/lib/utils/createModifier.js");
const { RelationDoesNotExistError } = __webpack_require__("./node_modules/objection/lib/model/RelationDoesNotExistError.js");
const { RelationOwner } = __webpack_require__("./node_modules/objection/lib/relations/RelationOwner.js");

class WhereInEagerOperation extends EagerOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relationsToFetch = [];
    this.omitProps = [];
  }

  batchSize(knex) {
    if (this.graphOptions.maxBatchSize) {
      return this.graphOptions.maxBatchSize;
    } else if (isMsSql(knex)) {
      // On MSSQL the parameter limit is actually 2100, but since I couldn't figure out
      // if the limit is for all parameters in a query or for individual clauses, we set
      // the limit to 2000 to leave 100 parameters for where clauses etc.
      return 2000;
    } else if (isOracle(knex)) {
      return 1000;
    } else if (isSqlite(knex)) {
      // SQLITE_MAX_VARIABLE_NUMBER is 999 by default
      return 999;
    } else {
      // I'm sure there is some kind of limit for other databases too, but let's lower
      // this if someone ever hits those limits.
      return 10000;
    }
  }

  onBuild(builder) {
    const relationsToFetch = findRelationsToFetch(
      builder.modelClass(),
      this.buildFinalExpression(),
    );

    const { selectionsToAdd, selectedProps } = findRelationPropsToSelect(builder, relationsToFetch);

    if (selectionsToAdd.length) {
      builder.select(selectionsToAdd);
    }

    this.relationsToFetch = relationsToFetch;
    this.omitProps = selectedProps;
  }

  async onAfter2(builder, result) {
    const modelClass = builder.resultModelClass();

    if (!result) {
      return result;
    }

    const models = asArray(result);

    // Check models to be actual objects, to filter out `count` results (#2397).
    if (!models.length || !isObject(models[0])) {
      return result;
    }

    await promiseUtils.map(
      this.relationsToFetch,
      (it) => this.fetchRelation(builder, models, it.relation, it.childExpression),
      { concurrency: modelClass.getConcurrency(builder.unsafeKnex()) },
    );

    const intOpt = builder.internalOptions();

    if (!this.omitProps.length || intOpt.keepImplicitJoinProps) {
      return result;
    }

    // Now that relations have been fetched for `models` we can omit the
    // columns that were implicitly selected by this class.
    for (let i = 0, l = result.length; i < l; ++i) {
      const model = result[i];

      for (let c = 0, lc = this.omitProps.length; c < lc; ++c) {
        modelClass.omitImpl(model, this.omitProps[c]);
      }
    }

    return result;
  }

  async fetchRelation(builder, models, relation, expr) {
    const modelClass = builder.resultModelClass();
    const batchSize = this.batchSize(builder.knex());
    const modelBatches = chunk(models, batchSize);

    const result = await promiseUtils.map(
      modelBatches,
      (batch) => this.fetchRelationBatch(builder, batch, relation, expr),
      {
        concurrency: modelClass.getConcurrency(builder.unsafeKnex()),
      },
    );

    return flatten(result);
  }

  fetchRelationBatch(builder, models, relation, expr) {
    if (this.shouldSkipFetched(models, relation, expr)) {
      return this.createSkippedQuery(builder, models, relation, expr);
    }

    const queryBuilder = this.createRelationQuery(builder, relation, expr);
    const findOperation = relation.find(queryBuilder, RelationOwner.create(models));

    findOperation.alwaysReturnArray = true;
    findOperation.assignResultToOwner = true;
    findOperation.relationProperty = expr.node.$name;

    queryBuilder.addOperation(findOperation, []);

    for (const modifierName of expr.node.$modify) {
      const modifier = createModifier({
        modifier: modifierName,
        modelClass: relation.relatedModelClass,
        modifiers: this.buildFinalModifiers(builder),
      });

      try {
        modifier(queryBuilder);
      } catch (err) {
        const modelClass = builder.modelClass();

        if (err instanceof modelClass.ModifierNotFoundError) {
          throw modelClass.createValidationError({
            type: ValidationErrorType.RelationExpression,
            message: `could not find modifier "${modifierName}" for relation "${relation.name}"`,
          });
        } else {
          throw err;
        }
      }
    }

    return queryBuilder;
  }

  shouldSkipFetched(models, relation, expr) {
    if (!this.graphOptions.skipFetched) {
      return false;
    }

    if (models.some((it) => it[expr.node.$name] === undefined)) {
      return false;
    }

    const relationsToFetch = findRelationsToFetch(relation.relatedModelClass, expr);
    const childModels = getRelatedModels(models, expr);

    // We can only skip fetching a relation if all already fetched models
    // have all needed relation properties so that we can fetch the next
    // level of relations.
    for (const { relation } of relationsToFetch) {
      const { ownerProp } = relation;

      for (let c = 0, lc = ownerProp.size; c < lc; ++c) {
        const prop = ownerProp.props[c];

        for (const model of childModels) {
          if (model[prop] === undefined) {
            return false;
          }
        }
      }
    }

    return true;
  }

  createSkippedQuery(builder, models, relation, expr) {
    const childModels = getRelatedModels(models, expr);

    return relation.relatedModelClass
      .query()
      .childQueryOf(builder)
      .findOptions({ dontCallFindHooks: true })
      .withGraphFetched(expr, this.graphOptions)
      .resolve(childModels);
  }

  createRelationQuery(builder, relation, expr) {
    return relation.relatedModelClass
      .query()
      .childQueryOf(builder)
      .withGraphFetched(expr, this.graphOptions)
      .modifiers(this.buildFinalModifiers(builder));
  }

  clone() {
    const clone = super.clone();

    clone.relationsToFetch = this.relationsToFetch.slice();
    clone.omitProps = this.omitProps.slice();

    return clone;
  }
}

function findRelationsToFetch(modelClass, eagerExpression) {
  const relationsToFetch = [];

  try {
    eagerExpression.forEachChildExpression(modelClass, (childExpression, relation) => {
      relationsToFetch.push({
        childExpression,
        relation,
      });
    });
  } catch (err) {
    if (err instanceof RelationDoesNotExistError) {
      throw modelClass.createValidationError({
        type: ValidationErrorType.RelationExpression,
        message: `unknown relation "${err.relationName}" in an eager expression`,
      });
    }
    throw err;
  }

  return relationsToFetch;
}

function findRelationPropsToSelect(builder, relationsToFetch) {
  const selectionsToAdd = [];
  const selectedProps = [];

  // Collect columns that need to be selected for the eager fetch
  // to work that are not currently selected.
  for (const { relation } of relationsToFetch) {
    const ownerProp = relation.ownerProp;

    for (let c = 0, lc = ownerProp.size; c < lc; ++c) {
      const fullCol = ownerProp.ref(builder, c).fullColumn(builder);
      const prop = ownerProp.props[c];
      const col = ownerProp.cols[c];

      if (!builder.hasSelectionAs(fullCol, col) && selectionsToAdd.indexOf(fullCol) === -1) {
        selectedProps.push(prop);
        selectionsToAdd.push(fullCol);
      }
    }
  }

  return {
    selectionsToAdd,
    selectedProps,
  };
}

function getRelatedModels(models, expr) {
  const allRelated = [];

  for (const model of models) {
    const related = model[expr.node.$name];

    if (related) {
      if (Array.isArray(related)) {
        for (const rel of related) {
          allRelated.push(rel);
        }
      } else {
        allRelated.push(related);
      }
    }
  }

  return allRelated;
}

module.exports = {
  WhereInEagerOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonHasPostgresOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonApi = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/jsonApi/postgresJsonApi.js");
const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");

class WhereJsonHasPostgresOperation extends ObjectionToKnexConvertingOperation {
  onBuildKnex(knexBuilder, builder) {
    const args = this.getKnexArgs(builder);

    const sql = jsonApi.whereJsonFieldRightStringArrayOnLeftQuery(
      builder.knex(),
      args[0],
      this.opt.operator,
      args[1],
    );

    if (this.opt.bool === 'or') {
      knexBuilder = knexBuilder.orWhereRaw(sql);
    } else {
      knexBuilder = knexBuilder.whereRaw(sql);
    }

    return knexBuilder;
  }
}

module.exports = {
  WhereJsonHasPostgresOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonNotObjectPostgresOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonApi = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/jsonApi/postgresJsonApi.js");
const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");

class WhereJsonNotObjectPostgresOperation extends ObjectionToKnexConvertingOperation {
  onBuildKnex(knexBuilder, builder) {
    return this.whereJsonNotObject(knexBuilder, builder.knex(), this.getKnexArgs(builder)[0]);
  }

  whereJsonNotObject(knexBuilder, knex, fieldExpression) {
    const innerQuery = (innerQuery) => {
      const builder = jsonApi.whereJsonbRefOnLeftJsonbValOrRefOnRight(
        innerQuery,
        fieldExpression,
        '@>',
        this.opt.compareValue,
        'not',
      );

      builder.orWhereRaw(jsonApi.whereJsonFieldQuery(knex, fieldExpression, 'IS', null));
    };

    if (this.opt.bool === 'or') {
      knexBuilder = knexBuilder.orWhere(innerQuery);
    } else {
      knexBuilder = knexBuilder.where(innerQuery);
    }

    return knexBuilder;
  }
}

module.exports = {
  WhereJsonNotObjectPostgresOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonPostgresOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonApi = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/jsonApi/postgresJsonApi.js");
const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");

class WhereJsonPostgresOperation extends ObjectionToKnexConvertingOperation {
  onBuildKnex(knexBuilder, builder) {
    const args = this.getKnexArgs(builder);

    const rawArgs = jsonApi.whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(
      args[0],
      this.opt.operator,
      args[1],
      this.opt.prefix,
    );

    if (this.opt.bool === 'or') {
      knexBuilder = knexBuilder.orWhereRaw.apply(knexBuilder, rawArgs);
    } else {
      knexBuilder = knexBuilder.whereRaw.apply(knexBuilder, rawArgs);
    }

    return knexBuilder;
  }
}

module.exports = {
  WhereJsonPostgresOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/jsonApi/postgresJsonApi.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const parser = __webpack_require__("./node_modules/objection/lib/utils/parseFieldExpression.js");
const { asArray, isObject, isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

/**
 * @typedef {String} FieldExpression
 *
 * Field expressions allow one to refer to separate JSONB fields inside columns.
 *
 * Syntax: <column reference>[:<json field reference>]
 *
 * e.g. `Person.jsonColumnName:details.names[1]` would refer to value `'Second'`
 * in column `Person.jsonColumnName` which has
 * `{ details: { names: ['First', 'Second', 'Last'] } }` object stored in it.
 *
 * First part `<column reference>` is compatible with column references used in
 * knex e.g. `MyFancyTable.tributeToThBestColumnNameEver`.
 *
 * Second part describes a path to an attribute inside the referred column.
 * It is optional and it always starts with colon which follows directly with
 * first path element. e.g. `Table.jsonObjectColumnName:jsonFieldName` or
 * `Table.jsonArrayColumn:[321]`.
 *
 * Syntax supports `[<key or index>]` and `.<key or index>` flavors of reference
 * to json keys / array indexes:
 *
 * e.g. both `Table.myColumn:[1][3]` and `Table.myColumn:1.3` would access correctly
 * both of the following objects `[null, [null,null,null, "I was accessed"]]` and
 * `{ "1": { "3" : "I was accessed" } }`
 *
 * Caveats when using special characters in keys:
 *
 * 1. `objectColumn.key` This is the most common syntax, good if you are
 *    not using dots or square brackets `[]` in your json object key name.
 * 2. Keys containing dots `objectColumn:[keywith.dots]` Column `{ "keywith.dots" : "I was referred" }`
 * 3. Keys containing square brackets `column['[]']` `{ "[]" : "This is getting ridiculous..." }`
 * 4. Keys containing square brackets and quotes
 *    `objectColumn:['Double."Quote".[]']` and `objectColumn:["Sinlge.'Quote'.[]"]`
 *    Column `{ "Double.\"Quote\".[]" : "I was referred",  "Single.'Quote'.[]" : "Mee too!" }`
 * 99. Keys containing dots, square brackets, single quotes and double quotes in one json key is
 *     not currently supported
 */

function parseFieldExpression(expression, extractAsText) {
  let parsed = parser.parseFieldExpression(expression);
  let jsonRefs = parsed.access.map((it) => it.ref).join(',');
  let extractor = extractAsText ? '#>>' : '#>';
  let middleQuotedColumnName = parsed.columnName.split('.').join('"."');
  return `"${middleQuotedColumnName}"${extractor}'{${jsonRefs}}'`;
}

function whereJsonbRefOnLeftJsonbValOrRefOnRight(
  builder,
  fieldExpression,
  operator,
  jsonObjectOrFieldExpression,
  queryPrefix,
) {
  let queryParams = whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(
    fieldExpression,
    operator,
    jsonObjectOrFieldExpression,
    queryPrefix,
  );
  return builder.whereRaw.apply(builder, queryParams);
}

function whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(
  fieldExpression,
  operator,
  jsonObjectOrFieldExpression,
  queryPrefix,
) {
  let fieldReference = parseFieldExpression(fieldExpression);

  if (isString(jsonObjectOrFieldExpression)) {
    let rightHandReference = parseFieldExpression(jsonObjectOrFieldExpression);
    let refRefQuery = [
      '(',
      fieldReference,
      ')::jsonb',
      operator,
      '(',
      rightHandReference,
      ')::jsonb',
    ];
    if (queryPrefix) {
      refRefQuery.unshift(queryPrefix);
    }
    return [refRefQuery.join(' ')];
  } else if (isObject(jsonObjectOrFieldExpression)) {
    let refValQuery = ['(', fieldReference, ')::jsonb', operator, '?::jsonb'];
    if (queryPrefix) {
      refValQuery.unshift(queryPrefix);
    }
    return [refValQuery.join(' '), JSON.stringify(jsonObjectOrFieldExpression)];
  }

  throw new Error('Invalid right hand expression.');
}

function whereJsonFieldRightStringArrayOnLeftQuery(knex, fieldExpression, operator, keys) {
  let fieldReference = parseFieldExpression(fieldExpression);
  keys = asArray(keys);

  let questionMarksArray = keys.map((key) => {
    if (!isString(key)) {
      throw new Error('All keys to find must be strings.');
    }
    return '?';
  });

  let rawSqlTemplateString = 'array[' + questionMarksArray.join(',') + ']';
  let rightHandExpression = knex.raw(rawSqlTemplateString, keys);

  return `${fieldReference} ${operator.replace('?', '\\?')} ${rightHandExpression}`;
}

function whereJsonFieldQuery(knex, fieldExpression, operator, value) {
  let fieldReference = parseFieldExpression(fieldExpression, true);
  let normalizedOperator = normalizeOperator(knex, operator);

  // json type comparison takes json type in string format
  let cast;
  let escapedValue = knex.raw(' ?', [value]);
  let type = typeof value;

  if (type === 'number') {
    cast = '::NUMERIC';
  } else if (type === 'boolean') {
    cast = '::BOOLEAN';
  } else if (type === 'string') {
    cast = '::TEXT';
  } else if (value === null) {
    cast = '::TEXT';
    escapedValue = 'NULL';
  } else {
    throw new Error('Value must be string, number, boolean or null.');
  }

  return `(${fieldReference})${cast} ${normalizedOperator} ${escapedValue}`;
}

function normalizeOperator(knex, operator) {
  let trimmedLowerCase = operator.trim().toLowerCase();

  switch (trimmedLowerCase) {
    case 'is':
    case 'is not':
      return trimmedLowerCase;
    default:
      return knex.client.formatter().operator(operator);
  }
}

module.exports = {
  parseFieldExpression: parseFieldExpression,
  whereJsonbRefOnLeftJsonbValOrRefOnRight: whereJsonbRefOnLeftJsonbValOrRefOnRight,
  whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams:
    whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams,
  whereJsonFieldRightStringArrayOnLeftQuery: whereJsonFieldRightStringArrayOnLeftQuery,
  whereJsonFieldQuery: whereJsonFieldQuery,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/select/SelectOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { flatten } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { Selection } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/select/Selection.js");
const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");

const COUNT_REGEX = /count/i;

class SelectOperation extends ObjectionToKnexConvertingOperation {
  constructor(name, opt) {
    super(name, opt);
    this.selections = [];
  }

  onAdd(builder, args) {
    const selections = flatten(args);

    // Don't add an empty selection. Empty list is accepted for `count`, `countDistinct`
    // etc. because knex apparently supports it.
    if (selections.length === 0 && !COUNT_REGEX.test(this.name)) {
      return false;
    }

    const ret = super.onAdd(builder, selections);

    for (const selection of selections) {
      const selectionInstance = Selection.create(selection);

      if (selectionInstance) {
        this.selections.push(selectionInstance);
      }
    }

    return ret;
  }

  onBuildKnex(knexBuilder, builder) {
    return knexBuilder[this.name].apply(knexBuilder, this.getKnexArgs(builder));
  }

  findSelection(builder, selectionToFind) {
    const selectionInstanceToFind = Selection.create(selectionToFind);

    if (!selectionInstanceToFind) {
      return null;
    }

    for (const selection of this.selections) {
      if (Selection.doesSelect(builder, selection, selectionInstanceToFind)) {
        return selection;
      }
    }

    return null;
  }

  clone() {
    const clone = super.clone();
    clone.selections = this.selections.slice();
    return clone;
  }
}

module.exports = {
  SelectOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/select/Selection.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isString, isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

const ALIAS_REGEX = /\s+as\s+/i;

class Selection {
  constructor(table, column, alias) {
    this.table = table;
    this.column = column;
    this.alias = alias;
  }

  get name() {
    return this.alias || this.column;
  }

  static create(selection) {
    if (isObject(selection)) {
      if (selection.isObjectionSelection) {
        return selection;
      } else if (selection.isObjectionReferenceBuilder) {
        return createSelectionFromReference(selection);
      } else if (selection.isObjectionRawBuilder) {
        return createSelectionFromRaw(selection);
      } else {
        return null;
      }
    } else if (isString(selection)) {
      return createSelectionFromString(selection);
    } else {
      return null;
    }
  }

  /**
   * Returns true if `selectionInBuilder` causes `selectionToTest` to be selected.
   *
   * Examples that return true:
   *
   * doesSelect(Person.query(), '*', 'name')
   * doesSelect(Person.query(), 'Person.*', 'name')
   * doesSelect(Person.query(), 'name', 'name')
   * doesSelect(Person.query(), 'name', 'Person.name')
   */
  static doesSelect(builder, selectionInBuilder, selectionToTest) {
    selectionInBuilder = Selection.create(selectionInBuilder);
    selectionToTest = Selection.create(selectionToTest);

    if (selectionInBuilder.column === '*') {
      if (selectionInBuilder.table) {
        if (selectionToTest.column === '*') {
          return selectionToTest.table === selectionInBuilder.table;
        } else {
          return (
            selectionToTest.table === null || selectionToTest.table === selectionInBuilder.table
          );
        }
      } else {
        return true;
      }
    } else {
      const selectionInBuilderTable = selectionInBuilder.table || builder.tableRef();

      if (selectionToTest.column === '*') {
        return false;
      } else {
        return (
          selectionToTest.column === selectionInBuilder.column &&
          (selectionToTest.table === null || selectionToTest.table === selectionInBuilderTable)
        );
      }
    }
  }
}

Object.defineProperties(Selection.prototype, {
  isObjectionSelection: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

function createSelectionFromReference(ref) {
  return new Selection(ref.tableName, ref.column, ref.alias);
}

function createSelectionFromRaw(raw) {
  if (raw.alias) {
    return new Selection(null, null, raw.alias);
  } else {
    return null;
  }
}

function createSelectionFromString(selection) {
  let table = null;
  let column = null;
  let alias = null;

  if (ALIAS_REGEX.test(selection)) {
    const parts = selection.split(ALIAS_REGEX);

    selection = parts[0].trim();
    alias = parts[1].trim();
  }

  const dotIdx = selection.lastIndexOf('.');

  if (dotIdx !== -1) {
    table = selection.substr(0, dotIdx);
    column = selection.substr(dotIdx + 1);
  } else {
    column = selection;
  }

  return new Selection(table, column, alias);
}

module.exports = {
  Selection,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeMsSqlOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");
const { flatten, zipObject, isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { getTempColumn } = __webpack_require__("./node_modules/objection/lib/utils/tmpColumnUtils.js");

class WhereInCompositeMsSqlOperation extends ObjectionToKnexConvertingOperation {
  constructor(name, opt) {
    super(name, opt);
    this.prefix = this.opt.prefix || null;
  }

  onBuildKnex(knexBuilder, builder) {
    const args = this.getKnexArgs(builder);
    return this.build(builder.knex(), knexBuilder, args[0], args[1]);
  }

  build(knex, knexBuilder, columns, values) {
    let isCompositeKey = Array.isArray(columns) && columns.length > 1;

    if (isCompositeKey) {
      return this.buildComposite(knex, knexBuilder, columns, values);
    } else {
      return this.buildNonComposite(knexBuilder, columns, values);
    }
  }

  buildComposite(knex, knexBuilder, columns, values) {
    const helperColumns = columns.map((_, index) => getTempColumn(index));

    if (Array.isArray(values)) {
      return this.buildCompositeValue(knex, knexBuilder, columns, helperColumns, values);
    } else {
      return this.buildCompositeSubquery(
        knex,
        knexBuilder,
        columns,
        helperColumns,
        values.as(knex.raw(`V(${helperColumns.map((_) => '??')})`, helperColumns)),
      );
    }
  }

  buildCompositeValue(knex, knexBuilder, columns, helperColumns, values) {
    return this.buildCompositeSubquery(
      knex,
      knexBuilder,
      columns,
      helperColumns,
      knex.raw(
        `(VALUES ${values
          .map((value) => `(${value.map((_) => '?').join(',')})`)
          .join(',')}) AS V(${helperColumns.map((_) => '??').join(',')})`,
        flatten(values).concat(helperColumns),
      ),
    );
  }

  buildCompositeSubquery(knex, knexBuilder, columns, helperColumns, subQuery) {
    const wrapperQuery = knex.from(subQuery).where(
      zipObject(
        helperColumns,
        columns.map((column) => knex.raw('??', column)),
      ),
    );

    if (this.prefix === 'not') {
      return knexBuilder.whereNotExists(wrapperQuery);
    } else {
      return knexBuilder.whereExists(wrapperQuery);
    }
  }

  buildNonComposite(knexBuilder, columns, values) {
    const col = isString(columns) ? columns : columns[0];

    if (Array.isArray(values)) {
      values = pickNonNull(values, []);
    } else {
      values = [values];
    }

    return this.whereIn(knexBuilder, col, values);
  }

  whereIn(knexBuilder, col, val) {
    if (this.prefix === 'not') {
      return knexBuilder.whereNotIn(col, val);
    } else {
      return knexBuilder.whereIn(col, val);
    }
  }

  clone() {
    const clone = super.clone();
    clone.prefix = this.prefix;
    return clone;
  }
}

function pickNonNull(values, output) {
  for (let i = 0, l = values.length; i < l; ++i) {
    const val = values[i];

    if (Array.isArray(val)) {
      pickNonNull(val, output);
    } else if (val !== null && val !== undefined) {
      output.push(val);
    }
  }

  return output;
}

module.exports = {
  WhereInCompositeMsSqlOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");
const { isObject, asSingle } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { isKnexQueryBuilder } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");

class WhereInCompositeOperation extends ObjectionToKnexConvertingOperation {
  constructor(name, opt) {
    super(name, opt);
    this.prefix = this.opt.prefix || null;
  }

  onBuildKnex(knexBuilder, builder) {
    const whereInArgs = buildWhereInArgs(builder.knex(), ...this.getKnexArgs(builder));

    if (this.prefix === 'not') {
      return knexBuilder.whereNotIn(...whereInArgs);
    } else {
      return knexBuilder.whereIn(...whereInArgs);
    }
  }

  clone() {
    const clone = super.clone();
    clone.prefix = this.prefix;
    return clone;
  }
}

function buildWhereInArgs(knex, columns, values) {
  if (isCompositeKey(columns)) {
    return buildCompositeArgs(knex, columns, values);
  } else {
    return buildNonCompositeArgs(columns, values);
  }
}

function isCompositeKey(columns) {
  return Array.isArray(columns) && columns.length > 1;
}

function buildCompositeArgs(knex, columns, values) {
  if (Array.isArray(values)) {
    return buildCompositeValueArgs(columns, values);
  } else {
    return buildCompositeSubqueryArgs(knex, columns, values);
  }
}

function buildCompositeValueArgs(columns, values) {
  if (!Array.isArray(values[0])) {
    return [columns, [values]];
  } else {
    return [columns, values];
  }
}

function buildCompositeSubqueryArgs(knex, columns, subquery) {
  const sql = `(${columns
    .map((col) => {
      // On older versions of knex, raw doesn't work
      // with `??`. We use `?` for those.
      if (isObject(col)) {
        return '?';
      } else {
        return '??';
      }
    })
    .join(',')})`;

  return [knex.raw(sql, columns), subquery];
}

function buildNonCompositeArgs(columns, values) {
  if (Array.isArray(values)) {
    values = pickNonNull(values, []);
  } else if (!isKnexQueryBuilder(values)) {
    values = [values];
  }

  return [asSingle(columns), values];
}

function pickNonNull(values, output) {
  for (let i = 0, l = values.length; i < l; ++i) {
    const val = values[i];

    if (Array.isArray(val)) {
      pickNonNull(val, output);
    } else if (val !== null && val !== undefined) {
      output.push(val);
    }
  }

  return output;
}

module.exports = {
  WhereInCompositeOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeSqliteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ObjectionToKnexConvertingOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js");
const { isKnexQueryBuilder } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { asSingle } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

class WhereInCompositeSqliteOperation extends ObjectionToKnexConvertingOperation {
  constructor(name, opt) {
    super(name, opt);
    this.prefix = this.opt.prefix || null;
  }

  onBuildKnex(knexBuilder, builder) {
    const { method, args } = buildWhereArgs(...this.getKnexArgs(builder));

    if (method === 'where') {
      if (this.prefix === 'not') {
        return knexBuilder.whereNot(...args);
      } else {
        return knexBuilder.where(...args);
      }
    } else {
      if (this.prefix === 'not') {
        return knexBuilder.whereNotIn(...args);
      } else {
        return knexBuilder.whereIn(...args);
      }
    }
  }

  clone() {
    const clone = super.clone();
    clone.prefix = this.prefix;
    return clone;
  }
}

function buildWhereArgs(columns, values) {
  if (isCompositeKey(columns)) {
    return buildCompositeArgs(columns, values);
  } else {
    return buildNonCompositeArgs(columns, values);
  }
}

function isCompositeKey(columns) {
  return Array.isArray(columns) && columns.length > 1;
}

function buildCompositeArgs(columns, values) {
  if (!Array.isArray(values)) {
    // If the `values` is not an array of values but a function or a subquery
    // we have no way to implement this method.
    throw new Error(`sqlite doesn't support multi-column where in clauses`);
  }

  // Sqlite doesn't support the `where in` syntax for multiple columns but
  // we can emulate it using grouped `or` clauses.
  return {
    method: 'where',
    args: [
      (builder) => {
        values.forEach((val) => {
          builder.orWhere((builder) => {
            columns.forEach((col, idx) => {
              builder.andWhere(col, val[idx]);
            });
          });
        });
      },
    ],
  };
}

function buildNonCompositeArgs(columns, values) {
  if (Array.isArray(values)) {
    values = pickNonNull(values, []);
  } else if (!isKnexQueryBuilder(values)) {
    values = [values];
  }

  return {
    method: 'whereIn',
    args: [asSingle(columns), values],
  };
}

function pickNonNull(values, output) {
  for (let i = 0, l = values.length; i < l; ++i) {
    const val = values[i];

    if (Array.isArray(val)) {
      pickNonNull(val, output);
    } else if (val !== null && val !== undefined) {
      output.push(val);
    }
  }

  return output;
}

module.exports = {
  WhereInCompositeSqliteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/parsers/jsonFieldExpressionParser.js":
/***/ ((module) => {

"use strict";


/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

function peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = 'SyntaxError';

  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return '"' + literalEscape(expectation.text) + '"';
    },

    class: function (expectation) {
      var escapedParts = '',
        i;

      for (i = 0; i < expectation.parts.length; i++) {
        escapedParts +=
          expectation.parts[i] instanceof Array
            ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])
            : classEscape(expectation.parts[i]);
      }

      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';
    },

    any: function (expectation) {
      return 'any character';
    },

    end: function (expectation) {
      return 'end of input';
    },

    other: function (expectation) {
      return expectation.description;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g, '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
      i,
      j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + ' or ' + descriptions[1];

      default:
        return (
          descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1]
        );
    }
  }

  function describeFound(found) {
    return found ? '"' + literalEscape(found) + '"' : 'end of input';
  }

  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},
    peg$startRuleFunctions = { start: peg$parsestart },
    peg$startRuleFunction = peg$parsestart,
    peg$c0 = ':',
    peg$c1 = peg$literalExpectation(':', false),
    peg$c2 = function (column, refs) {
      var access = [];
      if (refs) {
        var firstAccess = refs[1];
        access = refs[2];
        access.unshift(firstAccess);
      }
      return { columnName: column, access: access };
    },
    peg$c3 = '[',
    peg$c4 = peg$literalExpectation('[', false),
    peg$c5 = '"',
    peg$c6 = peg$literalExpectation('"', false),
    peg$c7 = "'",
    peg$c8 = peg$literalExpectation("'", false),
    peg$c9 = ']',
    peg$c10 = peg$literalExpectation(']', false),
    peg$c11 = function (key) {
      return { type: 'object', ref: Array.isArray(key) ? key[1] : key };
    },
    peg$c12 = function (index) {
      return { type: 'array', ref: parseInt(index, 10) };
    },
    peg$c13 = function (key) {
      return { type: 'object', ref: key };
    },
    peg$c14 = '.',
    peg$c15 = peg$literalExpectation('.', false),
    peg$c16 = /^[^\][]/,
    peg$c17 = peg$classExpectation([']', '['], true, false),
    peg$c18 = function (chars) {
      return chars.join('');
    },
    peg$c19 = /^[^:]/,
    peg$c20 = peg$classExpectation([':'], true, false),
    peg$c21 = /^[^"]/,
    peg$c22 = peg$classExpectation(['"'], true, false),
    peg$c23 = /^[^']/,
    peg$c24 = peg$classExpectation(["'"], true, false),
    peg$c25 = /^[^.\][]/,
    peg$c26 = peg$classExpectation(['.', ']', '['], true, false),
    peg$c27 = /^[0-9]/,
    peg$c28 = peg$classExpectation([['0', '9']], false, false),
    peg$c29 = function (digits) {
      return digits.join('');
    },
    peg$currPos = 0,
    peg$savedPos = 0,
    peg$posDetailsCache = [{ line: 1, column: 1 }],
    peg$maxFailPos = 0,
    peg$maxFailExpected = [],
    peg$silentFails = 0,
    peg$result;

  if ('startRule' in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error('Can\'t start parsing from rule "' + options.startRule + '".');
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location,
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: 'literal', text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: 'any' };
  }

  function peg$endExpectation() {
    return { type: 'end' };
  }

  function peg$otherExpectation(description) {
    return { type: 'other', description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
      p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location,
    );
  }

  function peg$parsestart() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parsestringWithoutColon();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s3 = peg$c0;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c1);
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsebracketIndexRef();
        if (s4 === peg$FAILED) {
          s4 = peg$parsebracketStringRef();
          if (s4 === peg$FAILED) {
            s4 = peg$parsecolonReference();
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsebracketIndexRef();
          if (s6 === peg$FAILED) {
            s6 = peg$parsebracketStringRef();
            if (s6 === peg$FAILED) {
              s6 = peg$parsedotReference();
            }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsebracketIndexRef();
            if (s6 === peg$FAILED) {
              s6 = peg$parsebracketStringRef();
              if (s6 === peg$FAILED) {
                s6 = peg$parsedotReference();
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebracketStringRef() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c3;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c4);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s3 = peg$c5;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c6);
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsestringWithoutDoubleQuotes();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s5 = peg$c5;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c7;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsestringWithoutSingleQuotes();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s5 = peg$c7;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parsestringWithoutSquareBrackets();
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 93) {
          s3 = peg$c9;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebracketIndexRef() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c3;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c4);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseinteger();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 93) {
          s3 = peg$c9;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c12(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolonReference() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsestringWithoutSquareBracketsOrDots();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c13(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsedotReference() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c14;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c15);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestringWithoutSquareBracketsOrDots();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c13(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestringWithoutSquareBrackets() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c16.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c17);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c16.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c18(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestringWithoutColon() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c19.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c20);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c19.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c18(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestringWithoutDoubleQuotes() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c21.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c22);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c21.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c18(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestringWithoutSingleQuotes() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c23.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c24);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c23.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c18(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestringWithoutSquareBracketsOrDots() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c25.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c26);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c25.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c18(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseinteger() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c27.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c28);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c27.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c29(s1);
    }
    s0 = s1;

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos),
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/parsers/relationExpressionParser.js":
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = 'SyntaxError';

  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return '"' + literalEscape(expectation.text) + '"';
    },

    class: function (expectation) {
      var escapedParts = '',
        i;

      for (i = 0; i < expectation.parts.length; i++) {
        escapedParts +=
          expectation.parts[i] instanceof Array
            ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])
            : classEscape(expectation.parts[i]);
      }

      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';
    },

    any: function (expectation) {
      return 'any character';
    },

    end: function (expectation) {
      return 'end of input';
    },

    other: function (expectation) {
      return expectation.description;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g, '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
      i,
      j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + ' or ' + descriptions[1];

      default:
        return (
          descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1]
        );
    }
  }

  function describeFound(found) {
    return found ? '"' + literalEscape(found) + '"' : 'end of input';
  }

  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},
    peg$startRuleFunctions = { start: peg$parsestart },
    peg$startRuleFunction = peg$parsestart,
    peg$c0 = function (expr) {
      const node = newNode();

      if (expr.$name === '*') {
        node.$allRecursive = true;
      } else {
        assertDuplicateRelation(node, expr);
        node[expr.$name] = expr;
        node.$childNames.push(expr.$name);
      }

      return node;
    },
    peg$c1 = function (list) {
      const node = newNode();

      list.forEach((expr) => {
        assertDuplicateRelation(node, expr);
        node[expr.$name] = expr;
        node.$childNames.push(expr.$name);
      });

      return node;
    },
    peg$c2 = function (name, args, alias, list) {
      const node = newNode();

      node.$name = alias || name;
      node.$relation = name;
      node.$modify = args || [];

      list.forEach((expr) => {
        assertDuplicateRelation(node, expr);
        node[expr.$name] = expr;
        node.$childNames.push(expr.$name);
      });

      return node;
    },
    peg$c3 = function (name, args, alias, expr) {
      const node = newNode();

      node.$name = alias || name;
      node.$relation = name;
      node.$modify = args || [];

      if (expr) {
        const match = /^\^(\d*)$/.exec(expr.$name);

        if (match) {
          if (match[1]) {
            node.$recursive = parseInt(match[1], 10);
          } else {
            node.$recursive = true;
          }
        } else if (expr.$name === '*') {
          node.$allRecursive = true;
        } else {
          assertDuplicateRelation(node, expr);
          node[expr.$name] = expr;
          node.$childNames.push(expr.$name);
        }
      }

      return node;
    },
    peg$c4 = 'as',
    peg$c5 = peg$literalExpectation('as', false),
    peg$c6 = function (alias) {
      return alias;
    },
    peg$c7 = function (name) {
      return name.join('');
    },
    peg$c8 = /^[^[\](),. \t\r\n]/,
    peg$c9 = peg$classExpectation(
      ['[', ']', '(', ')', ',', '.', ' ', '\t', '\r', '\n'],
      true,
      false,
    ),
    peg$c10 = '(',
    peg$c11 = peg$literalExpectation('(', false),
    peg$c12 = ')',
    peg$c13 = peg$literalExpectation(')', false),
    peg$c14 = function (args) {
      return args;
    },
    peg$c15 = ',',
    peg$c16 = peg$literalExpectation(',', false),
    peg$c17 = function (arg) {
      return arg;
    },
    peg$c18 = /^[ \t\r\n]/,
    peg$c19 = peg$classExpectation([' ', '\t', '\r', '\n'], false, false),
    peg$c20 = '.',
    peg$c21 = peg$literalExpectation('.', false),
    peg$c22 = function (list) {
      return list;
    },
    peg$c23 = '[',
    peg$c24 = peg$literalExpectation('[', false),
    peg$c25 = ']',
    peg$c26 = peg$literalExpectation(']', false),
    peg$c27 = function (items) {
      return items;
    },
    peg$c28 = function (expr) {
      return expr;
    },
    peg$c29 = function (sub) {
      return sub;
    },
    peg$currPos = 0,
    peg$savedPos = 0,
    peg$posDetailsCache = [{ line: 1, column: 1 }],
    peg$maxFailPos = 0,
    peg$maxFailExpected = [],
    peg$silentFails = 0,
    peg$result;

  if ('startRule' in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error('Can\'t start parsing from rule "' + options.startRule + '".');
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location,
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: 'literal', text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: 'any' };
  }

  function peg$endExpectation() {
    return { type: 'end' };
  }

  function peg$otherExpectation(description) {
    return { type: 'other', description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
      p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location,
    );
  }

  function peg$parsestart() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parselistExpression();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseexpression() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseargs();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsealias();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsesubListExpression();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s2, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsename();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseargs();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsealias();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsesubExpression();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsealias() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsews();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c4) {
        s2 = peg$c4;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c5);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsews();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsews();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsename();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsechar();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c7(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsechar() {
    var s0;

    if (peg$c8.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c9);
      }
    }

    return s0;
  }

  function peg$parseargs() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c10;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c11);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseargListItem();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseargListItem();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsews();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsews();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c12;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c13);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c14(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseargListItem() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsename();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsews();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsews();
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c15;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c16);
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c17(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsews() {
    var s0;

    if (peg$c18.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c19);
      }
    }

    return s0;
  }

  function peg$parsesubListExpression() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c20;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c21);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parselistExpression();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c22(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistExpression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c23;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c24);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parselistExpressionItem();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parselistExpressionItem();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsews();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsews();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s5 = peg$c25;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c26);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parsews();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsews();
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c27(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselistExpressionItem() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsews();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsews();
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c15;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c16);
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c28(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesubExpression() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c20;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c21);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsews();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsews();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseexpression();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsews();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsews();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function assertDuplicateRelation(node, expr) {
    if (expr.$name in node) {
      console.warn(
        `Duplicate relation "${expr.$name}" in a relation expression. You should use "a.[b, c]" instead of "[a.b, a.c]". This will cause an error in objection 2.0`,
      );

      // TODO: enable for v2.0.
      // const err = new Error();
      // err.duplicateRelationName = expr.$name;
      // throw err;
    }
  }

  function newNode() {
    return {
      $name: null,
      $relation: null,
      $modify: [],
      $recursive: false,
      $allRecursive: false,
      $childNames: [],
    };
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos),
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/transformations/CompositeQueryTransformation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryTransformation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/transformations/QueryTransformation.js");

class CompositeQueryTransformation extends QueryTransformation {
  constructor(transformations) {
    super();
    this.transformations = transformations;
  }

  onConvertQueryBuilderBase(item, builder) {
    for (const transformation of this.transformations) {
      item = transformation.onConvertQueryBuilderBase(item, builder);
    }

    return item;
  }
}

module.exports = {
  CompositeQueryTransformation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/transformations/QueryTransformation.js":
/***/ ((module) => {

"use strict";


class QueryTransformation {
  onConvertQueryBuilderBase(item, builder) {
    return item;
  }
}

module.exports = {
  QueryTransformation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/transformations/WrapMysqlModifySubqueryTransformation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { QueryTransformation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/transformations/QueryTransformation.js");
const { isMySql } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");

/**
 * Mysql doesn't allow queries like this:
 *
 *   update foo set bar = 1 where id in (select id from foo)
 *
 * because the subquery is for the same table `foo` as the parent update query.
 * The same goes for delete queries too.
 *
 * This transformation wraps those subqueries like this:
 *
 *   update foo set bar = 1 where id in (select * from (select id from foo))
 */
class WrapMysqlModifySubqueryTransformation extends QueryTransformation {
  onConvertQueryBuilderBase(query, parentQuery) {
    const knex = parentQuery.unsafeKnex();

    // Cannot detect anything if, for whatever reason, a knex instance
    // or a transaction is not registered at this point.
    if (!knex) {
      return query;
    }

    // This transformation only applies to MySQL.
    if (!isMySql(knex)) {
      return query;
    }

    // This transformation only applies to update and delete queries.
    if (!parentQuery.isUpdate() && !parentQuery.isDelete()) {
      return query;
    }

    // If the subquery is for another table and the query doesn't join the
    // parent query's table, we're good to go.
    if (
      parentQuery.tableName() !== query.tableName() &&
      !hasJoinsToTable(query, parentQuery.tableName())
    ) {
      return query;
    }

    return query.modelClass().query().from(query.as('mysql_subquery_fix'));
  }
}

function hasJoinsToTable(query, tableName) {
  let found = false;

  query.forEachOperation(query.constructor.JoinSelector, (op) => {
    if (op.args[0] === tableName) {
      found = true;
      return false;
    }
  });

  return found;
}

module.exports = {
  WrapMysqlModifySubqueryTransformation,
};


/***/ }),

/***/ "./node_modules/objection/lib/queryBuilder/transformations/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { CompositeQueryTransformation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/transformations/CompositeQueryTransformation.js");

const {
  WrapMysqlModifySubqueryTransformation,
} = __webpack_require__("./node_modules/objection/lib/queryBuilder/transformations/WrapMysqlModifySubqueryTransformation.js");

const transformation = new CompositeQueryTransformation([
  new WrapMysqlModifySubqueryTransformation(),
]);

module.exports = {
  transformation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/Relation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RelationProperty } = __webpack_require__("./node_modules/objection/lib/relations/RelationProperty.js");

const { RelationFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationFindOperation.js");
const { RelationUpdateOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationUpdateOperation.js");
const { RelationDeleteOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationDeleteOperation.js");

const { resolveModel } = __webpack_require__("./node_modules/objection/lib/utils/resolveModel.js");
const { get, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { mapAfterAllReturn } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { createModifier } = __webpack_require__("./node_modules/objection/lib/utils/createModifier.js");

class Relation {
  constructor(relationName, OwnerClass) {
    this.name = relationName;
    this.ownerModelClass = OwnerClass;
    this.relatedModelClass = null;

    this.ownerProp = null;
    this.relatedProp = null;

    this.joinTableModelClass = null;
    this.joinTableOwnerProp = null;
    this.joinTableRelatedProp = null;
    this.joinTableBeforeInsert = null;
    this.joinTableExtras = [];

    this.modify = null;
    this.beforeInsert = null;
  }

  setMapping(mapping) {
    let ctx = {
      name: this.name,
      mapping,
      ownerModelClass: this.ownerModelClass,
      relatedModelClass: null,
      relatedProp: null,
      ownerProp: null,
      modify: null,
      beforeInsert: null,
      forbiddenMappingProperties: this.forbiddenMappingProperties,
      createError: (msg) => this.createError(msg),
    };

    ctx = checkForbiddenProperties(ctx);
    ctx = checkOwnerModelClass(ctx);
    ctx = checkRelatedModelClass(ctx);
    ctx = resolveRelatedModelClass(ctx);
    ctx = checkRelation(ctx);
    ctx = createJoinProperties(ctx);
    ctx = parseModify(ctx);
    ctx = parseBeforeInsert(ctx);

    this.relatedModelClass = ctx.relatedModelClass;
    this.ownerProp = ctx.ownerProp;
    this.relatedProp = ctx.relatedProp;
    this.modify = ctx.modify;
    this.beforeInsert = ctx.beforeInsert;
  }

  get forbiddenMappingProperties() {
    return ['join.through'];
  }

  get joinTable() {
    return this.joinTableModelClass ? this.joinTableModelClass.getTableName() : null;
  }

  get joinModelClass() {
    return this.getJoinModelClass(this.ownerModelClass.knex());
  }

  getJoinModelClass(knex) {
    return this.joinTableModelClass && knex !== this.joinTableModelClass.knex()
      ? this.joinTableModelClass.bindKnex(knex)
      : this.joinTableModelClass;
  }

  isOneToOne() {
    return false;
  }

  clone() {
    const relation = new this.constructor(this.name, this.ownerModelClass);

    relation.relatedModelClass = this.relatedModelClass;
    relation.ownerProp = this.ownerProp;
    relation.relatedProp = this.relatedProp;
    relation.modify = this.modify;
    relation.beforeInsert = this.beforeInsert;

    relation.joinTableModelClass = this.joinTableModelClass;
    relation.joinTableOwnerProp = this.joinTableOwnerProp;
    relation.joinTableRelatedProp = this.joinTableRelatedProp;
    relation.joinTableBeforeInsert = this.joinTableBeforeInsert;
    relation.joinTableExtras = this.joinTableExtras;

    return relation;
  }

  bindKnex(knex) {
    const bound = this.clone();

    bound.relatedModelClass = this.relatedModelClass.bindKnex(knex);
    bound.ownerModelClass = this.ownerModelClass.bindKnex(knex);

    if (this.joinTableModelClass) {
      bound.joinTableModelClass = this.joinTableModelClass.bindKnex(knex);
    }

    return bound;
  }

  findQuery(builder, owner) {
    const relatedRefs = this.relatedProp.refs(builder);
    owner.buildFindQuery(builder, this, relatedRefs);

    return this.applyModify(builder);
  }

  applyModify(builder) {
    try {
      return builder.modify(this.modify);
    } catch (err) {
      if (err instanceof this.relatedModelClass.ModifierNotFoundError) {
        throw this.createError(err.message);
      } else {
        throw err;
      }
    }
  }

  join(
    builder,
    {
      joinOperation = 'join',
      relatedTableAlias = builder.tableRefFor(this.relatedModelClass),
      relatedJoinSelectQuery = this.relatedModelClass.query().childQueryOf(builder),
      relatedTable = builder.tableNameFor(this.relatedModelClass),
      ownerTable = builder.tableRefFor(this.ownerModelClass),
    } = {},
  ) {
    let relatedJoinSelect = this.applyModify(relatedJoinSelectQuery).as(relatedTableAlias);

    if (relatedJoinSelect.isSelectAll()) {
      // No need to join a subquery if the query is `select * from "RelatedTable"`.
      relatedJoinSelect = aliasedTableName(relatedTable, relatedTableAlias);
    }

    return builder[joinOperation](relatedJoinSelect, (join) => {
      const relatedProp = this.relatedProp;
      const ownerProp = this.ownerProp;

      relatedProp.forEach((i) => {
        const relatedRef = relatedProp.ref(builder, i).table(relatedTableAlias);
        const ownerRef = ownerProp.ref(builder, i).table(ownerTable);

        join.on(relatedRef, ownerRef);
      });
    });
  }

  find(_, owner) {
    return new RelationFindOperation('find', {
      relation: this,
      owner,
    });
  }

  insert(_, owner) {
    /* istanbul ignore next */
    throw this.createError('not implemented');
  }

  update(_, owner) {
    return new RelationUpdateOperation('update', {
      relation: this,
      owner,
    });
  }

  patch(_, owner) {
    return new RelationUpdateOperation('patch', {
      relation: this,
      owner,
      modelOptions: { patch: true },
    });
  }

  delete(_, owner) {
    return new RelationDeleteOperation('delete', {
      relation: this,
      owner,
    });
  }

  relate() {
    /* istanbul ignore next */
    throw this.createError('not implemented');
  }

  unrelate() {
    /* istanbul ignore next */
    throw this.createError('not implemented');
  }

  hasRelateProp(model) {
    return model.$hasProps(this.relatedProp.props);
  }

  setRelateProp(model, values) {
    this.relatedProp.forEach((i) => {
      this.relatedProp.setProp(model, i, values[i]);
    });
  }

  executeBeforeInsert(models, queryContext, result) {
    return mapAfterAllReturn(models, (model) => this.beforeInsert(model, queryContext), result);
  }

  createError(message) {
    if (this.ownerModelClass && this.ownerModelClass.name && this.name) {
      return new Error(`${this.ownerModelClass.name}.relationMappings.${this.name}: ${message}`);
    } else {
      return new Error(`${this.constructor.name}: ${message}`);
    }
  }
}

Object.defineProperties(Relation, {
  isObjectionRelationClass: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

Object.defineProperties(Relation.prototype, {
  isObjectionRelation: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

function checkForbiddenProperties(ctx) {
  ctx.forbiddenMappingProperties.forEach((prop) => {
    if (get(ctx.mapping, prop.split('.')) !== undefined) {
      throw ctx.createError(`Property ${prop} is not supported for this relation type.`);
    }
  });

  return ctx;
}

function checkOwnerModelClass(ctx) {
  if (!isFunction(ctx.ownerModelClass) || !ctx.ownerModelClass.isObjectionModelClass) {
    throw ctx.createError(`Relation's owner is not a subclass of Model`);
  }

  return ctx;
}

function checkRelatedModelClass(ctx) {
  if (!ctx.mapping.modelClass) {
    throw ctx.createError('modelClass is not defined');
  }

  return ctx;
}

function resolveRelatedModelClass(ctx) {
  let relatedModelClass;

  try {
    relatedModelClass = resolveModel(
      ctx.mapping.modelClass,
      ctx.ownerModelClass.modelPaths,
      'modelClass',
    );
  } catch (err) {
    throw ctx.createError(err.message);
  }

  return Object.assign(ctx, { relatedModelClass });
}

function checkRelation(ctx) {
  if (!ctx.mapping.relation) {
    throw ctx.createError('relation is not defined');
  }

  if (!isFunction(ctx.mapping.relation) || !ctx.mapping.relation.isObjectionRelationClass) {
    throw ctx.createError('relation is not a subclass of Relation');
  }

  return ctx;
}

function createJoinProperties(ctx) {
  const mapping = ctx.mapping;

  if (!mapping.join || !mapping.join.from || !mapping.join.to) {
    throw ctx.createError(
      'join must be an object that maps the columns of the related models together. For example: {from: "SomeTable.id", to: "SomeOtherTable.someModelId"}',
    );
  }

  const fromProp = createRelationProperty(ctx, mapping.join.from, 'join.from');
  const toProp = createRelationProperty(ctx, mapping.join.to, 'join.to');

  let ownerProp;
  let relatedProp;

  if (fromProp.modelClass.getTableName() === ctx.ownerModelClass.getTableName()) {
    ownerProp = fromProp;
    relatedProp = toProp;
  } else if (toProp.modelClass.getTableName() === ctx.ownerModelClass.getTableName()) {
    ownerProp = toProp;
    relatedProp = fromProp;
  } else {
    throw ctx.createError('join: either `from` or `to` must point to the owner model table.');
  }

  if (ownerProp.props.some((it) => it === ctx.name)) {
    throw ctx.createError(
      `join: relation name and join property '${ctx.name}' cannot have the same name. If you cannot change one or the other, you can use $parseDatabaseJson and $formatDatabaseJson methods to convert the column name.`,
    );
  }

  if (relatedProp.modelClass.getTableName() !== ctx.relatedModelClass.getTableName()) {
    throw ctx.createError('join: either `from` or `to` must point to the related model table.');
  }

  return Object.assign(ctx, { ownerProp, relatedProp });
}

function createRelationProperty(ctx, refString, propName) {
  try {
    return new RelationProperty(refString, (table) => {
      return [ctx.ownerModelClass, ctx.relatedModelClass].find((it) => it.getTableName() === table);
    });
  } catch (err) {
    if (err instanceof RelationProperty.ModelNotFoundError) {
      throw ctx.createError(
        `join: either \`from\` or \`to\` must point to the owner model table and the other one to the related table. It might be that specified table '${err.tableName}' is not correct`,
      );
    } else if (err instanceof RelationProperty.InvalidReferenceError) {
      throw ctx.createError(
        `${propName} must have format TableName.columnName. For example "SomeTable.id" or in case of composite key ["SomeTable.a", "SomeTable.b"].`,
      );
    } else {
      throw err;
    }
  }
}

function parseModify(ctx) {
  const mapping = ctx.mapping;
  const modifier = mapping.modify || mapping.filter;
  const modify =
    modifier &&
    createModifier({
      modifier,
      modelClass: ctx.relatedModelClass,
    });

  return Object.assign(ctx, { modify });
}

function parseBeforeInsert(ctx) {
  let beforeInsert;

  if (isFunction(ctx.mapping.beforeInsert)) {
    beforeInsert = ctx.mapping.beforeInsert;
  } else {
    beforeInsert = (model) => model;
  }

  return Object.assign(ctx, { beforeInsert });
}

function aliasedTableName(tableName, alias) {
  if (tableName === alias) {
    return tableName;
  } else {
    return `${tableName} as ${alias}`;
  }
}

module.exports = {
  Relation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/RelationDeleteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DeleteOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DeleteOperation.js");
const { RelationFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationFindOperation.js");

class RelationDeleteOperation extends DeleteOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
  }

  onBuild(builder) {
    super.onBuild(builder);
    this.relation.findQuery(builder, this.owner);
  }

  toFindOperation() {
    return new RelationFindOperation('find', {
      relation: this.relation,
      owner: this.owner,
    });
  }
}

module.exports = {
  RelationDeleteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/RelationFindOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { FindOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/FindOperation.js");

class RelationFindOperation extends FindOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
    this.alwaysReturnArray = false;
    this.assignResultToOwner = true;
    this.relationProperty = opt.relationProperty || this.relation.name;
    this.omitProps = [];
    this.alias = null;
  }

  onBuild(builder) {
    this.maybeApplyAlias(builder);
    this.relation.findQuery(builder, this.owner);

    if (this.assignResultToOwner && this.owner.isModels) {
      this.selectMissingJoinColumns(builder);
    }
  }

  onAfter2(_, related) {
    const isOneToOne = this.relation.isOneToOne();

    if (this.assignResultToOwner && this.owner.isModels) {
      const owners = this.owner.modelArray;
      const relatedByOwnerId = new Map();

      for (let i = 0, l = related.length; i < l; ++i) {
        const rel = related[i];
        const key = this.relation.relatedProp.propKey(rel);
        let arr = relatedByOwnerId.get(key);

        if (!arr) {
          arr = [];
          relatedByOwnerId.set(key, arr);
        }

        arr.push(rel);
      }

      for (let i = 0, l = owners.length; i < l; ++i) {
        const own = owners[i];
        const key = this.relation.ownerProp.propKey(own);
        const related = relatedByOwnerId.get(key);

        if (isOneToOne) {
          own[this.relationProperty] = (related && related[0]) || null;
        } else {
          own[this.relationProperty] = related || [];
        }
      }
    }

    return related;
  }

  onAfter3(builder, related) {
    const isOneToOne = this.relation.isOneToOne();
    const intOpt = builder.internalOptions();

    if (!intOpt.keepImplicitJoinProps) {
      this.omitImplicitJoinProps(related);
    }

    if (!this.alwaysReturnArray && isOneToOne && related.length <= 1) {
      related = related[0] || undefined;
    }

    return super.onAfter3(builder, related);
  }

  selectMissingJoinColumns(builder) {
    const relatedProp = this.relation.relatedProp;
    const addedSelects = [];

    for (let c = 0, lc = relatedProp.size; c < lc; ++c) {
      const fullCol = relatedProp.ref(builder, c).fullColumn(builder);
      const prop = relatedProp.props[c];
      const col = relatedProp.cols[c];

      if (!builder.hasSelectionAs(fullCol, col) && addedSelects.indexOf(fullCol) === -1) {
        this.omitProps.push(prop);
        addedSelects.push(fullCol);
      }
    }

    if (addedSelects.length) {
      builder.select(addedSelects);
    }
  }

  maybeApplyAlias(builder) {
    if (!builder.alias() && this.alias) {
      builder.alias(this.alias);
    }
  }

  omitImplicitJoinProps(related) {
    const relatedModelClass = this.relation.relatedModelClass;

    if (!this.omitProps.length || !related) {
      return related;
    }

    if (!Array.isArray(related)) {
      return this.omitImplicitJoinPropsFromOne(relatedModelClass, related);
    }

    if (!related.length) {
      return related;
    }

    for (let i = 0, l = related.length; i < l; ++i) {
      this.omitImplicitJoinPropsFromOne(relatedModelClass, related[i]);
    }

    return related;
  }

  omitImplicitJoinPropsFromOne(relatedModelClass, model) {
    for (let c = 0, lc = this.omitProps.length; c < lc; ++c) {
      relatedModelClass.omitImpl(model, this.omitProps[c]);
    }

    return model;
  }

  clone() {
    const clone = super.clone();

    clone.alwaysReturnArray = this.alwaysReturnArray;
    clone.assignResultToOwner = this.assignResultToOwner;
    clone.relationProperty = this.relationProperty;
    clone.omitProps = this.omitProps.slice();
    clone.alias = this.alias;

    return clone;
  }
}

module.exports = {
  RelationFindOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/RelationInsertOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InsertOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/InsertOperation.js");

class RelationInsertOperation extends InsertOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
    this.assignResultToOwner = true;
  }

  async onBefore2(builder, result) {
    const queryContext = builder.context();
    result = await this.relation.executeBeforeInsert(this.models, queryContext, result);
    return super.onBefore2(builder, result);
  }

  clone() {
    const clone = super.clone();

    clone.relation = this.relation;
    clone.owner = this.owner;
    clone.assignResultToOwner = this.assignResultToOwner;

    return clone;
  }
}

module.exports = {
  RelationInsertOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/RelationOwner.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, asArray, asSingle, uniqBy } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { normalizeIds } = __webpack_require__("./node_modules/objection/lib/utils/normalizeIds.js");

const Type = {
  Models: 'Models',
  Reference: 'Reference',
  QueryBuilder: 'QueryBuilder',
  Identifiers: 'Identifiers',
};

class RelationOwner {
  constructor(owner) {
    this.owner = owner;
    this.type = detectType(owner);
  }

  static create(owner) {
    return new RelationOwner(owner);
  }

  static createParentReference(builder, relation) {
    return this.create(relation.ownerProp.refs(findFirstNonPartialAncestorQuery(builder)));
  }

  get isModels() {
    return this.type === Type.Models;
  }

  get isReference() {
    return this.type === Type.Reference;
  }

  get isQueryBuilder() {
    return this.type === Type.QueryBuilder;
  }

  get isIdentifiers() {
    return this.type === Type.Identifiers;
  }

  get modelArray() {
    return asArray(this.owner);
  }

  get model() {
    return asSingle(this.owner);
  }

  get reference() {
    return this.owner;
  }

  get queryBuilder() {
    return this.owner;
  }

  get identifiers() {
    return this.owner;
  }

  buildFindQuery(builder, relation, relatedRefs) {
    if (this.isReference) {
      relatedRefs.forEach((relatedRef, i) => {
        builder.where(relatedRef, this.reference[i]);
      });
    } else if (this.isModels || this.isIdentifiers || this.isQueryBuilder) {
      const values = this.getProps(relation);

      if (values) {
        builder.whereInComposite(relatedRefs, values);
      } else {
        builder.where(false).resolve([]);
      }
    } else {
      builder.where(false).resolve([]);
    }

    return builder;
  }

  getProps(relation, ownerProp = relation.ownerProp) {
    if (this.isModels) {
      return this._getPropsFromModels(ownerProp);
    } else if (this.isIdentifiers) {
      return this._getPropsFromIdentifiers(relation, ownerProp);
    } else if (this.isQueryBuilder) {
      return this._getPropsFromQuery(relation, ownerProp);
    }
  }

  getSplitProps(builder, relation, ownerProp = relation.ownerProp) {
    const values = this.getProps(relation, relation.ownerProp);

    if (isQueryBuilder(values)) {
      if (ownerProp.size === 1) {
        return [[values]];
      } else {
        // For composite keys, we need to create a query builder for each
        // key. Each query builder only select that key.
        return [
          Array.from({ length: ownerProp.size }).map((_, i) => {
            return values.clone().clearSelect().select(ownerProp.ref(builder, i));
          }),
        ];
      }
    } else {
      return values;
    }
  }

  getNormalizedIdentifiers(ownerProp) {
    return normalizeIds(this.identifiers, ownerProp, {
      arrayOutput: true,
    });
  }

  _getPropsFromModels(ownerProp) {
    const props = this.modelArray.map((owner) => ownerProp.getProps(owner));

    if (!containsNonNull(props)) {
      return null;
    }

    return uniqBy(props, join);
  }

  _getPropsFromIdentifiers(relation, ownerProp) {
    const ids = this.getNormalizedIdentifiers(ownerProp);

    if (isIdProp(ownerProp)) {
      return ids;
    } else {
      const query = relation.ownerModelClass.query();

      query.findByIds(ids);
      query.select(ownerProp.refs(query));

      return query;
    }
  }

  _getPropsFromQuery(relation, ownerProp) {
    const query = this.queryBuilder.clone();

    if (isOwnerModelClassQuery(query, relation)) {
      query.clearSelect();
      query.select(ownerProp.refs(query));
    }

    return query;
  }
}

function detectType(owner) {
  if (isModel(owner) || isModelArray(owner)) {
    return Type.Models;
  } else if (isReferenceArray(owner)) {
    return Type.Reference;
  } else if (isQueryBuilder(owner)) {
    return Type.QueryBuilder;
  } else {
    return Type.Identifiers;
  }
}

function isModel(item) {
  return isObject(item) && !!item.$isObjectionModel;
}

function isModelArray(item) {
  return Array.isArray(item) && isModel(item[0]);
}

function isReference(item) {
  return isObject(item) && !!item.isObjectionReferenceBuilder;
}

function isReferenceArray(item) {
  return Array.isArray(item) && isReference(item[0]);
}

function isQueryBuilder(item) {
  return isObject(item) && !!item.isObjectionQueryBuilder;
}

function findFirstNonPartialAncestorQuery(builder) {
  builder = builder.parentQuery();
  if (!builder)
    throw Error(
      'query method `for` ommitted outside a subquery, can not figure out relation target',
    );
  while (builder.isPartial()) {
    if (!builder.parentQuery()) {
      break;
    }

    builder = builder.parentQuery();
  }

  return builder;
}

function containsNonNull(arr) {
  for (let i = 0, l = arr.length; i < l; ++i) {
    const val = arr[i];

    if (Array.isArray(val)) {
      if (containsNonNull(val)) {
        return true;
      }
    } else if (val !== null && val !== undefined) {
      return true;
    }
  }

  return false;
}

function join(id) {
  return id.map((x) => (Buffer.isBuffer(x) ? x.toString('hex') : x)).join(',');
}

function isIdProp(relationProp) {
  const idProp = relationProp.modelClass.getIdRelationProperty();
  return idProp.props.every((prop, i) => prop === relationProp.props[i]);
}

function isOwnerModelClassQuery(query, relation) {
  return query.modelClass().getTableName() === relation.ownerModelClass.getTableName();
}

module.exports = {
  RelationOwner,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/RelationProperty.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray, isObject, uniqBy, get, set } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { ref: createRef } = __webpack_require__("./node_modules/objection/lib/queryBuilder/ReferenceBuilder.js");
const { propToStr, PROP_KEY_PREFIX } = __webpack_require__("./node_modules/objection/lib/model/modelValues.js");

class ModelNotFoundError extends Error {
  constructor(tableName) {
    super();
    this.name = this.constructor.name;
    this.tableName = tableName;
  }
}

class InvalidReferenceError extends Error {
  constructor() {
    super();
    this.name = this.constructor.name;
  }
}

// A pair of these define how two tables are related to each other.
// Both the owner and the related table have one of these.
//
// A relation property can be a single column, an array of columns
// (composite key) a json column reference, an array of json column
// references or any combination of the above.
class RelationProperty {
  // references must be a reference string like `Table.column:maybe.some.json[1].path`.
  // or an array of such references (composite key).
  //
  // modelClassResolver must be a function that takes a table name
  // and returns a model class.
  constructor(references, modelClassResolver) {
    const refs = createRefs(asArray(references));
    const paths = createPaths(refs, modelClassResolver);
    const modelClass = resolveModelClass(paths);

    this._refs = refs.map((ref) => ref.model(modelClass));
    this._modelClass = modelClass;
    this._props = paths.map((it) => it.path[0]);
    this._cols = refs.map((it) => it.column);
    this._propGetters = paths.map((it) => createGetter(it.path));
    this._propSetters = paths.map((it) => createSetter(it.path));
    this._patchers = refs.map((it, i) => createPatcher(it, paths[i].path));
  }

  static get ModelNotFoundError() {
    return ModelNotFoundError;
  }

  static get InvalidReferenceError() {
    return InvalidReferenceError;
  }

  // The number of columns.
  get size() {
    return this._refs.length;
  }

  // The model class that owns the property.
  get modelClass() {
    return this._modelClass;
  }

  // An array of property names. Contains multiple values in case of composite key.
  // This may be different from `cols` if the model class has some kind of conversion
  // between database and "external" formats, for example a snake_case to camelCase
  // conversion.
  get props() {
    return this._props;
  }

  // An array of column names. Contains multiple values in case of composite key.
  // This may be different from `props` if the model class has some kind of conversion
  // between database and "external" formats, for example a snake_case to camelCase
  // conversion.
  get cols() {
    return this._cols;
  }

  forEach(callback) {
    for (let i = 0, l = this.size; i < l; ++i) {
      callback(i);
    }
  }

  // Creates a concatenated string from the property values of the given object.
  propKey(obj) {
    const size = this.size;
    let key = PROP_KEY_PREFIX;

    for (let i = 0; i < size; ++i) {
      key += propToStr(this.getProp(obj, i));

      if (i !== size - 1) {
        key += ',';
      }
    }

    return key;
  }

  // Returns the property values of the given object as an array.
  getProps(obj) {
    const size = this.size;
    const props = new Array(size);

    for (let i = 0; i < size; ++i) {
      props[i] = this.getProp(obj, i);
    }

    return props;
  }

  // Returns true if the given object has a non-null value in all properties.
  hasProps(obj) {
    const size = this.size;

    for (let i = 0; i < size; ++i) {
      const prop = this.getProp(obj, i);

      if (prop === null || prop === undefined) {
        return false;
      }
    }

    return true;
  }

  // Returns the index:th property value of the given object.
  getProp(obj, index) {
    return this._propGetters[index](obj);
  }

  // Sets the index:th property value of the given object.
  setProp(obj, index, value) {
    return this._propSetters[index](obj, value);
  }

  // Returns an instance of ReferenceBuilder that points to the index:th
  // value of a row.
  ref(builder, index) {
    const table = builder.tableRefFor(this.modelClass);

    return this._refs[index].clone().table(table);
  }

  // Returns an array of reference builders. `ref(builder, i)` for each i.
  refs(builder) {
    const refs = new Array(this.size);

    for (let i = 0, l = refs.length; i < l; ++i) {
      refs[i] = this.ref(builder, i);
    }

    return refs;
  }

  // Appends an update operation for the index:th column into `patch` object.
  patch(patch, index, value) {
    return this._patchers[index](patch, value);
  }

  // String representation of this property's index:th column for logging.
  propDescription(index) {
    return this._refs[index].expression;
  }
}

function createRefs(refs) {
  try {
    return refs.map((it) => {
      if (!isObject(it) || !it.isObjectionReferenceBuilder) {
        return createRef(it);
      } else {
        return it;
      }
    });
  } catch (err) {
    throw new InvalidReferenceError();
  }
}

function createPaths(refs, modelClassResolver) {
  return refs.map((ref) => {
    if (!ref.tableName) {
      throw new InvalidReferenceError();
    }

    const modelClass = modelClassResolver(ref.tableName);

    if (!modelClass) {
      throw new ModelNotFoundError(ref.tableName);
    }

    const prop = modelClass.columnNameToPropertyName(ref.column);
    const jsonPath = ref.parsedExpr.access.map((it) => it.ref);

    return {
      path: [prop].concat(jsonPath),
      modelClass,
    };
  });
}

function resolveModelClass(paths) {
  const modelClasses = paths.map((it) => it.modelClass);
  const uniqueModelClasses = uniqBy(modelClasses);

  if (uniqueModelClasses.length !== 1) {
    throw new InvalidReferenceError();
  }

  return modelClasses[0];
}

function createGetter(path) {
  if (path.length === 1) {
    const prop = path[0];
    return (obj) => obj[prop];
  } else {
    return (obj) => get(obj, path);
  }
}

function createSetter(path) {
  if (path.length === 1) {
    const prop = path[0];
    return (obj, value) => (obj[prop] = value);
  } else {
    return (obj, value) => set(obj, path, value);
  }
}

function createPatcher(ref, path) {
  if (ref.isPlainColumnRef) {
    return (patch, value) => (patch[path[0]] = value);
  } else {
    // Objection `patch`, `update` etc. methods understand field expressions.
    return (patch, value) => (patch[ref.expression] = value);
  }
}

module.exports = {
  RelationProperty,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/RelationUpdateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UpdateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js");
const { RelationFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationFindOperation.js");

class RelationUpdateOperation extends UpdateOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
  }

  onBuild(builder) {
    super.onBuild(builder);

    this.relation.findQuery(builder, this.owner);
  }

  toFindOperation() {
    return new RelationFindOperation('find', {
      relation: this.relation,
      owner: this.owner,
    });
  }
}

module.exports = {
  RelationUpdateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/belongsToOne/BelongsToOneDeleteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RelationDeleteOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationDeleteOperation.js");

class BelongsToOneDeleteOperation extends RelationDeleteOperation {
  onAfter1(_, result) {
    if (this.owner.isModels) {
      const ownerProp = this.relation.ownerProp;

      for (const owner of this.owner.modelArray) {
        ownerProp.forEach((i) => {
          ownerProp.setProp(owner, i, null);
        });
      }
    }

    return result;
  }
}

module.exports = {
  BelongsToOneDeleteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/belongsToOne/BelongsToOneInsertOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RelationInsertOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationInsertOperation.js");
const { BelongsToOneRelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelateOperation.js");

class BelongsToOneInsertOperation extends RelationInsertOperation {
  onAdd(builder, args) {
    const retVal = super.onAdd(builder, args);

    if (this.models.length > 1) {
      throw this.relation.createError('can only insert one model to a BelongsToOneRelation');
    }

    return retVal;
  }

  async onAfter1(builder, ret) {
    const inserted = await super.onAfter1(builder, ret);

    if (!builder.isExecutable()) {
      return inserted;
    }

    const relateOp = new BelongsToOneRelateOperation('relate', {
      relation: this.relation,
      owner: this.owner,
    });

    if (this.assignResultToOwner && this.owner.isModels) {
      for (const owner of this.owner.modelArray) {
        owner.$setRelated(this.relation, inserted);
      }
    }

    relateOp.onAdd(builder, [inserted]);
    await relateOp.queryExecutor(builder);

    return inserted;
  }
}

module.exports = {
  BelongsToOneInsertOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { normalizeIds } = __webpack_require__("./node_modules/objection/lib/utils/normalizeIds.js");
const { RelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RelateOperation.js");

class BelongsToOneRelateOperation extends RelateOperation {
  onAdd(_, args) {
    this.input = args[0];
    this.ids = normalizeIds(args[0], this.relation.relatedProp, { arrayOutput: true });

    assertOneId(this.ids);
    return true;
  }

  queryExecutor(builder) {
    const patch = {};
    const ownerProp = this.relation.ownerProp;

    ownerProp.forEach((i) => {
      const relatedValue = this.ids[0][i];

      if (this.owner.isModels) {
        for (const owner of this.owner.modelArray) {
          ownerProp.setProp(owner, i, relatedValue);
        }
      }

      ownerProp.patch(patch, i, relatedValue);
    });

    const ownerIdProp = this.relation.ownerModelClass.getIdRelationProperty();
    const ownerIds = this.owner.getProps(this.relation, ownerIdProp);

    return this.relation.ownerModelClass
      .query()
      .childQueryOf(builder)
      .patch(patch)
      .whereInComposite(ownerIdProp.refs(builder), ownerIds);
  }
}

function assertOneId(ids) {
  if (ids.length > 1) {
    throw new Error('can only relate one model to a BelongsToOneRelation');
  }
}

module.exports = {
  BelongsToOneRelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Relation } = __webpack_require__("./node_modules/objection/lib/relations/Relation.js");
const { BelongsToOneInsertOperation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneInsertOperation.js");
const { BelongsToOneDeleteOperation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneDeleteOperation.js");
const { BelongsToOneRelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelateOperation.js");
const { BelongsToOneUnrelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/belongsToOne/BelongsToOneUnrelateOperation.js");

class BelongsToOneRelation extends Relation {
  isOneToOne() {
    return true;
  }

  insert(_, owner) {
    return new BelongsToOneInsertOperation('insert', {
      relation: this,
      owner,
    });
  }

  delete(_, owner) {
    return new BelongsToOneDeleteOperation('delete', {
      relation: this,
      owner,
    });
  }

  relate(_, owner) {
    return new BelongsToOneRelateOperation('relate', {
      relation: this,
      owner,
    });
  }

  unrelate(_, owner) {
    return new BelongsToOneUnrelateOperation('unrelate', {
      relation: this,
      owner,
    });
  }
}

Object.defineProperties(BelongsToOneRelation.prototype, {
  isObjectionBelongsToOneRelation: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

module.exports = {
  BelongsToOneRelation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/belongsToOne/BelongsToOneUnrelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UnrelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UnrelateOperation.js");

class BelongsToOneUnrelateOperation extends UnrelateOperation {
  onAdd() {
    const ids = new Array(this.relation.ownerProp.size);

    this.relation.ownerProp.forEach((i) => {
      ids[i] = null;
    });

    this.ids = [ids];
    return true;
  }

  queryExecutor(builder) {
    const patch = {};
    const ownerProp = this.relation.ownerProp;

    ownerProp.forEach((i) => {
      const relatedValue = this.ids[0][i];

      if (this.owner.isModels) {
        for (const owner of this.owner.modelArray) {
          ownerProp.setProp(owner, i, relatedValue);
        }
      }

      ownerProp.patch(patch, i, relatedValue);
    });

    const ownerIdProp = this.relation.ownerModelClass.getIdRelationProperty();
    const ownerRefs = ownerIdProp.refs(builder);
    const ownerIds = this.owner.getProps(this.relation, ownerIdProp);

    const query = this.relation.ownerModelClass
      .query()
      .childQueryOf(builder)
      .patch(patch)
      .whereInComposite(ownerRefs, ownerIds);

    // We are creating a query to the related items. So any `where` statements
    // must filter the *related* items, not the root query above, which is actually
    // for the owners.
    if (builder.has(builder.constructor.WhereSelector)) {
      query.whereExists(
        this.relation.ownerModelClass
          .relatedQuery(this.relation.name)
          .copyFrom(builder, builder.constructor.JoinSelector)
          .copyFrom(builder, builder.constructor.WhereSelector),
      );
    }

    return query;
  }
}

module.exports = {
  BelongsToOneUnrelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/hasMany/HasManyInsertOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RelationInsertOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationInsertOperation.js");

class HasManyInsertOperation extends RelationInsertOperation {
  onAdd(builder, args) {
    const retVal = super.onAdd(builder, args);
    assertOwnerIsSingleItem(this.owner, this.relation);

    const ownerValues = this.owner.getSplitProps(builder, this.relation);
    const relatedProp = this.relation.relatedProp;

    for (const model of this.models) {
      for (let j = 0, lp = relatedProp.size; j < lp; ++j) {
        relatedProp.setProp(model, j, ownerValues[0][j]);
      }
    }

    return retVal;
  }

  async onAfter1(builder, ret) {
    const inserted = await super.onAfter1(builder, ret);

    if (!this.assignResultToOwner) {
      return inserted;
    }

    if (this.owner.isModels) {
      for (const owner of this.owner.modelArray) {
        owner.$appendRelated(this.relation, inserted);
      }
    }

    return inserted;
  }
}

function assertOwnerIsSingleItem(owner, relation) {
  const { isModels, isIdentifiers, isQueryBuilder } = owner;
  const { ownerProp } = relation;

  const singleModel = isModels && owner.modelArray.length === 1;
  const singleId = isIdentifiers && owner.getNormalizedIdentifiers(ownerProp).length === 1;

  if (!singleModel && !singleId && !isQueryBuilder) {
    throw new Error(
      [
        'Can only insert items for one parent at a time in case of HasManyRelation.',
        'Otherwise multiple insert queries would need to be created.',

        'If you need to insert items for multiple parents, simply loop through them.',
        `That's the most performant way.`,
      ].join(' '),
    );
  }
}

module.exports = {
  HasManyInsertOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/hasMany/HasManyRelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { normalizeIds } = __webpack_require__("./node_modules/objection/lib/utils/normalizeIds.js");
const { RelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RelateOperation.js");

class HasManyRelateOperation extends RelateOperation {
  onAdd(_, args) {
    this.input = args[0];

    this.ids = normalizeIds(args[0], this.relation.relatedModelClass.getIdRelationProperty(), {
      arrayOutput: true,
    });

    assertOwnerIsSingleItem(this.owner, this.relation);
    return true;
  }

  queryExecutor(builder) {
    const patch = {};
    const relatedProp = this.relation.relatedProp;
    const ownerValues = this.owner.getSplitProps(builder, this.relation);

    relatedProp.forEach((i) => {
      relatedProp.patch(patch, i, ownerValues[0][i]);
    });

    return this.relation.relatedModelClass
      .query()
      .childQueryOf(builder)
      .patch(patch)
      .copyFrom(builder, builder.constructor.JoinSelector)
      .copyFrom(builder, builder.constructor.WhereSelector)
      .findByIds(this.ids)
      .modify(this.relation.modify);
  }
}

function assertOwnerIsSingleItem(owner, relation) {
  const { isModels, isIdentifiers, isQueryBuilder } = owner;
  const { ownerProp } = relation;

  const singleModel = isModels && owner.modelArray.length === 1;
  const singleId = isIdentifiers && owner.getNormalizedIdentifiers(ownerProp).length === 1;

  if (!singleModel && !singleId && !isQueryBuilder) {
    throw new Error(
      [
        'Can only relate items for one parent at a time in case of HasManyRelation.',
        'Otherwise multiple update queries would need to be created.',

        'If you need to relate items for multiple parents, simply loop through them.',
        `That's the most performant way.`,
      ].join(' '),
    );
  }
}

module.exports = {
  HasManyRelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/hasMany/HasManyRelation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Relation } = __webpack_require__("./node_modules/objection/lib/relations/Relation.js");
const { HasManyInsertOperation } = __webpack_require__("./node_modules/objection/lib/relations/hasMany/HasManyInsertOperation.js");
const { HasManyRelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/hasMany/HasManyRelateOperation.js");
const { HasManyUnrelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/hasMany/HasManyUnrelateOperation.js");

class HasManyRelation extends Relation {
  insert(_, owner) {
    return new HasManyInsertOperation('insert', {
      relation: this,
      owner: owner,
    });
  }

  relate(_, owner) {
    return new HasManyRelateOperation('relate', {
      relation: this,
      owner: owner,
    });
  }

  unrelate(_, owner) {
    return new HasManyUnrelateOperation('unrelate', {
      relation: this,
      owner: owner,
    });
  }

  hasRelateProp(model) {
    return model.$hasId();
  }

  setRelateProp(model, values) {
    model.$id(values);
  }
}

Object.defineProperties(HasManyRelation.prototype, {
  isObjectionHasManyRelation: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

module.exports = {
  HasManyRelation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/hasMany/HasManyUnrelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UnrelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UnrelateOperation.js");

class HasManyUnrelateOperation extends UnrelateOperation {
  queryExecutor(builder) {
    const patch = {};
    const relatedProp = this.relation.relatedProp;
    const ownerValues = this.owner.getProps(this.relation);
    const relatedRefs = relatedProp.refs(builder);

    relatedProp.forEach((i) => {
      relatedProp.patch(patch, i, null);
    });

    return this.relation.relatedModelClass
      .query()
      .childQueryOf(builder)
      .patch(patch)
      .copyFrom(builder, builder.constructor.JoinSelector)
      .copyFrom(builder, builder.constructor.WhereSelector)
      .whereInComposite(relatedRefs, ownerValues)
      .modify(this.relation.modify);
  }
}

module.exports = {
  HasManyUnrelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/hasOne/HasOneRelation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { HasManyRelation } = __webpack_require__("./node_modules/objection/lib/relations/hasMany/HasManyRelation.js");

class HasOneRelation extends HasManyRelation {
  isOneToOne() {
    return true;
  }
}

module.exports = {
  HasOneRelation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/hasOneThrough/HasOneThroughRelation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyRelation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyRelation.js");

class HasOneThroughRelation extends ManyToManyRelation {
  isOneToOne() {
    return true;
  }
}

module.exports = {
  HasOneThroughRelation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/ManyToManyModifyMixin.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/find/ManyToManyFindOperation.js");

// This mixin contains the shared code for all modify operations (update, delete, relate, unrelate)
// for ManyToManyRelation operations.
//
// The most important thing this mixin does is that it moves the filters from the main query
// into a subquery and then adds a single where clause that uses the subquery. This is done so
// that we are able to `innerJoin` the join table to the query. Most SQL engines don't allow
// joins in updates or deletes. Join table is joined so that queries can reference the join
// table columns.
const ManyToManyModifyMixin = (Operation) => {
  return class extends Operation {
    constructor(...args) {
      super(...args);
      this.modifyFilterSubquery = null;
    }

    get modifyMainQuery() {
      return true;
    }

    // At this point `builder` should only have the user's own wheres and joins. There can
    // be other operations (like orderBy) too, but those are meaningless with modify operations.
    onBuild(builder) {
      this.modifyFilterSubquery = this.createModifyFilterSubquery(builder);

      if (this.modifyMainQuery) {
        // We can now remove the where and join statements from the main query.
        this.removeFiltersFromMainQuery(builder);

        // Add a single where clause that uses the created subquery.
        this.applyModifyFilterForRelatedTable(builder);
      }

      return super.onBuild(builder);
    }

    createModifyFilterSubquery(builder) {
      const relatedModelClass = this.relation.relatedModelClass;
      const builderClass = builder.constructor;

      // Create an empty subquery.
      const modifyFilterSubquery = relatedModelClass.query().childQueryOf(builder);

      // Add the necessary joins and wheres so that only rows related to
      // `this.owner` are selected.
      this.relation.findQuery(modifyFilterSubquery, this.owner);

      // Copy all where and join statements from the main query to the subquery.
      modifyFilterSubquery
        .copyFrom(builder, builderClass.WhereSelector)
        .copyFrom(builder, builderClass.JoinSelector);

      return modifyFilterSubquery.clearSelect();
    }

    removeFiltersFromMainQuery(builder) {
      const builderClass = builder.constructor;

      builder.clear(builderClass.WhereSelector);
      builder.clear(builderClass.JoinSelector);
    }

    applyModifyFilterForRelatedTable(builder) {
      const idRefs = this.relation.relatedModelClass.getIdRelationProperty().refs(builder);
      const subquery = this.modifyFilterSubquery.clone().select(idRefs);

      return builder.whereInComposite(idRefs, subquery);
    }

    applyModifyFilterForJoinTable(builder) {
      const joinTableOwnerRefs = this.relation.joinTableOwnerProp.refs(builder);
      const joinTableRelatedRefs = this.relation.joinTableRelatedProp.refs(builder);

      const relatedRefs = this.relation.relatedProp.refs(builder);
      const ownerValues = this.owner.getProps(this.relation);

      const subquery = this.modifyFilterSubquery.clone().select(relatedRefs);

      return builder
        .whereInComposite(joinTableRelatedRefs, subquery)
        .whereInComposite(joinTableOwnerRefs, ownerValues);
    }

    toFindOperation() {
      return new ManyToManyFindOperation('find', {
        relation: this.relation,
        owner: this.owner,
      });
    }

    clone() {
      const clone = super.clone();
      clone.modifyFilterSubquery = this.modifyFilterSubquery;
      return clone;
    }
  };
};

module.exports = {
  ManyToManyModifyMixin,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/ManyToManyRelation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { getModel } = __webpack_require__("./node_modules/objection/lib/model/getModel.js");
const { Relation } = __webpack_require__("./node_modules/objection/lib/relations/Relation.js");
const { RelationProperty } = __webpack_require__("./node_modules/objection/lib/relations/RelationProperty.js");

const { isSqlite } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { inheritModel } = __webpack_require__("./node_modules/objection/lib/model/inheritModel.js");
const { resolveModel } = __webpack_require__("./node_modules/objection/lib/utils/resolveModel.js");
const { mapAfterAllReturn } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { isFunction, isObject, isString } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");
const { createModifier } = __webpack_require__("./node_modules/objection/lib/utils/createModifier.js");

const { ManyToManyFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/find/ManyToManyFindOperation.js");
const { ManyToManyInsertOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/insert/ManyToManyInsertOperation.js");
const { ManyToManyRelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/relate/ManyToManyRelateOperation.js");

const { ManyToManyUnrelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperation.js");
const {
  ManyToManyUnrelateSqliteOperation,
} = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateSqliteOperation.js");

const { ManyToManyUpdateOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperation.js");
const { ManyToManyUpdateSqliteOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateSqliteOperation.js");

const { ManyToManyDeleteOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperation.js");
const { ManyToManyDeleteSqliteOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteSqliteOperation.js");

class ManyToManyRelation extends Relation {
  setMapping(mapping) {
    const retVal = super.setMapping(mapping);

    let ctx = {
      mapping,
      ownerModelClass: this.ownerModelClass,
      relatedModelClass: this.relatedModelClass,
      ownerProp: this.ownerProp,
      relatedProp: this.relatedProp,

      joinTableModelClass: null,
      joinTableOwnerProp: null,
      joinTableRelatedProp: null,
      joinTableBeforeInsert: null,
      joinTableExtras: [],

      createError: (msg) => this.createError(msg),
    };

    ctx = checkThroughObject(ctx);
    ctx = resolveJoinModelClassIfDefined(ctx);
    ctx = createJoinProperties(ctx);
    ctx = parseExtras(ctx);
    ctx = parseModify(ctx);
    ctx = parseBeforeInsert(ctx);
    ctx = finalizeJoinModelClass(ctx);

    this.joinTableExtras = ctx.joinTableExtras;
    this.joinTableModify = ctx.joinTableModify;
    this.joinTableModelClass = ctx.joinTableModelClass;
    this.joinTableOwnerProp = ctx.joinTableOwnerProp;
    this.joinTableRelatedProp = ctx.joinTableRelatedProp;
    this.joinTableBeforeInsert = ctx.joinTableBeforeInsert;

    return retVal;
  }

  get forbiddenMappingProperties() {
    return [];
  }

  findQuery(builder, owner) {
    const joinTableOwnerRefs = this.joinTableOwnerProp.refs(builder);
    const joinTable = builder.tableNameFor(this.joinTable);
    const joinTableAlias = builder.tableRefFor(this.joinTable);

    let joinTableSelect = this.joinTableModelClass
      .query()
      .childQueryOf(builder)
      .modify(this.joinTableModify)
      .as(joinTableAlias);
    if (joinTableSelect.isSelectAll()) {
      joinTableSelect = aliasedTableName(joinTable, joinTableAlias);
    }

    builder.join(joinTableSelect, (join) => {
      this.relatedProp.forEach((i) => {
        const relatedRef = this.relatedProp.ref(builder, i);
        const joinTableRelatedRef = this.joinTableRelatedProp.ref(builder, i);

        join.on(relatedRef, joinTableRelatedRef);
      });
    });

    owner.buildFindQuery(builder, this, joinTableOwnerRefs);
    return this.applyModify(builder);
  }

  join(
    builder,
    {
      joinOperation = defaultJoinOperation(this, builder),
      relatedTableAlias = defaultRelatedTableAlias(this, builder),
      relatedJoinSelectQuery = defaultRelatedJoinSelectQuery(this, builder),
      relatedTable = defaultRelatedTable(this, builder),
      ownerTable = defaultOwnerTable(this, builder),
      joinTableAlias = defaultJoinTableAlias(this, relatedTableAlias, builder),
    } = {},
  ) {
    let relatedJoinSelect = this.applyModify(relatedJoinSelectQuery).as(relatedTableAlias);

    if (relatedJoinSelect.isSelectAll()) {
      // No need to join a subquery if the query is `select * from "RelatedTable"`.
      relatedJoinSelect = aliasedTableName(relatedTable, relatedTableAlias);
    }

    let joinTableSelect = this.joinTableModelClass
      .query()
      .childQueryOf(builder)
      .modify(this.joinTableModify)
      .as(joinTableAlias);
    if (joinTableSelect.isSelectAll()) {
      joinTableSelect = aliasedTableName(this.joinTable, joinTableAlias);
    }

    return builder[joinOperation](joinTableSelect, (join) => {
      const ownerProp = this.ownerProp;
      const joinTableOwnerProp = this.joinTableOwnerProp;

      ownerProp.forEach((i) => {
        const joinTableOwnerRef = joinTableOwnerProp.ref(builder, i).table(joinTableAlias);
        const ownerRef = ownerProp.ref(builder, i).table(ownerTable);

        join.on(joinTableOwnerRef, ownerRef);
      });
    })[joinOperation](relatedJoinSelect, (join) => {
      const relatedProp = this.relatedProp;
      const joinTableRelatedProp = this.joinTableRelatedProp;

      relatedProp.forEach((i) => {
        const joinTableRelatedRef = joinTableRelatedProp.ref(builder, i).table(joinTableAlias);
        const relatedRef = relatedProp.ref(builder, i).table(relatedTableAlias);

        join.on(joinTableRelatedRef, relatedRef);
      });
    });
  }

  find(_, owner) {
    return new ManyToManyFindOperation('find', {
      relation: this,
      owner,
    });
  }

  insert(_, owner) {
    return new ManyToManyInsertOperation('insert', {
      relation: this,
      owner,
    });
  }

  update(builder, owner) {
    if (isSqlite(builder.knex())) {
      return new ManyToManyUpdateSqliteOperation('update', {
        relation: this,
        owner,
      });
    } else {
      return new ManyToManyUpdateOperation('update', {
        relation: this,
        owner,
      });
    }
  }

  patch(builder, owner) {
    if (isSqlite(builder.knex())) {
      return new ManyToManyUpdateSqliteOperation('patch', {
        modelOptions: { patch: true },
        relation: this,
        owner,
      });
    } else {
      return new ManyToManyUpdateOperation('patch', {
        modelOptions: { patch: true },
        relation: this,
        owner,
      });
    }
  }

  delete(builder, owner) {
    if (isSqlite(builder.knex())) {
      return new ManyToManyDeleteSqliteOperation('delete', {
        relation: this,
        owner,
      });
    } else {
      return new ManyToManyDeleteOperation('delete', {
        relation: this,
        owner,
      });
    }
  }

  relate(builder, owner) {
    return new ManyToManyRelateOperation('relate', {
      relation: this,
      owner,
    });
  }

  unrelate(builder, owner) {
    if (isSqlite(builder.knex())) {
      return new ManyToManyUnrelateSqliteOperation('unrelate', {
        relation: this,
        owner,
      });
    } else {
      return new ManyToManyUnrelateOperation('unrelate', {
        relation: this,
        owner,
      });
    }
  }

  createJoinModels(ownerId, related) {
    return related.map((related) => this.createJoinModel(ownerId, related));
  }

  createJoinModel(ownerId, rel) {
    let joinModel = {};

    for (let j = 0, lp = this.joinTableOwnerProp.size; j < lp; ++j) {
      this.joinTableOwnerProp.setProp(joinModel, j, ownerId[j]);
    }

    for (let j = 0, lp = this.joinTableRelatedProp.size; j < lp; ++j) {
      const value = this.relatedProp.getProp(rel, j);

      if (value !== undefined) {
        this.joinTableRelatedProp.setProp(joinModel, j, value);
      }
    }

    for (const extra of this.joinTableExtras) {
      let extraValue = rel[extra.aliasProp];

      if (extraValue === undefined && rel.$$queryProps) {
        extraValue = rel.$$queryProps[extra.aliasProp];
      }

      if (extraValue !== undefined) {
        joinModel[extra.joinTableProp] = extraValue;
      }
    }

    return joinModel;
  }

  omitExtraProps(models) {
    if (this.joinTableExtras && this.joinTableExtras.length) {
      const props = this.joinTableExtras.map((extra) => extra.aliasProp);

      for (const model of models) {
        // Omit extra properties instead of deleting them from the models so that they can
        // be used in the `$before` and `$after` hooks.
        model.$omitFromDatabaseJson(props);
      }
    }
  }

  executeJoinTableBeforeInsert(models, queryContext, result) {
    return mapAfterAllReturn(
      models,
      (model) => this.joinTableBeforeInsert(model, queryContext),
      result,
    );
  }
}

Object.defineProperties(ManyToManyRelation.prototype, {
  isObjectionManyToManyRelation: {
    enumerable: false,
    writable: false,
    value: true,
  },
});

function defaultJoinOperation() {
  return 'join';
}

function defaultRelatedTableAlias(relation, builder) {
  return builder.tableRefFor(relation.relatedModelClass);
}

function defaultRelatedJoinSelectQuery(relation, builder) {
  return relation.relatedModelClass.query().childQueryOf(builder);
}

function defaultRelatedTable(relation, builder) {
  return builder.tableNameFor(relation.relatedModelClass);
}

function defaultOwnerTable(relation, builder) {
  return builder.tableRefFor(relation.ownerModelClass);
}

function defaultJoinTableAlias(relation, relatedTableAlias, builder) {
  const alias = builder.tableRefFor(relation.joinTable);

  if (alias === relation.joinTable) {
    return relation.ownerModelClass.joinTableAlias(relatedTableAlias);
  } else {
    return alias;
  }
}

function aliasedTableName(tableName, alias) {
  if (tableName === alias) {
    return tableName;
  } else {
    return `${tableName} as ${alias}`;
  }
}

function checkThroughObject(ctx) {
  const mapping = ctx.mapping;

  if (!isObject(mapping.join.through)) {
    throw ctx.createError('join must have a `through` object that describes the join table.');
  }

  if (!mapping.join.through.from || !mapping.join.through.to) {
    throw ctx.createError(
      'join.through must be an object that describes the join table. For example: {from: "JoinTable.someId", to: "JoinTable.someOtherId"}',
    );
  }

  return ctx;
}

function resolveJoinModelClassIfDefined(ctx) {
  let joinTableModelClass = null;

  if (ctx.mapping.join.through.modelClass) {
    try {
      joinTableModelClass = resolveModel(
        ctx.mapping.join.through.modelClass,
        ctx.ownerModelClass.modelPaths,
        'join.through.modelClass',
      );
    } catch (err) {
      throw ctx.createError(err.message);
    }
  }

  return Object.assign(ctx, { joinTableModelClass });
}

function createJoinProperties(ctx) {
  let ret;

  let fromProp;
  let toProp;

  let relatedProp;
  let ownerProp;

  ret = createRelationProperty(ctx, ctx.mapping.join.through.from, 'join.through.from');
  fromProp = ret.prop;
  ctx = ret.ctx;

  ret = createRelationProperty(ctx, ctx.mapping.join.through.to, 'join.through.to');
  toProp = ret.prop;
  ctx = ret.ctx;

  if (fromProp.modelClass.getTableName() !== toProp.modelClass.getTableName()) {
    throw ctx.createError('join.through `from` and `to` must point to the same join table.');
  }

  if (ctx.relatedProp.modelClass.getTableName() === fromProp.modelClass.getTableName()) {
    relatedProp = fromProp;
    ownerProp = toProp;
  } else {
    relatedProp = toProp;
    ownerProp = fromProp;
  }

  return Object.assign(ctx, {
    joinTableOwnerProp: ownerProp,
    joinTableRelatedProp: relatedProp,
  });
}

function createRelationProperty(ctx, refString, messagePrefix) {
  let prop = null;
  let joinTableModelClass = ctx.joinTableModelClass;

  const resolveModelClass = (table) => {
    if (joinTableModelClass === null) {
      joinTableModelClass = inheritModel(getModel());
      joinTableModelClass.tableName = table;
      joinTableModelClass.idColumn = null;
      joinTableModelClass.concurrency = ctx.ownerModelClass.concurrency;
    }

    if (joinTableModelClass.getTableName() === table) {
      return joinTableModelClass;
    } else {
      return null;
    }
  };

  try {
    prop = new RelationProperty(refString, resolveModelClass);
  } catch (err) {
    if (err instanceof RelationProperty.ModelNotFoundError) {
      throw ctx.createError('join.through `from` and `to` must point to the same join table.');
    } else {
      throw ctx.createError(
        `${messagePrefix} must have format JoinTable.columnName. For example "JoinTable.someId" or in case of composite key ["JoinTable.a", "JoinTable.b"].`,
      );
    }
  }

  return {
    ctx: Object.assign(ctx, { joinTableModelClass }),
    prop,
  };
}

function parseExtras(ctx) {
  let extraDef = ctx.mapping.join.through.extra;

  if (!extraDef) {
    return ctx;
  }

  if (isString(extraDef)) {
    extraDef = {
      [extraDef]: extraDef,
    };
  } else if (Array.isArray(extraDef)) {
    extraDef = extraDef.reduce((extraDef, col) => {
      extraDef[col] = col;
      return extraDef;
    }, {});
  }

  const joinTableExtras = Object.keys(extraDef).map((key) => {
    const val = extraDef[key];

    return {
      joinTableCol: val,
      joinTableProp: ctx.joinTableModelClass.columnNameToPropertyName(val),
      aliasCol: key,
      aliasProp: ctx.joinTableModelClass.columnNameToPropertyName(key),
    };
  });

  return Object.assign(ctx, { joinTableExtras });
}

function parseModify(ctx) {
  const mapping = ctx.mapping.join.through;
  const modifier = mapping.modify || mapping.filter;
  const joinTableModify =
    modifier &&
    createModifier({
      modifier,
      modelClass: ctx.relatedModelClass,
    });

  return Object.assign(ctx, { joinTableModify });
}

function parseBeforeInsert(ctx) {
  let joinTableBeforeInsert;

  if (isFunction(ctx.mapping.join.through.beforeInsert)) {
    joinTableBeforeInsert = ctx.mapping.join.through.beforeInsert;
  } else {
    joinTableBeforeInsert = (model) => model;
  }

  return Object.assign(ctx, { joinTableBeforeInsert });
}

function finalizeJoinModelClass(ctx) {
  if (ctx.joinTableModelClass.getIdColumn() === null) {
    // We cannot know if the join table has a primary key. Therefore we set some
    // known column as the idColumn so that inserts will work.
    ctx.joinTableModelClass.idColumn = ctx.joinTableRelatedProp.cols;
  }

  return ctx;
}

module.exports = {
  ManyToManyRelation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/ManyToManySqliteModifyMixin.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyModifyMixin.js");
const SQLITE_BUILTIN_ROW_ID = '_rowid_';

// We need to override this mixin for sqlite because sqlite doesn't support
// multi-column where in statements with subqueries. We need to use the
// internal _rowid_ column instead.
const ManyToManySqliteModifyMixin = (Operation) => {
  return class extends ManyToManyModifyMixin(Operation) {
    applyModifyFilterForRelatedTable(builder) {
      const tableRef = builder.tableRefFor(this.relation.relatedModelClass);
      const rowIdRef = `${tableRef}.${SQLITE_BUILTIN_ROW_ID}`;
      const subquery = this.modifyFilterSubquery.clone().select(rowIdRef);

      return builder.whereInComposite(rowIdRef, subquery);
    }

    applyModifyFilterForJoinTable(builder) {
      const joinTableOwnerRefs = this.relation.joinTableOwnerProp.refs(builder);
      const tableRef = builder.tableRefFor(this.relation.getJoinModelClass(builder));
      const rowIdRef = `${tableRef}.${SQLITE_BUILTIN_ROW_ID}`;

      const ownerValues = this.owner.getProps(this.relation);
      const subquery = this.modifyFilterSubquery.clone().select(rowIdRef);

      return builder
        .whereInComposite(rowIdRef, subquery)
        .whereInComposite(joinTableOwnerRefs, ownerValues);
    }
  };
};

module.exports = {
  ManyToManySqliteModifyMixin,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyDeleteOperationBase } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperationBase.js");
const { ManyToManyModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyModifyMixin.js");

class ManyToManyDeleteOperation extends ManyToManyModifyMixin(ManyToManyDeleteOperationBase) {}

module.exports = {
  ManyToManyDeleteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperationBase.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { DeleteOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/DeleteOperation.js");

class ManyToManyDeleteOperationBase extends DeleteOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;
  }

  /* istanbul ignore next */
  applyModifyFilterForRelatedTable(builder) {
    throw new Error('not implemented');
  }

  /* istanbul ignore next */
  applyModifyFilterForJoinTable(builder) {
    throw new Error('not implemented');
  }
}

module.exports = {
  ManyToManyDeleteOperationBase,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteSqliteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyDeleteOperationBase } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperationBase.js");
const { ManyToManySqliteModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManySqliteModifyMixin.js");

class ManyToManyDeleteSqliteOperation extends ManyToManySqliteModifyMixin(
  ManyToManyDeleteOperationBase,
) {}

module.exports = {
  ManyToManyDeleteSqliteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/find/ManyToManyFindOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RelationFindOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationFindOperation.js");
const { getTempColumn } = __webpack_require__("./node_modules/objection/lib/utils/tmpColumnUtils.js");

class ManyToManyFindOperation extends RelationFindOperation {
  constructor(name, opt) {
    super(name, opt);

    this.ownerJoinColumnAlias = new Array(this.relation.joinTableOwnerProp.size);

    for (let i = 0, l = this.ownerJoinColumnAlias.length; i < l; ++i) {
      this.ownerJoinColumnAlias[i] = getTempColumn(i);
    }
  }

  onBuild(builder) {
    const relatedModelClass = this.relation.relatedModelClass;

    this.maybeApplyAlias(builder);
    this.relation.findQuery(builder, this.owner);

    if (!builder.hasSelects()) {
      const table = builder.tableRefFor(relatedModelClass);

      // If the user hasn't specified a select clause, select the related model's columns.
      // If we don't do this we also get the join table's columns.
      builder.select(`${table}.*`);

      // Also select all extra columns.
      for (const extra of this.relation.joinTableExtras) {
        const joinTable = builder.tableRefFor(this.relation.joinTable);
        builder.select(`${joinTable}.${extra.joinTableCol} as ${extra.aliasCol}`);
      }
    }

    if (this.assignResultToOwner && this.owner.isModels) {
      this.selectMissingJoinColumns(builder);
    }
  }

  onAfter2(_, related) {
    const isOneToOne = this.relation.isOneToOne();

    if (this.assignResultToOwner && this.owner.isModels) {
      const owners = this.owner.modelArray;
      const ownerProp = this.relation.ownerProp;
      const relatedByOwnerId = new Map();

      for (let i = 0, l = related.length; i < l; ++i) {
        const rel = related[i];
        const key = rel.$propKey(this.ownerJoinColumnAlias);
        let arr = relatedByOwnerId.get(key);

        if (!arr) {
          arr = [];
          relatedByOwnerId.set(key, arr);
        }

        arr.push(rel);
      }

      for (let i = 0, l = owners.length; i < l; ++i) {
        const own = owners[i];
        const key = ownerProp.propKey(own);
        const related = relatedByOwnerId.get(key);

        if (isOneToOne) {
          own[this.relationProperty] = (related && related[0]) || null;
        } else {
          own[this.relationProperty] = related || [];
        }
      }
    }

    return related;
  }

  clone() {
    const clone = super.clone();
    clone.ownerJoinColumnAlias = this.ownerJoinColumnAlias.slice();
    return clone;
  }

  selectMissingJoinColumns(builder) {
    const { relatedModelClass, joinTableOwnerProp } = this.relation;

    // We must select the owner join columns so that we know for which owner model the related
    // models belong to after the requests.
    joinTableOwnerProp.forEach((i) => {
      const joinTableOwnerRef = joinTableOwnerProp.ref(builder, i);
      const propName = relatedModelClass.columnNameToPropertyName(this.ownerJoinColumnAlias[i]);

      builder.select(joinTableOwnerRef.as(this.ownerJoinColumnAlias[i]));
      // Mark them to be omitted later.
      this.omitProps.push(propName);
    });

    super.selectMissingJoinColumns(builder);
  }
}

module.exports = {
  ManyToManyFindOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/insert/ManyToManyInsertOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RelationInsertOperation } = __webpack_require__("./node_modules/objection/lib/relations/RelationInsertOperation.js");
const { ManyToManyRelateOperation } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/relate/ManyToManyRelateOperation.js");

class ManyToManyInsertOperation extends RelationInsertOperation {
  onAdd(builder, args) {
    const retVal = super.onAdd(builder, args);

    // Omit extra properties so that we don't try to insert
    // them to the related table. We don't actually remove them
    // from the objects, but simply mark them to be removed
    // from the inserted row.
    this.relation.omitExtraProps(this.models);

    return retVal;
  }

  async onAfter1(builder, ret) {
    const inserted = await super.onAfter1(builder, ret);

    const relateOp = new ManyToManyRelateOperation('relate', {
      dontCopyReturning: true,
      dontCopyOnConflict: true,
      relation: this.relation,
      owner: this.owner,
    });

    const modelsToRelate = inserted.filter((it) => {
      return this.relation.relatedProp.hasProps(it);
    });

    if (this.assignResultToOwner && this.owner.isModels) {
      for (const owner of this.owner.modelArray) {
        owner.$appendRelated(this.relation, inserted);
      }
    }

    if (modelsToRelate.length === 0) {
      return inserted;
    }

    relateOp.onAdd(builder, [modelsToRelate]);
    await relateOp.queryExecutor(builder);

    return inserted;
  }
}

module.exports = {
  ManyToManyInsertOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/relate/ManyToManyRelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPostgres } = __webpack_require__("./node_modules/objection/lib/utils/knexUtils.js");
const { normalizeIds } = __webpack_require__("./node_modules/objection/lib/utils/normalizeIds.js");
const { RelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/RelateOperation.js");

class ManyToManyRelateOperation extends RelateOperation {
  onAdd(builder, args) {
    this.input = args[0];
    this.ids = normalizeIds(args[0], this.relation.relatedProp);

    assertOwnerIsSingleItem(builder, this.owner, this.relation);
    return true;
  }

  queryExecutor(builder) {
    const joinModelClass = this.relation.getJoinModelClass(builder.knex());
    const ownerValues = this.owner.getSplitProps(builder, this.relation);
    const joinModels = [];

    for (const ownerValue of ownerValues) {
      for (const relatedValue of this.ids) {
        joinModels.push(
          joinModelClass.fromJson(this.relation.createJoinModel(ownerValue, relatedValue)),
        );
      }
    }

    return joinModelClass
      .query()
      .childQueryOf(builder)
      .modify((query) => {
        if (!this.opt.dontCopyReturning) {
          query.copyFrom(builder, /returning/);
        }

        if (!this.opt.dontCopyOnConflict) {
          query.copyFrom(builder, /onConflict|ignore|merge/);
        }
      })
      .runBefore((_, builder) => {
        return this.relation.executeJoinTableBeforeInsert(joinModels, builder.context(), null);
      })
      .insert(joinModels)
      .runAfter((models) => {
        return Array.isArray(models) ? models.length : 1;
      });
  }
}

function assertOwnerIsSingleItem(builder, owner, relation) {
  const { isModels, isIdentifiers, isQueryBuilder } = owner;
  const { ownerProp } = relation;

  const singleModel = isModels && owner.modelArray.length === 1;
  const singleId = isIdentifiers && owner.getNormalizedIdentifiers(ownerProp).length === 1;

  if (isPostgres(builder.unsafeKnex())) {
    if (!isModels && !isIdentifiers && !isQueryBuilder) {
      throw new Error(
        'Parent must be a list of identifiers or a list of models when relating a ManyToManyRelation',
      );
    }
  } else {
    if (!singleModel && !singleId && !isQueryBuilder) {
      throw new Error(
        [
          'Can only relate items for one parent at a time in case of ManyToManyRelation.',
          'Otherwise multiple insert queries would need to be created.',

          'If you need to relate items for multiple parents, simply loop through them.',
          `That's the most performant way.`,
        ].join(' '),
      );
    }
  }
}

module.exports = {
  ManyToManyRelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyUnrelateOperationBase } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperationBase.js");
const { ManyToManyModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyModifyMixin.js");

class ManyToManyUnrelateOperation extends ManyToManyModifyMixin(ManyToManyUnrelateOperationBase) {
  get modifyMainQuery() {
    return false;
  }
}

module.exports = {
  ManyToManyUnrelateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperationBase.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UnrelateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UnrelateOperation.js");

class ManyToManyUnrelateOperationBase extends UnrelateOperation {
  queryExecutor(builder) {
    const unrelateQuery = this.relation
      .getJoinModelClass(builder.knex())
      .query()
      .childQueryOf(builder)
      .delete();

    return this.applyModifyFilterForJoinTable(unrelateQuery).modify(this.relation.joinTableModify);
  }

  /* istanbul ignore next */
  applyModifyFilterForRelatedTable(builder) {
    throw new Error('not implemented');
  }

  /* istanbul ignore next */
  applyModifyFilterForJoinTable(builder) {
    throw new Error('not implemented');
  }
}

module.exports = {
  ManyToManyUnrelateOperationBase,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateSqliteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyUnrelateOperationBase } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperationBase.js");
const { ManyToManySqliteModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManySqliteModifyMixin.js");

class ManyToManyUnrelateSqliteOperation extends ManyToManySqliteModifyMixin(
  ManyToManyUnrelateOperationBase,
) {
  get modifyMainQuery() {
    return false;
  }
}

module.exports = {
  ManyToManyUnrelateSqliteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyUpdateOperationBase } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperationBase.js");
const { ManyToManyModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManyModifyMixin.js");

class ManyToManyUpdateOperation extends ManyToManyModifyMixin(ManyToManyUpdateOperationBase) {}

module.exports = {
  ManyToManyUpdateOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperationBase.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UpdateOperation } = __webpack_require__("./node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js");

class ManyToManyUpdateOperationBase extends UpdateOperation {
  constructor(name, opt) {
    super(name, opt);

    this.relation = opt.relation;
    this.owner = opt.owner;

    this.hasExtraProps = false;
    this.joinTablePatch = {};
    this.joinTablePatchFilterQuery = null;
  }

  onAdd(builder, args) {
    const obj = args[0];

    // Copy all extra properties to the `joinTablePatch` object.
    for (const extra of this.relation.joinTableExtras) {
      if (extra.aliasProp in obj) {
        this.hasExtraProps = true;
        this.joinTablePatch[extra.joinTableProp] = obj[extra.aliasProp];
      }
    }

    const res = super.onAdd(builder, args);

    if (this.hasExtraProps) {
      // Make sure we don't try to insert the extra properties
      // to the target table.
      this.relation.omitExtraProps([this.model]);
    }

    return res;
  }

  async onAfter1(builder, result) {
    if (this.hasExtraProps) {
      const joinTableUpdateQuery = this.relation
        .getJoinModelClass(builder.knex())
        .query()
        .childQueryOf(builder)
        .patch(this.joinTablePatch);

      await this.applyModifyFilterForJoinTable(joinTableUpdateQuery).modify(
        this.relation.joinTableModify,
      );
      return result;
    } else {
      return result;
    }
  }

  /* istanbul ignore next */
  applyModifyFilterForRelatedTable(builder) {
    throw new Error('not implemented');
  }

  /* istanbul ignore next */
  applyModifyFilterForJoinTable(builder) {
    throw new Error('not implemented');
  }

  clone() {
    const clone = super.clone();

    clone.hasExtraProps = this.hasExtraProps;
    clone.joinTablePatch = this.joinTablePatch;
    clone.joinTablePatchFilterQuery = this.joinTablePatchFilterQuery;

    return clone;
  }
}

module.exports = {
  ManyToManyUpdateOperationBase,
};


/***/ }),

/***/ "./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateSqliteOperation.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ManyToManyUpdateOperationBase } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperationBase.js");
const { ManyToManySqliteModifyMixin } = __webpack_require__("./node_modules/objection/lib/relations/manyToMany/ManyToManySqliteModifyMixin.js");

class ManyToManyUpdateSqliteOperation extends ManyToManySqliteModifyMixin(
  ManyToManyUpdateOperationBase,
) {}

module.exports = {
  ManyToManyUpdateSqliteOperation,
};


/***/ }),

/***/ "./node_modules/objection/lib/transaction.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const promiseUtils = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/index.js");
const { isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function transaction() {
  // There must be at least one model class and the callback.
  if (arguments.length < 2) {
    return Promise.reject(
      new Error(
        'objection.transaction: provide at least one Model class to bind to the transaction or a knex instance',
      ),
    );
  }

  let args = Array.from(arguments);

  if (!isModelClass(args[0]) && isFunction(args[0].transaction)) {
    let knex = args[0];
    args = args.slice(1);

    return knex.transaction.apply(knex, args);
  } else {
    // The last argument should be the callback and all other Model subclasses.
    let callback = args[args.length - 1];
    let modelClasses = args.slice(0, args.length - 1);
    let i;

    for (i = 0; i < modelClasses.length; ++i) {
      if (!isModelClass(modelClasses[i])) {
        return Promise.reject(
          new Error('objection.transaction: all but the last argument should be Model subclasses'),
        );
      }
    }

    let knex = modelClasses[0].knex();
    for (i = 0; i < modelClasses.length; ++i) {
      if (modelClasses[i].knex() !== knex) {
        return Promise.reject(
          new Error(
            'objection.transaction: all Model subclasses must be bound to the same database',
          ),
        );
      }
    }

    return knex.transaction((trx) => {
      let args = new Array(modelClasses.length + 1);

      for (let i = 0; i < modelClasses.length; ++i) {
        args[i] = modelClasses[i].bindTransaction(trx);
      }

      args[args.length - 1] = trx;

      return promiseUtils.try(() => {
        return callback.apply(trx, args);
      });
    });
  }
}

transaction.start = function (modelClassOrKnex) {
  let knex = modelClassOrKnex;

  if (isModelClass(modelClassOrKnex)) {
    knex = modelClassOrKnex.knex();
  }

  if (!knex || !isFunction(knex.transaction)) {
    return Promise.reject(
      new Error(
        'objection.transaction.start: first argument must be a model class or a knex instance',
      ),
    );
  }

  return new Promise((resolve, reject) => {
    knex
      .transaction((trx) => {
        resolve(trx);
      })
      .catch((err) => {
        reject(err);
      });
  });
};

function isModelClass(maybeModel) {
  return isFunction(maybeModel) && maybeModel.isObjectionModelClass;
}

module.exports = {
  transaction,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/assert.js":
/***/ ((module) => {

"use strict";


function assertHasId(model) {
  if (!model.$hasId()) {
    const modelClass = model.constructor;
    const ids = modelClass.getIdColumnArray().join(', ');

    throw new Error(
      `one of the identifier columns [${ids}] is null or undefined. Have you specified the correct identifier column for the model '${modelClass.name}' using the 'idColumn' property?`,
    );
  }
}

function assertIdNotUndefined(id, message) {
  if (Array.isArray(id)) {
    id.forEach((id) => assertIdNotUndefined(id, message));
  } else if (id === undefined) {
    throw Error(message);
  }
}

module.exports = {
  assertHasId,
  assertIdNotUndefined,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/buildUtils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function buildArg(arg, builder) {
  if (!isObject(arg)) {
    return arg;
  }

  if (isFunction(arg.toKnexRaw)) {
    return arg.toKnexRaw(builder);
  } else if (arg.isObjectionQueryBuilderBase === true) {
    return arg.subqueryOf(builder).toKnexQuery();
  } else {
    return arg;
  }
}

module.exports = {
  buildArg,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/classUtils.js":
/***/ ((module) => {

"use strict";


function inherit(Constructor, BaseConstructor) {
  Constructor.prototype = Object.create(BaseConstructor.prototype);
  Constructor.prototype.constructor = BaseConstructor;
  Object.setPrototypeOf(Constructor, BaseConstructor);

  return Constructor;
}

module.exports = {
  inherit,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/clone.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash include="cloneDeep,clone" exports="node" --development`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function () {
  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] =
    typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] =
    typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] =
    typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] =
    typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] =
      true;
  typedArrayTags[argsTag] =
    typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] =
    typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] =
    typedArrayTags[dateTag] =
    typedArrayTags[errorTag] =
    typedArrayTags[funcTag] =
    typedArrayTags[mapTag] =
    typedArrayTags[numberTag] =
    typedArrayTags[objectTag] =
    typedArrayTags[regexpTag] =
    typedArrayTags[setTag] =
    typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] =
      false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] =
    cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] =
    cloneableTags[dataViewTag] =
    cloneableTags[boolTag] =
    cloneableTags[dateTag] =
    cloneableTags[float32Tag] =
    cloneableTags[float64Tag] =
    cloneableTags[int8Tag] =
    cloneableTags[int16Tag] =
    cloneableTags[int32Tag] =
    cloneableTags[mapTag] =
    cloneableTags[numberTag] =
    cloneableTags[objectTag] =
    cloneableTags[regexpTag] =
    cloneableTags[setTag] =
    cloneableTags[stringTag] =
    cloneableTags[symbolTag] =
    cloneableTags[uint8Tag] =
    cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] =
    cloneableTags[uint32Tag] =
      true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Used as a reference to the global object. */
  var root = freeGlobal || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function () {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  })();

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap,
    nodeIsSet = nodeUtil && nodeUtil.isSet,
    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
      length = values.length,
      offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
      result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  })();

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp(
    '^' +
      funcToString
        .call(hasOwnProperty)
        .replace(reRegExpChar, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
      '$',
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  var defineProperty = (function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  })();

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

  /** Used to lookup unminified function names. */
  var realNames = {};

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash() {
    // No operation performed.
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function () {
    function object() {}
    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  })();

  /*------------------------------------------------------------------------*/

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash(),
      map: new (Map || ListCache)(),
      string: new Hash(),
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
      size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = (this.__data__ = new ListCache(entries));
    this.size = data.size;
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
      result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

    for (var key in value) {
      if (
        (inherited || hasOwnProperty.call(value, key)) &&
        !(
          skipIndexes &&
          // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == 'length' ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            (isBuff && (key == 'offset' || key == 'parent')) ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
            // Skip index properties.
            isIndex(key, length))
        )
      ) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (
      !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))
    ) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        value: value,
        writable: true,
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });

      return result;
    }

    if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });

      return result;
    }

    var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys;

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value)
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
      result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
      length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
      length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols
    ? stubArray
    : function (object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols
    ? stubArray
    : function (object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if (
    (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map()) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set()) != setTag) ||
    (WeakMap && getTag(new WeakMap()) != weakMapTag)
  ) {
    getTag = function (value) {
      var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
      result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object)
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor();

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor();

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return (
      !!length &&
      (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
      ? value !== '__proto__'
      : value === null;
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(
    (function () {
      return arguments;
    })(),
  )
    ? baseIsArguments
    : function (value) {
        return (
          isObjectLike(value) &&
          hasOwnProperty.call(value, 'callee') &&
          !propertyIsEnumerable.call(value, 'callee')
        );
      };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /*------------------------------------------------------------------------*/

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /*------------------------------------------------------------------------*/

  // Add methods that return wrapped values in chain sequences.
  lodash.keys = keys;
  lodash.keysIn = keysIn;

  /*------------------------------------------------------------------------*/

  // Add methods that return unwrapped values in chain sequences.
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.eq = eq;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isArrayLike = isArrayLike;
  lodash.isBuffer = isBuffer;
  lodash.isFunction = isFunction;
  lodash.isLength = isLength;
  lodash.isMap = isMap;
  lodash.isObject = isObject;
  lodash.isObjectLike = isObjectLike;
  lodash.isSet = isSet;
  lodash.isTypedArray = isTypedArray;
  lodash.stubArray = stubArray;
  lodash.stubFalse = stubFalse;

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */
  lodash.VERSION = VERSION;

  /*--------------------------------------------------------------------------*/

  if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = lodash)._ = lodash;
    // Export for CommonJS support.
    freeExports._ = lodash;
  }
}).call(this);


/***/ }),

/***/ "./node_modules/objection/lib/utils/createModifier.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { asArray, isString, isFunction, isPlainObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function createModifier({ modelClass, modifier, modifiers }) {
  const modelModifiers = modelClass ? modelClass.getModifiers() : {};

  const modifierFunctions = asArray(modifier).map((modifier) => {
    let modify = null;

    if (isString(modifier)) {
      modify = (modifiers && modifiers[modifier]) || modelModifiers[modifier];

      // Modifiers can be pointers to other modifiers. Call this function recursively.
      if (modify && !isFunction(modify)) {
        return createModifier({ modelClass, modifier: modify, modifiers });
      }
    } else if (isFunction(modifier)) {
      modify = modifier;
    } else if (isPlainObject(modifier)) {
      modify = (builder) => builder.where(modifier);
    } else if (Array.isArray(modifier)) {
      return createModifier({ modelClass, modifier, modifiers });
    }

    if (!modify) {
      modify = (builder) => modelClass.modifierNotFound(builder, modifier);
    }

    return modify;
  });

  return (builder, ...args) => {
    for (const modifier of modifierFunctions) {
      modifier.call(builder, builder, ...args);
    }
  };
}

module.exports = {
  createModifier,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/deprecate.js":
/***/ ((module) => {

"use strict";


const LOGGED_DEPRECATIONS = new Set();

function deprecate(message) {
  // Only log deprecation messages once.
  if (!LOGGED_DEPRECATIONS.has(message)) {
    LOGGED_DEPRECATIONS.add(message);
    console.warn(message);
  }
}

module.exports = {
  deprecate,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/identifierMapping.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

// Super fast memoize for single argument functions.
function memoize(func) {
  const cache = new Map();

  return (input) => {
    let output = cache.get(input);

    if (output === undefined) {
      output = func(input);
      cache.set(input, output);
    }

    return output;
  };
}

// camelCase to snake_case converter that also works with non-ascii characters
// This is needed especially so that aliases containing the `:` character,
// objection uses internally, work.
function snakeCase(
  str,
  {
    upperCase = false,
    underscoreBeforeDigits = false,
    underscoreBetweenUppercaseLetters = false,
  } = {},
) {
  if (str.length === 0) {
    return str;
  }

  const upper = str.toUpperCase();
  const lower = str.toLowerCase();

  let out = lower[0];

  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i];
    const prevChar = str[i - 1];

    const upperChar = upper[i];
    const prevUpperChar = upper[i - 1];

    const lowerChar = lower[i];
    const prevLowerChar = lower[i - 1];

    // If underScoreBeforeDigits is true then, well, insert an underscore
    // before digits :). Only the first digit gets an underscore if
    // there are multiple.
    if (underscoreBeforeDigits && isDigit(char) && !isDigit(prevChar)) {
      out += '_' + char;
      continue;
    }

    // Test if `char` is an upper-case character and that the character
    // actually has different upper and lower case versions.
    if (char === upperChar && upperChar !== lowerChar) {
      const prevCharacterIsUppercase =
        prevChar === prevUpperChar && prevUpperChar !== prevLowerChar;

      // If underscoreBetweenUppercaseLetters is true, we always place an underscore
      // before consecutive uppercase letters (e.g. "fooBAR" becomes "foo_b_a_r").
      // Otherwise, we don't (e.g. "fooBAR" becomes "foo_bar").
      if (underscoreBetweenUppercaseLetters || !prevCharacterIsUppercase) {
        out += '_' + lowerChar;
      } else {
        out += lowerChar;
      }
    } else {
      out += char;
    }
  }

  if (upperCase) {
    return out.toUpperCase();
  } else {
    return out;
  }
}

// snake_case to camelCase converter that simply reverses
// the actions done by `snakeCase` function.
function camelCase(str, { upperCase = false } = {}) {
  if (str.length === 0) {
    return str;
  }

  if (upperCase && isAllUpperCaseSnakeCase(str)) {
    // Only convert to lower case if the string is all upper
    // case snake_case. This allowes camelCase strings to go
    // through without changing.
    str = str.toLowerCase();
  }

  let out = str[0];

  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i];
    const prevChar = str[i - 1];

    if (char !== '_') {
      if (prevChar === '_') {
        out += char.toUpperCase();
      } else {
        out += char;
      }
    }
  }

  return out;
}

function isAllUpperCaseSnakeCase(str) {
  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i];

    if (char !== '_' && char !== char.toUpperCase()) {
      return false;
    }
  }

  return true;
}

function isDigit(char) {
  return char >= '0' && char <= '9';
}

// Returns a function that splits the inputs string into pieces using `separator`,
// only calls `mapper` for the last part and concatenates the string back together.
// If no separators are found, `mapper` is called for the entire string.
function mapLastPart(mapper, separator) {
  return (str) => {
    if (!str) return str;
    const idx = str.lastIndexOf(separator);
    const mapped = mapper(str.slice(idx + separator.length));
    return str.slice(0, idx + separator.length) + mapped;
  };
}

// Returns a function that takes an object as an input and maps the object's keys
// using `mapper`. If the input is not an object, the input is returned unchanged.
function keyMapper(mapper) {
  return (obj) => {
    if (!isObject(obj) || Array.isArray(obj)) {
      return obj;
    }

    const keys = Object.keys(obj);
    const out = {};

    for (let i = 0, l = keys.length; i < l; ++i) {
      const key = keys[i];
      out[mapper(key)] = obj[key];
    }

    return out;
  };
}

function snakeCaseMappers(opt = {}) {
  return {
    parse: keyMapper(memoize((str) => camelCase(str, opt))),
    format: keyMapper(memoize((str) => snakeCase(str, opt))),
  };
}

function knexIdentifierMappers({ parse, format, idSeparator = ':' } = {}) {
  const formatId = memoize(mapLastPart(format, idSeparator));
  const parseId = memoize(mapLastPart(parse, idSeparator));
  const parseKeys = keyMapper(parseId);

  return {
    wrapIdentifier(identifier, origWrap) {
      return origWrap(formatId(identifier));
    },

    postProcessResponse(result) {
      if (Array.isArray(result)) {
        const output = new Array(result.length);

        for (let i = 0, l = result.length; i < l; ++i) {
          output[i] = parseKeys(result[i]);
        }

        return output;
      } else {
        return parseKeys(result);
      }
    },
  };
}

function knexSnakeCaseMappers(opt = {}) {
  return knexIdentifierMappers({
    parse: (str) => camelCase(str, opt),
    format: (str) => snakeCase(str, opt),
  });
}

function knexIdentifierMapping(colToProp) {
  const propToCol = Object.keys(colToProp).reduce((propToCol, column) => {
    propToCol[colToProp[column]] = column;
    return propToCol;
  }, {});

  return knexIdentifierMappers({
    parse: (column) => colToProp[column] || column,
    format: (prop) => propToCol[prop] || prop,
  });
}

module.exports = {
  snakeCase,
  camelCase,
  snakeCaseMappers,
  knexSnakeCaseMappers,
  knexIdentifierMappers,
  knexIdentifierMapping,

  camelCaseKeys: keyMapper(memoize(camelCase)),
  snakeCaseKeys: keyMapper(memoize(snakeCase)),
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/internalPropUtils.js":
/***/ ((module) => {

"use strict";


const INTERNAL_PROP_PREFIX = '$';

function isInternalProp(propName) {
  return propName[0] === INTERNAL_PROP_PREFIX;
}

module.exports = {
  isInternalProp,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/knexUtils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function getDialect(knex) {
  const type = typeof knex;

  return (
    (knex !== null &&
      (type === 'object' || type === 'function') &&
      knex.client &&
      knex.client.dialect) ||
    null
  );
}

function isPostgres(knex) {
  return getDialect(knex) === 'postgresql';
}

function isOracle(knex) {
  const dialect = getDialect(knex);
  return dialect === 'oracle' || dialect === 'oracledb';
}

function isMySql(knex) {
  const dialect = getDialect(knex);
  return dialect === 'mysql' || dialect === 'mysql2';
}

function isSqlite(knex) {
  return getDialect(knex) === 'sqlite3';
}

function isMsSql(knex) {
  return getDialect(knex) === 'mssql';
}

function isKnexQueryBuilder(value) {
  return (
    hasConstructor(value) &&
    isFunction(value.select) &&
    isFunction(value.column) &&
    value.select === value.column &&
    'client' in value
  );
}

function isKnexJoinBuilder(value) {
  return hasConstructor(value) && value.grouping === 'join' && 'joinType' in value;
}

function isKnexRaw(value) {
  return hasConstructor(value) && value.isRawInstance && 'client' in value;
}

function isKnexTransaction(knex) {
  return !!getDialect(knex) && isFunction(knex.commit) && isFunction(knex.rollback);
}

function hasConstructor(value) {
  return isObject(value) && isFunction(value.constructor);
}

module.exports = {
  getDialect,
  isPostgres,
  isMySql,
  isSqlite,
  isMsSql,
  isOracle,
  isKnexQueryBuilder,
  isKnexJoinBuilder,
  isKnexRaw,
  isKnexTransaction,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/mixin.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { flatten } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function mixin() {
  const args = flatten(arguments);
  const mixins = args.slice(1);

  return mixins.reduce((Class, mixinFunc) => {
    return mixinFunc(Class);
  }, args[0]);
}

function compose() {
  const mixins = flatten(arguments);

  return function (Class) {
    return mixin(Class, mixins);
  };
}

module.exports = {
  compose,
  mixin,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/normalizeIds.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

// ids is of type RelationProperty.
function normalizeIds(ids, prop, opt) {
  opt = opt || {};

  let isComposite = prop.size > 1;
  let ret;

  if (isComposite) {
    // For composite ids these are okay:
    //
    // 1. [1, 'foo', 4]
    // 2. {a: 1, b: 'foo', c: 4}
    // 3. [[1, 'foo', 4], [4, 'bar', 1]]
    // 4. [{a: 1, b: 'foo', c: 4}, {a: 4, b: 'bar', c: 1}]
    //
    if (Array.isArray(ids)) {
      if (Array.isArray(ids[0])) {
        ret = new Array(ids.length);

        // 3.
        for (let i = 0, l = ids.length; i < l; ++i) {
          ret[i] = convertIdArrayToObject(ids[i], prop);
        }
      } else if (isObject(ids[0])) {
        ret = new Array(ids.length);

        // 4.
        for (let i = 0, l = ids.length; i < l; ++i) {
          ret[i] = ensureObject(ids[i], prop);
        }
      } else {
        // 1.
        ret = [convertIdArrayToObject(ids, prop)];
      }
    } else if (isObject(ids)) {
      // 2.
      ret = [ids];
    } else {
      throw new Error(`invalid composite key ${JSON.stringify(ids)}`);
    }
  } else {
    // For non-composite ids, these are okay:
    //
    // 1. 1
    // 2. {id: 1}
    // 3. [1, 'foo', 4]
    // 4. [{id: 1}, {id: 'foo'}, {id: 4}]
    //
    if (Array.isArray(ids)) {
      if (isObject(ids[0])) {
        ret = new Array(ids.length);

        // 4.
        for (let i = 0, l = ids.length; i < l; ++i) {
          ret[i] = ensureObject(ids[i]);
        }
      } else {
        ret = new Array(ids.length);

        // 3.
        for (let i = 0, l = ids.length; i < l; ++i) {
          ret[i] = {};
          prop.setProp(ret[i], 0, ids[i]);
        }
      }
    } else if (isObject(ids)) {
      // 2.
      ret = [ids];
    } else {
      // 1.
      const obj = {};
      prop.setProp(obj, 0, ids);
      ret = [obj];
    }
  }

  checkProperties(ret, prop);

  if (opt.arrayOutput) {
    return normalizedToArray(ret, prop);
  } else {
    return ret;
  }
}

function convertIdArrayToObject(ids, prop) {
  if (!Array.isArray(ids)) {
    throw new Error(`invalid composite key ${JSON.stringify(ids)}`);
  }

  if (ids.length != prop.size) {
    throw new Error(`composite identifier ${JSON.stringify(ids)} should have ${prop.size} values`);
  }

  const obj = {};

  for (let i = 0; i < ids.length; ++i) {
    prop.setProp(obj, i, ids[i]);
  }

  return obj;
}

function ensureObject(ids) {
  if (isObject(ids)) {
    return ids;
  } else {
    throw new Error(`invalid composite key ${JSON.stringify(ids)}`);
  }
}

function checkProperties(ret, prop) {
  for (let i = 0, l = ret.length; i < l; ++i) {
    const obj = ret[i];

    for (let j = 0, lp = prop.size; j < lp; ++j) {
      const val = prop.getProp(obj, j);

      if (typeof val === 'undefined') {
        throw new Error(
          `expected id ${JSON.stringify(obj)} to have property ${prop.propDescription(j)}`,
        );
      }
    }
  }
}

function normalizedToArray(ret, prop) {
  const arr = new Array(ret.length);

  for (let i = 0, l = ret.length; i < l; ++i) {
    arr[i] = prop.getProps(ret[i]);
  }

  return arr;
}

module.exports = {
  normalizeIds,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/objectUtils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { clone, cloneDeep } = __webpack_require__("./node_modules/objection/lib/utils/clone.js");
const SMALL_ARRAY_SIZE = 10;

function isEmpty(item) {
  if (Array.isArray(item) || Buffer.isBuffer(item)) {
    return item.length === 0;
  } else if (isObject(item)) {
    return Object.keys(item).length === 0;
  } else {
    return true;
  }
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

// Quick and dirty check if an object is a plain object and not
// for example an instance of some class.
function isPlainObject(value) {
  return (
    isObject(value) &&
    (!value.constructor || value.constructor === Object) &&
    (!value.toString || value.toString === Object.prototype.toString)
  );
}

function isFunction(value) {
  return typeof value === 'function';
}

function isRegExp(value) {
  return value instanceof RegExp;
}

function isString(value) {
  return typeof value === 'string';
}

function isNumber(value) {
  return typeof value === 'number';
}

function asArray(value) {
  return Array.isArray(value) ? value : [value];
}

function asSingle(value) {
  return Array.isArray(value) ? value[0] : value;
}

function uniqBy(items, keyGetter = null) {
  const map = new Map();

  for (let i = 0, l = items.length; i < l; ++i) {
    const item = items[i];
    const key = keyGetter !== null ? keyGetter(item) : item;

    map.set(key, item);
  }

  return Array.from(map.values());
}

function groupBy(items, keyGetter = null) {
  const groups = new Map();

  for (const item of items) {
    const key = keyGetter !== null ? keyGetter(item) : item;
    let group = groups.get(key);

    if (!group) {
      group = [];
      groups.set(key, group);
    }

    group.push(item);
  }

  return groups;
}

function omit(obj, keysToOmit) {
  keysToOmit = asArray(keysToOmit);

  const keys = Object.keys(obj);
  const out = {};

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];

    if (!keysToOmit.includes(key)) {
      out[key] = obj[key];
    }
  }

  return out;
}

function difference(arr1, arr2) {
  const arr2Set = new Set(arr2);
  const diff = [];

  for (let i = 0; i < arr1.length; ++i) {
    const value = arr1[i];

    if (!arr2Set.has(value)) {
      diff.push(value);
    }
  }

  return diff;
}

function union(arr1, arr2) {
  if (arr1.length < SMALL_ARRAY_SIZE && arr2.length < SMALL_ARRAY_SIZE) {
    return unionSmall(arr1, arr2);
  } else {
    return unionGeneric(arr1, arr2);
  }
}

function unionSmall(arr1, arr2) {
  const all = arr1.slice();

  for (let i = 0, l = arr2.length; i < l; ++i) {
    const item = arr2[i];

    if (all.indexOf(item) === -1) {
      all.push(item);
    }
  }

  return all;
}

function unionGeneric(arr1, arr2) {
  const all = new Set();

  for (let i = 0; i < arr1.length; ++i) {
    all.add(arr1[i]);
  }

  for (let i = 0; i < arr2.length; ++i) {
    all.add(arr2[i]);
  }

  return Array.from(all);
}

function last(arr) {
  return arr[arr.length - 1];
}

function upperFirst(str) {
  return str[0].toUpperCase() + str.substring(1);
}

function values(obj) {
  if (isObject(obj)) {
    const keys = Object.keys(obj);
    const values = new Array(keys.length);

    for (let i = 0, l = keys.length; i < l; ++i) {
      values[i] = obj[keys[i]];
    }

    return values;
  } else {
    return [];
  }
}

function once(func) {
  let called = false;
  let value = undefined;

  return function () {
    if (called === false) {
      called = true;
      value = func.apply(this, arguments);
    }

    return value;
  };
}

function flatten(arrays) {
  const out = [];

  for (let i = 0, l = arrays.length; i < l; ++i) {
    const value = arrays[i];

    if (Array.isArray(value)) {
      for (let j = 0; j < value.length; ++j) {
        out.push(value[j]);
      }
    } else {
      out.push(value);
    }
  }

  return out;
}

function get(obj, path) {
  for (let i = 0, l = path.length; i < l; ++i) {
    const key = path[i];

    if (!isObject(obj)) {
      return undefined;
    }

    obj = obj[key];
  }

  return obj;
}

function set(obj, path, value) {
  const inputObj = obj;

  for (let i = 0, l = path.length - 1; i < l; ++i) {
    const key = path[i];

    if (!isSafeKey(key)) {
      return inputObj;
    }

    let child = obj[key];

    if (!isObject(child)) {
      const nextKey = path[i + 1];

      if (isNaN(nextKey)) {
        child = {};
      } else {
        child = [];
      }

      obj[key] = child;
    }

    obj = child;
  }

  if (path.length > 0 && isObject(obj)) {
    const key = path[path.length - 1];

    if (isSafeKey(key)) {
      obj[key] = value;
    }
  }

  return inputObj;
}

function zipObject(keys, values) {
  const out = {};

  for (let i = 0, l = keys.length; i < l; ++i) {
    const key = keys[i];

    if (isSafeKey(key)) {
      out[key] = values[i];
    }
  }

  return out;
}

function chunk(arr, chunkSize) {
  const out = [];

  for (let i = 0, l = arr.length; i < l; ++i) {
    const item = arr[i];

    if (out.length === 0 || out[out.length - 1].length === chunkSize) {
      out.push([]);
    }

    out[out.length - 1].push(item);
  }

  return out;
}

function jsonEquals(val1, val2) {
  return jsonEqualsBase(val1, val2, compareStrict);
}

function jsonEqualsBase(val1, val2, compare) {
  if (val1 === val2) {
    return true;
  }

  return jsonEqualsSlowPath(val1, val2, compare);
}

function jsonEqualsSlowPath(val1, val2, compare) {
  const type1 = typeof val1;
  const type2 = typeof val2;

  const isNonNullObject1 = type1 === 'object' && !compare(val1, null);
  const isNonNullObject2 = type2 === 'object' && !compare(val2, null);

  if (isNonNullObject1 && isNonNullObject2) {
    const isArray1 = Array.isArray(val1);
    const isArray2 = Array.isArray(val2);

    if (isArray1 && isArray2) {
      return jsonEqualsArray(val1, val2, compare);
    } else if (!isArray1 && !isArray2) {
      return jsonEqualsObject(val1, val2, compare);
    } else {
      return false;
    }
  } else if (isNonNullObject1 !== isNonNullObject2) {
    return false;
  } else {
    return compare(val1, val2);
  }
}

function jsonEqualsArray(arr1, arr2, compare) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0, l = arr1.length; i < l; ++i) {
    if (!jsonEqualsBase(arr1[i], arr2[i], compare)) {
      return false;
    }
  }

  return true;
}

function jsonEqualsObject(obj1, obj2, compare) {
  if (obj1.constructor === Date && obj2.constructor === Date) {
    return equalsDate(obj1, obj2);
  }

  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  for (let i = 0, l = keys1.length; i < l; ++i) {
    const key = keys1[i];

    if (!jsonEqualsBase(obj1[key], obj2[key], compare)) {
      return false;
    }
  }

  return true;
}

function equalsDate(date1, date2) {
  return date1.getTime() === date2.getTime();
}

function compareStrict(val1, val2) {
  return val1 === val2;
}

function isSafeKey(key) {
  return isNumber(key) || (isString(key) && key !== '__proto__');
}

function mergeMaps(map1, map2) {
  const map = new Map(map1);

  if (map2) {
    for (const key of map2.keys()) {
      map.set(key, map2.get(key));
    }
  }

  return map;
}

module.exports = {
  isEmpty,
  isString,
  isRegExp,
  isObject,
  isNumber,
  isFunction,
  jsonEquals,
  isPlainObject,
  difference,
  upperFirst,
  zipObject,
  mergeMaps,
  cloneDeep,
  asSingle,
  asArray,
  flatten,
  groupBy,
  uniqBy,
  values,
  union,
  chunk,
  clone,
  omit,
  once,
  last,
  get,
  set,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/parseFieldExpression.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonFieldExpressionParser = __webpack_require__("./node_modules/objection/lib/queryBuilder/parsers/jsonFieldExpressionParser.js");
const cache = new Map();

function parseFieldExpression(expr) {
  let parsedExpr = cache.get(expr);

  if (parsedExpr !== undefined) {
    return parsedExpr;
  } else {
    parsedExpr = jsonFieldExpressionParser.parse(expr);
    parsedExpr = preprocessParsedExpression(parsedExpr);

    // We don't take a copy of the parsedExpr each time we
    // use if from cache. Instead to make sure it's never
    // mutated we deep-freeze it.
    parsedExpr = freezeParsedExpr(parsedExpr);

    cache.set(expr, parsedExpr);
    return parsedExpr;
  }
}

function preprocessParsedExpression(parsedExpr) {
  const columnParts = parsedExpr.columnName.split('.').map((part) => part.trim());
  parsedExpr.column = columnParts[columnParts.length - 1];

  if (columnParts.length >= 2) {
    parsedExpr.table = columnParts.slice(0, columnParts.length - 1).join('.');
  } else {
    parsedExpr.table = null;
  }

  return parsedExpr;
}

function freezeParsedExpr(parsedExpr) {
  for (const access of parsedExpr.access) {
    Object.freeze(access);
  }

  Object.freeze(parsedExpr.access);
  Object.freeze(parsedExpr);

  return parsedExpr;
}

module.exports = {
  parseFieldExpression,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/after.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/isPromise.js");

// Call `func` after `obj` has been resolved. Call `func` synchronously if
// `obj` is not a promise for performance reasons.
function after(obj, func) {
  if (isPromise(obj)) {
    return obj.then(func);
  } else {
    return func(obj);
  }
}

module.exports = {
  after,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/afterReturn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/isPromise.js");

// Return `returnValue` after `obj` has been resolved. Return `returnValue`
// synchronously if `obj` is not a promise for performance reasons.
function afterReturn(obj, returnValue) {
  if (isPromise(obj)) {
    return obj.then(() => returnValue);
  } else {
    return returnValue;
  }
}

module.exports = {
  afterReturn,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/isPromise.js");
const { after } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/after.js");
const { afterReturn } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/afterReturn.js");
const { mapAfterAllReturn } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/mapAfterAllReturn.js");
const { promiseMap } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/map.js");
const { promiseTry } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/try.js");

module.exports = {
  isPromise,
  after,
  afterReturn,
  mapAfterAllReturn,
  map: promiseMap,
  try: promiseTry,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/isPromise.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isObject, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function isPromise(obj) {
  return isObject(obj) && isFunction(obj.then);
}

module.exports = {
  isPromise,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/map.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/isPromise.js");

// Works like Bluebird.map.
function promiseMap(items, mapper, opt) {
  switch (items.length) {
    case 0:
      return mapZero();
    case 1:
      return mapOne(items, mapper);
    default:
      return mapMany(items, mapper, opt);
  }
}

function mapZero() {
  return Promise.resolve([]);
}

function mapOne(items, mapper) {
  try {
    const maybePromise = mapper(items[0], 0);

    if (isPromise(maybePromise)) {
      return maybePromise.then(wrapArray);
    } else {
      return Promise.resolve(wrapArray(maybePromise));
    }
  } catch (err) {
    return Promise.reject(err);
  }
}

function wrapArray(item) {
  return [item];
}

function mapMany(items, mapper, opt = {}) {
  return new Promise((resolve, reject) => {
    const concurrency = opt.concurrency || Number.MAX_SAFE_INTEGER;

    const ctx = {
      reject,
      resolve,
      rejected: false,
      index: 0,
      numFinished: 0,
      results: new Array(items.length),
      items,
      mapper,
    };

    while (ctx.index < concurrency && ctx.index < items.length && !ctx.rejected) {
      executeNext(ctx);
    }
  });
}

function executeNext(ctx) {
  try {
    if (ctx.rejected) {
      return;
    }

    const index = ctx.index++;
    const item = ctx.items[index];
    const maybePromise = ctx.mapper(item, index);

    if (isPromise(maybePromise)) {
      maybePromise
        .then((result) => afterExecute(ctx, result, index))
        .catch((err) => onError(ctx, err));
    } else {
      process.nextTick(() => afterExecute(ctx, maybePromise, index));
    }

    return null;
  } catch (err) {
    onError(ctx, err);
  }
}

function afterExecute(ctx, result, index) {
  if (ctx.rejected) {
    return null;
  }

  ctx.results[index] = result;
  ctx.numFinished++;

  if (ctx.numFinished === ctx.items.length) {
    ctx.resolve(ctx.results);
  }

  if (ctx.index < ctx.items.length) {
    executeNext(ctx);
  }

  return null;
}

function onError(ctx, err) {
  ctx.rejected = true;
  ctx.reject(err);
}

module.exports = {
  promiseMap,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/mapAfterAllReturn.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/isPromise.js");

// Map `arr` with `mapper` and after that return `returnValue`. If none of
// the mapped values is a promise, return synchronously for performance
// reasons.
function mapAfterAllReturn(arr, mapper, returnValue) {
  const results = new Array(arr.length);
  let containsPromise = false;

  for (let i = 0, l = arr.length; i < l; ++i) {
    results[i] = mapper(arr[i]);

    if (isPromise(results[i])) {
      containsPromise = true;
    }
  }

  if (containsPromise) {
    return Promise.all(results).then(() => returnValue);
  } else {
    return returnValue;
  }
}

module.exports = {
  mapAfterAllReturn,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/promiseUtils/try.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isPromise } = __webpack_require__("./node_modules/objection/lib/utils/promiseUtils/isPromise.js");

// Works like Bluebird.try.
function promiseTry(callback) {
  try {
    const maybePromise = callback();

    if (isPromise(maybePromise)) {
      return maybePromise;
    } else {
      return Promise.resolve(maybePromise);
    }
  } catch (err) {
    return Promise.reject(err);
  }
}

module.exports = {
  promiseTry,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/resolveModel.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isString, isFunction } = __webpack_require__("./node_modules/objection/lib/utils/objectUtils.js");

function resolveModel(modelRef, modelPaths, errorPrefix) {
  if (isString(modelRef)) {
    throw new Error(`${errorPrefix}: is a string`);
  } else {
    if (isFunction(modelRef) && !isModelClass(modelRef)) {
      modelRef = modelRef();
    }

    if (!isModelClass(modelRef)) {
      throw new Error(`${errorPrefix}: is not a subclass of Model`);
    }

    return modelRef;
  }
}

function isModelClass(maybeModel) {
  return isFunction(maybeModel) && maybeModel.isObjectionModelClass;
}

module.exports = {
  resolveModel,
};


/***/ }),

/***/ "./node_modules/objection/lib/utils/tmpColumnUtils.js":
/***/ ((module) => {

"use strict";


const OWNER_JOIN_COLUMN_ALIAS_PREFIX = 'objectiontmpjoin';

function getTempColumn(index) {
  return `${OWNER_JOIN_COLUMN_ALIAS_PREFIX}${index}`;
}

function isTempColumn(col) {
  return col.startsWith(OWNER_JOIN_COLUMN_ALIAS_PREFIX);
}

module.exports = {
  getTempColumn,
  isTempColumn,
};


/***/ }),

/***/ "./node_modules/pg-connection-string/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


//Parse method copied from https://github.com/brianc/node-postgres
//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
//MIT License

//parses a connection string
function parse(str) {
  //unix socket
  if (str.charAt(0) === '/') {
    const config = str.split(' ')
    return { host: config[0], database: config[1] }
  }

  // Check for empty host in URL

  const config = {}
  let result
  let dummyHost = false
  if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
    // Ensure spaces are encoded as %20
    str = encodeURI(str).replace(/\%25(\d\d)/g, '%$1')
  }

  try {
    result = new URL(str, 'postgres://base')
  } catch (e) {
    // The URL is invalid so try again with a dummy host
    result = new URL(str.replace('@/', '@___DUMMY___/'), 'postgres://base')
    dummyHost = true
  }

  // We'd like to use Object.fromEntries() here but Node.js 10 does not support it
  for (const entry of result.searchParams.entries()) {
    config[entry[0]] = entry[1]
  }

  config.user = config.user || decodeURIComponent(result.username)
  config.password = config.password || decodeURIComponent(result.password)

  if (result.protocol == 'socket:') {
    config.host = decodeURI(result.pathname)
    config.database = result.searchParams.get('db')
    config.client_encoding = result.searchParams.get('encoding')
    return config
  }
  const hostname = dummyHost ? '' : result.hostname
  if (!config.host) {
    // Only set the host if there is no equivalent query param.
    config.host = decodeURIComponent(hostname)
  } else if (hostname && /^%2f/i.test(hostname)) {
    // Only prepend the hostname to the pathname if it is not a URL encoded Unix socket host.
    result.pathname = hostname + result.pathname
  }
  if (!config.port) {
    // Only set the port if there is no equivalent query param.
    config.port = result.port
  }

  const pathname = result.pathname.slice(1) || null
  config.database = pathname ? decodeURI(pathname) : null

  if (config.ssl === 'true' || config.ssl === '1') {
    config.ssl = true
  }

  if (config.ssl === '0') {
    config.ssl = false
  }

  if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
    config.ssl = {}
  }

  // Only try to load fs if we expect to read from the disk
  const fs = config.sslcert || config.sslkey || config.sslrootcert ? __webpack_require__("fs") : null

  if (config.sslcert) {
    config.ssl.cert = fs.readFileSync(config.sslcert).toString()
  }

  if (config.sslkey) {
    config.ssl.key = fs.readFileSync(config.sslkey).toString()
  }

  if (config.sslrootcert) {
    config.ssl.ca = fs.readFileSync(config.sslrootcert).toString()
  }

  switch (config.sslmode) {
    case 'disable': {
      config.ssl = false
      break
    }
    case 'prefer':
    case 'require':
    case 'verify-ca':
    case 'verify-full': {
      break
    }
    case 'no-verify': {
      config.ssl.rejectUnauthorized = false
      break
    }
  }

  return config
}

module.exports = parse

parse.parse = parse


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/***/ ((module) => {

"use strict";


if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.production.min.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f=__webpack_require__("./node_modules/react/index.js"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}__webpack_unused_export__=l;exports.jsx=q;__webpack_unused_export__=q;


/***/ }),

/***/ "./node_modules/react/cjs/react.production.min.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}
var B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};
E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;
H.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
function N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}
var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};function X(){throw Error("act(...) is not supported in production builds of React.");}
exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;exports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;exports.act=X;
exports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};
exports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=X;exports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};
exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};exports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};
exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};exports.useTransition=function(){return U.current.useTransition()};exports.version="18.3.1";


/***/ }),

/***/ "./node_modules/react/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__("./node_modules/react/cjs/react.production.min.js");
} else {}


/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__("./node_modules/react/cjs/react-jsx-runtime.production.min.js");
} else {}


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__("./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__("./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("./node_modules/inherits/inherits.js");
/*</replacement>*/

var Readable = __webpack_require__("./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__("./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__("./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = Object.create(__webpack_require__("./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("./node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__("./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__("./node_modules/readable-stream/node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__("events").EventEmitter);

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__("./node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__("./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("./node_modules/inherits/inherits.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__("util");
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__("./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__("./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__("./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__("./node_modules/string_decoder/lib/string_decoder.js")/* .StringDecoder */ .I);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__("./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__("./node_modules/string_decoder/lib/string_decoder.js")/* .StringDecoder */ .I);
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__("./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = Object.create(__webpack_require__("./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("./node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__("./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__("./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("./node_modules/inherits/inherits.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__("./node_modules/util-deprecate/node.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__("./node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__("./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__("./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__("./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
var util = __webpack_require__("util");

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*<replacement>*/

var pna = __webpack_require__("./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("stream");


/***/ }),

/***/ "./node_modules/readable-stream/node_modules/isarray/index.js":
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/readable-stream/readable.js":
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__("stream");
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__("./node_modules/readable-stream/lib/_stream_readable.js");
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__("./node_modules/readable-stream/lib/_stream_writable.js");
  exports.Duplex = __webpack_require__("./node_modules/readable-stream/lib/_stream_duplex.js");
  exports.Transform = __webpack_require__("./node_modules/readable-stream/lib/_stream_transform.js");
  exports.PassThrough = __webpack_require__("./node_modules/readable-stream/lib/_stream_passthrough.js");
}


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof globalThis === "object" ? globalThis :
            typeof global === "object" ? global :
                typeof self === "object" ? self :
                    typeof this === "object" ? this :
                        sloppyModeThis();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        function makeExporter(target, previous) {
            return function (key, value) {
                Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                if (previous)
                    previous(key, value);
            };
        }
        function functionThis() {
            try {
                return Function("return this;")();
            }
            catch (_) { }
        }
        function indirectEvalThis() {
            try {
                return (void 0, eval)("(function() { return this; })()");
            }
            catch (_) { }
        }
        function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
        }
    })(function (exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(target, propertyKey, /*Create*/ false);
            if (IsUndefined(provider))
                return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ false);
            if (IsUndefined(provider))
                return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ false);
            if (IsUndefined(provider))
                return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ true);
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var provider = GetMetadataProvider(O, P, /*create*/ false);
            if (!provider) {
                return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        // 6 ECMAScript Data Types and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        function SameValueZero(x, y) {
            return x === y || x !== x && y !== y;
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // Global metadata registry
        // - Allows `import "reflect-metadata"` and `import "reflect-metadata/no-conflict"` to interoperate.
        // - Uses isolated metadata if `Reflect` is frozen before the registry can be installed.
        /**
         * Creates a registry used to allow multiple `reflect-metadata` providers.
         */
        function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) &&
                typeof root.Reflect !== "undefined" &&
                !(registrySymbol in root.Reflect) &&
                typeof root.Reflect.defineMetadata === "function") {
                // interoperate with older version of `reflect-metadata` that did not support a registry.
                fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
                registerProvider: registerProvider,
                getProvider: getProvider,
                setProvider: setProvider,
            };
            return registry;
            function registerProvider(provider) {
                if (!Object.isExtensible(registry)) {
                    throw new Error("Cannot add provider to a frozen registry.");
                }
                switch (true) {
                    case fallback === provider: break;
                    case IsUndefined(first):
                        first = provider;
                        break;
                    case first === provider: break;
                    case IsUndefined(second):
                        second = provider;
                        break;
                    case second === provider: break;
                    default:
                        if (rest === undefined)
                            rest = new _Set();
                        rest.add(provider);
                        break;
                }
            }
            function getProviderNoCache(O, P) {
                if (!IsUndefined(first)) {
                    if (first.isProviderFor(O, P))
                        return first;
                    if (!IsUndefined(second)) {
                        if (second.isProviderFor(O, P))
                            return first;
                        if (!IsUndefined(rest)) {
                            var iterator = GetIterator(rest);
                            while (true) {
                                var next = IteratorStep(iterator);
                                if (!next) {
                                    return undefined;
                                }
                                var provider = IteratorValue(next);
                                if (provider.isProviderFor(O, P)) {
                                    IteratorClose(iterator);
                                    return provider;
                                }
                            }
                        }
                    }
                }
                if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
                    return fallback;
                }
                return undefined;
            }
            function getProvider(O, P) {
                var providerMap = targetProviderMap.get(O);
                var provider;
                if (!IsUndefined(providerMap)) {
                    provider = providerMap.get(P);
                }
                if (!IsUndefined(provider)) {
                    return provider;
                }
                provider = getProviderNoCache(O, P);
                if (!IsUndefined(provider)) {
                    if (IsUndefined(providerMap)) {
                        providerMap = new _Map();
                        targetProviderMap.set(O, providerMap);
                    }
                    providerMap.set(P, provider);
                }
                return provider;
            }
            function hasProvider(provider) {
                if (IsUndefined(provider))
                    throw new TypeError();
                return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O, P, provider) {
                if (!hasProvider(provider)) {
                    throw new Error("Metadata provider not registered.");
                }
                var existingProvider = getProvider(O, P);
                if (existingProvider !== provider) {
                    if (!IsUndefined(existingProvider)) {
                        return false;
                    }
                    var providerMap = targetProviderMap.get(O);
                    if (IsUndefined(providerMap)) {
                        providerMap = new _Map();
                        targetProviderMap.set(O, providerMap);
                    }
                    providerMap.set(P, provider);
                }
                return true;
            }
        }
        /**
         * Gets or creates the shared registry of metadata providers.
         */
        function GetOrCreateMetadataRegistry() {
            var metadataRegistry;
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
                metadataRegistry = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry)) {
                metadataRegistry = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
                Object.defineProperty(root.Reflect, registrySymbol, {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: metadataRegistry
                });
            }
            return metadataRegistry;
        }
        function CreateMetadataProvider(registry) {
            // [[Metadata]] internal slot
            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
            var metadata = new _WeakMap();
            var provider = {
                isProviderFor: function (O, P) {
                    var targetMetadata = metadata.get(O);
                    if (IsUndefined(targetMetadata))
                        return false;
                    return targetMetadata.has(P);
                },
                OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata,
                OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata,
                OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata,
                OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys,
                OrdinaryDeleteMetadata: OrdinaryDeleteMetadata,
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O, P, Create) {
                var targetMetadata = metadata.get(O);
                var createdTargetMetadata = false;
                if (IsUndefined(targetMetadata)) {
                    if (!Create)
                        return undefined;
                    targetMetadata = new _Map();
                    metadata.set(O, targetMetadata);
                    createdTargetMetadata = true;
                }
                var metadataMap = targetMetadata.get(P);
                if (IsUndefined(metadataMap)) {
                    if (!Create)
                        return undefined;
                    metadataMap = new _Map();
                    targetMetadata.set(P, metadataMap);
                    if (!registry.setProvider(O, P, provider)) {
                        targetMetadata.delete(P);
                        if (createdTargetMetadata) {
                            metadata.delete(O);
                        }
                        throw new Error("Wrong provider for target.");
                    }
                }
                return metadataMap;
            }
            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                return ToBoolean(metadataMap.has(MetadataKey));
            }
            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return undefined;
                return metadataMap.get(MetadataKey);
            }
            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
                metadataMap.set(MetadataKey, MetadataValue);
            }
            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
            function OrdinaryOwnMetadataKeys(O, P) {
                var keys = [];
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return keys;
                var keysObj = metadataMap.keys();
                var iterator = GetIterator(keysObj);
                var k = 0;
                while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                        keys.length = k;
                        return keys;
                    }
                    var nextValue = IteratorValue(next);
                    try {
                        keys[k] = nextValue;
                    }
                    catch (e) {
                        try {
                            IteratorClose(iterator);
                        }
                        finally {
                            throw e;
                        }
                    }
                    k++;
                }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                if (!metadataMap.delete(MetadataKey))
                    return false;
                if (metadataMap.size === 0) {
                    var targetMetadata = metadata.get(O);
                    if (!IsUndefined(targetMetadata)) {
                        targetMetadata.delete(P);
                        if (targetMetadata.size === 0) {
                            metadata.delete(targetMetadata);
                        }
                    }
                }
                return true;
            }
        }
        function CreateFallbackProvider(reflect) {
            var defineMetadata = reflect.defineMetadata, hasOwnMetadata = reflect.hasOwnMetadata, getOwnMetadata = reflect.getOwnMetadata, getOwnMetadataKeys = reflect.getOwnMetadataKeys, deleteMetadata = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
                isProviderFor: function (O, P) {
                    var metadataPropertySet = metadataOwner.get(O);
                    if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                        return true;
                    }
                    if (getOwnMetadataKeys(O, P).length) {
                        if (IsUndefined(metadataPropertySet)) {
                            metadataPropertySet = new _Set();
                            metadataOwner.set(O, metadataPropertySet);
                        }
                        metadataPropertySet.add(P);
                        return true;
                    }
                    return false;
                },
                OrdinaryDefineOwnMetadata: defineMetadata,
                OrdinaryHasOwnMetadata: hasOwnMetadata,
                OrdinaryGetOwnMetadata: getOwnMetadata,
                OrdinaryOwnMetadataKeys: getOwnMetadataKeys,
                OrdinaryDeleteMetadata: deleteMetadata,
            };
            return provider;
        }
        /**
         * Gets the metadata provider for an object. If the object has no metadata provider and this is for a create operation,
         * then this module's metadata provider is assigned to the object.
         */
        function GetMetadataProvider(O, P, Create) {
            var registeredProvider = metadataRegistry.getProvider(O, P);
            if (!IsUndefined(registeredProvider)) {
                return registeredProvider;
            }
            if (Create) {
                if (metadataRegistry.setProvider(O, P, metadataProvider)) {
                    return metadataProvider;
                }
                throw new Error("Illegal state.");
            }
            return undefined;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            var Map = /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (SameValueZero(key, this._cacheKey)) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (!SameValueZero(this._cacheKey, key)) {
                        this._cacheIndex = -1;
                        for (var i = 0; i < this._keys.length; i++) {
                            if (SameValueZero(this._keys[i], key)) {
                                this._cacheIndex = i;
                                break;
                            }
                        }
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            return Map;
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            var Set = /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.keys(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
            return Set;
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    var array = new Uint8Array(size);
                    if (typeof crypto !== "undefined") {
                        crypto.getRandomValues(array);
                    }
                    else if (typeof msCrypto !== "undefined") {
                        msCrypto.getRandomValues(array);
                    }
                    else {
                        FillRandomBytes(array, size);
                    }
                    return array;
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__("buffer")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/sqlstring/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("./node_modules/sqlstring/lib/SqlString.js");


/***/ }),

/***/ "./node_modules/sqlstring/lib/SqlString.js":
/***/ ((__unused_webpack_module, exports) => {

var SqlString  = exports;

var ID_GLOBAL_REGEXP    = /`/g;
var QUAL_GLOBAL_REGEXP  = /\./g;
var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
var CHARS_ESCAPE_MAP    = {
  '\0'   : '\\0',
  '\b'   : '\\b',
  '\t'   : '\\t',
  '\n'   : '\\n',
  '\r'   : '\\r',
  '\x1a' : '\\Z',
  '"'    : '\\"',
  '\''   : '\\\'',
  '\\'   : '\\\\'
};

SqlString.escapeId = function escapeId(val, forbidQualified) {
  if (Array.isArray(val)) {
    var sql = '';

    for (var i = 0; i < val.length; i++) {
      sql += (i === 0 ? '' : ', ') + SqlString.escapeId(val[i], forbidQualified);
    }

    return sql;
  } else if (forbidQualified) {
    return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``') + '`';
  } else {
    return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
  }
};

SqlString.escape = function escape(val, stringifyObjects, timeZone) {
  if (val === undefined || val === null) {
    return 'NULL';
  }

  switch (typeof val) {
    case 'boolean': return (val) ? 'true' : 'false';
    case 'number': return val + '';
    case 'object':
      if (val instanceof Date) {
        return SqlString.dateToString(val, timeZone || 'local');
      } else if (Array.isArray(val)) {
        return SqlString.arrayToList(val, timeZone);
      } else if (Buffer.isBuffer(val)) {
        return SqlString.bufferToString(val);
      } else if (typeof val.toSqlString === 'function') {
        return String(val.toSqlString());
      } else if (stringifyObjects) {
        return escapeString(val.toString());
      } else {
        return SqlString.objectToValues(val, timeZone);
      }
    default: return escapeString(val);
  }
};

SqlString.arrayToList = function arrayToList(array, timeZone) {
  var sql = '';

  for (var i = 0; i < array.length; i++) {
    var val = array[i];

    if (Array.isArray(val)) {
      sql += (i === 0 ? '' : ', ') + '(' + SqlString.arrayToList(val, timeZone) + ')';
    } else {
      sql += (i === 0 ? '' : ', ') + SqlString.escape(val, true, timeZone);
    }
  }

  return sql;
};

SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
  if (values == null) {
    return sql;
  }

  if (!(values instanceof Array || Array.isArray(values))) {
    values = [values];
  }

  var chunkIndex        = 0;
  var placeholdersRegex = /\?+/g;
  var result            = '';
  var valuesIndex       = 0;
  var match;

  while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
    var len = match[0].length;

    if (len > 2) {
      continue;
    }

    var value = len === 2
      ? SqlString.escapeId(values[valuesIndex])
      : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);

    result += sql.slice(chunkIndex, match.index) + value;
    chunkIndex = placeholdersRegex.lastIndex;
    valuesIndex++;
  }

  if (chunkIndex === 0) {
    // Nothing was replaced
    return sql;
  }

  if (chunkIndex < sql.length) {
    return result + sql.slice(chunkIndex);
  }

  return result;
};

SqlString.dateToString = function dateToString(date, timeZone) {
  var dt = new Date(date);

  if (isNaN(dt.getTime())) {
    return 'NULL';
  }

  var year;
  var month;
  var day;
  var hour;
  var minute;
  var second;
  var millisecond;

  if (timeZone === 'local') {
    year        = dt.getFullYear();
    month       = dt.getMonth() + 1;
    day         = dt.getDate();
    hour        = dt.getHours();
    minute      = dt.getMinutes();
    second      = dt.getSeconds();
    millisecond = dt.getMilliseconds();
  } else {
    var tz = convertTimezone(timeZone);

    if (tz !== false && tz !== 0) {
      dt.setTime(dt.getTime() + (tz * 60000));
    }

    year       = dt.getUTCFullYear();
    month       = dt.getUTCMonth() + 1;
    day         = dt.getUTCDate();
    hour        = dt.getUTCHours();
    minute      = dt.getUTCMinutes();
    second      = dt.getUTCSeconds();
    millisecond = dt.getUTCMilliseconds();
  }

  // YYYY-MM-DD HH:mm:ss.mmm
  var str = zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' +
    zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' +
    zeroPad(millisecond, 3);

  return escapeString(str);
};

SqlString.bufferToString = function bufferToString(buffer) {
  return 'X' + escapeString(buffer.toString('hex'));
};

SqlString.objectToValues = function objectToValues(object, timeZone) {
  var sql = '';

  for (var key in object) {
    var val = object[key];

    if (typeof val === 'function') {
      continue;
    }

    sql += (sql.length === 0 ? '' : ', ') + SqlString.escapeId(key) + ' = ' + SqlString.escape(val, true, timeZone);
  }

  return sql;
};

SqlString.raw = function raw(sql) {
  if (typeof sql !== 'string') {
    throw new TypeError('argument sql must be a string');
  }

  return {
    toSqlString: function toSqlString() { return sql; }
  };
};

function escapeString(val) {
  var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
  var escapedVal = '';
  var match;

  while ((match = CHARS_GLOBAL_REGEXP.exec(val))) {
    escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
    chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
  }

  if (chunkIndex === 0) {
    // Nothing was escaped
    return "'" + val + "'";
  }

  if (chunkIndex < val.length) {
    return "'" + escapedVal + val.slice(chunkIndex) + "'";
  }

  return "'" + escapedVal + "'";
}

function zeroPad(number, length) {
  number = number.toString();
  while (number.length < length) {
    number = '0' + number;
  }

  return number;
}

function convertTimezone(tz) {
  if (tz === 'Z') {
    return 0;
  }

  var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
  if (m) {
    return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
  }
  return false;
}


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__("./node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.I = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/supports-color/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__("os");
const tty = __webpack_require__("tty");
const hasFlag = __webpack_require__("./node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./node_modules/tarn/dist/PendingOperation.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const TimeoutError_1 = __webpack_require__("./node_modules/tarn/dist/TimeoutError.js");
const utils_1 = __webpack_require__("./node_modules/tarn/dist/utils.js");
class PendingOperation {
    constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch(err => {
            if (err instanceof TimeoutError_1.TimeoutError) {
                if (this.possibleTimeoutCause) {
                    err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
                }
                else {
                    err = new TimeoutError_1.TimeoutError('operation timed out for an unknown reason');
                }
            }
            this.isRejected = true;
            return Promise.reject(err);
        });
    }
    abort() {
        this.reject(new Error('aborted'));
    }
    reject(err) {
        this.deferred.reject(err);
    }
    resolve(value) {
        this.deferred.resolve(value);
    }
}
exports.PendingOperation = PendingOperation;
function timeout(promise, time) {
    return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise
            .then(result => {
            clearTimeout(timeoutHandle);
            resolve(result);
        })
            .catch(err => {
            clearTimeout(timeoutHandle);
            reject(err);
        });
    });
}


/***/ }),

/***/ "./node_modules/tarn/dist/Pool.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const PendingOperation_1 = __webpack_require__("./node_modules/tarn/dist/PendingOperation.js");
const Resource_1 = __webpack_require__("./node_modules/tarn/dist/Resource.js");
const utils_1 = __webpack_require__("./node_modules/tarn/dist/utils.js");
const events_1 = __webpack_require__("events");
const timers_1 = __webpack_require__("timers");
class Pool {
    constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
            throw new Error('Tarn: opt.create function most be provided');
        }
        if (!opt.destroy) {
            throw new Error('Tarn: opt.destroy function most be provided');
        }
        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {
            throw new Error('Tarn: opt.min must be an integer >= 0');
        }
        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
            throw new Error('Tarn: opt.max must be an integer > 0');
        }
        if (opt.min > opt.max) {
            throw new Error('Tarn: opt.max is smaller than opt.min');
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +
                JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
            create: true,
            validate: true,
            destroy: true,
            log: true,
            min: true,
            max: true,
            acquireTimeoutMillis: true,
            createTimeoutMillis: true,
            destroyTimeoutMillis: true,
            idleTimeoutMillis: true,
            reapIntervalMillis: true,
            createRetryIntervalMillis: true,
            propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
            if (!allowedKeys[key]) {
                throw new Error(`Tarn: unsupported option opt.${key}`);
            }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;
        this.log = opt.log || (() => { });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;
        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        // All the resources, which are either already acquired or which are
        // considered for being passed to acquire in async validation phase.
        this.used = [];
        // All the resources, which are either just created and free or returned
        // back to pool after using.
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        // When acquire is pending, but also still in validation phase
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
    }
    numUsed() {
        return this.used.length;
    }
    numFree() {
        return this.free.length;
    }
    numPendingAcquires() {
        return this.pendingAcquires.length;
    }
    numPendingValidations() {
        return this.pendingValidations.length;
    }
    numPendingCreates() {
        return this.pendingCreates.length;
    }
    acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers('acquireRequest', eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        // If the acquire fails for whatever reason
        // remove it from the pending queue.
        pendingAcquire.promise = pendingAcquire.promise
            .then(resource => {
            this._executeEventHandlers('acquireSuccess', eventId, resource);
            return resource;
        })
            .catch(err => {
            this._executeEventHandlers('acquireFail', eventId, err);
            remove(this.pendingAcquires, pendingAcquire);
            return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
    }
    release(resource) {
        this._executeEventHandlers('release', resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
            const used = this.used[i];
            if (used.resource === resource) {
                this.used.splice(i, 1);
                this.free.push(used.resolve());
                this._tryAcquireOrCreate();
                return true;
            }
        }
        return false;
    }
    isEmpty() {
        return ([
            this.numFree(),
            this.numUsed(),
            this.numPendingAcquires(),
            this.numPendingValidations(),
            this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0);
    }
    /**
     * Reaping cycle.
     */
    check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach(free => {
            if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis &&
                numDestroyed < maxDestroy) {
                numDestroyed++;
                this._destroy(free.resource);
            }
            else {
                newFree.push(free);
            }
        });
        this.free = newFree;
        // Pool is completely empty, stop reaping.
        // Next .acquire will start reaping interval again.
        if (this.isEmpty()) {
            this._stopReaping();
        }
    }
    destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers('poolDestroyRequest', eventId);
        this._stopReaping();
        this.destroyed = true;
        // First wait for all the pending creates get ready.
        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))
            .then(() => {
            // eslint-disable-next-line
            return new Promise((resolve, reject) => {
                // poll every 100ms and wait that all validations are ready
                if (this.numPendingValidations() === 0) {
                    resolve();
                    return;
                }
                const interval = setInterval(() => {
                    if (this.numPendingValidations() === 0) {
                        timers_1.clearInterval(interval);
                        resolve();
                    }
                }, 100);
            });
        })
            .then(() => {
            // Wait for all the used resources to be freed.
            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));
        })
            .then(() => {
            // Abort all pending acquires.
            return Promise.all(this.pendingAcquires.map(acquire => {
                acquire.abort();
                return utils_1.reflect(acquire.promise);
            }));
        })
            .then(() => {
            // Now we can destroy all the freed resources.
            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));
        })
            .then(() => {
            // Also wait rest of the pending destroys to finish
            return Promise.all(this.pendingDestroys.map(pd => pd.promise));
        })
            .then(() => {
            this.free = [];
            this.pendingAcquires = [];
        })).then(res => {
            this._executeEventHandlers('poolDestroySuccess', eventId);
            this.emitter.removeAllListeners();
            return res;
        });
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
    }
    removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
    }
    /**
     * The most important method that is called always when resources
     * are created / destroyed / acquired / released. In other words
     * every time when resources are moved from used to free or vice
     * versa.
     *
     * Either assigns free resources to pendingAcquires or creates new
     * resources if there is room for it in the pool.
     */
    _tryAcquireOrCreate() {
        if (this.destroyed) {
            return;
        }
        if (this._hasFreeResources()) {
            this._doAcquire();
        }
        else if (this._shouldCreateMoreResources()) {
            this._doCreate();
        }
    }
    _hasFreeResources() {
        return this.free.length > 0;
    }
    _doAcquire() {
        // Acquire as many pending acquires as possible concurrently
        while (this._canAcquire()) {
            // To allow async validation, we actually need to move free resource
            // and pending acquire temporary from their respective arrays and depending
            // on validation result to either leave the free resource to used resources array
            // or destroy the free resource if validation did fail.
            const pendingAcquire = this.pendingAcquires.shift();
            const free = this.free.pop();
            if (free === undefined || pendingAcquire === undefined) {
                const errMessage = 'this.free was empty while trying to acquire resource';
                this.log(`Tarn: ${errMessage}`, 'warn');
                throw new Error(`Internal error, should never happen. ${errMessage}`);
            }
            // Make sure that pendingAcquire that is being validated is not lost and
            // can be freed when pool is destroyed.
            this.pendingValidations.push(pendingAcquire);
            // Must be added here pre-emptively to prevent logic that decides
            // if new resources are created will keep on working correctly.
            this.used.push(free);
            // if acquire fails also pending validation, must be aborted so that pre reserved
            // resource will be returned to free resources immediately
            const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
            // eslint-disable-next-line
            pendingAcquire.promise.catch(err => {
                abortAbleValidation.abort();
            });
            abortAbleValidation.promise
                .catch(err => {
                // There's nothing we can do here but log the error. This would otherwise
                // leak out as an unhandled exception.
                this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');
                return false;
            })
                .then(validationSuccess => {
                try {
                    if (validationSuccess && !pendingAcquire.isRejected) {
                        // At least one active resource exist, start reaping.
                        this._startReaping();
                        pendingAcquire.resolve(free.resource);
                    }
                    else {
                        remove(this.used, free);
                        // Only destroy the resource if the validation has failed
                        if (!validationSuccess) {
                            this._destroy(free.resource);
                            // Since we destroyed an invalid resource and were not able to fulfill
                            // all the pending acquires, we may need to create new ones or at
                            // least run this acquire loop again to verify it. But not immediately
                            // to prevent starving event loop.
                            setTimeout(() => {
                                this._tryAcquireOrCreate();
                            }, 0);
                        }
                        else {
                            this.free.push(free);
                        }
                        // is acquire was canceled, failed or timed out already
                        // no need to return it to pending queries
                        if (!pendingAcquire.isRejected) {
                            this.pendingAcquires.unshift(pendingAcquire);
                        }
                    }
                }
                finally {
                    remove(this.pendingValidations, pendingAcquire);
                }
            });
            // try to validate
            this._validateResource(free.resource)
                .then(validationSuccess => {
                abortAbleValidation.resolve(validationSuccess);
            })
                .catch(err => {
                abortAbleValidation.reject(err);
            });
        }
    }
    _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
    }
    _validateResource(resource) {
        try {
            return Promise.resolve(this.validate(resource));
        }
        catch (err) {
            // prevent leaking of sync exception
            return Promise.reject(err);
        }
    }
    _shouldCreateMoreResources() {
        return (this.used.length + this.pendingCreates.length < this.max &&
            this.pendingCreates.length < this.pendingAcquires.length);
    }
    _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise
            .then(() => {
            // Not returned on purpose.
            this._tryAcquireOrCreate();
            return null;
        })
            .catch(err => {
            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
                // If propagateCreateError is true, we don't retry the create
                // but reject the first pending acquire immediately. Intentionally
                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`
                // in case some acquires in pendingAcquiresBeforeCreate have already
                // been resolved.
                this.pendingAcquires[0].reject(err);
            }
            // Save the create error to all pending acquires so that we can use it
            // as the error to reject the acquire if it times out.
            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {
                pendingAcquire.possibleTimeoutCause = err;
            });
            // Not returned on purpose.
            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
    }
    _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers('createRequest', eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        // If an error occurs (likely a create timeout) remove this creation from
        // the list of pending creations so we try to create a new one.
        pendingCreate.promise = pendingCreate.promise.catch(err => {
            if (remove(this.pendingCreates, pendingCreate)) {
                // TODO: figure out more consistent way for different error handlers in next rewrite
                this._executeEventHandlers('createFail', eventId, err);
            }
            throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator)
            .then(resource => {
            if (pendingCreate.isRejected) {
                this.destroyer(resource);
                return null;
            }
            remove(this.pendingCreates, pendingCreate);
            this.free.push(new Resource_1.Resource(resource));
            // Not returned on purpose.
            pendingCreate.resolve(resource);
            this._executeEventHandlers('createSuccess', eventId, resource);
            return null;
        })
            .catch(err => {
            if (pendingCreate.isRejected) {
                return null;
            }
            if (remove(this.pendingCreates, pendingCreate)) {
                this._executeEventHandlers('createFail', eventId, err);
            }
            // Not returned on purpose.
            pendingCreate.reject(err);
            return null;
        });
        return pendingCreate;
    }
    _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers('destroyRequest', eventId, resource);
        // this.destroyer can be both synchronous and asynchronous.
        // so we wrap it to promise to get all exceptions through same pipeline
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal
            .then(() => {
            pendingDestroy.resolve(resource);
        })
            .catch((err) => {
            pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        // In case of an error there's nothing we can do here but log it.
        return pendingDestroy.promise
            .then(res => {
            this._executeEventHandlers('destroySuccess', eventId, resource);
            return res;
        })
            .catch(err => this._logDestroyerError(eventId, resource, err))
            .then(res => {
            const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);
            this.pendingDestroys.splice(index, 1);
            return res;
        });
    }
    _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers('destroyFail', eventId, resource, err);
        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');
    }
    _startReaping() {
        if (!this.interval) {
            this._executeEventHandlers('startReaping');
            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
    }
    _stopReaping() {
        if (this.interval !== null) {
            this._executeEventHandlers('stopReaping');
            timers_1.clearInterval(this.interval);
        }
        this.interval = null;
    }
    _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        // just calling .emit() would stop running rest of the listeners if one them fails
        listeners.forEach(listener => {
            try {
                listener(...args);
            }
            catch (err) {
                // There's nothing we can do here but log the error. This would otherwise
                // leak out as an unhandled exception.
                this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, 'warn');
            }
        });
    }
}
exports.Pool = Pool;
function remove(arr, item) {
    const idx = arr.indexOf(item);
    if (idx === -1) {
        return false;
    }
    else {
        arr.splice(idx, 1);
        return true;
    }
}
function callbackOrPromise(func) {
    return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(resource);
            }
        };
        utils_1.tryPromise(() => func(callback))
            .then(res => {
            // If the result is falsy, we assume that the callback will
            // be called instead of interpreting the falsy value as a
            // result value.
            if (res) {
                resolve(res);
            }
        })
            .catch(err => {
            reject(err);
        });
    });
}


/***/ }),

/***/ "./node_modules/tarn/dist/PromiseInspection.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class PromiseInspection {
    constructor(args) {
        this._value = args.value;
        this._error = args.error;
    }
    value() {
        return this._value;
    }
    reason() {
        return this._error;
    }
    isRejected() {
        return !!this._error;
    }
    isFulfilled() {
        return !!this._value;
    }
}
exports.PromiseInspection = PromiseInspection;


/***/ }),

/***/ "./node_modules/tarn/dist/Resource.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__("./node_modules/tarn/dist/utils.js");
class Resource {
    constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
    }
    get promise() {
        return this.deferred.promise;
    }
    resolve() {
        this.deferred.resolve(undefined);
        return new Resource(this.resource);
    }
}
exports.Resource = Resource;


/***/ }),

/***/ "./node_modules/tarn/dist/TimeoutError.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class TimeoutError extends Error {
}
exports.TimeoutError = TimeoutError;


/***/ }),

/***/ "./node_modules/tarn/dist/tarn.js":
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Pool_1 = __webpack_require__("./node_modules/tarn/dist/Pool.js");
exports.Pool = Pool_1.Pool;
const TimeoutError_1 = __webpack_require__("./node_modules/tarn/dist/TimeoutError.js");
exports.TimeoutError = TimeoutError_1.TimeoutError;
module.exports = {
    Pool: Pool_1.Pool,
    TimeoutError: TimeoutError_1.TimeoutError
};


/***/ }),

/***/ "./node_modules/tarn/dist/utils.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const PromiseInspection_1 = __webpack_require__("./node_modules/tarn/dist/PromiseInspection.js");
function defer() {
    let resolve = null;
    let reject = null;
    const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
    });
    return {
        promise,
        resolve,
        reject
    };
}
exports.defer = defer;
function now() {
    return Date.now();
}
exports.now = now;
function duration(t1, t2) {
    return Math.abs(t2 - t1);
}
exports.duration = duration;
function checkOptionalTime(time) {
    if (typeof time === 'undefined') {
        return true;
    }
    return checkRequiredTime(time);
}
exports.checkOptionalTime = checkOptionalTime;
function checkRequiredTime(time) {
    return typeof time === 'number' && time === Math.round(time) && time > 0;
}
exports.checkRequiredTime = checkRequiredTime;
function delay(millis) {
    return new Promise(resolve => setTimeout(resolve, millis));
}
exports.delay = delay;
function reflect(promise) {
    return promise
        .then(value => {
        return new PromiseInspection_1.PromiseInspection({ value });
    })
        .catch(error => {
        return new PromiseInspection_1.PromiseInspection({ error });
    });
}
exports.reflect = reflect;
function tryPromise(cb) {
    try {
        const result = cb();
        return Promise.resolve(result);
    }
    catch (err) {
        return Promise.reject(err);
    }
}
exports.tryPromise = tryPromise;


/***/ }),

/***/ "./node_modules/util-deprecate/node.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__("util").deprecate;


/***/ }),

/***/ "better-sqlite3":
/***/ ((module) => {

"use strict";
module.exports = require("better-sqlite3");

/***/ }),

/***/ "sqlite3":
/***/ ((module) => {

"use strict";
module.exports = require("sqlite3");

/***/ }),

/***/ "assert":
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "net":
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:child_process":
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),

/***/ "node:events":
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ "node:fs":
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:path":
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "os":
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "timers":
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tls":
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "./node_modules/colorette/index.cjs":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var tty = __webpack_require__("tty");

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var tty__namespace = /*#__PURE__*/_interopNamespace(tty);

const {
  env = {},
  argv = [],
  platform = "",
} = typeof process === "undefined" ? {} : process;

const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env.TERM === "dumb";

const isCompatibleTerminal =
  tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;

const isCI =
  "CI" in env &&
  ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);

const isColorSupported =
  !isDisabled &&
  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);

const replaceClose = (
  index,
  string,
  close,
  replace,
  head = string.substring(0, index) + replace,
  tail = string.substring(index + close.length),
  next = tail.indexOf(close)
) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));

const clearBleed = (index, string, open, close, replace) =>
  index < 0
    ? open + string + close
    : open + replaceClose(index, string, close, replace) + close;

const filterEmpty =
  (open, close, replace = open, at = open.length + 1) =>
  (string) =>
    string || !(string === "" || string === undefined)
      ? clearBleed(
          ("" + string).indexOf(close, at),
          string,
          open,
          close,
          replace
        )
      : "";

const init = (open, close, replace) =>
  filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);

const colors = {
  reset: init(0, 0),
  bold: init(1, 22, "\x1b[22m\x1b[1m"),
  dim: init(2, 22, "\x1b[22m\x1b[2m"),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49),
  blackBright: init(90, 39),
  redBright: init(91, 39),
  greenBright: init(92, 39),
  yellowBright: init(93, 39),
  blueBright: init(94, 39),
  magentaBright: init(95, 39),
  cyanBright: init(96, 39),
  whiteBright: init(97, 39),
  bgBlackBright: init(100, 49),
  bgRedBright: init(101, 49),
  bgGreenBright: init(102, 49),
  bgYellowBright: init(103, 49),
  bgBlueBright: init(104, 49),
  bgMagentaBright: init(105, 49),
  bgCyanBright: init(106, 49),
  bgWhiteBright: init(107, 49),
};

const createColors = ({ useColor = isColorSupported } = {}) =>
  useColor
    ? colors
    : Object.keys(colors).reduce(
        (colors, key) => ({ ...colors, [key]: String }),
        {}
      );

const {
  reset,
  bold,
  dim,
  italic,
  underline,
  inverse,
  hidden,
  strikethrough,
  black,
  red,
  green,
  yellow,
  blue,
  magenta,
  cyan,
  white,
  gray,
  bgBlack,
  bgRed,
  bgGreen,
  bgYellow,
  bgBlue,
  bgMagenta,
  bgCyan,
  bgWhite,
  blackBright,
  redBright,
  greenBright,
  yellowBright,
  blueBright,
  magentaBright,
  cyanBright,
  whiteBright,
  bgBlackBright,
  bgRedBright,
  bgGreenBright,
  bgYellowBright,
  bgBlueBright,
  bgMagentaBright,
  bgCyanBright,
  bgWhiteBright,
} = createColors();

exports.bgBlack = bgBlack;
exports.bgBlackBright = bgBlackBright;
exports.bgBlue = bgBlue;
exports.bgBlueBright = bgBlueBright;
exports.bgCyan = bgCyan;
exports.bgCyanBright = bgCyanBright;
exports.bgGreen = bgGreen;
exports.bgGreenBright = bgGreenBright;
exports.bgMagenta = bgMagenta;
exports.bgMagentaBright = bgMagentaBright;
exports.bgRed = bgRed;
exports.bgRedBright = bgRedBright;
exports.bgWhite = bgWhite;
exports.bgWhiteBright = bgWhiteBright;
exports.bgYellow = bgYellow;
exports.bgYellowBright = bgYellowBright;
exports.black = black;
exports.blackBright = blackBright;
exports.blue = blue;
exports.blueBright = blueBright;
exports.bold = bold;
exports.createColors = createColors;
exports.cyan = cyan;
exports.cyanBright = cyanBright;
exports.dim = dim;
exports.gray = gray;
exports.green = green;
exports.greenBright = greenBright;
exports.hidden = hidden;
exports.inverse = inverse;
exports.isColorSupported = isColorSupported;
exports.italic = italic;
exports.magenta = magenta;
exports.magentaBright = magentaBright;
exports.red = red;
exports.redBright = redBright;
exports.reset = reset;
exports.strikethrough = strikethrough;
exports.underline = underline;
exports.white = white;
exports.whiteBright = whiteBright;
exports.yellow = yellow;
exports.yellowBright = yellowBright;


/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.mjs":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BigNumber: () => (/* binding */ BigNumber),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 *      bignumber.js v9.0.0
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


var
  isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,

  mathceil = Math.ceil,
  mathfloor = Math.floor,

  bignumberError = '[BigNumber Error] ',
  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

  BASE = 1e14,
  LOG_BASE = 14,
  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  SQRT_BASE = 1e7,

  // EDITABLE
  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
  // the arguments to toExponential, toFixed, toFormat, and toPrecision.
  MAX = 1E9;                                   // 0 to MAX_INT32


/*
 * Create and return a BigNumber constructor.
 */
function clone(configObject) {
  var div, convertBase, parseNumeric,
    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
    ONE = new BigNumber(1),


    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.

    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20,                     // 0 to MAX

    // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4,                       // 0 to 8

    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7,                         // 0 to -MAX

    // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21,                         // 0 to MAX

    // RANGE : [MIN_EXP, MAX_EXP]

    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7,                          // -1 to -MAX

    // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7,                           // 1 to MAX

    // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false,                          // true or false

    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1,                         // 0 to 9

    // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0,                    // 0 to MAX

    // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
      prefix: '',
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ',',
      decimalSeparator: '.',
      fractionGroupSize: 0,
      fractionGroupSeparator: '\xA0',      // non-breaking space
      suffix: ''
    },

    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


  //------------------------------------------------------------------------------------------


  // CONSTRUCTOR


  /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */
  function BigNumber(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str,
      x = this;

    // Enable constructor call without `new`.
    if (!(x instanceof BigNumber)) return new BigNumber(v, b);

    if (b == null) {

      if (v && v._isBigNumber === true) {
        x.s = v.s;

        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }

        return;
      }

      if ((isNum = typeof v == 'number') && v * 0 == 0) {

        // Use `1 / n` to handle minus zero also.
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;

        // Fast path for integers, where n < 2147483648 (2**31).
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);

          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }

          return;
        }

        str = String(v);
      } else {

        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

    } else {

      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
      intCheck(b, 2, ALPHABET.length, 'Base');

      // Allow exponential notation to be used with base 10 argument, while
      // also rounding to DECIMAL_PLACES as with other bases.
      if (b == 10) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }

      str = String(v);

      if (isNum = typeof v == 'number') {

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error
           (tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }

      alphabet = ALPHABET.slice(0, b);
      e = i = 0;

      // Check that str is a valid base b number.
      // Don't use RegExp, so alphabet can contain special characters.
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {

            // If '.' is not the first character and it has not be found before.
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {

            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }

          return parseNumeric(x, String(v), isNum, b);
        }
      }

      // Prevent later check for length on converted number.
      isNum = false;
      str = convertBase(str, b, 10, x.s);

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
      else e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(--len) === 48;);

    if (str = str.slice(i, ++len)) {
      len -= i;

      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
      if (isNum && BigNumber.DEBUG &&
        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error
           (tooManyDigits + (x.s * v));
      }

       // Overflow?
      if ((e = e - i - 1) > MAX_EXP) {

        // Infinity.
        x.c = x.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first element of the coefficient array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;  // i < 1

        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));

          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }

          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }

        for (; i--; str += '0');
        x.c.push(+str);
      }
    } else {

      // Zero.
      x.c = [x.e = 0];
    }
  }


  // CONSTRUCTOR PROPERTIES


  BigNumber.clone = clone;

  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;


  /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                     not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */
  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;

    if (obj != null) {

      if (typeof obj == 'object') {

        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }

        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }

        // EXPONENTIAL_AT {number|number[]}
        // Integer, -MAX to MAX inclusive or
        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }

        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error
               (bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        }

        // CRYPTO {boolean} true or false.
        // '[BigNumber Error] CRYPTO not true or false: {v}'
        // '[BigNumber Error] crypto unavailable'
        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto &&
               (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error
             (bignumberError + p + ' not true or false: ' + v);
          }
        }

        // MODULO_MODE {number} Integer, 0 to 9 inclusive.
        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }

        // POW_PRECISION {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }

        // FORMAT {object}
        // '[BigNumber Error] FORMAT not an object: {v}'
        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;
          else throw Error
           (bignumberError + p + ' not an object: ' + v);
        }

        // ALPHABET {string}
        // '[BigNumber Error] ALPHABET invalid: {v}'
        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p];

          // Disallow if only one character,
          // or if it contains '+', '-', '.', whitespace, or a repeated character.
          if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
            ALPHABET = v;
          } else {
            throw Error
             (bignumberError + p + ' invalid: ' + v);
          }
        }

      } else {

        // '[BigNumber Error] Object expected: {v}'
        throw Error
         (bignumberError + 'Object expected: ' + obj);
      }
    }

    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };


  /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */
  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;

    var i, n,
      c = v.c,
      e = v.e,
      s = v.s;

    out: if ({}.toString.call(c) == '[object Array]') {

      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

        // If the first element is zero, the BigNumber value must be zero.
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }

        // Calculate number of digits that c[0] should have, based on the exponent.
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;

        // Calculate number of digits of c[0].
        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
        if (String(c[0]).length == i) {

          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }

          // Last element cannot be zero, unless it is the only element.
          if (n !== 0) return true;
        }
      }

    // Infinity/NaN
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }

    throw Error
      (bignumberError + 'Invalid BigNumber: ' + v);
  };


  /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, P.lt);
  };


  /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, P.gt);
  };


  /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */
  BigNumber.random = (function () {
    var pow2_53 = 0x20000000000000;

    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
    // Check if Math.random() produces more than 32 bits of randomness.
    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
     ? function () { return mathfloor(Math.random() * pow2_53); }
     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
       (Math.random() * 0x800000 | 0); };

    return function (dp) {
      var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);

      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);

      k = mathceil(dp / LOG_BASE);

      if (CRYPTO) {

        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {

          a = crypto.getRandomValues(new Uint32Array(k *= 2));

          for (; i < k;) {

            // 53 bits:
            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
            //                                     11111 11111111 11111111
            // 0x20000 is 2^21.
            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

            // Rejection sampling:
            // 0 <= v < 9007199254740992
            // Probability that v >= 9e15, is
            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {

              // 0 <= v <= 8999999999999999
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

          // buffer
          a = crypto.randomBytes(k *= 7);

          for (; i < k;) {

            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
            // 0x100000000 is 2^32, 0x1000000 is 2^24
            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
            // 0 <= v < 9007199254740992
            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {

              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error
           (bignumberError + 'crypto unavailable');
        }
      }

      // Use Math.random.
      if (!CRYPTO) {

        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }

      k = c[--i];
      dp %= LOG_BASE;

      // Convert trailing digits to zeros according to dp.
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }

      // Remove trailing elements which are zero.
      for (; c[i] === 0; c.pop(), i--);

      // Zero?
      if (i < 0) {
        c = [e = 0];
      } else {

        // Remove leading elements which are zero and adjust exponent accordingly.
        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

        // Count the digits of the first element of c to determine leading zeros, and...
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

        // adjust the exponent accordingly.
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }

      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();


   /*
   * Return a BigNumber whose value is the sum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.sum = function () {
    var i = 1,
      args = arguments,
      sum = new BigNumber(args[0]);
    for (; i < args.length;) sum = sum.plus(args[i++]);
    return sum;
  };


  // PRIVATE FUNCTIONS


  // Called by BigNumber and BigNumber.prototype.toString.
  convertBase = (function () {
    var decimal = '0123456789';

    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        len = str.length;

      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

        arr[0] += alphabet.indexOf(str.charAt(i++));

        for (j = 0; j < arr.length; j++) {

          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }

    // Convert a numeric string of baseIn to a numeric string of baseOut.
    // If the caller is toString, we are converting from base 10 to baseOut.
    // If the caller is BigNumber, we are converting from baseIn to base 10.
    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y,
        i = str.indexOf('.'),
        dp = DECIMAL_PLACES,
        rm = ROUNDING_MODE;

      // Non-integer.
      if (i >= 0) {
        k = POW_PRECISION;

        // Unlimited precision.
        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;

        // Convert str as if an integer, then restore the fraction part by dividing the
        // result by its base raised to a power.

        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
         10, baseOut, decimal);
        y.e = y.c.length;
      }

      // Convert the number as integer.

      xc = toBaseOut(str, baseIn, baseOut, callerIsToString
       ? (alphabet = ALPHABET, decimal)
       : (alphabet = decimal, ALPHABET));

      // xc now represents str as an integer and converted to baseOut. e is the exponent.
      e = k = xc.length;

      // Remove trailing zeros.
      for (; xc[--k] == 0; xc.pop());

      // Zero?
      if (!xc[0]) return alphabet.charAt(0);

      // Does str represent an integer? If so, no need for the division.
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;

        // The sign is needed for correct rounding.
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }

      // xc now represents str converted to baseOut.

      // THe index of the rounding digit.
      d = e + dp + 1;

      // The rounding digit: the digit to the right of the digit that may be rounded up.
      i = xc[d];

      // Look at the rounding digits and mode to determine whether to round up.

      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;

      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
             rm == (x.s < 0 ? 8 : 7));

      // If the index of the rounding digit is not greater than zero, or xc represents
      // zero, then the result of the base conversion is zero or, if rounding up, a value
      // such as 0.00001.
      if (d < 1 || !xc[0]) {

        // 1^-dp or 0
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {

        // Truncate xc to the required number of decimal places.
        xc.length = d;

        // Round up?
        if (r) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;

            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }

        // Determine trailing zeros.
        for (k = xc.length; !xc[--k];);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

        // Add leading zeros, decimal point and trailing zeros as required.
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }

      // The caller will add the sign.
      return str;
    };
  })();


  // Perform division in the specified base. Called by div and convertBase.
  div = (function () {

    // Assume non-zero x and k.
    function multiply(x, k, base) {
      var m, temp, xlo, xhi,
        carry = 0,
        i = x.length,
        klo = k % SQRT_BASE,
        khi = k / SQRT_BASE | 0;

      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }

      if (carry) x = [carry].concat(x);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, cmp;

      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {

        for (i = cmp = 0; i < aL; i++) {

          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return cmp;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1; a.splice(0, 1));
    }

    // x: dividend, y: divisor.
    return function (x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
        yL, yz,
        s = x.s == y.s ? 1 : -1,
        xc = x.c,
        yc = y.c;

      // Either NaN, Infinity or 0?
      if (!xc || !xc[0] || !yc || !yc[0]) {

        return new BigNumber(

         // Return NaN if either NaN, or both Infinity or 0.
         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0
       );
      }

      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;

      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }

      // Result exponent may be one less then the current value of e.
      // The coefficients of the BigNumbers from convertBase may have trailing zeros.
      for (i = 0; yc[i] == (xc[i] || 0); i++);

      if (yc[i] > (xc[i] || 0)) e--;

      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;

        // Normalise xc and yc so highest order digit of yc is >= base / 2.

        n = mathfloor(base / (yc[0] + 1));

        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }

        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL; rem[remL++] = 0);
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        // Not necessary, but to prevent trial digit n > base, when using base 3.
        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

        do {
          n = 0;

          // Compare divisor and remainder.
          cmp = compare(yc, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, n.

            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

            // n is how many times the divisor goes into the current remainder.
            n = mathfloor(rem0 / yc0);

            //  Algorithm:
            //  product = divisor multiplied by trial digit (n).
            //  Compare product and remainder.
            //  If product is greater than remainder:
            //    Subtract divisor from product, decrement trial digit.
            //  Subtract product from remainder.
            //  If product was less than remainder at the last compare:
            //    Compare new remainder and divisor.
            //    If remainder is greater than divisor:
            //      Subtract divisor from remainder, increment trial digit.

            if (n > 1) {

              // n may be > base only when base is 3.
              if (n >= base) n = base - 1;

              // product = divisor * trial digit.
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              // If product > remainder then trial digit n too high.
              // n is 1 too high about 5% of the time, and is not known to have
              // ever been more than 1 too high.
              while (compare(prod, rem, prodL, remL) == 1) {
                n--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {

              // n is 0 or 1, cmp is -1.
              // If n is 0, there is no need to compare yc and rem again below,
              // so change cmp to 1 to avoid it.
              // If n is 1, leave cmp as -1, so yc and rem are compared again.
              if (n == 0) {

                // divisor < remainder, so n must be at least 1.
                cmp = n = 1;
              }

              // product = divisor
              prod = yc.slice();
              prodL = prod.length;
            }

            if (prodL < remL) prod = [0].concat(prod);

            // Subtract product from remainder.
            subtract(rem, prod, remL, base);
            remL = rem.length;

             // If product was < remainder.
            if (cmp == -1) {

              // Compare divisor and new remainder.
              // If divisor < new remainder, subtract divisor from remainder.
              // Trial digit n too low.
              // n is 1 too low about 5% of the time, and very rarely 2 too low.
              while (compare(yc, rem, yL, remL) < 1) {
                n++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          } // else cmp === 1 and n will be 0

          // Add the next digit, n, to the result array.
          qc[i++] = n;

          // Update the remainder.
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);

        more = rem[0] != null;

        // Leading zero?
        if (!qc[0]) qc.splice(0, 1);
      }

      if (base == BASE) {

        // To calculate q.e, first get the number of digits of qc[0].
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

      // Caller is convertBase.
      } else {
        q.e = e;
        q.r = +more;
      }

      return q;
    };
  })();


  /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;

    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);

    if (!n.c) return n.toString();

    c0 = n.c[0];
    ne = n.e;

    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
       ? toExponential(str, ne)
       : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm);

      // n.e may have changed if the value was rounded up.
      e = n.e;

      str = coeffToString(n.c);
      len = str.length;

      // toPrecision returns exponential notation if the number of significant digits
      // specified is less than the number of digits necessary to represent the integer
      // part of the value in fixed-point notation.

      // Exponential notation.
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

        // Append zeros?
        for (; len < i; str += '0', len++);
        str = toExponential(str, e);

      // Fixed-point notation.
      } else {
        i -= ne;
        str = toFixedPoint(str, e, '0');

        // Append zeros?
        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += '.';
            for (; i--; str += '0');
          }
        }
      }
    }

    return n.s < 0 && c0 ? '-' + str : str;
  }


  // Handle BigNumber.max and BigNumber.min.
  function maxOrMin(args, method) {
    var n,
      i = 1,
      m = new BigNumber(args[0]);

    for (; i < args.length; i++) {
      n = new BigNumber(args[i]);

      // If any number is NaN, return NaN.
      if (!n.s) {
        m = n;
        break;
      } else if (method.call(m, n)) {
        m = n;
      }
    }

    return m;
  }


  /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */
  function normalise(n, c, e) {
    var i = 1,
      j = c.length;

     // Remove trailing zeros.
    for (; !c[--j]; c.pop());

    // Calculate the base 10 exponent. First get the number of digits of c[0].
    for (j = c[0]; j >= 10; j /= 10, i++);

    // Overflow?
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

      // Infinity.
      n.c = n.e = null;

    // Underflow?
    } else if (e < MIN_EXP) {

      // Zero.
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }

    return n;
  }


  // Handle values that fail the validity test in BigNumber.
  parseNumeric = (function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      dotAfter = /^([^.]+)\.$/,
      dotBefore = /^\.([^.]+)$/,
      isInfinityOrNaN = /^-?(Infinity|NaN)$/,
      whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

    return function (x, str, isNum, b) {
      var base,
        s = isNum ? str : str.replace(whitespaceOrPlus, '');

      // No exception on Infinity or NaN.
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {

          // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });

          if (b) {
            base = b;

            // E.g. '1.' to '1', '.1' to '0.1'
            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }

          if (str != s) return new BigNumber(s, base);
        }

        // '[BigNumber Error] Not a number: {n}'
        // '[BigNumber Error] Not a base {b} number: {n}'
        if (BigNumber.DEBUG) {
          throw Error
            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        }

        // NaN
        x.s = null;
      }

      x.c = x.e = null;
    }
  })();


  /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd,
      xc = x.c,
      pows10 = POWS_TEN;

    // if x is not Infinity or NaN...
    if (xc) {

      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
      // n is a base 1e14 number, the value of the element of array x.c containing rd.
      // ni is the index of n within x.c.
      // d is the number of digits of n.
      // i is the index of rd within n including leading zeros.
      // j is the actual index of rd within n (if < 0, rd is a leading zero).
      out: {

        // Get the number of digits of the first element of xc.
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
        i = sd - d;

        // If the rounding digit is in the first element of xc...
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];

          // Get the rounding digit at index j of n.
          rd = n / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);

          if (ni >= xc.length) {

            if (r) {

              // Needed by sqrt.
              for (; xc.length <= ni; xc.push(0));
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];

            // Get the number of digits of n.
            for (d = 1; k >= 10; k /= 10, d++);

            // Get the index of rd within n.
            i %= LOG_BASE;

            // Get the index of rd within n, adjusted for leading zeros.
            // The number of leading zeros of n is given by LOG_BASE - d.
            j = i - LOG_BASE + d;

            // Get the rounding digit at index j of n.
            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
          }
        }

        r = r || sd < 0 ||

        // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

        r = rm < 4
         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
           rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xc[0]) {
          xc.length = 0;

          if (r) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {

            // Zero.
            xc[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of n.
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }

        // Round up?
        if (r) {

          for (; ;) {

            // If the digit to be rounded up is in the first element of xc...
            if (ni == 0) {

              // i will be the length of xc[0] before k is added.
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++);

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }

              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xc.length; xc[--i] === 0; xc.pop());
      }

      // Overflow? Infinity.
      if (x.e > MAX_EXP) {
        x.c = x.e = null;

      // Underflow? Zero.
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }

    return x;
  }


  function valueOf(n) {
    var str,
      e = n.e;

    if (e === null) return n.toString();

    str = coeffToString(n.c);

    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
      ? toExponential(str, e)
      : toFixedPoint(str, e, '0');

    return n.s < 0 ? '-' + str : str;
  }


  // PROTOTYPE/INSTANCE METHODS


  /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */
  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };


  /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */
  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };


  /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.decimalPlaces = P.dp = function (dp, rm) {
    var c, n, v,
      x = this;

    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), dp + x.e + 1, rm);
    }

    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last number.
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };


  /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */
  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };


  /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */
  P.exponentiatedBy = P.pow = function (n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
      x = this;

    n = new BigNumber(n);

    // Allow NaN and Infinity, but not other non-integers.
    if (n.c && !n.isInteger()) {
      throw Error
        (bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }

    if (m != null) m = new BigNumber(m);

    // Exponent of MAX_SAFE_INTEGER is 15.
    nIsBig = n.e > 14;

    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

      // The sign of the result of pow when x is negative depends on the evenness of n.
      // If +n overflows to Infinity, the evenness of n would be not be known.
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }

    nIsNeg = n.s < 0;

    if (m) {

      // x % m returns NaN if abs(m) is zero, or m is NaN.
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

      isModExp = !nIsNeg && x.isInteger() && m.isInteger();

      if (isModExp) x = x.mod(m);

    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

      // If x is negative and n is odd, k = -0, else k = 0.
      k = x.s < 0 && isOdd(n) ? -0 : 0;

      // If x >= 1, k = Infinity.
      if (x.e > -1) k = 1 / k;

      // If n is negative return 0, else return Infinity.
      return new BigNumber(nIsNeg ? 1 / k : k);

    } else if (POW_PRECISION) {

      // Truncating each coefficient array to a length of k after each multiplication
      // equates to truncating significant digits to POW_PRECISION + [28, 41],
      // i.e. there will be a minimum of 28 guard digits retained.
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }

    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }

    y = new BigNumber(ONE);

    // Performs 54 loop iterations for n of 9007199254740991.
    for (; ;) {

      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;

        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
        }
      }

      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);

        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }

      x = x.times(x);

      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
      }
    }

    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);

    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */
  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };


  /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };


  /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */
  P.isFinite = function () {
    return !!this.c;
  };


  /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };


  /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

  };


  /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */
  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };


  /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };


  /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };


  /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */
  P.isNegative = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */
  P.isPositive = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */
  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */
  P.minus = function (y, b) {
    var i, j, t, xLTy,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Either Infinity?
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

      // Either zero?
      if (!xc[0] || !yc[0]) {

        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
         ROUNDING_MODE == 3 ? -0 : 0);
      }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Determine which is the bigger number.
    if (a = xe - ye) {

      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse();

      // Prepend zeros to equalise exponents.
      for (b = a; b--; t.push(0));
      t.reverse();
    } else {

      // Exponents equal. Check digit by digit.
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

      for (a = b = 0; b < j; b++) {

        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

    b = (j = yc.length) - (i = xc.length);

    // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1;

    // Subtract yc from xc.
    for (; j > a;) {

      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);
        --xc[i];
        xc[j] += BASE;
      }

      xc[j] -= yc[j];
    }

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] == 0; xc.splice(0, 1), --ye);

    // Zero?
    if (!xc[0]) {

      // Following IEEE 754 (2008) 6.3,
      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }

    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
    // for finite x and y.
    return normalise(y, xc, ye);
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */
  P.modulo = P.mod = function (y, b) {
    var q, s,
      x = this;

    y = new BigNumber(y, b);

    // Return NaN if x is Infinity or NaN, or y is NaN or zero.
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN);

    // Return x if y is Infinity or x is zero.
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }

    if (MODULO_MODE == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // r = x - qy    where  0 <= r < abs(y)
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }

    y = x.minus(q.times(y));

    // To match JavaScript %, ensure sign of zero is sign of dividend.
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

    return y;
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */
  P.multipliedBy = P.times = function (y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
      base, sqrtBase,
      x = this,
      xc = x.c,
      yc = (y = new BigNumber(y, b)).c;

    // Either NaN, Infinity or 0?
    if (!xc || !yc || !xc[0] || !yc[0]) {

      // Return NaN if either is NaN, or one is 0 and the other is Infinity.
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;

        // Return Infinity if either is Infinity.
        if (!xc || !yc) {
          y.c = y.e = null;

        // Return 0 if either is 0.
        } else {
          y.c = [0];
          y.e = 0;
        }
      }

      return y;
    }

    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;

    // Ensure xc points to longer array and xcL to its length.
    if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

    // Initialise the result array with zeros.
    for (i = xcL + ycL, zc = []; i--; zc.push(0));

    base = BASE;
    sqrtBase = SQRT_BASE;

    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;

      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }

      zc[j] = c;
    }

    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }

    return normalise(y, zc, e);
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */
  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */
  P.plus = function (y, b) {
    var t,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
     if (a != b) {
      y.s = -b;
      return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Return Infinity if either Infinity.
      if (!xc || !yc) return new BigNumber(a / 0);

      // Either zero?
      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }

      t.reverse();
      for (; a--; t.push(0));
      t.reverse();
    }

    a = xc.length;
    b = yc.length;

    // Point xc to the longer array, and b to the shorter length.
    if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    // ye = MAX_EXP + 1 possible
    return normalise(y, xc, ye);
  };


  /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.precision = P.sd = function (sd, rm) {
    var c, n, v,
      x = this;

    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), sd, rm);
    }

    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if (v = c[v]) {

      // Subtract the number of trailing zeros of the last element.
      for (; v % 10 == 0; v /= 10, n--);

      // Add the number of digits of the first element.
      for (v = c[0]; v >= 10; v /= 10, n++);
    }

    if (sd && x.e + 1 > n) n = x.e + 1;

    return n;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */
  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };


  /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, r, rep, t,
      x = this,
      c = x.c,
      s = x.s,
      e = x.e,
      dp = DECIMAL_PLACES + 4,
      half = new BigNumber('0.5');

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }

    // Initial estimate.
    s = Math.sqrt(+valueOf(x));

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '1e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    }

    // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;

      // Newton-Raphson iteration.
      for (; ;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));

        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

          // The exponent of r may here be one less than the final result exponent,
          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
          // are indexed correctly.
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
          // iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the
            // exact result as the nines may infinitely repeat.
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            dp += 4;
            s += 4;
            rep = 1;
          } else {

            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
            // result. If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }
    }

    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };


  /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */
  P.toFormat = function (dp, rm, format) {
    var str,
      x = this;

    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error
        (bignumberError + 'Argument not an object: ' + format);
    }

    str = x.toFixed(dp, rm);

    if (x.c) {
      var i,
        arr = str.split('.'),
        g1 = +format.groupSize,
        g2 = +format.secondaryGroupSize,
        groupSeparator = format.groupSeparator || '',
        intPart = arr[0],
        fractionPart = arr[1],
        isNeg = x.s < 0,
        intDigits = isNeg ? intPart.slice(1) : intPart,
        len = intDigits.length;

      if (g2) i = g1, g1 = g2, g2 = i, len -= i;

      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }

      str = fractionPart
       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
        ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
         '$&' + (format.fractionGroupSeparator || ''))
        : fractionPart)
       : intPart;
    }

    return (format.prefix || '') + str + (format.suffix || '');
  };


  /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */
  P.toFraction = function (md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
      x = this,
      xc = x.c;

    if (md != null) {
      n = new BigNumber(md);

      // Throw if md is less than one or is not an integer, unless it is Infinity.
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error
          (bignumberError + 'Argument ' +
            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }

    if (!xc) return new BigNumber(x);

    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc);

    // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);

    // n0 = d1 = 0
    n0.c[0] = 0;

    for (; ;)  {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }

    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;

    // Determine which fraction is closer to x, n0/d0 or n1/d1
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

    MAX_EXP = exp;

    return r;
  };


  /*
   * Return the value of this BigNumber converted to a number primitive.
   */
  P.toNumber = function () {
    return +valueOf(this);
  };


  /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };


  /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */
  P.toString = function (b) {
    var str,
      n = this,
      s = n.s,
      e = n.e;

    // Infinity or NaN?
    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS
         ? toExponential(coeffToString(n.c), e)
         : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }

      if (s < 0 && n.c[0]) str = '-' + str;
    }

    return str;
  };


  /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */
  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };


  P._isBigNumber = true;

  P[Symbol.toStringTag] = 'BigNumber';

  // Node.js v10.12.0+
  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;

  if (configObject != null) BigNumber.set(configObject);

  return BigNumber;
}


// PRIVATE HELPER FUNCTIONS

// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}


// Return a coefficient array as a string of base 10 digits.
function coeffToString(a) {
  var s, z,
    i = 1,
    j = a.length,
    r = a[0] + '';

  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;
    for (; z--; s = '0' + s);
    r += s;
  }

  // Determine trailing zeros.
  for (j = r.length; r.charCodeAt(--j) === 48;);

  return r.slice(0, j + 1 || 1);
}


// Compare the value of BigNumbers x and y.
function compare(x, y) {
  var a, b,
    xc = x.c,
    yc = y.c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either NaN?
  if (!i || !j) return null;

  a = xc && !xc[0];
  b = yc && !yc[0];

  // Either zero?
  if (a || b) return a ? b ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  a = i < 0;
  b = k == l;

  // Either Infinity?
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

  // Compare exponents.
  if (!b) return k > l ^ a ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

  // Compare lengths.
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}


/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error
     (bignumberError + (name || 'Argument') + (typeof n == 'number'
       ? n < min || n > max ? ' out of range: ' : ' not an integer: '
       : ' not a primitive number: ') + String(n));
  }
}


// Assumes finite n.
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}


function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
   (e < 0 ? 'e' : 'e+') + e;
}


function toFixedPoint(str, e, z) {
  var len, zs;

  // Negative exponent?
  if (e < 0) {

    // Prepend zeros.
    for (zs = z + '.'; ++e; zs += z);
    str = zs + str;

  // Positive exponent
  } else {
    len = str.length;

    // Append zeros.
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }

  return str;
}


// EXPORT


var BigNumber = clone();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigNumber);


/***/ }),

/***/ "./node_modules/ajv/dist/refs/data.json":
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-draft-07.json":
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');

/***/ }),

/***/ "./node_modules/dotenv/package.json":
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"dotenv","version":"16.4.7","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

;// ./node_modules/@fastr/lang/lib/debug.js
const typeId = (arg) => {
    switch (arg) {
        case undefined:
            return "<undefined>";
        case null:
            return "<null>";
    }
    switch (typeof arg) {
        case "symbol":
            return arg.description ? `<symbol ${arg.description}>` : "<symbol>";
        case "boolean":
            return `<boolean ${arg}>`;
        case "number":
            return `<number ${arg}>`;
        case "string":
            return `<string "${arg}">`;
        case "bigint":
            return `<bigint ${arg}>`;
        case "function":
            if (arg.name) {
                return `<function ${arg.name}>`;
            }
            else {
                return `<function>`;
            }
    }
    return Object.prototype.toString.call(arg);
};

// EXTERNAL MODULE: ./node_modules/reflect-metadata/Reflect.js
var reflect_metadata_Reflect = __webpack_require__("./node_modules/reflect-metadata/Reflect.js");
;// ./node_modules/@fastr/lang/lib/metadata.js

const hasMetadata = (metadataKey, target, propertyKey) => {
    if (propertyKey != null) {
        return Reflect.hasMetadata(metadataKey, target, propertyKey);
    }
    else {
        return Reflect.hasMetadata(metadataKey, target);
    }
};
const metadata_hasOwnMetadata = (metadataKey, target, propertyKey) => {
    if (propertyKey != null) {
        return Reflect.hasOwnMetadata(metadataKey, target, propertyKey);
    }
    else {
        return Reflect.hasOwnMetadata(metadataKey, target);
    }
};
const getMetadata = (metadataKey, target, propertyKey) => {
    if (propertyKey != null) {
        return Reflect.getMetadata(metadataKey, target, propertyKey);
    }
    else {
        return Reflect.getMetadata(metadataKey, target);
    }
};
const metadata_getOwnMetadata = (metadataKey, target, propertyKey) => {
    if (propertyKey != null) {
        return Reflect.getOwnMetadata(metadataKey, target, propertyKey);
    }
    else {
        return Reflect.getOwnMetadata(metadataKey, target);
    }
};
const metadata_setMetadata = (metadataKey, metadataValue, target, propertyKey) => {
    if (propertyKey != null) {
        Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    else {
        Reflect.defineMetadata(metadataKey, metadataValue, target);
    }
};

;// ./node_modules/@fastr/lang/lib/newable.js
const isConstructor = (target) => {
    return (typeof target === "function" && target.prototype?.constructor === target);
};
const newable_getConstructor = (instance) => {
    if (instance == null || typeof instance !== "object") {
        throw new TypeError();
    }
    const { constructor } = instance;
    if (!isConstructor(constructor)) {
        throw new TypeError();
    }
    return constructor;
};
const getBaseConstructor = (newable) => {
    if (!isConstructor(newable)) {
        throw new TypeError();
    }
    const prototype = Object.getPrototypeOf(newable);
    if (prototype != null && prototype !== Object && isConstructor(prototype)) {
        return prototype;
    }
    return null;
};

;// ./node_modules/@fastr/lang/lib/reflector.js


const kPropertyKeys = Symbol("kPropertyKeys");
const kDesignType = "design:type";
const kDesignParamTypes = "design:paramtypes";
const kDesignReturnType = "design:returntype";
class ClassReflector {
    newable;
    paramTypes;
    #properties = null;
    #methods = null;
    #allProperties = null;
    #allMethods = null;
    constructor(newable) {
        if (!isConstructor(newable)) {
            throw new TypeError();
        }
        this.newable = newable;
        this.paramTypes = metadata_getOwnMetadata(kDesignParamTypes, newable) ?? [];
    }
    get properties() {
        return (this.#properties ??= getProperties(this.newable));
    }
    get methods() {
        return (this.#methods ??= getMethods(this.newable));
    }
    get allProperties() {
        return (this.#allProperties ??= getAllProperties(this));
    }
    get allMethods() {
        return (this.#allMethods ??= getAllMethods(this));
    }
    get base() {
        const base = getBaseConstructor(this.newable);
        if (base != null) {
            return reflector_reflectorOf(base);
        }
        else {
            return null;
        }
    }
    construct(...args) {
        if (args.length < this.newable.length) {
            throw new TypeError();
        }
        return Reflect.construct(this.newable, args);
    }
    hasOwnMetadata(metadataKey) {
        return metadata_hasOwnMetadata(metadataKey, this.newable);
    }
    hasMetadata(metadataKey) {
        return hasMetadata(metadataKey, this.newable);
    }
    getOwnMetadata(metadataKey) {
        return metadata_getOwnMetadata(metadataKey, this.newable);
    }
    getMetadata(metadataKey) {
        return getMetadata(metadataKey, this.newable);
    }
    setMetadata(metadataKey, metadataValue) {
        metadata_setMetadata(metadataKey, metadataValue, this.newable);
    }
    get [Symbol.toStringTag]() {
        return "ClassReflector";
    }
}
class PropertyReflector {
    prototype;
    key;
    type;
    constructor(prototype, key) {
        this.prototype = prototype;
        this.key = key;
        this.type = metadata_getOwnMetadata(kDesignType, prototype, key);
    }
    get(inst) {
        return Reflect.get(inst, this.key);
    }
    set(inst, value) {
        Reflect.set(inst, this.key, value);
    }
    hasOwnMetadata(metadataKey) {
        return metadata_hasOwnMetadata(metadataKey, this.prototype, this.key);
    }
    hasMetadata(metadataKey) {
        return hasMetadata(metadataKey, this.prototype, this.key);
    }
    getOwnMetadata(metadataKey) {
        return metadata_getOwnMetadata(metadataKey, this.prototype, this.key);
    }
    getMetadata(metadataKey) {
        return getMetadata(metadataKey, this.prototype, this.key);
    }
    setMetadata(metadataKey, metadataValue) {
        metadata_setMetadata(metadataKey, metadataValue, this.prototype, this.key);
    }
    get [Symbol.toStringTag]() {
        return "PropertyReflector";
    }
}
class MethodReflector {
    prototype;
    key;
    value;
    type;
    paramTypes;
    returnType;
    constructor(prototype, key, value) {
        this.prototype = prototype;
        this.key = key;
        this.value = value;
        this.type = metadata_getOwnMetadata(kDesignType, prototype, key);
        this.paramTypes = metadata_getOwnMetadata(kDesignParamTypes, prototype, key) ?? [];
        this.returnType = metadata_getOwnMetadata(kDesignReturnType, prototype, key);
    }
    apply(inst, ...args) {
        if (args.length < this.value.length) {
            throw new TypeError();
        }
        return Reflect.apply(this.value, inst, args);
    }
    hasOwnMetadata(metadataKey) {
        return metadata_hasOwnMetadata(metadataKey, this.prototype, this.key);
    }
    hasMetadata(metadataKey) {
        return hasMetadata(metadataKey, this.prototype, this.key);
    }
    getOwnMetadata(metadataKey) {
        return metadata_getOwnMetadata(metadataKey, this.prototype, this.key);
    }
    getMetadata(metadataKey) {
        return getMetadata(metadataKey, this.prototype, this.key);
    }
    setMetadata(metadataKey, metadataValue) {
        metadata_setMetadata(metadataKey, metadataValue, this.prototype, this.key);
    }
    get [Symbol.toStringTag]() {
        return "MethodReflector";
    }
}
const getProperties = ({ prototype }) => {
    const map = Object.create(null);
    for (const key of metadata_getOwnMetadata(kPropertyKeys, prototype) ?? []) {
        map[key] = new PropertyReflector(prototype, key);
    }
    return map;
};
const getMethods = ({ prototype }) => {
    const map = Object.create(null);
    for (const [key, { value }] of Object.entries(Object.getOwnPropertyDescriptors(prototype))) {
        if (key !== "constructor" && typeof value === "function") {
            map[key] = new MethodReflector(prototype, key, value);
        }
    }
    return map;
};
const getAllProperties = (ref) => {
    const map = Object.create(null);
    const visit = (current) => {
        const { base } = current;
        if (base != null) {
            visit(base);
        }
        for (const value of Object.values(current.properties)) {
            map[value.key] = value;
        }
    };
    visit(ref);
    return map;
};
const getAllMethods = (ref) => {
    const map = Object.create(null);
    const visit = (current) => {
        const { base } = current;
        if (base != null) {
            visit(base);
        }
        for (const value of Object.values(current.methods)) {
            map[value.key] = value;
        }
    };
    visit(ref);
    return map;
};
const cache = new WeakMap();
const reflector_reflectorOf = (newable) => {
    let reflector = cache.get(newable);
    if (reflector == null) {
        cache.set(newable, (reflector = new ClassReflector(newable)));
    }
    return reflector;
};
reflector_reflectorOf.addPropertyKey = (prototype, key) => {
    let propertyKeys = metadata_getOwnMetadata(kPropertyKeys, prototype);
    if (propertyKeys == null) {
        metadata_setMetadata(kPropertyKeys, (propertyKeys = new Set()), prototype);
    }
    propertyKeys.add(key);
};

;// ./node_modules/@fastr/lang/lib/index.js







;// ./node_modules/@fastr/invert/lib/impl/constants.js
const kInjectable = Symbol("injectable");
const kInject = Symbol("inject");
const constants_kProp = Symbol("prop");
const constants_kProvides = Symbol("provides");

;// ./node_modules/@fastr/invert/lib/annotations.js


/**
 * Annotates a class as an injectable.
 *
 * @example
 * ```
 * @injectable()
 * class MyService { ... }
 * ```
 *
 * @example
 * ```
 * @injectable({ singleton: true })
 * class MyService { ... }
 * ```
 */
const injectable = ({ id, name, singleton } = {}) => {
    return (target) => {
        if (metadata_hasOwnMetadata(kInjectable, target)) {
            throw new Error("Duplicate annotation @injectable");
        }
        metadata_setMetadata(kInjectable, {
            id: id ?? null,
            name: name ?? null,
            singleton: singleton ?? false,
        }, target);
    };
};
/**
 * Annotates a constructor or method parameter with additional metadata about an
 * injected dependency.
 *
 * @example
 * ```
 * @injectable()
 * class MyService {
 *   constructor(@inject("url") url: string) { ... }
 * }
 * ```
 *
 * @example
 * ```
 * class MyModule implements Module {
 *   @provides({ id: "url" }})
 *   provideUrl(@inject("base") base: string): string {
 *     ...
 *   }
 * }
 * ```
 */
const inject = (id, { name } = {}) => {
    if (id == null) {
        throw new TypeError();
    }
    return (target, propertyKey, parameterIndex) => {
        const metadata = metadata_getOwnMetadata(kInject, target, propertyKey) ?? [];
        if (metadata[parameterIndex] != null) {
            throw new Error("Duplicate annotation @inject");
        }
        metadata[parameterIndex] = {
            id,
            name: name ?? null,
        };
        metadata_setMetadata(kInject, metadata, target, propertyKey);
    };
};
const prop = ({ id, name } = {}) => {
    return (target, propertyKey) => {
        reflectorOf.addPropertyKey(target, propertyKey);
        const { constructor } = target;
        const metadata = getOwnMetadata(kProp, constructor) ?? {};
        if (metadata[propertyKey] != null) {
            throw new Error("Duplicate annotation @prop");
        }
        metadata[propertyKey] = {
            propertyKey,
            id: id ?? null,
            name: name ?? null,
        };
        setMetadata(kProp, metadata, constructor);
    };
};
/**
 * Annotates a module method which is a provider of a value.
 *
 * @example
 * ```
 * class MyModule implements Module {
 *   @provide()
 *   provideSum(@inject("a") a: number, @inject("b") b: number): number {
 *     return a + b;
 *   }
 * }
 * ```
 */
const provides = ({ id, name, singleton } = {}) => {
    return (target, propertyKey) => {
        if (hasOwnMetadata(kProvides, target, propertyKey)) {
            throw new Error("Duplicate annotation @provides");
        }
        setMetadata(kProvides, {
            id: id ?? null,
            name: name ?? null,
            singleton: singleton ?? false,
        }, target, propertyKey);
    };
};

;// ./node_modules/@fastr/invert/lib/errors.js
class ContainerError extends Error {
    constructor(message, options) {
        super(message, options);
    }
    get [Symbol.toStringTag]() {
        return "ContainerError";
    }
}

;// ./node_modules/@fastr/invert/lib/impl/util.js


const util_getArgs = (factory, params) => {
    return params.map(({ id, name }) => factory.get(id, name));
};
const toValueId = (arg) => {
    if (typeof arg === "string" || typeof arg === "symbol") {
        return arg;
    }
    if (isConstructor(arg)) {
        return arg;
    }
    throw new TypeError(`${typeId(arg)} cannot be used as a ValueId`);
};
const checkValueId = (id, name) => {
    if ((id == null || id === Object) && name == null) {
        throw new TypeError(`${typeId(id)} is not a valid binding identifier`);
    }
};
const nameOf = (id, name) => {
    if (id == null) {
        return `name=${typeId(name)}`;
    }
    if (name == null) {
        return `id=${typeId(id)}`;
    }
    return `id=${typeId(id)} name=${typeId(name)}`;
};
const mergeParams = (callable, paramTypes, injectAnn) => {
    const { length } = callable;
    const params = new Array(length);
    for (let index = 0; index < length; index++) {
        const type = paramTypes[index];
        const ann = injectAnn[index];
        params[index] = {
            index,
            type,
            id: ann?.id ?? toValueId(type),
            name: ann?.name ?? null,
        };
    }
    return params;
};
const getConstructorParamsMetadata = (ref) => {
    const { newable, paramTypes } = ref;
    if (newable.length !== paramTypes.length) {
        throw new Error(`Design types are missing on ${newable.name}`);
    }
    const injectAnn = ref.getOwnMetadata(kInject) ?? [];
    return mergeParams(newable, paramTypes, injectAnn);
};
const util_getMethodParamsMetadata = (ref, method) => {
    const { newable } = ref;
    const { paramTypes, value } = method;
    if (value.length !== paramTypes.length) {
        throw new Error(`Design types are missing on ${newable.name}`);
    }
    const injectAnn = method.getOwnMetadata(kInject) ?? [];
    return mergeParams(value, paramTypes, injectAnn);
};
const getPropsMetadata = (ref) => {
    const { newable } = ref;
    const metadata = new Array();
    const propAnn = ref.getOwnMetadata(constants_kProp) ?? {};
    for (const property of Object.values(ref.properties)) {
        const { key, type } = property;
        if (type == null) {
            throw new Error(`Design types are missing on ${newable.name}`);
        }
        const ann = propAnn[key];
        metadata.push({
            propertyKey: key,
            type,
            id: ann?.id ?? toValueId(type),
            name: ann?.name ?? null,
        });
    }
    return metadata;
};

;// ./node_modules/@fastr/invert/lib/impl/binding/class.js

class ClassBinding {
    metadata;
    #value;
    constructor(metadata) {
        this.metadata = metadata;
    }
    getValue(factory) {
        const { singleton, newable, params, props } = this.metadata;
        const makeValue = () => {
            const value = Reflect.construct(newable, util_getArgs(factory, params));
            for (const { propertyKey, id, name } of props) {
                Reflect.set(value, propertyKey, factory.get(id, name));
            }
            return value;
        };
        if (singleton) {
            let value = this.#value;
            if (value == null) {
                value = this.#value = makeValue();
            }
            return value;
        }
        else {
            return makeValue();
        }
    }
    get [Symbol.toStringTag]() {
        return "ClassBinding";
    }
}

;// ./node_modules/@fastr/invert/lib/impl/binding/provider.js

class ProviderBinding {
    metadata;
    #value;
    constructor(metadata) {
        this.metadata = metadata;
    }
    getValue(factory) {
        const { singleton, value, module, params } = this.metadata;
        const makeValue = () => {
            return Reflect.apply(value, module, util_getArgs(factory, params));
        };
        if (singleton) {
            let value = this.#value;
            if (value == null) {
                value = this.#value = makeValue();
            }
            return value;
        }
        else {
            return makeValue();
        }
    }
    get [Symbol.toStringTag]() {
        return "ProviderBinding";
    }
}

;// ./node_modules/@fastr/invert/lib/impl/binding/value.js
class ValueBinding {
    value;
    constructor(value) {
        this.value = value;
    }
    getValue(container) {
        return this.value;
    }
    get [Symbol.toStringTag]() {
        return "ValueBinding";
    }
}

;// ./node_modules/@fastr/invert/lib/impl/class-metadata.js



function getClassMetadata(newable) {
    if (!isConstructor(newable)) {
        throw new TypeError();
    }
    const ref = reflector_reflectorOf(newable);
    const injectableAnn = ref.getOwnMetadata(kInjectable);
    const params = getConstructorParamsMetadata(ref);
    const props = getPropsMetadata(ref);
    return {
        id: injectableAnn?.id ?? null,
        name: injectableAnn?.name ?? null,
        singleton: injectableAnn?.singleton ?? false,
        newable,
        params,
        props,
    };
}

;// ./node_modules/@fastr/invert/lib/impl/module-metadata.js



function* getProviders(module) {
    const ref = reflector_reflectorOf(newable_getConstructor(module));
    for (const method of Object.values(ref.methods)) {
        const providesAnn = method.getOwnMetadata(constants_kProvides) ?? null;
        if (method.key === "configure") {
            if (providesAnn != null) {
                throw new TypeError();
            }
            continue;
        }
        if (providesAnn == null) {
            continue;
        }
        const { value, returnType: type } = method;
        const params = util_getMethodParamsMetadata(ref, method);
        yield {
            type,
            id: providesAnn.id ?? toValueId(type),
            name: providesAnn.name ?? null,
            singleton: providesAnn.singleton ?? false,
            module,
            value,
            params,
        };
    }
}

;// ./node_modules/@fastr/invert/lib/impl/binder.js







function makeBinder(reg) {
    const binder = {
        bind: (id, name = null) => {
            checkValueId(id, name);
            const bindTo = {
                toSelf: () => {
                    if (!isConstructor(id)) {
                        throw new TypeError(`Cannot bind ${nameOf(id, name)} ` +
                            `to itself because it is not a constructor`);
                    }
                    reg.set(id, name, new ClassBinding(getClassMetadata(id)));
                },
                to: (constructor) => {
                    if (!isConstructor(constructor)) {
                        throw new TypeError(`Cannot bind ${nameOf(id, name)} ` +
                            `to ${typeId(constructor)} because it is not a constructor`);
                    }
                    reg.set(id, name, new ClassBinding(getClassMetadata(constructor)));
                },
                toValue: (value) => {
                    reg.set(id, name, new ValueBinding(value));
                },
            };
            return bindTo;
        },
        load: (module) => {
            module.configure(binder);
            for (const provider of getProviders(module)) {
                reg.set(provider.id, provider.name, new ProviderBinding(provider));
            }
            return binder;
        },
    };
    return binder;
}

;// ./node_modules/@fastr/invert/lib/impl/registry.js
class Registry {
    #unnamed = new Map();
    #named = new Map();
    *[Symbol.iterator]() {
        for (const [id, binding] of this.#unnamed) {
            yield [id, null, binding];
        }
        for (const [name, map] of this.#named) {
            for (const [id, binding] of map) {
                yield [id, name, binding];
            }
        }
    }
    *bindings() {
        for (const binding of this.#unnamed.values()) {
            yield binding;
        }
        for (const map of this.#named.values()) {
            for (const binding of map.values()) {
                yield binding;
            }
        }
    }
    has(id, name) {
        const map = name == null ? this.#unnamed : this.#named.get(name);
        if (map == null) {
            return false;
        }
        return map.has(id);
    }
    get(id, name) {
        const map = name == null ? this.#unnamed : this.#named.get(name);
        if (map == null) {
            return null;
        }
        return map.get(id) ?? null;
    }
    set(id, name, binding) {
        let map = name == null ? this.#unnamed : this.#named.get(name);
        if (map == null) {
            this.#named.set(name, (map = new Map()));
        }
        map.set(id, binding);
    }
    addAll(that) {
        for (const [id, name, binding] of that) {
            this.set(id, name, binding);
        }
    }
    delete(id, name) {
        const map = name == null ? this.#unnamed : this.#named.get(name);
        if (map != null) {
            map.delete(id);
        }
    }
    clear() {
        this.#unnamed.clear();
        this.#named.clear();
    }
    get [Symbol.toStringTag]() {
        return "Registry";
    }
}

;// ./node_modules/@fastr/invert/lib/container.js







class Container {
    #options;
    #registry;
    #binder;
    #parent;
    constructor({ autoBindInjectable = true, eagerSingletons = true, } = {}) {
        this.#options = {
            autoBindInjectable,
            eagerSingletons,
        };
        this.#registry = new Registry();
        this.#binder = makeBinder(this.#registry);
        this.#parent = null;
        this.#binder.bind(Container).toValue(this);
    }
    get parent() {
        return this.#parent;
    }
    createChild() {
        const child = new Container(this.#options);
        child.#parent = this;
        return child;
    }
    load(module) {
        this.#binder.load(module);
        return this;
    }
    bind(id, name = null) {
        checkValueId(id, name);
        return this.#binder.bind(id, name);
    }
    has(id, name = null) {
        checkValueId(id, name);
        if (this.#registry.has(id, name)) {
            return true;
        }
        if (this.#parent != null) {
            return this.#parent.has(id, name);
        }
        return false;
    }
    get(id, name = null) {
        checkValueId(id, name);
        const binding = this.#registry.get(id, name);
        if (binding != null) {
            return binding.getValue(this);
        }
        if (this.#parent != null && this.#parent.has(id, name)) {
            return this.#parent.get(id, name);
        }
        if (name == null && this.#options.autoBindInjectable && isConstructor(id)) {
            const binding = new ClassBinding(getClassMetadata(id));
            this.#registry.set(id, name, binding);
            return binding.getValue(this);
        }
        throw new ContainerError(`Binding ${nameOf(id, name)} not found`);
    }
    get [Symbol.toStringTag]() {
        return "Container";
    }
}

;// ./node_modules/@fastr/invert/lib/methods.js


function methodHandle(target, propertyKey) {
    const ref = reflectorOf(getConstructor(target));
    const method = ref.methods[propertyKey];
    if (method == null) {
        if (method == null) {
            throw new TypeError(`Method ${String(propertyKey)} ` +
                `is missing in class ${ref.newable.name}`);
        }
    }
    const params = getMethodParamsMetadata(ref, method);
    return {
        apply(factory) {
            return method.apply(target, getArgs(factory, params));
        },
    };
}

;// ./node_modules/@fastr/invert/lib/index.js






;// ./node_modules/tslib/tslib.es6.mjs
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var tslib_es6_assign = function() {
  tslib_es6_assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return tslib_es6_assign.apply(this, arguments);
}

function tslib_es6_rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function tslib_es6_spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const tslib_es6 = ({
  __extends,
  __assign: tslib_es6_assign,
  __rest: tslib_es6_rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray: tslib_es6_spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});

// EXTERNAL MODULE: external "node:path"
var external_node_path_ = __webpack_require__("node:path");
;// ./packages/keybr-config/lib/datadir.ts



let DataDir = class DataDir {
    dataDir;
    constructor(dataDir) {
        this.dataDir = dataDir;
    }
    dataPath(...parts) {
        return (0,external_node_path_.join)(this.dataDir, ...parts);
    }
    /**
     * Returns the full path to a user settings file for the given user id.
     */
    userSettingsFile(userId) {
        const s = String(userId).padStart(9, "0");
        return this.dataPath("user_settings", //
        s.substring(0, 3), s.substring(3, 6), s);
    }
    /**
     * Returns the full path to a user stats file for the given user id.
     */
    userStatsFile(userId) {
        const s = String(userId).padStart(9, "0");
        return this.dataPath("user_stats", //
        s.substring(0, 3), s.substring(3, 6), s);
    }
};
DataDir = __decorate([
    injectable(),
    __param(0, inject("dataDir")),
    __metadata("design:paramtypes", [String])
], DataDir);


;// external "node:crypto"
const external_node_crypto_namespaceObject = require("node:crypto");
// EXTERNAL MODULE: external "node:fs"
var external_node_fs_ = __webpack_require__("node:fs");
var external_node_fs_default = /*#__PURE__*/__webpack_require__.n(external_node_fs_);
;// external "node:os"
const external_node_os_namespaceObject = require("node:os");
var external_node_os_default = /*#__PURE__*/__webpack_require__.n(external_node_os_namespaceObject);
;// external "node:util"
const external_node_util_namespaceObject = require("node:util");
var external_node_util_default = /*#__PURE__*/__webpack_require__.n(external_node_util_namespaceObject);
;// ./packages/keybr-logger/node_modules/chalk/source/vendor/ansi-styles/index.js
const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles;
}

const ansiStyles = assembleStyles();

/* harmony default export */ const ansi_styles = (ansiStyles);

// EXTERNAL MODULE: external "node:process"
var external_node_process_ = __webpack_require__("node:process");
var external_node_process_default = /*#__PURE__*/__webpack_require__.n(external_node_process_);
;// external "node:tty"
const external_node_tty_namespaceObject = require("node:tty");
var external_node_tty_default = /*#__PURE__*/__webpack_require__.n(external_node_tty_namespaceObject);
;// ./packages/keybr-logger/node_modules/chalk/source/vendor/supports-color/index.js




// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : (external_node_process_default()).argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = (external_node_process_default());

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if ((external_node_process_default()).platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = external_node_os_default().release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {
			return 3;
		}

		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: external_node_tty_default().isatty(1)}),
	stderr: createSupportsColor({isTTY: external_node_tty_default().isatty(2)}),
};

/* harmony default export */ const supports_color = (supportsColor);

;// ./packages/keybr-logger/node_modules/chalk/source/utilities.js
// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

;// ./packages/keybr-logger/node_modules/chalk/source/index.js




const {stdout: stdoutColor, stderr: stderrColor} = supports_color;

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const source_styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class Chalk {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansi_styles)) {
	source_styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

source_styles.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return ansi_styles[type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return ansi_styles[type].ansi256(ansi_styles.rgbToAnsi256(...arguments_));
		}

		return ansi_styles[type].ansi(ansi_styles.rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ...ansi_styles.hexToRgb(...arguments_));
	}

	return ansi_styles[type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	source_styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansi_styles.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	source_styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansi_styles.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...source_styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, source_styles);

const chalk = createChalk();
const chalkStderr = createChalk({level: stderrColor ? stderrColor.level : 0});





/* harmony default export */ const source = (chalk);

;// ./packages/keybr-logger/lib/level.ts
var Level;
(function (Level) {
    Level[Level["DEBUG"] = 0] = "DEBUG";
    Level[Level["INFO"] = 1] = "INFO";
    Level[Level["WARN"] = 2] = "WARN";
    Level[Level["ERROR"] = 3] = "ERROR";
})(Level || (Level = {}));
function getLevel() {
    switch (process.env.LOG_LEVEL) {
        case "debug":
            return Level.DEBUG;
        case "info":
            return Level.INFO;
        case "warn":
            return Level.WARN;
        case "error":
            return Level.ERROR;
    }
    switch ("production") {
        case "production":
            return Level.INFO;
        case "development":
            return Level.DEBUG;
    }
    return Level.INFO;
}

;// ./packages/keybr-logger/lib/console.ts



class ConsoleTransport {
    #inspectOptions;
    constructor(inspectOptions = {}) {
        this.#inspectOptions = {
            colors: source.level > 0,
            ...inspectOptions,
        };
    }
    append(message) {
        const { level, time, err, format, args } = message;
        const a = source.gray(time.toISOString());
        const b = source.cyan(Level[level]);
        const c = (0,external_node_util_namespaceObject.formatWithOptions)(this.#inspectOptions, format, ...args);
        const log = getLog(message);
        log(`${a} ${b}: ${c}`);
        if (err != null) {
            log((0,external_node_util_namespaceObject.inspect)(err, this.#inspectOptions));
        }
    }
}
function getLog(message) {
    switch (message.level) {
        case Level.DEBUG:
            return console.debug;
        case Level.INFO:
            return console.info;
        case Level.WARN:
            return console.warn;
        case Level.ERROR:
            return console.error;
        default:
            return console.log;
    }
}

;// ./packages/keybr-logger/lib/format.ts
function format(level, time, args) {
    let err = null;
    let format;
    let arg = args.shift();
    if (arg instanceof Error) {
        err = arg;
        arg = args.shift();
    }
    if (typeof arg === "string") {
        format = arg;
    }
    else {
        throw new TypeError();
    }
    return {
        level,
        time,
        err,
        format,
        args,
    };
}

;// ./packages/keybr-logger/lib/logger.ts



class Logger {
    static #level = getLevel();
    static #transports = [new ConsoleTransport()];
    constructor() { }
    static configure({ level, transports }) {
        if (level !== undefined) {
            Logger.#level = level;
        }
        if (transports !== undefined) {
            Logger.#transports = [...transports];
        }
    }
    static enabled(level) {
        return Logger.#level <= level;
    }
    static #report(message) {
        for (const transport of Logger.#transports) {
            transport.append(message);
        }
    }
    static debug(...args) {
        Logger.#log(Level.DEBUG, args);
    }
    static info(...args) {
        Logger.#log(Level.INFO, args);
    }
    static warn(...args) {
        Logger.#log(Level.WARN, args);
    }
    static error(...args) {
        Logger.#log(Level.ERROR, args);
    }
    static #log(level, args) {
        if (Logger.enabled(level)) {
            Logger.#report(format(level, new Date(), args));
        }
    }
}

;// ./packages/keybr-logger/lib/index.ts





// EXTERNAL MODULE: ./node_modules/dotenv/lib/main.js
var main = __webpack_require__("./node_modules/dotenv/lib/main.js");
;// ./packages/keybr-config/lib/env.ts






class Env {
    static getFiles() {
        const env = "production" || 0;
        return [
            // First definition wins, so list files in the reversed order.
            (0,external_node_path_.join)(process.cwd(), `.env.${env}`),
            (0,external_node_path_.join)(process.cwd(), `.env`),
            `/etc/keybr/env.${env}`,
            `/etc/keybr/env`,
        ];
    }
    static probeFilesSync(paths = Env.getFiles()) {
        for (const path of paths) {
            Logger.debug(`Probe dotenv file '${path}'`);
            try {
                if (Env.loadFileSync(path)) {
                    Logger.info(`Loaded dotenv file '${path}'`);
                }
            }
            catch (err) {
                Logger.error(err, `Cannot load dotenv file '${path}'`);
            }
        }
    }
    static loadFileSync(path) {
        try {
            copyToProcessEnv((0,main.parse)((0,external_node_fs_.readFileSync)(path, "utf-8")));
        }
        catch (err) {
            if (err.code === "ENOENT") {
                return false;
            }
            else {
                throw err;
            }
        }
        return true;
    }
    static getString(name, defaultValue) {
        return Env.getValue(name, defaultValue, String);
    }
    static getNumber(name, defaultValue) {
        return Env.getValue(name, defaultValue, Env.asNumber);
    }
    static getInteger(name, defaultValue) {
        return Env.getValue(name, defaultValue, Env.asInteger);
    }
    static getBoolean(name, defaultValue) {
        return Env.getValue(name, defaultValue, Env.asBoolean);
    }
    static getPort(name, defaultValue) {
        return Env.getValue(name, defaultValue, Env.asPortNumber);
    }
    static getPath(name, defaultValue) {
        return Env.getValue(name, defaultValue, Env.asPath);
    }
    static getPrivateKey(name) {
        return Env.getValue(name, undefined, Env.asPrivateKey);
    }
    static getPublicKey(name) {
        return Env.getValue(name, undefined, Env.asPublicKey);
    }
    static getValue(name, defaultValue, parse) {
        const value = process.env[name];
        if (value == null) {
            if (defaultValue == null) {
                throw new TypeError(`Missing env property '${name}'`);
            }
            return defaultValue;
        }
        try {
            return parse(value);
        }
        catch (err) {
            throw new TypeError(`Invalid env property '${name}': ${err.message}`);
        }
    }
    static asNumber(value) {
        const result = Number(value);
        if (!Number.isFinite(result)) {
            throw new TypeError(`Invalid numeric value '${value}'`);
        }
        return result;
    }
    static asInteger(value) {
        const result = Env.asNumber(value);
        if (!Number.isSafeInteger(result)) {
            throw new TypeError(`Invalid integer value '${value}'`);
        }
        return result;
    }
    static asBoolean(value) {
        switch (value) {
            case "true":
                return true;
            case "false":
                return false;
            default:
                throw new TypeError(`Invalid boolean value '${value}'`);
        }
    }
    static asPortNumber(value) {
        const result = Env.asInteger(value);
        if (result < 1 || result > 65535) {
            throw new TypeError(`Invalid port number '${value}'`);
        }
        return result;
    }
    static asPath(value) {
        if (value === "") {
            throw new TypeError(`Empty path string`);
        }
        let path = value;
        if (path === "~") {
            path = (0,external_node_os_namespaceObject.homedir)();
        }
        else if (path.startsWith("~/")) {
            path = (0,external_node_path_.join)((0,external_node_os_namespaceObject.homedir)(), path.substring(2));
        }
        return (0,external_node_path_.resolve)(path);
    }
    static asPrivateKey(value) {
        try {
            return (0,external_node_crypto_namespaceObject.createPrivateKey)(value);
        }
        catch (cause) {
            throw new TypeError(`Cannot parse as a private key`, { cause });
        }
    }
    static asPublicKey(value) {
        try {
            return (0,external_node_crypto_namespaceObject.createPublicKey)(value);
        }
        catch (cause) {
            throw new TypeError(`Cannot parse as a public key`, { cause });
        }
    }
}
function copyToProcessEnv(entries) {
    for (const [key, value] of Object.entries(entries)) {
        if (typeof process.env[key] === "undefined") {
            process.env[key] = value;
        }
    }
}

// EXTERNAL MODULE: ./node_modules/knex/knex.js
var knex_knex = __webpack_require__("./node_modules/knex/knex.js");
var knex_default = /*#__PURE__*/__webpack_require__.n(knex_knex);
// EXTERNAL MODULE: ./node_modules/objection/lib/objection.js
var objection = __webpack_require__("./node_modules/objection/lib/objection.js");
// EXTERNAL MODULE: ./node_modules/knex/lib/dialects/mysql/index.js
var mysql = __webpack_require__("./node_modules/knex/lib/dialects/mysql/index.js");
var mysql_default = /*#__PURE__*/__webpack_require__.n(mysql);
// EXTERNAL MODULE: ./node_modules/mysql/index.js
var node_modules_mysql = __webpack_require__("./node_modules/mysql/index.js");
;// ./packages/keybr-config/lib/knex/conn-mysql.ts



function connectMySql(config) {
    bundleMySqlPackage();
    return {
        __client: "mysql",
        client: (mysql_default()),
        connection: { ...config, timezone: "UTC", charset: "UTF8" },
        useNullAsDefault: true,
        debug: Boolean(process.env.KNEX_DEBUG),
        ...(0,objection.knexSnakeCaseMappers)(),
    };
}
function bundleMySqlPackage() {
    // We don't have any direct dependencies on the MySQL package.
    // If left as is then the MySQL package will not be bundled.
    // To fix this we need to introduce an artificial direct dependency,
    // so here is one.
    if (typeof node_modules_mysql.createConnection !== "function") {
        throw new Error();
    }
}

// EXTERNAL MODULE: ./node_modules/knex/lib/dialects/better-sqlite3/index.js
var better_sqlite3 = __webpack_require__("./node_modules/knex/lib/dialects/better-sqlite3/index.js");
var better_sqlite3_default = /*#__PURE__*/__webpack_require__.n(better_sqlite3);
;// ./packages/keybr-config/lib/knex/util.ts
function fixTimestamps(result) {
    if (Array.isArray(result)) {
        for (const item of result) {
            if (item != null && typeof item === "object") {
                for (const key of ["created_at", "updated_at", "expires_at"]) {
                    if (key in item && typeof item[key] === "number") {
                        item[key] = new Date(item[key]);
                    }
                }
            }
        }
    }
    return result;
}

;// ./packages/keybr-config/lib/knex/conn-sqlite.ts



function connectSqlite(config) {
    return {
        __client: "sqlite",
        client: (better_sqlite3_default()),
        connection: { ...config },
        useNullAsDefault: true,
        debug: Boolean(process.env.KNEX_DEBUG),
        ...(0,objection.knexSnakeCaseMappers)(),
        postProcessResponse: fixTimestamps,
    };
}
function dummy(db) {
    // Disable the unused dependency lint error.
}

;// ./packages/keybr-config/lib/knex.ts







function makeKnex() {
    const knex = knex_default()(connect());
    objection.Model.knex(knex);
    return knex;
}
function connect() {
    const client = Env.getString("DATABASE_CLIENT", "mysql");
    switch (client) {
        case "mysql": {
            const host = Env.getString("DATABASE_HOST", "localhost");
            const port = Env.getNumber("DATABASE_PORT", 3306);
            const database = Env.getString("DATABASE_DATABASE", "keybr");
            const user = Env.getString("DATABASE_USERNAME", "keybr") || undefined;
            const password = Env.getString("DATABASE_PASSWORD", "keybr11") || undefined;
            return connectMySql({ host, port, database, user, password });
        }
        case "sqlite": {
            let filename = Env.getString("DATABASE_FILENAME", ":memory:");
            if (filename !== ":memory:") {
                filename = Env.asPath(filename);
                (0,external_node_fs_.mkdirSync)((0,external_node_path_.dirname)(filename), { recursive: true });
            }
            return connectSqlite({ filename });
        }
        default:
            throw new TypeError(`Unsupported database client [${client}]`);
    }
}

;// ./packages/keybr-config/lib/module.ts



class ConfigModule {
    configure({ bind }) {
        bind((knex_default())).toValue(makeKnex());
        bind("dataDir").toValue(Env.getPath("DATA_DIR", "/var/lib/keybr"));
        bind("publicDir").toValue(Env.getPath("PUBLIC_DIR", "/opt/keybr/public"));
        bind("canonicalUrl").toValue(Env.getString("APP_URL", "http://c.keybr.com.cn/"));
    }
}

;// ./packages/keybr-config/lib/index.ts





// EXTERNAL MODULE: ./node_modules/commander/index.js
var commander = __webpack_require__("./node_modules/commander/index.js");
;// ./node_modules/commander/esm.mjs


// wrapper to provide named exports for ESM.
const {
  /* program */ "DM": program,
  /* createCommand */ "gu": createCommand,
  /* createArgument */ "er": createArgument,
  /* createOption */ "Ww": createOption,
  /* CommanderError */ "b7": CommanderError,
  /* InvalidArgumentError */ "Di": InvalidArgumentError,
  /* InvalidOptionArgumentError */ "a2": InvalidOptionArgumentError, // deprecated old name
  /* Command */ "uB": Command,
  /* Argument */ "ef": Argument,
  /* Option */ "c$": Option,
  /* Help */ "_V": Help,
} = commander;

;// ./packages/keybr-publicid/lib/index.ts
/** Inclusive lower bound of the range of valid internal user ids. */
const MIN_ID = 0x00000001;
/** Inclusive upper bound of the range of valid internal user ids. */
const MAX_ID = 0x0fffffff;
/** Regex pattern to match example user ids. */
const EXAMPLE_ID_PATTERN = new RegExp("^example([1-9])$");
/** Arbitrary offset. */
const OFFSET = 0x05b4c39f;
/** Arbitrary XOR mask. */
const MASK = 0x0a531fcd;
/** Multiplicative inverse of C2 modulo MAX_ID + 1. */
const C1 = 0x0527d98f;
/** Multiplicative inverse of C1 modulo MAX_ID + 1. */
const C2 = 0x00c9256f;
/** Base 36. */
const BASE = 36;
/** Base 36 digits. */
const DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz";
/** Base 36 digits. */
// prettier-ignore
const INVERSE_DIGITS = [
    null, null, null, null, null, null, null, null, null, null, null, null, null,
    null, null, null, null, null, null, null, null, null, null, null, null, null,
    null, null, null, null, null, null, null, null, null, null, null, null, null,
    null, null, null, null, null, null, null, null, null, 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, null, null, null, null, null, null, null, 10, 11, 12, 13, 14, 15, 16,
    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
    null, null, null, null, null, null, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, null, null,
    null, null, null,
];
class InvalidIdError extends Error {
    constructor() {
        super("invalid id");
    }
    get [Symbol.toStringTag]() {
        return "InvalidIdError";
    }
}
class PublicId {
    static example1 = PublicId.of("example1");
    static example2 = PublicId.of("example2");
    static example3 = PublicId.of("example3");
    static example4 = PublicId.of("example4");
    static example5 = PublicId.of("example5");
    static examples = [
        PublicId.example1,
        PublicId.example2,
        PublicId.example3,
        PublicId.example4,
        PublicId.example5,
    ];
    static of(publicId) {
        const match = EXAMPLE_ID_PATTERN.exec(publicId);
        if (match != null) {
            return new PublicId(-Number(match[1]));
        }
        else {
            return new PublicId(fromPublicId(publicId));
        }
    }
    static parse(publicId) {
        try {
            return PublicId.of(publicId);
        }
        catch {
            return null;
        }
    }
    /** Internal user id. */
    id;
    /** Public user id. */
    publicId;
    /** Whether user id is of an example profile. */
    example;
    constructor(id) {
        if (!Number.isInteger(id) || id === 0) {
            throw new InvalidIdError();
        }
        if (id < 0) {
            this.id = -id;
            this.publicId = `example${-id}`;
            this.example = true;
        }
        else {
            if (id < MIN_ID || id > MAX_ID) {
                throw new InvalidIdError();
            }
            this.id = id;
            this.publicId = toPublicId(id);
            this.example = false;
        }
    }
    toString() {
        return this.publicId;
    }
    toUser() {
        if (!this.example) {
            throw new Error();
        }
        return Object.freeze({
            id: this.publicId,
            name: `Example User ${this.id}`,
            imageUrl: null,
            premium: false,
        });
    }
}
function toPublicId(id) {
    return formatWithCheckDigit(toPublicInt(id));
}
function fromPublicId(publicId) {
    return fromPublicInt(parseWithCheckDigit(publicId));
}
function toPublicInt(id) {
    id = modMultiply(id, C1);
    id = id ^ MASK;
    id = id & MAX_ID;
    id = id + OFFSET;
    return id;
}
function fromPublicInt(id) {
    id = id - OFFSET;
    id = id ^ MASK;
    id = modMultiply(id, C2);
    id = id & MAX_ID;
    return id;
}
function parseWithCheckDigit(string) {
    let number = 0;
    let checkSum = 0;
    const checkDigit = toDigit(string, 0);
    for (let i = 1; i < string.length; i++) {
        const digit = toDigit(string, i);
        number = number * BASE + digit;
        checkSum += digit * digitWeight(string.length - i);
    }
    if (number === 0 || checkDigit !== checkSum % BASE) {
        throw new InvalidIdError();
    }
    return number;
}
function formatWithCheckDigit(number) {
    let string = "";
    let checkSum = 0;
    do {
        const digit = number % BASE;
        string = DIGITS[digit] + string;
        checkSum += digit * digitWeight(string.length);
    } while ((number = (number / BASE) >>> 0) > 0);
    const checkDigit = checkSum % BASE;
    string = DIGITS[checkDigit] + string;
    return string;
}
/** Multiply modulo 0xFFFFFFFF. */
function modMultiply(a, b) {
    a = a >>> 0;
    b = b >>> 0;
    let r = 0;
    for (let n = 0; n < 32; n++) {
        if (((b >>> n) & 1) === 1) {
            r += a << n;
        }
    }
    return r >>> 0;
}
function toDigit(string, index) {
    const digit = INVERSE_DIGITS[string.charCodeAt(index)];
    if (digit == null) {
        throw new InvalidIdError();
    }
    return digit;
}
function digitWeight(pos) {
    return (pos & 1) === 0 ? 1 : 3;
}

;// ./packages/keybr-rand/lib/rng/xorshift128plus.ts
const XorShift128Plus = (seed) => {
    let state0_lo = seed ^ 0x1f9d38af;
    let state0_hi = seed ^ 0xaf410049;
    let state1_lo = seed ^ 0xbd21e214;
    let state1_hi = seed ^ 0xd19d592c;
    let s1_hi = 0;
    let s1_lo = 0;
    let s0_hi = 0;
    let s0_lo = 0;
    let t_hi = 0;
    let t_lo = 0;
    const update = () => {
        // s1 = state0;
        s1_hi = state0_hi;
        s1_lo = state0_lo;
        // s0 = state1;
        s0_hi = state1_hi;
        s0_lo = state1_lo;
        // state0 = s0;
        state0_hi = s0_hi;
        state0_lo = s0_lo;
        // s1 ^= s1 << 23;
        t_hi = (s1_hi << 23) | (s1_lo >>> (32 - 23));
        t_lo = s1_lo << 23;
        s1_hi = s1_hi ^ t_hi;
        s1_lo = s1_lo ^ t_lo;
        // s1 ^= s1 >> 17;
        t_hi = s1_hi >>> 17;
        t_lo = (s1_lo >>> 17) | (s1_hi << (32 - 17));
        s1_hi = s1_hi ^ t_hi;
        s1_lo = s1_lo ^ t_lo;
        // s1 ^= s0;
        s1_hi = s1_hi ^ s0_hi;
        s1_lo = s1_lo ^ s0_lo;
        // s1 ^= s0 >> 26;
        t_hi = s0_hi >>> 26;
        t_lo = (s0_lo >>> 26) | (s0_hi << (32 - 26));
        s1_hi = s1_hi ^ t_hi;
        s1_lo = s1_lo ^ t_lo;
        // state1 = s1;
        state1_hi = s1_hi;
        state1_lo = s1_lo;
    };
    /* Generates a random number on [0,1) with 53-bit resolution. */
    const rng = () => {
        update();
        const a = state0_hi;
        const b = state0_lo;
        return ((a >>> 5) * 0x4000000 + (b >>> 6)) * (1.0 / 0x20000000000000);
    };
    rng.mark = () => {
        return {
            lo0: state0_lo,
            hi0: state0_hi,
            lo1: state1_lo,
            hi1: state1_hi,
        };
    };
    rng.reset = ({ lo0, hi0, lo1, hi1 }) => {
        state0_lo = lo0;
        state0_hi = hi0;
        state1_lo = lo1;
        state1_hi = hi1;
    };
    return rng;
};

;// ./packages/keybr-rand/lib/sample.ts
/**
 * Selects a random element from the given list of uniform elements.
 * @param list A list of uniform elements to sample from.
 * @param random A random number generator function.
 * @return A random element sampled from the list.
 */
function sample_randomSample(list, random = Math.random) {
    const { length } = list;
    if (length === 0) {
        throw new Error();
    }
    return list[(random() * length) | 0];
}
/**
 * Selects a random element from the given list of weighted elements.
 * @param list A list of weighted elements to sample from.
 * @param weight A function that gives weights to elements.
 * @param random A random number generator function.
 * @return A random element sampled from the list.
 */
function sample_weightedRandomSample(list, weight, random = Math.random) {
    const { length } = list;
    if (length === 0) {
        throw new Error();
    }
    let sum = 0;
    for (const v of list) {
        sum += weight(v);
    }
    let r = random() * sum;
    for (const v of list) {
        const w = weight(v);
        if (r <= w) {
            return v;
        }
        r -= w;
    }
    throw new Error();
}
/**
 * Selects a subset of random elements without replacement of the given size
 * from the given list of uniform elements.
 * @param list A list of uniform elements to sample from.
 * @param size The number of unique elements to sample.
 * @param random A random number generator function.
 * @return A subset of random unique elements sampled from the list.
 */
function randomSamples(list, size, random = Math.random) {
    const { length } = list;
    if (size > length) {
        throw new Error();
    }
    const shuffled = [...list];
    for (let i = 0; i < size; i++) {
        const j = (i + random() * (length - i)) | 0;
        const tmp = shuffled[i];
        shuffled[i] = shuffled[j];
        shuffled[j] = tmp;
    }
    return shuffled.slice(0, size);
}

;// ./packages/keybr-names/lib/data/adjectives.json
const adjectives_namespaceObject = /*#__PURE__*/JSON.parse('["able","above","absent","absolute","abstract","abundant","academic","acceptable","accepted","accessible","accurate","accused","active","actual","acute","added","additional","adequate","adjacent","adorable","advanced","adverse","advisory","aesthetic","afraid","african","aggregate","aggressive","agreeable","agreed","alert","alive","alleged","allied","alone","alright","alternative","amateur","amazing","ambitious","american","amused","ancient","angry","annoyed","annual","anonymous","anxious","appalling","apparent","applicable","appropriate","arab","arbitrary","armed","arrogant","artificial","artistic","ashamed","asian","asleep","assistant","associated","atomic","attractive","australian","automatic","autonomous","available","average","awake","aware","awful","awkward","back","bad","balanced","bare","basic","beautiful","beneficial","better","bewildered","big","binding","biological","bitter","bizarre","blank","blind","blonde","bloody","blushing","boiling","bold","bored","boring","bottom","brainy","brave","breakable","breezy","brief","bright","brilliant","british","broad","broken","bumpy","burning","busy","calm","canadian","capable","capitalist","careful","casual","catholic","causal","cautious","central","certain","changing","charming","cheap","cheerful","chemical","chief","chilly","chinese","chosen","christian","chronic","circular","civic","civil","civilian","classic","classical","clean","clever","clinical","close","cloudy","clumsy","coastal","cognitive","coherent","cold","collective","colonial","colorful","colossal","coloured","colourful","combative","combined","coming","commercial","common","communist","compact","comparable","compatible","competent","complete","complex","complicated","compulsory","conceptual","concerned","concrete","condemned","confident","confidential","confused","conscious","conservative","considerable","consistent","constant","contemporary","content","continental","continued","continuing","continuous","controlled","convenient","conventional","convinced","convincing","cool","cooperative","corporate","correct","costly","courageous","crazy","creative","creepy","criminal","critical","crooked","crowded","crucial","crude","cruel","cuddly","cultural","curious","curly","current","curved","cute","daily","damaged","damp","dangerous","dark","dead","deaf","deafening","dear","decent","decisive","deep","defeated","defensive","defiant","definite","deliberate","delicate","delicious","delighted","delightful","dependent","depressed","desirable","desperate","detailed","determined","developed","developing","devoted","different","difficult","digital","diplomatic","direct","dirty","disabled","disastrous","disgusted","distant","distinct","distinctive","disturbed","diverse","divine","dizzy","domestic","dominant","double","doubtful","drab","dramatic","dreadful","driving","drunk","dry","dual","dull","dusty","dynamic","eager","early","eastern","easy","economic","educational","eerie","effective","efficient","elaborate","elated","elderly","eldest","electoral","electric","electrical","electronic","elegant","eligible","embarrassed","embarrassing","emotional","empirical","empty","enchanting","encouraging","endless","energetic","english","enormous","enthusiastic","entire","entitled","envious","environmental","equal","equivalent","essential","established","estimated","ethical","ethnic","european","eventual","everyday","evident","evil","evolutionary","exact","excellent","exceptional","excessive","excited","exciting","exclusive","existing","exotic","expected","expensive","experienced","experimental","explicit","extended","extensive","external","extra","extraordinary","extreme","exuberant","faint","fair","faithful","familiar","famous","fancy","fantastic","far","fascinating","fashionable","fast","fat","fatal","favourable","favourite","federal","fellow","female","feminist","few","fierce","final","financial","fine","firm","fiscal","fit","fixed","flaky","flat","flexible","fluffy","fluttering","flying","following","fond","foolish","foreign","formal","formidable","forthcoming","fortunate","forward","fragile","frail","frantic","free","french","frequent","fresh","friendly","frightened","front","frozen","full","fun","functional","fundamental","funny","furious","future","fuzzy","general","generous","genetic","gentle","genuine","geographical","german","giant","gigantic","given","glad","glamorous","gleaming","global","glorious","golden","good","gorgeous","gothic","governing","graceful","gradual","grand","grateful","greasy","great","greek","grey","grieving","grim","gross","grotesque","growing","grubby","grumpy","guilty","handicapped","handsome","happy","hard","harsh","healthy","heavy","helpful","helpless","hidden","high","hilarious","hissing","historic","historical","hollow","holy","homeless","homely","honest","horizontal","horrible","hostile","hot","huge","human","hungry","hurt","hushed","husky","icy","ideal","identical","ideological","ill","illegal","imaginative","immediate","immense","imperial","implicit","important","impossible","impressed","impressive","improved","inadequate","inappropriate","inclined","increased","increasing","incredible","independent","indian","indirect","individual","industrial","inevitable","influential","informal","inherent","initial","injured","inland","inner","innocent","innovative","inquisitive","instant","institutional","insufficient","intact","integral","integrated","intellectual","intelligent","intense","intensive","interested","interesting","interim","interior","intermediate","internal","international","intimate","invisible","involved","iraqi","irish","irrelevant","isolated","italian","itchy","japanese","jealous","jittery","joint","jolly","joyous","judicial","juicy","junior","just","keen","key","kind","known","korean","labour","large","late","latin","lazy","leading","left","legal","legislative","legitimate","lengthy","lesser","lexical","liable","liberal","light","like","likely","limited","linear","linguistic","liquid","literary","little","live","lively","living","local","logical","lonely","long","loose","lost","loud","lovely","low","loyal","ltd","lucky","mad","magic","magnetic","magnificent","main","major","male","mammoth","managerial","managing","manual","many","marginal","marine","marked","married","marvellous","mass","massive","mathematical","mature","maximum","mean","meaningful","mechanical","medical","medieval","melodic","melted","mental","mere","metropolitan","middle","mighty","mild","military","miniature","minimal","minimum","ministerial","minor","miserable","misleading","missing","misty","mixed","moaning","mobile","moderate","modern","modest","molecular","monetary","monthly","moral","motionless","muddy","multiple","mushy","musical","mute","mutual","mysterious","naked","narrow","nasty","national","native","natural","naughty","naval","near","nearby","neat","necessary","negative","neighbouring","nervous","neutral","new","nice","noble","noisy","normal","northern","nosy","notable","novel","nuclear","numerous","nursing","nutritious","nutty","obedient","objective","obliged","obnoxious","obvious","occasional","occupational","odd","official","old","olympic","only","open","operational","opposite","optimistic","ordinary","organic","organisational","original","other","outdoor","outer","outrageous","outside","outstanding","overall","overseas","overwhelming","painful","pale","panicky","parallel","parental","parliamentary","partial","particular","passing","passive","past","patient","payable","peaceful","peculiar","perfect","permanent","persistent","personal","petite","philosophical","physical","plain","planned","plastic","pleasant","pleased","poised","polish","polite","political","poor","popular","positive","possible","potential","powerful","practical","precious","precise","preferred","pregnant","preliminary","premier","prepared","present","presidential","pretty","previous","prickly","primary","prime","primitive","principal","printed","prior","private","probable","productive","professional","profitable","profound","progressive","prominent","promising","proper","proposed","prospective","protective","protestant","proud","provincial","psychiatric","psychological","public","puny","pure","purring","puzzled","quaint","qualified","quick","quickest","quiet","radical","rainy","random","rapid","rare","raspy","rational","ratty","raw","ready","real","realistic","rear","reasonable","recent","reduced","redundant","regional","registered","regular","regulatory","related","relative","relaxed","relevant","reliable","relieved","reluctant","remaining","remarkable","remote","renewed","representative","repulsive","required","resident","residential","resonant","respectable","respective","responsible","resulting","retail","retired","revolutionary","rich","ridiculous","right","rigid","ripe","rising","rival","roasted","robust","rolling","roman","romantic","rotten","rough","round","royal","rubber","rude","ruling","running","rural","sacred","sad","safe","salty","satisfactory","satisfied","scared","scary","scattered","scientific","scornful","scottish","scrawny","screeching","secondary","secret","secure","select","selected","selective","selfish","semantic","senior","sensible","sensitive","separate","serious","severe","shaggy","shaky","shallow","shared","sharp","sheer","shiny","shivering","shocked","short","shrill","shy","sick","significant","silent","silky","silly","similar","simple","single","skilled","skinny","sleepy","slight","slim","slimy","slippery","slow","small","smart","smiling","smoggy","smooth","social","socialist","soft","solar","sole","solid","sophisticated","sore","sorry","sound","sour","southern","soviet","spanish","spare","sparkling","spatial","special","specific","specified","spectacular","spicy","spiritual","splendid","spontaneous","sporting","spotless","spotty","square","squealing","stable","stale","standard","static","statistical","statutory","steady","steep","sticky","stiff","still","stingy","stormy","straight","straightforward","strange","strategic","strict","striking","striped","strong","structural","stuck","stupid","subjective","subsequent","substantial","subtle","successful","successive","sudden","sufficient","suitable","sunny","super","superb","superior","supporting","supposed","supreme","sure","surprised","surprising","surrounding","surviving","suspicious","sweet","swift","swiss","symbolic","sympathetic","systematic","tall","tame","tart","tasteless","tasty","technical","technological","teenage","temporary","tender","tense","terrible","territorial","testy","then","theoretical","thick","thin","thirsty","thorough","thoughtful","thoughtless","thundering","tight","tiny","tired","top","tory","total","tough","toxic","traditional","tragic","tremendous","tricky","tropical","troubled","turkish","typical","ugliest","ugly","ultimate","unable","unacceptable","unaware","uncertain","unchanged","uncomfortable","unconscious","underground","underlying","unemployed","uneven","unexpected","unfair","unfortunate","unhappy","uniform","uninterested","unique","united","universal","unknown","unlikely","unnecessary","unpleasant","unsightly","unusual","unwilling","upper","upset","uptight","urban","urgent","used","useful","useless","usual","vague","valid","valuable","variable","varied","various","varying","vast","verbal","vertical","very","victorian","victorious","violent","visible","visiting","visual","vital","vivacious","vivid","vocational","voiceless","voluntary","vulnerable","wandering","warm","wasteful","watery","weak","wealthy","weary","weekly","weird","welcome","welsh","western","wet","whispering","whole","wicked","wide","widespread","wild","willing","wise","witty","wonderful","wooden","working","worldwide","worried","worrying","worthwhile","worthy","written","wrong","young","yummy","zany","zealous"]');
;// ./packages/keybr-names/lib/data/animals.json
const animals_namespaceObject = /*#__PURE__*/JSON.parse('["aardvark","aardwolf","albatross","alligator","alpaca","amphibian","anaconda","angelfish","anglerfish","ant","anteater","antelope","antlion","ape","aphid","armadillo","asp","baboon","badger","bandicoot","barnacle","barracuda","basilisk","bass","bat","bear","beaver","bedbug","bee","beetle","bird","bison","blackbird","boa","boar","bobcat","bobolink","bonobo","booby","bovid","bug","butterfly","buzzard","camel","canid","canidae","capybara","cardinal","caribou","carp","cat","caterpillar","catfish","catshark","cattle","centipede","cephalopod","chameleon","cheetah","chickadee","chicken","chimpanzee","chinchilla","chipmunk","cicada","clam","clownfish","cobra","cockroach","cod","condor","constrictor","coral","cougar","cow","coyote","crab","crane","crawdad","crayfish","cricket","crocodile","crow","cuckoo","damselfly","deer","dingo","dinosaur","dog","dolphin","donkey","dormouse","dove","dragon","dragonfly","duck","eagle","earthworm","earwig","echidna","eel","egret","elephant","elk","emu","ermine","falcon","felidae","ferret","finch","firefly","fish","flamingo","flea","fly","flyingfish","fowl","fox","frog","galliform","gamefowl","gayal","gazelle","gecko","gerbil","gibbon","giraffe","goat","goldfish","goose","gopher","gorilla","grasshopper","grouse","guan","guanaco","guineafowl","gull","guppy","haddock","halibut","hamster","hare","harrier","hawk","hedgehog","heron","herring","hippopotamus","hookworm","hornet","horse","hoverfly","hummingbird","hyena","iguana","impala","jackal","jaguar","jay","jellyfish","junglefowl","kangaroo","kingfisher","kite","kiwi","koala","koi","krill","ladybug","lamprey","landfowl","lark","leech","lemming","lemur","leopard","leopon","limpet","lion","lizard","llama","lobster","locust","loon","louse","lungfish","lynx","macaw","mackerel","magpie","mammal","manatee","mandrill","marlin","marmoset","marmot","marsupial","marten","mastodon","meadowlark","meerkat","mink","minnow","mite","mockingbird","mole","mollusk","mongoose","monkey","moose","mosquito","moth","mouse","mule","muskox","narwhal","newt","nightingale","ocelot","octopus","opossum","orangutan","orca","ostrich","otter","owl","ox","panda","panther","parakeet","parrot","parrotfish","partridge","peacock","peafowl","pelican","penguin","perch","pheasant","pig","pigeon","pike","pinniped","piranha","planarian","platypus","pony","porcupine","porpoise","possum","prawn","primate","ptarmigan","puffin","puma","python","quail","quelea","quokka","rabbit","raccoon","rat","rattlesnake","raven","reindeer","reptile","rhinoceros","roadrunner","rodent","rook","rooster","roundworm","sailfish","salamander","salmon","sawfish","scallop","scorpion","seahorse","shark","sheep","shrew","shrimp","silkworm","silverfish","skink","skunk","sloth","slug","smelt","snail","snake","snipe","sole","sparrow","spider","spoonbill","squid","squirrel","starfish","stingray","stoat","stork","sturgeon","swallow","swan","swift","swordfish","swordtail","tahr","takin","tapir","tarantula","tarsier","termite","tern","thrush","tick","tiger","tiglon","toad","tortoise","toucan","trout","tuna","turkey","turtle","tyrannosaurus","urial","vicuna","viper","vole","vulture","wallaby","walrus","warbler","wasp","weasel","whale","whippet","whitefish","wildcat","wildebeest","wildfowl","wolf","wolverine","wombat","woodpecker","worm","wren","xerinae","yak","zebra"]');
;// ./packages/keybr-names/lib/data/colors.json
const colors_namespaceObject = /*#__PURE__*/JSON.parse('["amaranth","amber","amethyst","apricot","aqua","aquamarine","azure","beige","black","blue","blush","bronze","brown","chocolate","coffee","copper","coral","crimson","cyan","emerald","fuchsia","gold","gray","green","harlequin","indigo","ivory","jade","lavender","lime","magenta","maroon","moccasin","olive","orange","peach","pink","plum","purple","red","rose","salmon","sapphire","scarlet","silver","tan","teal","tomato","turquoise","violet","white","yellow"]');
;// ./packages/keybr-names/lib/index.ts




function generateName({ separator = " ", capitalize = true, long = false, seed = 0, } = {}) {
    let random = Math.random;
    if (seed) {
        random = XorShift128Plus(seed);
    }
    if (long) {
        return fromParts([
            sample_randomSample(adjectives_namespaceObject, random),
            sample_randomSample(colors_namespaceObject, random),
            sample_randomSample(animals_namespaceObject, random),
        ], {
            separator,
            capitalize,
        });
    }
    else {
        return fromParts([
            sample_randomSample([...adjectives_namespaceObject, ...colors_namespaceObject], random),
            sample_randomSample(animals_namespaceObject, random),
        ], {
            separator,
            capitalize,
        });
    }
}
function fromParts(parts, { separator, capitalize, }) {
    return parts
        .map((v) => {
        if (capitalize) {
            return v.substring(0, 1).toUpperCase() + v.substring(1).toLowerCase();
        }
        else {
            return v.toLowerCase();
        }
    })
        .join(separator);
}

;// ./packages/keybr-rand/lib/hash.ts
function hashCode(value) {
    const { length } = value;
    let result = 1;
    for (let i = 0; i < length; i++) {
        result = (result * 31 + value.charCodeAt(i)) >>> 0;
    }
    return result;
}

;// ./packages/keybr-database/lib/name.ts


function anonymousName(hint) {
    let seed = 0;
    switch (typeof hint) {
        case "number":
            if (hint === 0) {
                throw new TypeError();
            }
            seed = hint;
            break;
        case "string":
            if (hint === "") {
                throw new TypeError();
            }
            seed = hashCode(hint);
            break;
        default:
            throw new TypeError();
    }
    return generateName({ seed });
}

;// ./packages/keybr-database/lib/util.ts
const alphabet = "0123456789" + //
    "abcdefghijklmnopqrstuvwxyz" + //
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
class Random {
    static string(length) {
        let result = "";
        for (let i = 0; i < length; i++) {
            result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return result;
    }
}

;// ./packages/keybr-database/lib/model.ts




function TimestampMixin(superClass) {
    return class extends superClass {
        createdAt;
        $beforeInsert() {
            if (this.createdAt == null) {
                this.createdAt = new Date();
            }
        }
    };
}
class model_User extends TimestampMixin(objection.Model) {
    static tableName = "user";
    static columnNameMappers = (0,objection.snakeCaseMappers)();
    static jsonSchema = {
        type: "object",
        required: ["email", "name"],
        properties: {
            id: { type: "integer" },
            email: { type: "string", minLength: 1, maxLength: 64 },
            name: { type: "string", minLength: 1, maxLength: 32 },
        },
    };
    static createTable(knex, table) {
        const { email, name } = model_User.jsonSchema.properties;
        table.increments("id").primary();
        table.string("email", email.maxLength).notNullable();
        table.string("name", name.maxLength).notNullable();
        table.boolean("anonymized").notNullable().defaultTo(false);
        table.timestamp("created_at").notNullable().defaultTo(knex.fn.now());
        table.unique(["email"]);
        table.unique(["name"]);
    }
    id;
    email;
    name;
    anonymized;
    createdAt;
    externalIds;
    order;
    static async loadProfileOwner(publicId) {
        if (publicId.example) {
            return publicId.toUser();
        }
        const user = await model_User.findById(publicId.id);
        if (user != null) {
            return model_User.toPublicUser(user, 0);
        }
        return null;
    }
    static async findById(id) {
        return ((await model_User.query() //
            .withGraphFetched("externalIds")
            .withGraphFetched("order")
            .findOne({ id })) ?? null);
    }
    static async findByEmail(email) {
        return ((await model_User.query() //
            .withGraphFetched("externalIds")
            .withGraphFetched("order")
            .findOne({ email })) ?? null);
    }
    static async loadAll(id) {
        return new Map((await model_User.query() //
            .withGraphFetched("externalIds")
            .withGraphFetched("order")
            .findByIds(id)).map((user) => [user.id, user]));
    }
    static async login(email) {
        let user = await model_User.findByEmail(email);
        if (user == null) {
            const name = await model_User.findUniqueName(email, email);
            user = await model_User.query()
                .withGraphFetched("externalIds")
                .withGraphFetched("order")
                .insertAndFetch({ email, name });
        }
        return user;
    }
    static async findUniqueName(email, hint) {
        for (const candidate of candidates(hint)) {
            if (!(await model_User.nameExists(email, candidate))) {
                return candidate;
            }
        }
        throw new Error(); // Unreachable.
        function* candidates(hint, length = 32) {
            let name = hint;
            const pos = hint.indexOf("@");
            if (pos !== -1) {
                name = hint.substring(0, pos);
            }
            name = name.substring(0, length);
            // Try original name.
            yield name;
            // Try name with numeric suffix.
            for (let index = 0; index < 10; index++) {
                const suffix = String(index + 1);
                yield name.substring(0, length - suffix.length) + suffix;
            }
            // Try name with random suffix.
            for (let index = 0; index < 10; index++) {
                const suffix = Random.string(10);
                yield name.substring(0, length - suffix.length) + suffix;
            }
        }
    }
    static async nameExists(email, name) {
        if (email != null) {
            return (await model_User.query().whereNot({ email }).findOne({ name })) != null;
        }
        else {
            return (await model_User.query().findOne({ name })) != null;
        }
    }
    static async ensure(ro) {
        ro = model_User.parseResourceOwner(ro);
        const { email } = ro;
        if (email == null) {
            throw new Error("No email address");
        }
        const user = await model_User.findByEmail(email);
        const model = await model_User.merge(user, ro, email);
        return await model_User.query().upsertGraphAndFetch(model);
    }
    static parseResourceOwner(ro) {
        const emailType = model_User.jsonSchema.properties.email;
        const nameType = model_User.jsonSchema.properties.name;
        const urlType = model_UserExternalId.jsonSchema.properties.url;
        const imageUrlType = model_UserExternalId.jsonSchema.properties.imageUrl;
        let { raw, provider, id, email, name, url, imageUrl } = ro;
        if (email != null && email.length > emailType.maxLength) {
            email = null;
        }
        if (name != null && name.length > nameType.maxLength) {
            name = name.substring(0, nameType.maxLength);
        }
        if (url != null && url.length > urlType.maxLength) {
            url = null;
        }
        if (imageUrl != null && imageUrl.length > imageUrlType.maxLength) {
            imageUrl = null;
        }
        return { raw, provider, id, email, name, url, imageUrl };
    }
    static async merge(user, ro, email) {
        let name;
        if (user != null && ro.name == null) {
            name = user.name;
        }
        else {
            name = await model_User.findUniqueName(email, ro.name ?? email);
        }
        const externalIds = new Map((user?.externalIds ?? []).map((id) => [id.provider, id]));
        externalIds.set(ro.provider, {
            ...externalIds.get(ro.provider),
            provider: ro.provider,
            externalId: ro.id,
            name: ro.name ?? undefined,
            url: ro.url ?? undefined,
            imageUrl: ro.imageUrl ?? undefined,
        });
        return {
            ...user,
            email: ro.email,
            name,
            externalIds: [...externalIds.values()],
        };
    }
    toDetails() {
        return {
            id: String(new PublicId(this.id)),
            email: this.email,
            name: this.name,
            anonymized: Boolean(this.anonymized),
            externalId: this.externalIds.map((id) => id.toDetails()),
            order: this.order?.toDetails() ?? null,
            createdAt: this.createdAt,
        };
    }
    static toPublicUser(user, hint) {
        if (user != null) {
            // Handle authenticated user.
            const details = user.toDetails();
            const premium = details.order != null;
            if (user.anonymized) {
                return Object.freeze({
                    id: details.id,
                    name: anonymousName(details.email),
                    imageUrl: null,
                    premium,
                });
            }
            const [externalId = null] = details.externalId;
            if (externalId != null) {
                // Try to take username from an external id, if exists.
                return Object.freeze({
                    id: details.id,
                    name: externalId.name ?? details.name,
                    imageUrl: externalId.imageUrl,
                    premium,
                });
            }
            else {
                // Otherwise use auto-generated username.
                return Object.freeze({
                    id: details.id,
                    name: details.name,
                    imageUrl: null,
                    premium,
                });
            }
        }
        else {
            // Handle anonymous user.
            return Object.freeze({
                id: null,
                name: anonymousName(hint),
                imageUrl: null,
            });
        }
    }
}
class model_UserExternalId extends TimestampMixin(objection.Model) {
    static tableName = "user_external_id";
    static columnNameMappers = (0,objection.snakeCaseMappers)();
    static jsonSchema = {
        type: "object",
        required: ["provider", "externalId"],
        properties: {
            id: { type: "integer" },
            provider: { type: "string", minLength: 1, maxLength: 16 },
            externalId: { type: "string", minLength: 1, maxLength: 32 },
            name: { type: ["null", "string"], minLength: 1, maxLength: 64 },
            url: { type: ["null", "string"], minLength: 1, maxLength: 256 },
            imageUrl: { type: ["null", "string"], minLength: 1, maxLength: 256 },
        },
    };
    static createTable(knex, table) {
        const { provider, externalId, name, url, imageUrl } = model_UserExternalId.jsonSchema.properties;
        table.increments("id").primary();
        table
            .integer("user_id")
            .unsigned()
            .notNullable()
            .references("id")
            .inTable("user")
            .onDelete("CASCADE")
            .onUpdate("CASCADE");
        table.string("provider", provider.maxLength).notNullable();
        table.string("external_id", externalId.maxLength).notNullable();
        table.string("name", name.maxLength).nullable();
        table.string("url", url.maxLength).nullable();
        table.string("image_url", imageUrl.maxLength).nullable();
        table.timestamp("created_at").notNullable().defaultTo(knex.fn.now());
        table.unique(["user_id", "provider"]);
        table.unique(["provider", "external_id"]);
    }
    id;
    provider;
    externalId;
    name;
    url;
    imageUrl;
    createdAt;
    user;
    toDetails() {
        return {
            provider: this.provider,
            id: this.externalId,
            name: this.name ?? null,
            url: this.url ?? null,
            imageUrl: this.imageUrl ?? null,
            createdAt: this.createdAt,
        };
    }
}
class model_Order extends TimestampMixin(objection.Model) {
    static tableName = "order";
    static columnNameMappers = (0,objection.snakeCaseMappers)();
    static jsonSchema = {
        type: "object",
        required: ["id", "provider"],
        properties: {
            id: { type: "string", minLength: 1, maxLength: 100 },
            provider: { type: "string", minLength: 1, maxLength: 30 },
            name: { type: ["null", "string"], minLength: 1, maxLength: 100 },
            email: { type: ["null", "string"], minLength: 1, maxLength: 100 },
        },
    };
    static createTable(knex, table) {
        const { id, provider, name, email } = model_Order.jsonSchema.properties;
        table.string("id", id.maxLength).primary();
        table.string("provider", provider.maxLength).notNullable();
        table.timestamp("created_at").notNullable().defaultTo(knex.fn.now());
        table
            .integer("user_id")
            .unsigned()
            .notNullable()
            .references("id")
            .inTable("user")
            .onDelete("CASCADE")
            .onUpdate("CASCADE");
        table.string("name", name.maxLength).nullable();
        table.string("email", email.maxLength).nullable();
        table.unique(["user_id"]);
    }
    id;
    provider;
    name;
    email;
    createdAt;
    user;
    toDetails() {
        return {
            id: this.id,
            provider: this.provider,
            name: this.name ?? null,
            email: this.email ?? null,
            createdAt: this.createdAt,
        };
    }
}
class model_UserLoginRequest extends TimestampMixin(objection.Model) {
    static tableName = "user_login_request";
    static columnNameMappers = (0,objection.snakeCaseMappers)();
    static jsonSchema = {
        type: "object",
        required: ["email", "accessToken"],
        properties: {
            id: { type: "integer" },
            email: { type: "string", minLength: 1, maxLength: 64 },
            accessToken: { type: "string", minLength: 1, maxLength: 64 },
        },
    };
    static createTable(knex, table) {
        const { email, accessToken } = model_UserLoginRequest.jsonSchema.properties;
        table.increments("id").primary();
        table.string("email", email.maxLength).notNullable();
        table.binary("access_token", accessToken.maxLength).notNullable();
        table.timestamp("created_at").notNullable().defaultTo(knex.fn.now());
        table.unique(["email"]);
        table.unique(["access_token"]);
    }
    static expireTime = 24 * 3600 * 1000;
    id;
    email;
    accessToken;
    createdAt;
    $formatDatabaseJson(json) {
        json = super.$formatDatabaseJson(json);
        if (json.accessToken != null) {
            json.accessToken = Buffer.from(json.accessToken);
        }
        return json;
    }
    $parseDatabaseJson(json) {
        json = super.$parseDatabaseJson(json);
        if (json.accessToken != null) {
            json.accessToken = String(json.accessToken);
        }
        return json;
    }
    static async findById(id) {
        return (await model_UserLoginRequest.query().findOne({ id })) ?? null;
    }
    static async findByEmail(email) {
        return (await model_UserLoginRequest.query().findOne({ email })) ?? null;
    }
    static async findByAccessToken(accessToken) {
        return (await model_UserLoginRequest.query().findOne({ accessToken })) ?? null;
    }
    static async init(email) {
        await this.deleteExpired();
        let request = await model_UserLoginRequest.findByEmail(email);
        if (request == null) {
            request = await model_UserLoginRequest.query().insertAndFetch({
                email,
                accessToken: Random.string(20),
            });
        }
        return request.accessToken;
    }
    static async login(accessToken) {
        await this.deleteExpired();
        const request = await model_UserLoginRequest.findByAccessToken(accessToken);
        if (request != null) {
            return model_User.login(request.email);
        }
        return null;
    }
    static async deleteExpired(now = Date.now()) {
        await model_UserLoginRequest.query()
            .where("createdAt", "<", new Date(now - model_UserLoginRequest.expireTime))
            .delete();
    }
}
model_User.relationMappings = {
    externalIds: {
        relation: objection.Model.HasManyRelation,
        modelClass: model_UserExternalId,
        join: {
            from: "user.id",
            to: "user_external_id.user_id",
        },
    },
    order: {
        relation: objection.Model.HasOneRelation,
        modelClass: model_Order,
        join: {
            from: "user.id",
            to: "order.user_id",
        },
    },
};
model_UserExternalId.relationMappings = {
    user: {
        relation: objection.Model.BelongsToOneRelation,
        modelClass: model_User,
        join: {
            from: "user_external_id.user_id",
            to: "user.id",
        },
    },
};
model_Order.relationMappings = {
    user: {
        relation: objection.Model.BelongsToOneRelation,
        modelClass: model_User,
        join: {
            from: "order.user_id",
            to: "user.id",
        },
    },
};
model_UserLoginRequest.relationMappings = {};

;// ./packages/keybr-database/lib/schema.ts

async function createSchema(knex) {
    const createTable = async ({ tableName, createTable, }) => {
        const { schema } = knex;
        if (!(await schema.hasTable(tableName))) {
            await schema.createTable(tableName, (table) => {
                createTable(knex, table);
            });
        }
    };
    await createTable(User);
    await createTable(UserExternalId);
    await createTable(Order);
    await createTable(UserLoginRequest);
}

;// ./packages/keybr-database/lib/index.ts



;// ./packages/server-cli/lib/command/premium/grant.ts




let GrantCommand = class GrantCommand {
    command() {
        return new Command("grant")
            .description("Grant premium account to a user.")
            .addArgument(new Argument("<user-email>", "User email."))
            .action(this.action.bind(this));
    }
    async action(email) {
        const user = await model_User.findByEmail(email);
        if (user == null) {
            throw new InvalidArgumentError(`User [${email}] not found.`);
        }
        if (user.order != null) {
            throw new InvalidArgumentError(`User [${email}] is already premium.`);
        }
        console.log(`Grant premium account to user [${email}].`);
        await user.$relatedQuery("order").insert({
            provider: "manual",
            id: email,
            createdAt: new Date(),
            name: user.name || null,
            email: user.email || null,
        });
    }
};
GrantCommand = __decorate([
    injectable()
], GrantCommand);


;// ./packages/server-cli/lib/command/premium/revoke.ts




let RevokeCommand = class RevokeCommand {
    command() {
        return new Command("revoke")
            .description("Revoke premium account from a user.")
            .addArgument(new Argument("<user-email>", "User email."))
            .action(this.action.bind(this));
    }
    async action(email) {
        const user = await model_User.findByEmail(email);
        if (user == null) {
            throw new InvalidArgumentError(`User [${email}] not found.`);
        }
        if (user.order == null) {
            throw new InvalidArgumentError(`User [${email}] is not premium.`);
        }
        console.log(`Revoke premium account from user [${email}].`);
        await user.$relatedQuery("order").delete();
    }
};
RevokeCommand = __decorate([
    injectable()
], RevokeCommand);


;// ./packages/server-cli/lib/command/premium/command.ts
var _a, _b;





let PremiumCommand = class PremiumCommand {
    grant;
    revoke;
    constructor(grant, revoke) {
        this.grant = grant;
        this.revoke = revoke;
    }
    command() {
        return new Command("premium")
            .description("Manipulate premium accounts.")
            .addCommand(this.grant.command())
            .addCommand(this.revoke.command());
    }
};
PremiumCommand = __decorate([
    injectable(),
    __metadata("design:paramtypes", [typeof (_a = typeof GrantCommand !== "undefined" && GrantCommand) === "function" ? _a : Object, typeof (_b = typeof RevokeCommand !== "undefined" && RevokeCommand) === "function" ? _b : Object])
], PremiumCommand);


;// ./packages/server-cli/lib/command/premium/index.ts


;// ./packages/keybr-result/lib/accuracy.ts
var accuracy_a;
class MutableStreakList {
    static level1 = 1.0;
    static level2 = 0.97;
    static level3 = 0.95;
    static findLongest(results) {
        const candidates = [
            { level: accuracy_a.level1, results: [] },
            { level: accuracy_a.level2, results: [] },
            { level: accuracy_a.level3, results: [] },
        ];
        const accept = (streak) => {
            for (const candidate of candidates) {
                if (streak.level >= candidate.level &&
                    streak.results.length >= candidate.results.length) {
                    candidate.results = streak.results;
                    break;
                }
            }
        };
        const list = new accuracy_a();
        for (const result of results) {
            list.append(result, accept);
        }
        list.end(accept);
        return candidates.filter((streak) => streak.results.length > 0);
    }
    #top = new TopMutableStreak();
    #level1 = new MutableStreak(accuracy_a.level1, this.#top);
    #level2 = new MutableStreak(accuracy_a.level2, this.#level1);
    #level3 = new MutableStreak(accuracy_a.level3, this.#level2);
    #bottom = new MutableStreak(0, this.#level3);
    #streaks = Object.freeze([this.#level1, this.#level2, this.#level3]);
    get level1() {
        return this.#level1;
    }
    get level2() {
        return this.#level2;
    }
    get level3() {
        return this.#level3;
    }
    [Symbol.iterator]() {
        return this.#streaks[Symbol.iterator]();
    }
    append(result, accept = null) {
        this.#bottom.append(result, accept);
    }
    end(accept) {
        this.#bottom.end(accept);
    }
    copy() {
        const level1 = this.#level1.copy();
        const level2 = this.#level2.copy();
        const level3 = this.#level3.copy();
        const streaks = [level1, level2, level3];
        return {
            level1,
            level2,
            level3,
            [Symbol.iterator]() {
                return streaks[Symbol.iterator]();
            },
        };
    }
}
accuracy_a = MutableStreakList;
class MutableStreak {
    #level;
    #next;
    #results;
    constructor(level, next) {
        this.#level = level;
        this.#next = next;
        this.#results = [];
    }
    get level() {
        return this.#level;
    }
    get results() {
        return this.#results;
    }
    append(result, accept) {
        const started = this.#results.length > this.#next.#results.length;
        if (this.#next.append(result, accept)) {
            if (started) {
                this.#results.push(result);
            }
            return true;
        }
        if (!started) {
            this.#results.push(...this.#next.#results);
        }
        this.#next.#results.length = 0;
        if (result.accuracy >= this.#level) {
            this.#results.push(result);
            return true;
        }
        if (started && this.#results.length > 0 && accept != null) {
            accept(this.copy());
        }
        return false;
    }
    end(accept) {
        if (this.#next != null) {
            this.#next.end(accept);
        }
        if (this.#results.length > 0) {
            accept(this.copy());
        }
    }
    copy() {
        return {
            level: this.#level,
            results: [...this.#results],
        };
    }
}
class TopMutableStreak extends MutableStreak {
    constructor() {
        super(Infinity, null);
    }
    append() {
        return false;
    }
}

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
;// ./packages/keybr-result/lib/context.ts

const context_ResultContext = (0,react.createContext)(null);
function useResults() {
    const value = useContext(context_ResultContext);
    if (value == null) {
        throw new Error( false
            ? 0
            : undefined);
    }
    return value;
}

;// ./packages/keybr-lang/lib/enum.ts
class Enum {
    #items;
    #byId;
    constructor(...items) {
        this.#items = [...items];
        this.#byId = new Map();
        for (const item of this.#items) {
            if (this.#byId.has(item.id)) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
            else {
                this.#byId.set(item.id, item);
            }
        }
    }
    [Symbol.iterator]() {
        return this.#items[Symbol.iterator]();
    }
    get size() {
        return this.#items.length;
    }
    at(index) {
        if (!Number.isInteger(index) || index < 0 || index >= this.#items.length) {
            throw new RangeError( false
                ? 0
                : undefined);
        }
        return this.#items[index];
    }
    indexOf(item) {
        return this.#items.indexOf(item);
    }
    has(item) {
        return this.#items.includes(item);
    }
    get(id, defaultValue = null) {
        let item = this.#byId.get(id) ?? null;
        if (item == null) {
            if (defaultValue == null) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
            else {
                item = defaultValue;
            }
        }
        return item;
    }
    map(fn) {
        return this.#items.map((value, index) => fn(value, index));
    }
    filter(fn) {
        return this.#items.filter((value, index) => fn(value, index));
    }
    find(fn) {
        return this.#items.find((value, index) => fn(value, index));
    }
}
class XEnum {
    #items;
    #byId;
    #byXId;
    constructor(...items) {
        this.#items = [...items];
        this.#byId = new Map();
        for (const item of this.#items) {
            if (this.#byId.has(item.id)) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
            else {
                this.#byId.set(item.id, item);
            }
        }
        this.#byXId = new Map();
        for (const item of this.#items) {
            if (this.#byXId.has(item.xid)) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
            else {
                this.#byXId.set(item.xid, item);
            }
        }
    }
    [Symbol.iterator]() {
        return this.#items[Symbol.iterator]();
    }
    get size() {
        return this.#items.length;
    }
    at(index) {
        if (!Number.isInteger(index) || index < 0 || index >= this.#items.length) {
            throw new RangeError( false
                ? 0
                : undefined);
        }
        return this.#items[index];
    }
    indexOf(item) {
        return this.#items.indexOf(item);
    }
    has(item) {
        return this.#items.includes(item);
    }
    get(id, defaultValue = null) {
        let item = this.#byId.get(id) ?? null;
        if (item == null) {
            if (defaultValue == null) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
            else {
                item = defaultValue;
            }
        }
        return item;
    }
    xget(xid, defaultValue = null) {
        let item = this.#byXId.get(xid) ?? null;
        if (item == null) {
            if (defaultValue == null) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
            else {
                item = defaultValue;
            }
        }
        return item;
    }
    map(fn) {
        return this.#items.map((value, index) => fn(value, index));
    }
    filter(fn) {
        return this.#items.filter((value, index) => fn(value, index));
    }
    find(fn) {
        return this.#items.find((value, index) => fn(value, index));
    }
}

;// ./packages/keybr-lang/lib/types.ts
const isBoolean = (v) => {
    return typeof v === "boolean";
};
const types_isNumber = (v) => {
    return typeof v === "number";
};
const types_isString = (v) => {
    return typeof v === "string";
};
const isSymbol = (v) => {
    return typeof v === "symbol";
};
const isFunction = (v) => {
    return typeof v === "function";
};
const types_isObject = (v) => {
    return v != null && typeof v === "object" && !Array.isArray(v);
};
const isObjectLike = (v) => {
    return v != null && typeof v === "object";
};
const types_isPlainObject = (v) => {
    if (v != null && typeof v === "object") {
        const p = Object.getPrototypeOf(v);
        if (p == null || p === Object.prototype) {
            return true;
        }
    }
    return false;
};
const isDate = (v) => {
    return Object.prototype.toString.call(v) === "[object Date]";
};

;// ./packages/keybr-lang/lib/index.ts









;// ./packages/keybr-result/lib/localdate.ts

var Month;
(function (Month) {
    Month[Month["January"] = 1] = "January";
    Month[Month["February"] = 2] = "February";
    Month[Month["March"] = 3] = "March";
    Month[Month["April"] = 4] = "April";
    Month[Month["May"] = 5] = "May";
    Month[Month["June"] = 6] = "June";
    Month[Month["July"] = 7] = "July";
    Month[Month["August"] = 8] = "August";
    Month[Month["September"] = 9] = "September";
    Month[Month["October"] = 10] = "October";
    Month[Month["November"] = 11] = "November";
    Month[Month["December"] = 12] = "December";
})(Month || (Month = {}));
var DayOfWeek;
(function (DayOfWeek) {
    DayOfWeek[DayOfWeek["Monday"] = 1] = "Monday";
    DayOfWeek[DayOfWeek["Tuesday"] = 2] = "Tuesday";
    DayOfWeek[DayOfWeek["Wednesday"] = 3] = "Wednesday";
    DayOfWeek[DayOfWeek["Thursday"] = 4] = "Thursday";
    DayOfWeek[DayOfWeek["Friday"] = 5] = "Friday";
    DayOfWeek[DayOfWeek["Saturday"] = 6] = "Saturday";
    DayOfWeek[DayOfWeek["Sunday"] = 7] = "Sunday";
})(DayOfWeek || (DayOfWeek = {}));
/**
 * A tuple consisting of a year, a month, and a day of the month,
 * all in the local timezone.
 */
class LocalDate {
    /** The year number in a local timezone, four digits. */
    year;
    /** The month number in a local timezone, 1-12. */
    month;
    /** The day of month number in a local timezone, 1-31. */
    dayOfMonth;
    /** The day of week number in a local timezone, 1-7. */
    dayOfWeek;
    /** The timestamp of midnight in the UTC timezone, milliseconds. */
    timeStamp;
    /** The string value formatted as YYYY-MM-DD. */
    value;
    static now() {
        return new LocalDate(Date.now());
    }
    constructor(...args) {
        const { length } = args;
        let year;
        let month;
        let day;
        let timeStamp;
        let date;
        if (length === 3 &&
            types_isNumber((year = args[0])) &&
            types_isNumber((month = args[1])) &&
            types_isNumber((day = args[2]))) {
            date = new Date(year, month - 1, day);
            if (date.getFullYear() !== year ||
                date.getMonth() !== month - 1 ||
                date.getDate() !== day) {
                throw new Error( false
                    ? 0
                    : undefined);
            }
        }
        else if (length === 1 && types_isNumber((timeStamp = args[0]))) {
            date = new Date(timeStamp);
        }
        else if (length === 1 && types_isObject((date = args[0]))) {
            date = new Date(date.getTime());
        }
        else {
            throw new TypeError( false
                ? 0
                : undefined);
        }
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        this.year = date.getFullYear();
        this.month = date.getMonth() + 1;
        this.dayOfMonth = date.getDate();
        let dayOfWeek = date.getDay();
        if (dayOfWeek === 0) {
            dayOfWeek = 7;
        }
        this.dayOfWeek = dayOfWeek;
        this.timeStamp = date.getTime();
        this.value =
            String(this.year) +
                "-" +
                String(this.month).padStart(2, "0") +
                "-" +
                String(this.dayOfMonth).padStart(2, "0");
        return Object.freeze(this);
    }
    plusDays(days) {
        const date = new Date(this.timeStamp);
        date.setDate(date.getDate() + days);
        return new LocalDate(date);
    }
    minusDays(days) {
        const date = new Date(this.timeStamp);
        date.setDate(date.getDate() - days);
        return new LocalDate(date);
    }
    toString() {
        return this.value;
    }
    valueOf() {
        return this.timeStamp;
    }
}
class LocalDateRange {
    #from;
    #to;
    constructor(from, to) {
        this.#from = from;
        this.#to = to;
    }
    get from() {
        return this.#from;
    }
    get to() {
        return this.#to;
    }
    includes(timeStamp) {
        return this.#from.timeStamp <= timeStamp && timeStamp < this.#to.timeStamp;
    }
    toString() {
        return `${this.#from} - ${this.#to}`;
    }
}
class Yesterday extends LocalDateRange {
    constructor(now = LocalDate.now()) {
        super(now.minusDays(1), now);
    }
}
class Today extends LocalDateRange {
    constructor(now = LocalDate.now()) {
        super(now, now.plusDays(1));
    }
}

;// ./packages/keybr-result/lib/group.ts

const layoutKey = () => {
    return ({ layout }) => layout;
};
const layoutFamilyKey = () => {
    return ({ layout }) => layout.family;
};
const dateKey = () => {
    let date = new LocalDate(0);
    let next = new LocalDate(0);
    return (result) => {
        const { timeStamp } = result;
        if (!(date.timeStamp <= timeStamp && timeStamp < next.timeStamp)) {
            date = new LocalDate(timeStamp);
            next = date.plusDays(1);
        }
        return date;
    };
};
class ResultGroups {
    static byLayout = (results) => {
        return new ResultGroups(layoutKey()).addAll(results);
    };
    static byLayoutFamily = (results) => {
        return new ResultGroups(layoutFamilyKey()).addAll(results);
    };
    static byDate = (results) => {
        return new ResultGroups(dateKey()).addAll(results);
    };
    #keyOf;
    #map;
    constructor(keyOf) {
        this.#keyOf = keyOf;
        this.#map = new Map();
    }
    [Symbol.iterator]() {
        return this.#map.values();
    }
    *keys() {
        for (const { key } of this.#map.values()) {
            yield key;
        }
    }
    get(key) {
        return this.#getGroup(key).results;
    }
    add(result) {
        this.#getGroup(this.#keyOf(result)).results.push(result);
        return this;
    }
    addAll(results) {
        for (const result of results) {
            this.add(result);
        }
        return this;
    }
    #getGroup(key) {
        const stringKey = String(key);
        let group = this.#map.get(stringKey);
        if (group == null) {
            this.#map.set(stringKey, (group = { key, results: [] }));
        }
        return group;
    }
}

;// ./packages/keybr-result/lib/summarystats.ts
function makeSummaryStats(results) {
    const stats = new MutableSummaryStats();
    for (const result of results) {
        stats.append(result);
    }
    return stats.copy();
}
class MutableSummaryStats {
    #count = 0;
    #time = 0;
    #speed = new MutableMetric();
    #accuracy = new MutableMetric();
    #score = new MutableMetric();
    get count() {
        return this.#count;
    }
    get time() {
        return this.#time;
    }
    get speed() {
        return this.#speed;
    }
    get accuracy() {
        return this.#accuracy;
    }
    get score() {
        return this.#score;
    }
    append(result) {
        this.#count += 1;
        this.#time += result.time;
        this.#speed.append(result.speed);
        this.#accuracy.append(result.accuracy);
        this.#score.append(result.score);
    }
    copy() {
        return {
            count: this.#count,
            time: this.#time,
            speed: this.#speed.copy(),
            accuracy: this.#accuracy.copy(),
            score: this.#score.copy(),
        };
    }
}
class MutableMetric {
    #last = 0;
    #delta = 0;
    #count = 0;
    #sum = 0;
    #min = 0;
    #max = 0;
    #avg = 0;
    get last() {
        return this.#last;
    }
    get delta() {
        return this.#delta;
    }
    get min() {
        return this.#min;
    }
    get max() {
        return this.#max;
    }
    get avg() {
        return this.#avg;
    }
    append(value) {
        this.#count += 1;
        if (this.#count === 1) {
            this.#last = value;
            this.#delta = value;
            this.#sum = value;
            this.#min = value;
            this.#max = value;
            this.#avg = value;
        }
        else {
            this.#last = value;
            this.#delta = value - this.#avg;
            this.#sum += value;
            this.#min = Math.min(this.#min, value);
            this.#max = Math.max(this.#max, value);
            this.#avg = this.#sum / this.#count;
        }
    }
    copy() {
        return {
            last: this.#last,
            delta: this.#delta,
            min: this.#min,
            max: this.#max,
            avg: this.#avg,
        };
    }
}

;// ./packages/keybr-result/lib/dailystats.ts



class DailyStatsMap {
    #map = new Map();
    #today;
    constructor(results, today = LocalDate.now()) {
        const groups = ResultGroups.byDate(results);
        for (const { key, results } of groups) {
            this.#map.set(String(key), makeStats(key, results));
        }
        this.#today = this.#map.get(String(today)) ?? makeStats(today, []);
    }
    [Symbol.iterator]() {
        return this.#map.values();
    }
    has(date) {
        return this.#map.has(String(date));
    }
    get(date) {
        return this.#map.get(String(date)) ?? makeStats(date, []);
    }
    /** Summary stats for the results of today. May not exist in the iterated entries. */
    get today() {
        return this.#today;
    }
}
function makeStats(date, results) {
    return { date, results, stats: makeSummaryStats(results) };
}

;// ./packages/keybr-result/lib/errors.ts
class InvalidResultError extends Error {
    name = "InvalidResultError";
    constructor(message, options) {
        super(message, options);
    }
    get [Symbol.toStringTag]() {
        return "InvalidResultError";
    }
}

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("./node_modules/react/jsx-runtime.js");
;// ./packages/keybr-settings/lib/context.ts

const context_SettingsContext = (0,react.createContext)(null);
function context_useSettings() {
    const value = useContext(context_SettingsContext);
    if (value == null) {
        throw new Error( false
            ? 0
            : undefined);
    }
    return value;
}

;// ./packages/keybr-settings/lib/settings.ts

let defaultJson = createJson();
class settings_Settings {
    static addDefaults(settings) {
        defaultJson = mergeJson(defaultJson, settings.#json);
    }
    #json;
    #isNew;
    constructor(json = createJson(), isNew = false) {
        if (!isPlainObject(json)) {
            throw new TypeError();
        }
        this.#json = migrate(cloneJson(json));
        this.#isNew = isNew;
    }
    get isNew() {
        return this.#isNew;
    }
    get(prop, defaultValue) {
        return prop.fromJson(this.#json[prop.key] ?? defaultJson[prop.key], defaultValue);
    }
    set(prop, value) {
        return new settings_Settings({ ...this.#json, [prop.key]: prop.toJson(value) });
    }
    reset() {
        return new settings_Settings();
    }
    toJSON() {
        const entries = [];
        for (const key of Object.keys(this.#json).sort()) {
            entries.push([key, this.#json[key]]);
        }
        return Object.fromEntries(entries);
    }
}
function createJson() {
    return Object.create(null);
}
function cloneJson(o) {
    return Object.assign(createJson(), o);
}
function mergeJson(a, b) {
    return Object.assign(createJson(), a, b);
}
function migrate(json) {
    return json;
}

;// ./packages/keybr-settings/lib/fake.tsx




function FakeSettingsContext({ initialSettings = new Settings(), children, }) {
    const [settings, setSettings] = useState(initialSettings);
    return (_jsx(SettingsContext.Provider, { value: {
            settings,
            updateSettings: (newSettings) => {
                setSettings(newSettings);
            },
        }, children: children }));
}

;// ./packages/keybr-settings/lib/props.ts
function booleanProp(key, defaultValue) {
    return {
        type: "boolean",
        key,
        defaultValue,
        toJson(value) {
            return value;
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "boolean" ? value : defaultValue0;
        },
    };
}
function numberProp(key, defaultValue, { min = NaN, max = NaN, } = {}) {
    return {
        type: "number",
        key,
        defaultValue,
        min,
        max,
        toJson(value) {
            return clamp(value, min, max);
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "number" ? clamp(value, min, max) : defaultValue0;
        },
    };
}
function stringProp(key, defaultValue, { maxLength = NaN, } = {}) {
    return {
        type: "string",
        key,
        defaultValue,
        maxLength,
        toJson(value) {
            return trim(value, maxLength);
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "string" ? trim(value, maxLength) : defaultValue0;
        },
    };
}
function enumProp(key, all, defaultValue) {
    const map = new Map();
    for (const [from, to] of Object.entries(all)) {
        if (typeof from === "string" && typeof to === "number") {
            map.set(from.toLowerCase(), to);
            map.set(to, from.toLowerCase());
        }
    }
    return {
        type: "enum",
        key,
        defaultValue,
        all,
        toJson(value) {
            return map.get(value);
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "string"
                ? (map.get(value) ?? defaultValue0)
                : defaultValue0;
        },
    };
}
function itemProp(key, all, defaultValue) {
    return {
        type: "item",
        key,
        defaultValue,
        all,
        toJson(value) {
            return value.id;
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "string"
                ? all.get(value, defaultValue0)
                : defaultValue0;
        },
    };
}
function xitemProp(key, all, defaultValue) {
    return {
        type: "xitem",
        key,
        defaultValue,
        all,
        toJson(value) {
            return value.id;
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "string"
                ? all.get(value, defaultValue0)
                : defaultValue0;
        },
    };
}
function flagsProp(key, all, defaultValue = all) {
    return {
        type: "flags",
        key,
        defaultValue: all,
        all,
        toJson(value) {
            return value.filter((v) => all.includes(v)).join(",");
        },
        fromJson(value, defaultValue0 = defaultValue) {
            return typeof value === "string"
                ? value.split(",").filter((v) => all.includes(v))
                : defaultValue0;
        },
    };
}
function clamp(value, min, max) {
    if (min === min) {
        value = Math.max(min, value);
    }
    if (max === max) {
        value = Math.min(max, value);
    }
    return value;
}
function trim(value, maxLength) {
    if (maxLength === maxLength) {
        value = value.substring(0, maxLength);
    }
    return value;
}

;// ./packages/keybr-settings/lib/index.ts






;// ./packages/keybr-keyboard/lib/geometry/mod.ts
const STANDARD_MOD = {};
const ANGLE_MOD = {
    Backquote: ["pinky", "left", "digit"],
    Digit1: ["pinky", "left", "digit"],
    Digit2: ["ring", "left", "digit"],
    Digit3: ["middle", "left", "digit"],
    Digit4: ["middle", "left", "digit"],
    Digit5: ["leftIndex", "left", "digit"],
    Digit6: ["leftIndex", "left", "digit"],
    Digit7: ["rightIndex", "right", "digit"],
    Digit8: ["rightIndex", "right", "digit"],
    Digit9: ["middle", "right", "digit"],
    Digit0: ["ring", "right", "digit"],
    Minus: ["pinky", "right", "digit"],
    Equal: ["pinky", "right", "digit"],
    Backspace: ["pinky", "right", "digit"],
    Tab: ["pinky", "left", "top"],
    KeyQ: ["pinky", "left", "top"],
    KeyW: ["ring", "left", "top"],
    KeyE: ["middle", "left", "top"],
    KeyR: ["leftIndex", "left", "top"],
    KeyT: ["leftIndex", "left", "top"],
    KeyY: ["rightIndex", "right", "top"],
    KeyU: ["rightIndex", "right", "top"],
    KeyI: ["middle", "right", "top"],
    KeyO: ["ring", "right", "top"],
    KeyP: ["pinky", "right", "top"],
    BracketLeft: ["pinky", "right", "top"],
    BracketRight: ["pinky", "right", "top"],
    Backslash: ["pinky", "right", "top"],
    CapsLock: ["pinky", "left", "home"],
    KeyA: ["pinky", "left", "home"],
    KeyS: ["ring", "left", "home"],
    KeyD: ["middle", "left", "home"],
    KeyF: ["leftIndex", "left", "home"],
    KeyG: ["leftIndex", "left", "home"],
    KeyH: ["rightIndex", "right", "home"],
    KeyJ: ["rightIndex", "right", "home"],
    KeyK: ["middle", "right", "home"],
    KeyL: ["ring", "right", "home"],
    Semicolon: ["pinky", "right", "home"],
    Quote: ["pinky", "right", "home"],
    Enter: ["pinky", "right", "home"],
    ShiftLeft: ["pinky", "left", "bottom"],
    KeyZ: ["ring", "left", "bottom"],
    KeyX: ["middle", "left", "bottom"],
    KeyC: ["leftIndex", "left", "bottom"],
    KeyV: ["leftIndex", "left", "bottom"],
    KeyB: ["leftIndex", "left", "bottom"],
    KeyN: ["rightIndex", "right", "bottom"],
    KeyM: ["rightIndex", "right", "bottom"],
    Comma: ["middle", "right", "bottom"],
    Period: ["ring", "right", "bottom"],
    Slash: ["pinky", "right", "bottom"],
    ShiftRight: ["pinky", "right", "bottom"],
    ControlLeft: ["pinky", "left", "bottom"],
    AltLeft: ["pinky", "left", "bottom"],
    Space: ["thumb", "right", "bottom"],
    AltRight: ["pinky", "right", "bottom"],
    ControlRight: ["pinky", "right", "bottom"],
};
const ANGLE_WIDE_MOD = {
    Backquote: ["pinky", "left", "digit"],
    Digit1: ["pinky", "left", "digit"],
    Digit2: ["ring", "left", "digit"],
    Digit3: ["middle", "left", "digit"],
    Digit4: ["middle", "left", "digit"],
    Digit5: ["leftIndex", "left", "digit"],
    Digit6: ["leftIndex", "left", "digit"],
    Digit7: ["rightIndex", "right", "digit"],
    Digit8: ["rightIndex", "right", "digit"],
    Digit9: ["rightIndex", "right", "digit"],
    Digit0: ["middle", "right", "digit"],
    Minus: ["ring", "right", "digit"],
    Equal: ["pinky", "right", "digit"],
    Backspace: ["pinky", "right", "digit"],
    Tab: ["pinky", "left", "top"],
    KeyQ: ["pinky", "left", "top"],
    KeyW: ["ring", "left", "top"],
    KeyE: ["middle", "left", "top"],
    KeyR: ["leftIndex", "left", "top"],
    KeyT: ["leftIndex", "left", "top"],
    KeyY: ["rightIndex", "right", "top"],
    KeyU: ["rightIndex", "right", "top"],
    KeyI: ["rightIndex", "right", "top"],
    KeyO: ["middle", "right", "top"],
    KeyP: ["ring", "right", "top"],
    BracketLeft: ["pinky", "right", "top"],
    BracketRight: ["pinky", "right", "top"],
    Backslash: ["pinky", "right", "top"],
    CapsLock: ["pinky", "left", "home"],
    KeyA: ["pinky", "left", "home"],
    KeyS: ["ring", "left", "home"],
    KeyD: ["middle", "left", "home"],
    KeyF: ["leftIndex", "left", "home"],
    KeyG: ["leftIndex", "left", "home"],
    KeyH: ["rightIndex", "right", "home"],
    KeyJ: ["rightIndex", "right", "home"],
    KeyK: ["rightIndex", "right", "home"],
    KeyL: ["middle", "right", "home"],
    Semicolon: ["ring", "right", "home"],
    Quote: ["pinky", "right", "home"],
    Enter: ["pinky", "right", "home"],
    ShiftLeft: ["pinky", "left", "bottom"],
    KeyZ: ["ring", "left", "bottom"],
    KeyX: ["middle", "left", "bottom"],
    KeyC: ["leftIndex", "left", "bottom"],
    KeyV: ["leftIndex", "left", "bottom"],
    KeyB: ["leftIndex", "left", "bottom"],
    KeyN: ["rightIndex", "right", "bottom"],
    KeyM: ["rightIndex", "right", "bottom"],
    Comma: ["rightIndex", "right", "bottom"],
    Period: ["middle", "right", "bottom"],
    Slash: ["ring", "right", "bottom"],
    ShiftRight: ["pinky", "right", "bottom"],
    ControlLeft: ["pinky", "left", "bottom"],
    AltLeft: ["pinky", "left", "bottom"],
    Space: ["thumb", "right", "bottom"],
    AltRight: ["pinky", "right", "bottom"],
    ControlRight: ["pinky", "right", "bottom"],
};
const SYMMETRIC_MOD = {
    Backquote: ["pinky", "left", "digit"],
    Digit1: ["pinky", "left", "digit"],
    Digit2: ["ring", "left", "digit"],
    Digit3: ["middle", "left", "digit"],
    Digit4: ["middle", "left", "digit"],
    Digit5: ["leftIndex", "left", "digit"],
    Digit6: ["leftIndex", "right", "digit"],
    Digit7: ["rightIndex", "right", "digit"],
    Digit8: ["middle", "right", "digit"],
    Digit9: ["middle", "right", "digit"],
    Digit0: ["ring", "right", "digit"],
    Minus: ["pinky", "right", "digit"],
    Equal: ["pinky", "right", "digit"],
    Backspace: ["pinky", "right", "digit"],
    Tab: ["pinky", "left", "top"],
    KeyQ: ["pinky", "left", "top"],
    KeyW: ["ring", "left", "top"],
    KeyE: ["middle", "left", "top"],
    KeyR: ["leftIndex", "left", "top"],
    KeyT: ["leftIndex", "left", "top"],
    KeyY: ["rightIndex", "right", "top"],
    KeyU: ["rightIndex", "right", "top"],
    KeyI: ["middle", "right", "top"],
    KeyO: ["ring", "right", "top"],
    KeyP: ["pinky", "right", "top"],
    BracketLeft: ["pinky", "right", "top"],
    BracketRight: ["pinky", "right", "top"],
    Enter: ["pinky", "right", "top"],
    CapsLock: ["pinky", "left", "home"],
    KeyA: ["pinky", "left", "home"],
    KeyS: ["ring", "left", "home"],
    KeyD: ["middle", "left", "home"],
    KeyF: ["leftIndex", "left", "home"],
    KeyG: ["leftIndex", "left", "home"],
    KeyH: ["rightIndex", "right", "home"],
    KeyJ: ["rightIndex", "right", "home"],
    KeyK: ["middle", "right", "home"],
    KeyL: ["ring", "right", "home"],
    Semicolon: ["pinky", "right", "home"],
    Quote: ["pinky", "right", "home"],
    Backslash: ["pinky", "right", "home"],
    ShiftLeft: ["pinky", "left", "bottom"],
    IntlBackslash: ["pinky", "left", "bottom"],
    KeyZ: ["ring", "left", "bottom"],
    KeyX: ["middle", "left", "bottom"],
    KeyC: ["leftIndex", "left", "bottom"],
    KeyV: ["leftIndex", "left", "bottom"],
    KeyB: ["leftIndex", "left", "bottom"],
    KeyN: ["rightIndex", "right", "bottom"],
    KeyM: ["rightIndex", "right", "bottom"],
    Comma: ["middle", "right", "bottom"],
    Period: ["ring", "right", "bottom"],
    Slash: ["pinky", "right", "bottom"],
    ShiftRight: ["pinky", "right", "bottom"],
    ControlLeft: ["pinky", "left", "bottom"],
    AltLeft: ["pinky", "left", "bottom"],
    Space: ["thumb", "right", "bottom"],
    AltRight: ["pinky", "right", "bottom"],
    ControlRight: ["pinky", "right", "bottom"],
};

;// ./packages/keybr-keyboard/lib/geometry.ts


class geometry_ZoneMod {
    id;
    name;
    mod;
    static STANDARD = new geometry_ZoneMod("standard", //
    "Standard", STANDARD_MOD);
    static SYMMETRIC = new geometry_ZoneMod("symmetric", "Symmetric", SYMMETRIC_MOD);
    static ALL = new Enum(geometry_ZoneMod.STANDARD, //
    geometry_ZoneMod.SYMMETRIC);
    static first(items) {
        return items[Symbol.iterator]().next().value ?? geometry_ZoneMod.STANDARD;
    }
    constructor(id, name, mod) {
        this.id = id;
        this.name = name;
        this.mod = mod;
    }
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}
class geometry_Geometry {
    id;
    name;
    form;
    zones;
    static ANSI_101 = new geometry_Geometry("ansi101", //
    "ANSI 101", "staggered", geometry_ZoneMod.ALL);
    static ANSI_101_FULL = new geometry_Geometry("ansi101full", //
    "ANSI 101 (Full)", "staggered", geometry_ZoneMod.ALL);
    static ISO_102 = new geometry_Geometry("iso102", //
    "ISO 102", "staggered", geometry_ZoneMod.ALL);
    static ISO_102_FULL = new geometry_Geometry("iso102full", //
    "ISO 102 (Full)", "staggered", geometry_ZoneMod.ALL);
    static KOREAN_103 = new geometry_Geometry("kr103", //
    "Korean 103", "staggered", geometry_ZoneMod.ALL);
    static KOREAN_103_FULL = new geometry_Geometry("kr103full", //
    "Korean 103 (Full)", "staggered", geometry_ZoneMod.ALL);
    static BRAZILIAN_104 = new geometry_Geometry("br104", //
    "Brazilian 104", "staggered", geometry_ZoneMod.ALL);
    static BRAZILIAN_104_FULL = new geometry_Geometry("br104full", //
    "Brazilian 104 (Full)", "staggered", geometry_ZoneMod.ALL);
    static JAPANESE_106 = new geometry_Geometry("jp106", //
    "Japanese 106", "staggered", geometry_ZoneMod.ALL);
    static JAPANESE_106_FULL = new geometry_Geometry("jp106full", //
    "Japanese 106 (Full)", "staggered", geometry_ZoneMod.ALL);
    static MATRIX = new geometry_Geometry("matrix", //
    "Matrix/Ergonomic", "matrix", new Enum());
    static ALL = new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.KOREAN_103, geometry_Geometry.KOREAN_103_FULL, geometry_Geometry.BRAZILIAN_104, geometry_Geometry.BRAZILIAN_104_FULL, geometry_Geometry.JAPANESE_106, geometry_Geometry.JAPANESE_106_FULL, geometry_Geometry.MATRIX);
    static first(items) {
        return items[Symbol.iterator]().next().value ?? geometry_Geometry.ANSI_101;
    }
    constructor(id, name, form, zones) {
        this.id = id;
        this.name = name;
        this.form = form;
        this.zones = zones;
    }
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}

;// ./packages/keybr-keyboard/lib/geometry/ansi_101.ts
// See https://www.w3.org/TR/uievents-code/#keyboard-101
const ANSI_101 = {
    Backquote: {
        x: 0,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit1: {
        x: 1,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit2: {
        x: 2,
        y: 0,
        zones: ["ring", "left", "digit"],
    },
    Digit3: {
        x: 3,
        y: 0,
        zones: ["middle", "left", "digit"],
    },
    Digit4: {
        x: 4,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit5: {
        x: 5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit6: {
        x: 6,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit7: {
        x: 7,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit8: {
        x: 8,
        y: 0,
        zones: ["middle", "right", "digit"],
    },
    Digit9: {
        x: 9,
        y: 0,
        zones: ["ring", "right", "digit"],
    },
    Digit0: {
        x: 10,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Minus: {
        x: 11,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Equal: {
        x: 12,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Backspace: {
        x: 13,
        y: 0,
        w: 2,
        h: 1,
        labels: [{ text: "Backspace" }],
        zones: ["pinky", "right", "digit"],
    },
    Tab: {
        x: 0,
        y: 1,
        w: 1.5,
        h: 1,
        labels: [{ text: "Tab" }],
        zones: ["pinky", "left", "top"],
    },
    KeyQ: {
        x: 1.5,
        y: 1,
        zones: ["pinky", "left", "top"],
    },
    KeyW: {
        x: 2.5,
        y: 1,
        zones: ["ring", "left", "top"],
    },
    KeyE: {
        x: 3.5,
        y: 1,
        zones: ["middle", "left", "top"],
    },
    KeyR: {
        x: 4.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyT: {
        x: 5.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyY: {
        x: 6.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyU: {
        x: 7.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyI: {
        x: 8.5,
        y: 1,
        zones: ["middle", "right", "top"],
    },
    KeyO: {
        x: 9.5,
        y: 1,
        zones: ["ring", "right", "top"],
    },
    KeyP: {
        x: 10.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketLeft: {
        x: 11.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketRight: {
        x: 12.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    Backslash: {
        x: 13.5,
        y: 1,
        w: 1.5,
        h: 1,
        zones: ["pinky", "right", "top"],
    },
    CapsLock: {
        x: 0,
        y: 2,
        w: 1.75,
        h: 1,
        labels: [{ text: "Caps Lock" }],
        zones: ["pinky", "left", "home"],
    },
    KeyA: {
        x: 1.75,
        y: 2,
        zones: ["pinky", "left", "home"],
    },
    KeyS: {
        x: 2.75,
        y: 2,
        zones: ["ring", "left", "home"],
    },
    KeyD: {
        x: 3.75,
        y: 2,
        zones: ["middle", "left", "home"],
    },
    KeyF: {
        x: 4.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
        homing: true,
    },
    KeyG: {
        x: 5.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
    },
    KeyH: {
        x: 6.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
    },
    KeyJ: {
        x: 7.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
        homing: true,
    },
    KeyK: {
        x: 8.75,
        y: 2,
        zones: ["middle", "right", "home"],
    },
    KeyL: {
        x: 9.75,
        y: 2,
        zones: ["ring", "right", "home"],
    },
    Semicolon: {
        x: 10.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Quote: {
        x: 11.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Enter: {
        x: 12.75,
        y: 2,
        w: 2.25,
        h: 1,
        labels: [{ text: "Enter" }],
        zones: ["pinky", "right", "home"],
    },
    ShiftLeft: {
        x: 0,
        y: 3,
        w: 2.25,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "left", "bottom"],
    },
    KeyZ: {
        x: 2.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyX: {
        x: 3.25,
        y: 3,
        zones: ["ring", "left", "bottom"],
    },
    KeyC: {
        x: 4.25,
        y: 3,
        zones: ["middle", "left", "bottom"],
    },
    KeyV: {
        x: 5.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyB: {
        x: 6.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyN: {
        x: 7.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    KeyM: {
        x: 8.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    Comma: {
        x: 9.25,
        y: 3,
        zones: ["middle", "right", "bottom"],
    },
    Period: {
        x: 10.25,
        y: 3,
        zones: ["ring", "right", "bottom"],
    },
    Slash: {
        x: 11.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    ShiftRight: {
        x: 12.25,
        y: 3,
        w: 2.75,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlLeft: {
        x: 0,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "left", "bottom"],
    },
    AltLeft: {
        x: 1.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "left", "bottom"],
    },
    Space: {
        x: 3,
        y: 4,
        w: 9,
        h: 1,
        zones: ["thumb", "right", "bottom"],
    },
    AltRight: {
        x: 12,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlRight: {
        x: 13.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "right", "bottom"],
    },
};

;// ./packages/keybr-keyboard/lib/geometry/extra.ts
const EXTRA = {
    Insert: {
        x: 15.5,
        y: 0,
        labels: [{ text: "Insert", pos: [5, 5], align: ["s", "t"] }],
    },
    Home: {
        x: 16.5,
        y: 0,
        labels: [{ text: "Home", pos: [5, 5], align: ["s", "t"] }],
    },
    PageUp: {
        x: 17.5,
        y: 0,
        labels: [
            { text: "Page", pos: [5, 5], align: ["s", "t"] },
            { text: "Up", pos: [5, 18], align: ["s", "t"] },
        ],
    },
    Delete: {
        x: 15.5,
        y: 1,
        labels: [{ text: "Delete", pos: [5, 5], align: ["s", "t"] }],
    },
    End: {
        x: 16.5,
        y: 1,
        labels: [{ text: "End", pos: [5, 5], align: ["s", "t"] }],
    },
    PageDown: {
        x: 17.5,
        y: 1,
        labels: [
            { text: "Page", pos: [5, 5], align: ["s", "t"] },
            { text: "Down", pos: [5, 18], align: ["s", "t"] },
        ],
    },
    ArrowUp: {
        x: 16.5,
        y: 3,
        labels: [{ text: "\u2191", pos: [20, 20], align: ["m", "m"] }],
    },
    ArrowLeft: {
        x: 15.5,
        y: 4,
        labels: [{ text: "\u2190", pos: [20, 20], align: ["m", "m"] }],
    },
    ArrowDown: {
        x: 16.5,
        y: 4,
        labels: [{ text: "\u2193", pos: [20, 20], align: ["m", "m"] }],
    },
    ArrowRight: {
        x: 17.5,
        y: 4,
        labels: [{ text: "\u2192", pos: [20, 20], align: ["m", "m"] }],
    },
    NumLock: {
        x: 19,
        y: 0,
        labels: [
            { text: "Num", pos: [5, 5], align: ["s", "t"] },
            { text: "Lock", pos: [5, 18], align: ["s", "t"] },
        ],
    },
    NumpadDivide: {
        x: 20,
        y: 0,
        labels: [{ text: "\u2044" }],
    },
    NumpadMultiply: {
        x: 21,
        y: 0,
        labels: [{ text: "\u00D7" }],
    },
    NumpadSubtract: {
        x: 22,
        y: 0,
        labels: [{ text: "\u2212" }],
    },
    Numpad7: {
        x: 19,
        y: 1,
        labels: [
            { text: "7", pos: [5, 5], align: ["s", "t"] },
            { text: "Home", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    Numpad8: {
        x: 20,
        y: 1,
        labels: [
            { text: "8", pos: [5, 5], align: ["s", "t"] },
            { text: "\u2191", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    Numpad9: {
        x: 21,
        y: 1,
        labels: [
            { text: "9", pos: [5, 5], align: ["s", "t"] },
            { text: "Pg Up", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    NumpadAdd: {
        x: 22,
        y: 1,
        w: 1,
        h: 2,
        labels: [{ text: "+" }],
    },
    Numpad4: {
        x: 19,
        y: 2,
        labels: [
            { text: "4", pos: [5, 5], align: ["s", "t"] },
            { text: "\u2190", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    Numpad5: {
        x: 20,
        y: 2,
        labels: [{ text: "5", pos: [5, 5], align: ["s", "t"] }],
    },
    Numpad6: {
        x: 21,
        y: 2,
        labels: [
            { text: "6", pos: [5, 5], align: ["s", "t"] },
            { text: "\u2192", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    Numpad1: {
        x: 19,
        y: 3,
        labels: [
            { text: "1", pos: [5, 5], align: ["s", "t"] },
            { text: "End", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    Numpad2: {
        x: 20,
        y: 3,
        labels: [
            { text: "2", pos: [5, 5], align: ["s", "t"] },
            { text: "\u2193", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    Numpad3: {
        x: 21,
        y: 3,
        labels: [
            { text: "3", pos: [5, 5], align: ["s", "t"] },
            { text: "Pg Dn", pos: [35, 35], align: ["e", "b"] },
        ],
    },
    NumpadEnter: {
        x: 22,
        y: 3,
        w: 1,
        h: 2,
        labels: [{ text: "Enter", pos: [5, 5], align: ["s", "t"] }],
    },
    Numpad0: {
        x: 19,
        y: 4,
        w: 2,
        h: 1,
        labels: [
            { text: "0", pos: [5, 5], align: ["s", "t"] },
            { text: "Ins", pos: [75, 35], align: ["e", "b"] },
        ],
    },
    NumpadDecimal: {
        x: 21,
        y: 4,
        labels: [
            { text: ".", pos: [5, 5], align: ["s", "t"] },
            { text: "Del", pos: [35, 35], align: ["e", "b"] },
        ],
    },
};

;// ./packages/keybr-keyboard/lib/geometry/ansi_101_full.ts


const ANSI_101_FULL = {
    ...ANSI_101,
    ...EXTRA,
};

;// ./packages/keybr-keyboard/lib/geometry/brazilian_104.ts
// See https://www.w3.org/TR/uievents-code/#keyboard-104
const BRAZILIAN_104 = {
    Backquote: {
        x: 0,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit1: {
        x: 1,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit2: {
        x: 2,
        y: 0,
        zones: ["ring", "left", "digit"],
    },
    Digit3: {
        x: 3,
        y: 0,
        zones: ["middle", "left", "digit"],
    },
    Digit4: {
        x: 4,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit5: {
        x: 5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit6: {
        x: 6,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit7: {
        x: 7,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit8: {
        x: 8,
        y: 0,
        zones: ["middle", "right", "digit"],
    },
    Digit9: {
        x: 9,
        y: 0,
        zones: ["ring", "right", "digit"],
    },
    Digit0: {
        x: 10,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Minus: {
        x: 11,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Equal: {
        x: 12,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Backspace: {
        x: 13,
        y: 0,
        w: 2,
        h: 1,
        labels: [{ text: "Backspace" }],
        zones: ["pinky", "right", "digit"],
    },
    Tab: {
        x: 0,
        y: 1,
        w: 1.5,
        h: 1,
        labels: [{ text: "Tab" }],
        zones: ["pinky", "left", "top"],
    },
    KeyQ: {
        x: 1.5,
        y: 1,
        zones: ["pinky", "left", "top"],
    },
    KeyW: {
        x: 2.5,
        y: 1,
        zones: ["ring", "left", "top"],
    },
    KeyE: {
        x: 3.5,
        y: 1,
        zones: ["middle", "left", "top"],
    },
    KeyR: {
        x: 4.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyT: {
        x: 5.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyY: {
        x: 6.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyU: {
        x: 7.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyI: {
        x: 8.5,
        y: 1,
        zones: ["middle", "right", "top"],
    },
    KeyO: {
        x: 9.5,
        y: 1,
        zones: ["ring", "right", "top"],
    },
    KeyP: {
        x: 10.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketLeft: {
        x: 11.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketRight: {
        x: 12.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    Enter: {
        x: 13.5,
        y: 1,
        w: 1.5,
        h: 2,
        labels: [{ text: "Enter" }],
        shape: "m 0 0 l 0 38 l 10 0 l 0 40 l 48 0 l 0 -78 z",
        zones: ["pinky", "right", "top"],
    },
    CapsLock: {
        x: 0,
        y: 2,
        w: 1.75,
        h: 1,
        labels: [{ text: "Caps Lock" }],
        zones: ["pinky", "left", "home"],
    },
    KeyA: {
        x: 1.75,
        y: 2,
        zones: ["pinky", "left", "home"],
    },
    KeyS: {
        x: 2.75,
        y: 2,
        zones: ["ring", "left", "home"],
    },
    KeyD: {
        x: 3.75,
        y: 2,
        zones: ["middle", "left", "home"],
    },
    KeyF: {
        x: 4.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
        homing: true,
    },
    KeyG: {
        x: 5.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
    },
    KeyH: {
        x: 6.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
    },
    KeyJ: {
        x: 7.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
        homing: true,
    },
    KeyK: {
        x: 8.75,
        y: 2,
        zones: ["middle", "right", "home"],
    },
    KeyL: {
        x: 9.75,
        y: 2,
        zones: ["ring", "right", "home"],
    },
    Semicolon: {
        x: 10.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Quote: {
        x: 11.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Backslash: {
        x: 12.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    ShiftLeft: {
        x: 0,
        y: 3,
        w: 1.25,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "left", "bottom"],
    },
    IntlBackslash: {
        x: 1.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyZ: {
        x: 2.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyX: {
        x: 3.25,
        y: 3,
        zones: ["ring", "left", "bottom"],
    },
    KeyC: {
        x: 4.25,
        y: 3,
        zones: ["middle", "left", "bottom"],
    },
    KeyV: {
        x: 5.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyB: {
        x: 6.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyN: {
        x: 7.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    KeyM: {
        x: 8.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    Comma: {
        x: 9.25,
        y: 3,
        zones: ["middle", "right", "bottom"],
    },
    Period: {
        x: 10.25,
        y: 3,
        zones: ["ring", "right", "bottom"],
    },
    Slash: {
        x: 11.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    IntlRo: {
        x: 12.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    ShiftRight: {
        x: 13.25,
        y: 3,
        w: 1.75,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlLeft: {
        x: 0,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "left", "bottom"],
    },
    AltLeft: {
        x: 1.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "left", "bottom"],
    },
    Space: {
        x: 3,
        y: 4,
        w: 9,
        h: 1,
        zones: ["thumb", "right", "bottom"],
    },
    AltRight: {
        x: 12,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlRight: {
        x: 13.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "right", "bottom"],
    },
};

;// ./packages/keybr-keyboard/lib/geometry/brazilian_104_full.ts


const BRAZILIAN_104_FULL = {
    ...BRAZILIAN_104,
    ...EXTRA,
};

;// ./packages/keybr-keyboard/lib/geometry/iso_102.ts
// See https://www.w3.org/TR/uievents-code/#keyboard-102
const ISO_102 = {
    Backquote: {
        x: 0,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit1: {
        x: 1,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit2: {
        x: 2,
        y: 0,
        zones: ["ring", "left", "digit"],
    },
    Digit3: {
        x: 3,
        y: 0,
        zones: ["middle", "left", "digit"],
    },
    Digit4: {
        x: 4,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit5: {
        x: 5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit6: {
        x: 6,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit7: {
        x: 7,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit8: {
        x: 8,
        y: 0,
        zones: ["middle", "right", "digit"],
    },
    Digit9: {
        x: 9,
        y: 0,
        zones: ["ring", "right", "digit"],
    },
    Digit0: {
        x: 10,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Minus: {
        x: 11,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Equal: {
        x: 12,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Backspace: {
        x: 13,
        y: 0,
        w: 2,
        h: 1,
        labels: [{ text: "Backspace" }],
        zones: ["pinky", "right", "digit"],
    },
    Tab: {
        x: 0,
        y: 1,
        w: 1.5,
        h: 1,
        labels: [{ text: "Tab" }],
        zones: ["pinky", "left", "top"],
    },
    KeyQ: {
        x: 1.5,
        y: 1,
        zones: ["pinky", "left", "top"],
    },
    KeyW: {
        x: 2.5,
        y: 1,
        zones: ["ring", "left", "top"],
    },
    KeyE: {
        x: 3.5,
        y: 1,
        zones: ["middle", "left", "top"],
    },
    KeyR: {
        x: 4.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyT: {
        x: 5.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyY: {
        x: 6.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyU: {
        x: 7.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyI: {
        x: 8.5,
        y: 1,
        zones: ["middle", "right", "top"],
    },
    KeyO: {
        x: 9.5,
        y: 1,
        zones: ["ring", "right", "top"],
    },
    KeyP: {
        x: 10.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketLeft: {
        x: 11.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketRight: {
        x: 12.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    Enter: {
        x: 13.5,
        y: 1,
        w: 1.5,
        h: 2,
        labels: [{ text: "Enter" }],
        shape: "m 0 0 l 0 38 l 10 0 l 0 40 l 48 0 l 0 -78 z",
        zones: ["pinky", "right", "top"],
    },
    CapsLock: {
        x: 0,
        y: 2,
        w: 1.75,
        h: 1,
        labels: [{ text: "Caps Lock" }],
        zones: ["pinky", "left", "home"],
    },
    KeyA: {
        x: 1.75,
        y: 2,
        zones: ["pinky", "left", "home"],
    },
    KeyS: {
        x: 2.75,
        y: 2,
        zones: ["ring", "left", "home"],
    },
    KeyD: {
        x: 3.75,
        y: 2,
        zones: ["middle", "left", "home"],
    },
    KeyF: {
        x: 4.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
        homing: true,
    },
    KeyG: {
        x: 5.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
    },
    KeyH: {
        x: 6.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
    },
    KeyJ: {
        x: 7.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
        homing: true,
    },
    KeyK: {
        x: 8.75,
        y: 2,
        zones: ["middle", "right", "home"],
    },
    KeyL: {
        x: 9.75,
        y: 2,
        zones: ["ring", "right", "home"],
    },
    Semicolon: {
        x: 10.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Quote: {
        x: 11.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Backslash: {
        x: 12.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    ShiftLeft: {
        x: 0,
        y: 3,
        w: 1.25,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "left", "bottom"],
    },
    IntlBackslash: {
        x: 1.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyZ: {
        x: 2.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyX: {
        x: 3.25,
        y: 3,
        zones: ["ring", "left", "bottom"],
    },
    KeyC: {
        x: 4.25,
        y: 3,
        zones: ["middle", "left", "bottom"],
    },
    KeyV: {
        x: 5.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyB: {
        x: 6.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyN: {
        x: 7.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    KeyM: {
        x: 8.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    Comma: {
        x: 9.25,
        y: 3,
        zones: ["middle", "right", "bottom"],
    },
    Period: {
        x: 10.25,
        y: 3,
        zones: ["ring", "right", "bottom"],
    },
    Slash: {
        x: 11.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    ShiftRight: {
        x: 12.25,
        y: 3,
        w: 2.75,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlLeft: {
        x: 0,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "left", "bottom"],
    },
    AltLeft: {
        x: 1.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "left", "bottom"],
    },
    Space: {
        x: 3,
        y: 4,
        w: 9,
        h: 1,
        zones: ["thumb", "right", "bottom"],
    },
    AltRight: {
        x: 12,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlRight: {
        x: 13.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "right", "bottom"],
    },
};

;// ./packages/keybr-keyboard/lib/geometry/iso_102_full.ts


const ISO_102_FULL = {
    ...ISO_102,
    ...EXTRA,
};

;// ./packages/keybr-keyboard/lib/geometry/japanese_106.ts
// See https://www.w3.org/TR/uievents-code/#keyboard-106
const JAPANESE_106 = {
    IntlHanZen: {
        x: 0,
        y: 0,
        labels: [
            { text: "/", pos: [20, 0], align: ["m", "t"] },
            { text: "/", pos: [20, 11], align: ["m", "t"] },
            { text: "", pos: [20, 22], align: ["m", "t"] },
        ],
        zones: ["pinky", "left", "digit"],
    },
    Digit1: {
        x: 1,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit2: {
        x: 2,
        y: 0,
        zones: ["ring", "left", "digit"],
    },
    Digit3: {
        x: 3,
        y: 0,
        zones: ["middle", "left", "digit"],
    },
    Digit4: {
        x: 4,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit5: {
        x: 5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit6: {
        x: 6,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit7: {
        x: 7,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit8: {
        x: 8,
        y: 0,
        zones: ["middle", "right", "digit"],
    },
    Digit9: {
        x: 9,
        y: 0,
        zones: ["ring", "right", "digit"],
    },
    Digit0: {
        x: 10,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Minus: {
        x: 11,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Equal: {
        x: 12,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    IntlYen: {
        x: 13,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Backspace: {
        x: 14,
        y: 0,
        labels: [
            { text: "Back", pos: [5, 5], align: ["s", "t"] },
            { text: "space", pos: [5, 18], align: ["s", "t"] },
        ],
        zones: ["pinky", "right", "digit"],
    },
    Tab: {
        x: 0,
        y: 1,
        w: 1.5,
        h: 1,
        labels: [{ text: "Tab" }],
        zones: ["pinky", "left", "top"],
    },
    KeyQ: {
        x: 1.5,
        y: 1,
        zones: ["pinky", "left", "top"],
    },
    KeyW: {
        x: 2.5,
        y: 1,
        zones: ["ring", "left", "top"],
    },
    KeyE: {
        x: 3.5,
        y: 1,
        zones: ["middle", "left", "top"],
    },
    KeyR: {
        x: 4.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyT: {
        x: 5.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyY: {
        x: 6.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyU: {
        x: 7.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyI: {
        x: 8.5,
        y: 1,
        zones: ["middle", "right", "top"],
    },
    KeyO: {
        x: 9.5,
        y: 1,
        zones: ["ring", "right", "top"],
    },
    KeyP: {
        x: 10.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketLeft: {
        x: 11.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketRight: {
        x: 12.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    Enter: {
        x: 13.5,
        y: 1,
        w: 1.5,
        h: 2,
        labels: [{ text: "Enter" }],
        shape: "m 0 0 l 0 38 l 10 0 l 0 40 l 48 0 l 0 -78 z",
        zones: ["pinky", "right", "top"],
    },
    CapsLock: {
        x: 0,
        y: 2,
        w: 1.75,
        h: 1,
        labels: [{ text: "Caps Lock" }],
        zones: ["pinky", "left", "home"],
    },
    KeyA: {
        x: 1.75,
        y: 2,
        zones: ["pinky", "left", "home"],
    },
    KeyS: {
        x: 2.75,
        y: 2,
        zones: ["ring", "left", "home"],
    },
    KeyD: {
        x: 3.75,
        y: 2,
        zones: ["middle", "left", "home"],
    },
    KeyF: {
        x: 4.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
        homing: true,
    },
    KeyG: {
        x: 5.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
    },
    KeyH: {
        x: 6.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
    },
    KeyJ: {
        x: 7.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
        homing: true,
    },
    KeyK: {
        x: 8.75,
        y: 2,
        zones: ["middle", "right", "home"],
    },
    KeyL: {
        x: 9.75,
        y: 2,
        zones: ["ring", "right", "home"],
    },
    Semicolon: {
        x: 10.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Quote: {
        x: 11.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Backslash: {
        x: 12.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    ShiftLeft: {
        x: 0,
        y: 3,
        w: 2.25,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "left", "bottom"],
    },
    KeyZ: {
        x: 2.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyX: {
        x: 3.25,
        y: 3,
        zones: ["ring", "left", "bottom"],
    },
    KeyC: {
        x: 4.25,
        y: 3,
        zones: ["middle", "left", "bottom"],
    },
    KeyV: {
        x: 5.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyB: {
        x: 6.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyN: {
        x: 7.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    KeyM: {
        x: 8.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    Comma: {
        x: 9.25,
        y: 3,
        zones: ["middle", "right", "bottom"],
    },
    Period: {
        x: 10.25,
        y: 3,
        zones: ["ring", "right", "bottom"],
    },
    Slash: {
        x: 11.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    IntlRo: {
        x: 12.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    ShiftRight: {
        x: 13.25,
        y: 3,
        w: 1.75,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlLeft: {
        x: 0,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "left", "bottom"],
    },
    AltLeft: {
        x: 1.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "left", "bottom"],
    },
    IntlMuhenkan: {
        x: 3,
        y: 4,
        w: 1,
        h: 1,
        labels: [{ text: "", pos: [20, 20], align: ["m", "m"] }],
        zones: ["thumb", "left", "bottom"],
    },
    Space: {
        x: 4,
        y: 4,
        w: 6,
        h: 1,
        zones: ["thumb", "right", "bottom"],
    },
    IntlHenkan: {
        x: 10,
        y: 4,
        h: 1,
        labels: [{ text: "", pos: [20, 20], align: ["m", "m"] }],
        zones: ["thumb", "right", "bottom"],
    },
    IntlHiraKata: {
        x: 11,
        y: 4,
        h: 1,
        labels: [
            { text: "", pos: [20, 0], align: ["m", "t"] },
            { text: "", pos: [20, 11], align: ["m", "t"] },
            { text: "", pos: [20, 22], align: ["m", "t"] },
        ],
        zones: ["thumb", "right", "bottom"],
    },
    AltRight: {
        x: 12,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlRight: {
        x: 13.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "right", "bottom"],
    },
};

;// ./packages/keybr-keyboard/lib/geometry/japanese_106_full.ts


const JAPANESE_106_FULL = {
    ...JAPANESE_106,
    ...EXTRA,
};

;// ./packages/keybr-keyboard/lib/geometry/korean_103.ts
// See https://www.w3.org/TR/uievents-code/#keyboard-103
const KOREAN_103 = {
    Backquote: {
        x: 0,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit1: {
        x: 1,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit2: {
        x: 2,
        y: 0,
        zones: ["ring", "left", "digit"],
    },
    Digit3: {
        x: 3,
        y: 0,
        zones: ["middle", "left", "digit"],
    },
    Digit4: {
        x: 4,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit5: {
        x: 5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit6: {
        x: 6,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit7: {
        x: 7,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit8: {
        x: 8,
        y: 0,
        zones: ["middle", "right", "digit"],
    },
    Digit9: {
        x: 9,
        y: 0,
        zones: ["ring", "right", "digit"],
    },
    Digit0: {
        x: 10,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Minus: {
        x: 11,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Equal: {
        x: 12,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    IntlYen: {
        x: 13,
        y: 0,
        labels: [{ text: "?" }],
        zones: ["pinky", "right", "digit"],
    },
    Backspace: {
        x: 14,
        y: 0,
        labels: [
            { text: "Back", pos: [5, 5], align: ["s", "t"] },
            { text: "space", pos: [5, 18], align: ["s", "t"] },
        ],
        zones: ["pinky", "right", "digit"],
    },
    Tab: {
        x: 0,
        y: 1,
        w: 1.5,
        h: 1,
        labels: [{ text: "Tab" }],
        zones: ["pinky", "left", "top"],
    },
    KeyQ: {
        x: 1.5,
        y: 1,
        zones: ["pinky", "left", "top"],
    },
    KeyW: {
        x: 2.5,
        y: 1,
        zones: ["ring", "left", "top"],
    },
    KeyE: {
        x: 3.5,
        y: 1,
        zones: ["middle", "left", "top"],
    },
    KeyR: {
        x: 4.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyT: {
        x: 5.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyY: {
        x: 6.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyU: {
        x: 7.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyI: {
        x: 8.5,
        y: 1,
        zones: ["middle", "right", "top"],
    },
    KeyO: {
        x: 9.5,
        y: 1,
        zones: ["ring", "right", "top"],
    },
    KeyP: {
        x: 10.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketLeft: {
        x: 11.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    BracketRight: {
        x: 12.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    Enter: {
        x: 12.75,
        y: 1,
        w: 2.25,
        h: 2,
        labels: [{ text: "Enter", pos: [50, 40], align: ["m", "m"] }],
        shape: "m 30 0 l 0 40 l -30 0 l 0 40 l 88 0 l 0 -80 z",
        zones: ["pinky", "right", "top"],
    },
    CapsLock: {
        x: 0,
        y: 2,
        w: 1.75,
        h: 1,
        labels: [{ text: "Caps Lock" }],
        zones: ["pinky", "left", "home"],
    },
    KeyA: {
        x: 1.75,
        y: 2,
        zones: ["pinky", "left", "home"],
    },
    KeyS: {
        x: 2.75,
        y: 2,
        zones: ["ring", "left", "home"],
    },
    KeyD: {
        x: 3.75,
        y: 2,
        zones: ["middle", "left", "home"],
    },
    KeyF: {
        x: 4.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
        homing: true,
    },
    KeyG: {
        x: 5.75,
        y: 2,
        zones: ["leftIndex", "left", "home"],
    },
    KeyH: {
        x: 6.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
    },
    KeyJ: {
        x: 7.75,
        y: 2,
        zones: ["rightIndex", "right", "home"],
        homing: true,
    },
    KeyK: {
        x: 8.75,
        y: 2,
        zones: ["middle", "right", "home"],
    },
    KeyL: {
        x: 9.75,
        y: 2,
        zones: ["ring", "right", "home"],
    },
    Semicolon: {
        x: 10.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Quote: {
        x: 11.75,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    ShiftLeft: {
        x: 0,
        y: 3,
        w: 2.25,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "left", "bottom"],
    },
    KeyZ: {
        x: 2.25,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyX: {
        x: 3.25,
        y: 3,
        zones: ["ring", "left", "bottom"],
    },
    KeyC: {
        x: 4.25,
        y: 3,
        zones: ["middle", "left", "bottom"],
    },
    KeyV: {
        x: 5.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyB: {
        x: 6.25,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyN: {
        x: 7.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    KeyM: {
        x: 8.25,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    Comma: {
        x: 9.25,
        y: 3,
        zones: ["middle", "right", "bottom"],
    },
    Period: {
        x: 10.25,
        y: 3,
        zones: ["ring", "right", "bottom"],
    },
    Slash: {
        x: 11.25,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    ShiftRight: {
        x: 12.25,
        y: 3,
        w: 2.75,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlLeft: {
        x: 0,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "left", "bottom"],
    },
    AltLeft: {
        x: 1.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "left", "bottom"],
    },
    Lang2: {
        x: 3,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "" }],
        zones: ["thumb", "left", "bottom"],
    },
    Space: {
        x: 4.5,
        y: 4,
        w: 6,
        h: 1,
        zones: ["thumb", "right", "bottom"],
    },
    Lang1: {
        x: 10.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "/" }],
        zones: ["thumb", "right", "bottom"],
    },
    AltRight: {
        x: 12,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Alt" }],
        zones: ["pinky", "right", "bottom"],
    },
    ControlRight: {
        x: 13.5,
        y: 4,
        w: 1.5,
        h: 1,
        labels: [{ text: "Ctrl" }],
        zones: ["pinky", "right", "bottom"],
    },
};

;// ./packages/keybr-keyboard/lib/geometry/korean_103_full.ts


const KOREAN_103_FULL = {
    ...KOREAN_103,
    ...EXTRA,
};

;// ./packages/keybr-keyboard/lib/geometry/matrix.ts
const MATRIX = {
    // ---
    Equal: {
        x: 0,
        y: 0,
        w: 1.5,
        h: 1,
        zones: ["pinky", "left", "digit"],
    },
    Digit1: {
        x: 1.5,
        y: 0,
        zones: ["pinky", "left", "digit"],
    },
    Digit2: {
        x: 2.5,
        y: 0,
        zones: ["ring", "left", "digit"],
    },
    Digit3: {
        x: 3.5,
        y: 0,
        zones: ["middle", "left", "digit"],
    },
    Digit4: {
        x: 4.5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit5: {
        x: 5.5,
        y: 0,
        zones: ["leftIndex", "left", "digit"],
    },
    Digit6: {
        x: 7.5,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit7: {
        x: 8.5,
        y: 0,
        zones: ["rightIndex", "right", "digit"],
    },
    Digit8: {
        x: 9.5,
        y: 0,
        zones: ["middle", "right", "digit"],
    },
    Digit9: {
        x: 10.5,
        y: 0,
        zones: ["ring", "right", "digit"],
    },
    Digit0: {
        x: 11.5,
        y: 0,
        zones: ["pinky", "right", "digit"],
    },
    Minus: {
        x: 12.5,
        y: 0,
        w: 1.5,
        h: 1,
        zones: ["pinky", "right", "digit"],
    },
    // ---
    Tab: {
        x: 0,
        y: 1,
        w: 1.5,
        h: 1,
        labels: [{ text: "Tab" }],
        zones: ["pinky", "left", "top"],
    },
    KeyQ: {
        x: 1.5,
        y: 1,
        zones: ["pinky", "left", "top"],
    },
    KeyW: {
        x: 2.5,
        y: 1,
        zones: ["ring", "left", "top"],
    },
    KeyE: {
        x: 3.5,
        y: 1,
        zones: ["middle", "left", "top"],
    },
    KeyR: {
        x: 4.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyT: {
        x: 5.5,
        y: 1,
        zones: ["leftIndex", "left", "top"],
    },
    KeyY: {
        x: 7.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyU: {
        x: 8.5,
        y: 1,
        zones: ["rightIndex", "right", "top"],
    },
    KeyI: {
        x: 9.5,
        y: 1,
        zones: ["middle", "right", "top"],
    },
    KeyO: {
        x: 10.5,
        y: 1,
        zones: ["ring", "right", "top"],
    },
    KeyP: {
        x: 11.5,
        y: 1,
        zones: ["pinky", "right", "top"],
    },
    Backslash: {
        x: 12.5,
        y: 1,
        w: 1.5,
        h: 1,
        zones: ["pinky", "right", "top"],
    },
    // ---
    CapsLock: {
        x: 0,
        y: 2,
        w: 1.5,
        h: 1,
        labels: [{ text: "Caps Lock" }],
        zones: ["pinky", "left", "home"],
    },
    KeyA: {
        x: 1.5,
        y: 2,
        zones: ["pinky", "left", "home"],
    },
    KeyS: {
        x: 2.5,
        y: 2,
        zones: ["ring", "left", "home"],
    },
    KeyD: {
        x: 3.5,
        y: 2,
        zones: ["middle", "left", "home"],
    },
    KeyF: {
        x: 4.5,
        y: 2,
        zones: ["leftIndex", "left", "home"],
        homing: true,
    },
    KeyG: {
        x: 5.5,
        y: 2,
        zones: ["leftIndex", "left", "home"],
    },
    KeyH: {
        x: 7.5,
        y: 2,
        zones: ["rightIndex", "right", "home"],
    },
    KeyJ: {
        x: 8.5,
        y: 2,
        zones: ["rightIndex", "right", "home"],
        homing: true,
    },
    KeyK: {
        x: 9.5,
        y: 2,
        zones: ["middle", "right", "home"],
    },
    KeyL: {
        x: 10.5,
        y: 2,
        zones: ["ring", "right", "home"],
    },
    Semicolon: {
        x: 11.5,
        y: 2,
        zones: ["pinky", "right", "home"],
    },
    Quote: {
        x: 12.5,
        y: 2,
        w: 1.5,
        h: 1,
        zones: ["pinky", "right", "home"],
    },
    // ---
    ShiftLeft: {
        x: 0,
        y: 3,
        w: 1.5,
        h: 1,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "left", "bottom"],
    },
    KeyZ: {
        x: 1.5,
        y: 3,
        zones: ["pinky", "left", "bottom"],
    },
    KeyX: {
        x: 2.5,
        y: 3,
        zones: ["ring", "left", "bottom"],
    },
    KeyC: {
        x: 3.5,
        y: 3,
        zones: ["middle", "left", "bottom"],
    },
    KeyV: {
        x: 4.5,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyB: {
        x: 5.5,
        y: 3,
        zones: ["leftIndex", "left", "bottom"],
    },
    KeyN: {
        x: 7.5,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    KeyM: {
        x: 8.5,
        y: 3,
        zones: ["rightIndex", "right", "bottom"],
    },
    Comma: {
        x: 9.5,
        y: 3,
        zones: ["middle", "right", "bottom"],
    },
    Period: {
        x: 10.5,
        y: 3,
        zones: ["ring", "right", "bottom"],
    },
    Slash: {
        x: 11.5,
        y: 3,
        zones: ["pinky", "right", "bottom"],
    },
    ShiftRight: {
        x: 12.5,
        y: 3,
        w: 1.5,
        labels: [{ text: "Shift" }],
        zones: ["pinky", "right", "bottom"],
    },
};

;// ./packages/keybr-unicode/lib/codepoints.ts
const codepoints_isCodePoint = (value) => Number.isSafeInteger(value) && value >= 0 && value < 0x11_0000;
const charCount = (codePoint) => codePoint >= 0x01_0000 ? 2 : 1;
const codepoints_toCodePoints = (text) => {
    const { length } = text;
    return {
        [Symbol.iterator]() {
            let index = 0;
            const result = { done: true, value: -1 };
            const iterator = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next() {
                    if (index < length) {
                        const codePoint = text.codePointAt(index) ?? 0;
                        index += charCount(codePoint);
                        result.done = false;
                        result.value = codePoint;
                    }
                    else {
                        result.done = true;
                        result.value = -1;
                    }
                    return result;
                },
            };
            return iterator;
        },
    };
};
const codePointLength = (text) => {
    const it = codepoints_toCodePoints(text)[Symbol.iterator]();
    let length = 0;
    while (true) {
        const { done } = it.next();
        if (done) {
            return length;
        }
        length += 1;
    }
};

;// ./packages/keybr-unicode/lib/diacritics.ts
// https://en.wikipedia.org/wiki/Combining_character
// https://en.wikipedia.org/wiki/Diacritic
// https://en.wikipedia.org/wiki/List_of_precomposed_Latin_characters_in_Unicode
// https://bepo.fr/wiki/Touches_mortes
const toCombined = new Map();
const toBase = new Map();
const diacritics_isDiacritic = (codePoint) => codePoint >= 0x0300 && codePoint <= 0x036f;
const diacritics_combineDiacritic = (base, combining) => {
    return toCombined.get((combining << 16) | base) ?? base;
};
const stripDiacritic = (combined) => {
    return toBase.get(combined) ?? combined;
};
for (const [codePoint, baseList, combinedList] of [
    [
        /* COMBINING GRAVE ACCENT */ 0x0300, //
        "AEINOUWYaeinouwy",
        "",
    ],
    [
        /* COMBINING ACUTE ACCENT */ 0x0301, //
        "ACEGIKLMNOPRSUWYZacegiklmnoprsuwyz",
        "",
    ],
    [
        /* COMBINING CIRCUMFLEX ACCENT */ 0x0302, //
        "ACEGHIJOSUWYZaceghijosuwyz",
        "",
    ],
    [
        /* COMBINING TILDE */ 0x0303, //
        "AEINOUVYaeinouvy",
        "",
    ],
    [
        /* COMBINING MACRON */ 0x0304, //
        "AEGIOUYaegiouy",
        "",
    ],
    [
        /* COMBINING BREVE */ 0x0306, //
        "AEGIOUaegiou",
        "",
    ],
    [
        /* COMBINING DOT ABOVE */ 0x0307,
        "ABCDEFGHIMNOPRSTWXYZabcdefghmnoprstwxyz",
        "",
    ],
    [
        /* COMBINING DIAERESIS */ 0x0308, //
        "AEHIOUWXYaehiotuwxy",
        "",
    ],
    [
        /* COMBINING RING ABOVE */ 0x030a, //
        "AUauwy",
        "",
    ],
    [
        /* COMBINING DOUBLE ACUTE ACCENT */ 0x030b, //
        "OUou",
        "",
    ],
    [
        /* COMBINING CARON */ 0x030c, //
        "ACDEGHIKLNORSTUZacdeghijklnorstuz",
        "",
    ],
    [
        /* COMBINING DOUBLE GRAVE ACCENT */ 0x030f, //
        "AEIORUaeioru",
        "",
    ],
    [
        /* COMBINING CEDILLA */ 0x0327, //
        "CDEGHKLNRSTcdeghklnrst",
        "",
    ],
    [
        /* COMBINING OGONEK */ 0x0328, //
        "AEIOUaeiou",
        "",
    ],
]) {
    for (let i = 0; i < baseList.length; i++) {
        const base = baseList.codePointAt(i);
        const combined = combinedList.codePointAt(i);
        toCombined.set((codePoint << 16) | base, combined);
        toBase.set(combined, base);
    }
}

;// ./packages/keybr-unicode/lib/normalize.ts
function expand(codePoint) {
    return expandMap.get(codePoint) ?? null;
}
function replace(codePoint) {
    return replaceMap.get(codePoint) ?? null;
}
const expandMap = ((data) => {
    const map = new Map();
    for (const [to, from] of data) {
        for (const codePoint of from) {
            map.set(codePoint, to);
        }
    }
    return map;
})([
    // ----- Letters -----
    [
        [/* "A" */ 0x0041],
        [
            /* "" */ 0x00c0, /* "" */ 0x00c1, /* "" */ 0x00c2, /* "" */ 0x00c3,
            /* "" */ 0x00c4, /* "" */ 0x00c5, /* "" */ 0x0100, /* "" */ 0x0102,
            /* "" */ 0x0104, /* "" */ 0x01cd, /* "" */ 0x01de, /* "" */ 0x01e0,
            /* "" */ 0x01fa, /* "" */ 0x0200, /* "" */ 0x0202, /* "" */ 0x0226,
            /* "" */ 0x023a, /* "" */ 0x1e00, /* "" */ 0x1ea0, /* "" */ 0x1ea2,
            /* "" */ 0x1ea4, /* "" */ 0x1ea6, /* "" */ 0x1ea8, /* "" */ 0x1eaa,
            /* "" */ 0x1eac, /* "" */ 0x1eae, /* "" */ 0x1eb0, /* "" */ 0x1eb2,
            /* "" */ 0x1eb4, /* "" */ 0x1eb6, /* "" */ 0x24b6, /* "" */ 0x2c6f,
            /* "" */ 0xff21,
        ],
    ],
    [[/* "A" */ 0x0041, /* "A" */ 0x0041], [/* "" */ 0xa732]],
    [
        [/* "A" */ 0x0041, /* "E" */ 0x0045],
        [/* "" */ 0x00c6, /* "" */ 0x01e2, /* "" */ 0x01fc],
    ],
    [[/* "A" */ 0x0041, /* "O" */ 0x004f], [/* "" */ 0xa734]],
    [[/* "A" */ 0x0041, /* "U" */ 0x0055], [/* "" */ 0xa736]],
    [
        [/* "A" */ 0x0041, /* "V" */ 0x0056],
        [/* "" */ 0xa738, /* "" */ 0xa73a],
    ],
    [[/* "A" */ 0x0041, /* "Y" */ 0x0059], [/* "" */ 0xa73c]],
    [
        [/* "B" */ 0x0042],
        [
            /* "" */ 0x0181, /* "" */ 0x0243, /* "" */ 0x1e02, /* "" */ 0x1e04,
            /* "" */ 0x1e06, /* "" */ 0x24b7, /* "" */ 0xff22,
        ],
    ],
    [
        [/* "C" */ 0x0043],
        [
            /* "C" */ 0x0043, /* "" */ 0x00c7, /* "" */ 0x0106, /* "" */ 0x0108,
            /* "" */ 0x010a, /* "" */ 0x010c, /* "" */ 0x0187, /* "" */ 0x023b,
            /* "" */ 0x1e08, /* "" */ 0x24b8, /* "" */ 0xa73e, /* "" */ 0xff23,
        ],
    ],
    [
        [/* "D" */ 0x0044],
        [
            /* "" */ 0x010e, /* "" */ 0x0110, /* "" */ 0x0189, /* "" */ 0x018a,
            /* "" */ 0x1d05, /* "" */ 0x1e0a, /* "" */ 0x1e0c, /* "" */ 0x1e0e,
            /* "" */ 0x1e10, /* "" */ 0x1e12, /* "" */ 0x24b9, /* "" */ 0xa779,
            /* "" */ 0xff24,
        ],
    ],
    [
        [/* "D" */ 0x0044, /* "Z" */ 0x005a],
        [/* "" */ 0x01c4, /* "" */ 0x01f1],
    ],
    [[/* "D" */ 0x0044, /* "h" */ 0x0068], [/* "" */ 0x00d0]],
    [
        [/* "D" */ 0x0044, /* "z" */ 0x007a],
        [/* "" */ 0x01c5, /* "" */ 0x01f2],
    ],
    [
        [/* "E" */ 0x0045],
        [
            /* "" */ 0x00c8, /* "" */ 0x00c9, /* "" */ 0x00ca, /* "" */ 0x00cb,
            /* "" */ 0x0112, /* "" */ 0x0114, /* "" */ 0x0116, /* "" */ 0x0118,
            /* "" */ 0x011a, /* "" */ 0x018e, /* "" */ 0x0190, /* "" */ 0x0204,
            /* "" */ 0x0206, /* "" */ 0x0228, /* "" */ 0x025b, /* "" */ 0x1d07,
            /* "" */ 0x1e14, /* "" */ 0x1e16, /* "" */ 0x1e18, /* "" */ 0x1e1a,
            /* "" */ 0x1e1c, /* "" */ 0x1eb8, /* "" */ 0x1eba, /* "" */ 0x1ebc,
            /* "" */ 0x1ebe, /* "" */ 0x1ec0, /* "" */ 0x1ec2, /* "" */ 0x1ec4,
            /* "" */ 0x1ec6, /* "" */ 0x24ba, /* "" */ 0xff25,
        ],
    ],
    [
        [/* "F" */ 0x0046],
        [
            /* "" */ 0x0191, /* "" */ 0x1e1e, /* "" */ 0x24bb, /* "" */ 0xa77b,
            /* "" */ 0xa77c, /* "" */ 0xff26,
        ],
    ],
    [
        [/* "G" */ 0x0047],
        [
            /* "" */ 0x011c, /* "" */ 0x011e, /* "" */ 0x0120, /* "" */ 0x0122,
            /* "" */ 0x0193, /* "" */ 0x01e4, /* "" */ 0x01e6, /* "" */ 0x01f4,
            /* "" */ 0x0262, /* "" */ 0x1e20, /* "" */ 0x24bc, /* "" */ 0xa77d,
            /* "" */ 0xa77e, /* "" */ 0xa7a0, /* "" */ 0xff27,
        ],
    ],
    [
        [/* "H" */ 0x0048],
        [
            /* "" */ 0x0124, /* "" */ 0x0126, /* "" */ 0x021e, /* "" */ 0x1e22,
            /* "" */ 0x1e24, /* "" */ 0x1e26, /* "" */ 0x1e28, /* "" */ 0x1e2a,
            /* "" */ 0x24bd, /* "" */ 0x2c67, /* "" */ 0x2c75, /* "" */ 0xa78d,
            /* "" */ 0xff28,
        ],
    ],
    [
        [/* "I" */ 0x0049],
        [
            /* "" */ 0x00cc, /* "" */ 0x00cd, /* "" */ 0x00ce, /* "" */ 0x00cf,
            /* "" */ 0x0128, /* "" */ 0x012a, /* "" */ 0x012c, /* "" */ 0x012e,
            /* "" */ 0x0130, /* "" */ 0x0197, /* "" */ 0x01cf, /* "" */ 0x0208,
            /* "" */ 0x020a, /* "" */ 0x1e2c, /* "" */ 0x1e2e, /* "" */ 0x1ec8,
            /* "" */ 0x1eca, /* "" */ 0x24be, /* "" */ 0xff29,
        ],
    ],
    [
        [/* "J" */ 0x004a],
        [
            /* "" */ 0x0134, /* "" */ 0x0237, /* "" */ 0x0248, /* "" */ 0x24bf,
            /* "" */ 0xff2a,
        ],
    ],
    [
        [/* "K" */ 0x004b],
        [
            /* "" */ 0x0136, /* "" */ 0x0198, /* "" */ 0x01e8, /* "" */ 0x1e30,
            /* "" */ 0x1e32, /* "" */ 0x1e34, /* "" */ 0x24c0, /* "" */ 0x2c69,
            /* "" */ 0xa740, /* "" */ 0xa742, /* "" */ 0xa744, /* "" */ 0xa7a2,
            /* "" */ 0xff2b,
        ],
    ],
    [
        [/* "L" */ 0x004c],
        [
            /* "" */ 0x0139, /* "" */ 0x013b, /* "" */ 0x013d, /* "" */ 0x013f,
            /* "" */ 0x0141, /* "" */ 0x023d, /* "" */ 0x1e36, /* "" */ 0x1e38,
            /* "" */ 0x1e3a, /* "" */ 0x1e3c, /* "" */ 0x24c1, /* "" */ 0x2c60,
            /* "" */ 0x2c62, /* "" */ 0xa746, /* "" */ 0xa748, /* "" */ 0xa780,
            /* "" */ 0xff2c,
        ],
    ],
    [[/* "L" */ 0x004c, /* "J" */ 0x004a], [/* "" */ 0x01c7]],
    [[/* "L" */ 0x004c, /* "j" */ 0x006a], [/* "" */ 0x01c8]],
    [
        [/* "M" */ 0x004d],
        [
            /* "" */ 0x019c, /* "" */ 0x03fb, /* "" */ 0x1e3e, /* "" */ 0x1e40,
            /* "" */ 0x1e42, /* "" */ 0x24c2, /* "" */ 0x2c6e, /* "" */ 0xff2d,
        ],
    ],
    [
        [/* "N" */ 0x004e],
        [
            /* "" */ 0x00d1, /* "" */ 0x0143, /* "" */ 0x0145, /* "" */ 0x0147,
            /* "" */ 0x019d, /* "" */ 0x01f8, /* "" */ 0x0220, /* "" */ 0x1d0e,
            /* "" */ 0x1e44, /* "" */ 0x1e46, /* "" */ 0x1e48, /* "" */ 0x1e4a,
            /* "" */ 0x24c3, /* "" */ 0xa790, /* "" */ 0xa7a4, /* "" */ 0xff2e,
        ],
    ],
    [[/* "N" */ 0x004e, /* "J" */ 0x004a], [/* "" */ 0x01ca]],
    [[/* "N" */ 0x004e, /* "j" */ 0x006a], [/* "" */ 0x01cb]],
    [
        [/* "O" */ 0x004f],
        [
            /* "" */ 0x00d2, /* "" */ 0x00d3, /* "" */ 0x00d4, /* "" */ 0x00d5,
            /* "" */ 0x00d6, /* "" */ 0x00d8, /* "" */ 0x014c, /* "" */ 0x014e,
            /* "" */ 0x0150, /* "" */ 0x0186, /* "" */ 0x019f, /* "" */ 0x01a0,
            /* "" */ 0x01d1, /* "" */ 0x01ea, /* "" */ 0x01ec, /* "" */ 0x01fe,
            /* "" */ 0x020c, /* "" */ 0x020e, /* "" */ 0x022a, /* "" */ 0x022c,
            /* "" */ 0x022e, /* "" */ 0x0230, /* "" */ 0x1e4c, /* "" */ 0x1e4e,
            /* "" */ 0x1e50, /* "" */ 0x1e52, /* "" */ 0x1ecc, /* "" */ 0x1ece,
            /* "" */ 0x1ed0, /* "" */ 0x1ed2, /* "" */ 0x1ed4, /* "" */ 0x1ed6,
            /* "" */ 0x1ed8, /* "" */ 0x1eda, /* "" */ 0x1edc, /* "" */ 0x1ede,
            /* "" */ 0x1ee0, /* "" */ 0x1ee2, /* "" */ 0x24c4, /* "" */ 0xa74a,
            /* "" */ 0xa74c, /* "" */ 0xff2f,
        ],
    ],
    [[/* "O" */ 0x004f, /* "E" */ 0x0045], [/* "" */ 0x0152]],
    [[/* "O" */ 0x004f, /* "I" */ 0x0049], [/* "" */ 0x01a2]],
    [[/* "O" */ 0x004f, /* "O" */ 0x004f], [/* "" */ 0xa74e]],
    [[/* "O" */ 0x004f, /* "U" */ 0x0055], [/* "" */ 0x0222]],
    [
        [/* "P" */ 0x0050],
        [
            /* "" */ 0x01a4, /* "" */ 0x1e54, /* "" */ 0x1e56, /* "" */ 0x24c5,
            /* "" */ 0x2c63, /* "" */ 0xa750, /* "" */ 0xa752, /* "" */ 0xa754,
            /* "" */ 0xff30,
        ],
    ],
    [
        [/* "Q" */ 0x0051],
        [
            /* "" */ 0x024a, /* "" */ 0x24c6, /* "" */ 0xa756, /* "" */ 0xa758,
            /* "" */ 0xff31,
        ],
    ],
    [
        [/* "R" */ 0x0052],
        [
            /* "" */ 0x0154, /* "" */ 0x0156, /* "" */ 0x0158, /* "" */ 0x0210,
            /* "" */ 0x0212, /* "" */ 0x024c, /* "" */ 0x1e58, /* "" */ 0x1e5a,
            /* "" */ 0x1e5c, /* "" */ 0x1e5e, /* "" */ 0x24c7, /* "" */ 0x2c64,
            /* "" */ 0xa75a, /* "" */ 0xa782, /* "" */ 0xa7a6, /* "" */ 0xff32,
        ],
    ],
    [
        [/* "S" */ 0x0053],
        [
            /* "" */ 0x015a, /* "" */ 0x015c, /* "" */ 0x015e, /* "" */ 0x0160,
            /* "" */ 0x0218, /* "" */ 0x1e60, /* "" */ 0x1e62, /* "" */ 0x1e64,
            /* "" */ 0x1e66, /* "" */ 0x1e68, /* "" */ 0x1e9e, /* "" */ 0x24c8,
            /* "" */ 0x2c7e, /* "" */ 0xa784, /* "" */ 0xa7a8, /* "" */ 0xff33,
        ],
    ],
    [
        [/* "T" */ 0x0054],
        [
            /* "" */ 0x0162, /* "" */ 0x0164, /* "" */ 0x0166, /* "" */ 0x01ac,
            /* "" */ 0x01ae, /* "" */ 0x021a, /* "" */ 0x023e, /* "" */ 0x1e6a,
            /* "" */ 0x1e6c, /* "" */ 0x1e6e, /* "" */ 0x1e70, /* "" */ 0x24c9,
            /* "" */ 0xa786, /* "" */ 0xff34,
        ],
    ],
    [[/* "T" */ 0x0054, /* "Z" */ 0x005a], [/* "" */ 0xa728]],
    [[/* "T" */ 0x0054, /* "h" */ 0x0068], [/* "" */ 0x00de]],
    [
        [/* "U" */ 0x0055],
        [
            /* "" */ 0x00d9, /* "" */ 0x00da, /* "" */ 0x00db, /* "" */ 0x00dc,
            /* "" */ 0x0168, /* "" */ 0x016a, /* "" */ 0x016c, /* "" */ 0x016e,
            /* "" */ 0x0170, /* "" */ 0x0172, /* "" */ 0x01af, /* "" */ 0x01d3,
            /* "" */ 0x01d5, /* "" */ 0x01d7, /* "" */ 0x01d9, /* "" */ 0x01db,
            /* "" */ 0x0214, /* "" */ 0x0216, /* "" */ 0x0244, /* "" */ 0x1e72,
            /* "" */ 0x1e74, /* "" */ 0x1e76, /* "" */ 0x1e78, /* "" */ 0x1e7a,
            /* "" */ 0x1ee4, /* "" */ 0x1ee6, /* "" */ 0x1ee8, /* "" */ 0x1eea,
            /* "" */ 0x1eec, /* "" */ 0x1eee, /* "" */ 0x1ef0, /* "" */ 0x24ca,
            /* "" */ 0xff35,
        ],
    ],
    [
        [/* "V" */ 0x0056],
        [
            /* "" */ 0x01b2, /* "" */ 0x0245, /* "" */ 0x1e7c, /* "" */ 0x1e7e,
            /* "" */ 0x24cb, /* "" */ 0xa75e, /* "" */ 0xff36,
        ],
    ],
    [[/* "V" */ 0x0056, /* "Y" */ 0x0059], [/* "" */ 0xa760]],
    [
        [/* "W" */ 0x0057],
        [
            /* "" */ 0x0174, /* "" */ 0x1e80, /* "" */ 0x1e82, /* "" */ 0x1e84,
            /* "" */ 0x1e86, /* "" */ 0x1e88, /* "" */ 0x24cc, /* "" */ 0x2c72,
            /* "" */ 0xff37,
        ],
    ],
    [
        [/* "X" */ 0x0058],
        [/* "" */ 0x1e8a, /* "" */ 0x1e8c, /* "" */ 0x24cd, /* "" */ 0xff38],
    ],
    [
        [/* "Y" */ 0x0059],
        [
            /* "" */ 0x00dd, /* "" */ 0x0176, /* "" */ 0x0178, /* "" */ 0x01b3,
            /* "" */ 0x0232, /* "" */ 0x024e, /* "" */ 0x1e8e, /* "" */ 0x1ef2,
            /* "" */ 0x1ef4, /* "" */ 0x1ef6, /* "" */ 0x1ef8, /* "" */ 0x1efe,
            /* "" */ 0x24ce, /* "" */ 0xff39,
        ],
    ],
    [
        [/* "Z" */ 0x005a],
        [
            /* "" */ 0x0179, /* "" */ 0x017b, /* "" */ 0x017d, /* "" */ 0x01b5,
            /* "" */ 0x0224, /* "" */ 0x1e90, /* "" */ 0x1e92, /* "" */ 0x1e94,
            /* "" */ 0x24cf, /* "" */ 0x2c6b, /* "" */ 0x2c7f, /* "" */ 0xa762,
            /* "" */ 0xff3a,
        ],
    ],
    [
        [/* "a" */ 0x0061],
        [
            /* "" */ 0x00e0, /* "" */ 0x00e1, /* "" */ 0x00e2, /* "" */ 0x00e3,
            /* "" */ 0x00e4, /* "" */ 0x00e5, /* "" */ 0x0101, /* "" */ 0x0103,
            /* "" */ 0x0105, /* "" */ 0x01ce, /* "" */ 0x01df, /* "" */ 0x01e1,
            /* "" */ 0x01fb, /* "" */ 0x0201, /* "" */ 0x0203, /* "" */ 0x0227,
            /* "" */ 0x0250, /* "" */ 0x0251, /* "" */ 0x1e01, /* "" */ 0x1e9a,
            /* "" */ 0x1ea1, /* "" */ 0x1ea3, /* "" */ 0x1ea5, /* "" */ 0x1ea7,
            /* "" */ 0x1ea9, /* "" */ 0x1eab, /* "" */ 0x1ead, /* "" */ 0x1eaf,
            /* "" */ 0x1eb1, /* "" */ 0x1eb3, /* "" */ 0x1eb5, /* "" */ 0x1eb7,
            /* "" */ 0x24d0, /* "" */ 0x2c65, /* "" */ 0xff41,
        ],
    ],
    [[/* "a" */ 0x0061, /* "a" */ 0x0061], [/* "" */ 0xa733]],
    [
        [/* "a" */ 0x0061, /* "e" */ 0x0065],
        [/* "" */ 0x00e6, /* "" */ 0x01e3, /* "" */ 0x01fd],
    ],
    [[/* "a" */ 0x0061, /* "o" */ 0x006f], [/* "" */ 0xa735]],
    [[/* "a" */ 0x0061, /* "u" */ 0x0075], [/* "" */ 0xa737]],
    [
        [/* "a" */ 0x0061, /* "v" */ 0x0076],
        [/* "" */ 0xa739, /* "" */ 0xa73b],
    ],
    [[/* "a" */ 0x0061, /* "y" */ 0x0079], [/* "" */ 0xa73d]],
    [
        [/* "b" */ 0x0062],
        [
            /* "" */ 0x0180, /* "" */ 0x0182, /* "" */ 0x0183, /* "" */ 0x0253,
            /* "" */ 0x1e03, /* "" */ 0x1e05, /* "" */ 0x1e07, /* "" */ 0x24d1,
            /* "" */ 0xff42,
        ],
    ],
    [
        [/* "c" */ 0x0063],
        [
            /* "" */ 0x00e7, /* "" */ 0x0107, /* "" */ 0x0109, /* "" */ 0x010b,
            /* "" */ 0x010d, /* "" */ 0x0188, /* "" */ 0x023c, /* "" */ 0x1e09,
            /* "" */ 0x2184, /* "" */ 0x24d2, /* "" */ 0xa73f, /* "" */ 0xff43,
        ],
    ],
    [
        [/* "d" */ 0x0064],
        [
            /* "" */ 0x010f, /* "" */ 0x0111, /* "" */ 0x018b, /* "" */ 0x018c,
            /* "" */ 0x0256, /* "" */ 0x0257, /* "" */ 0x0501, /* "" */ 0x13e7,
            /* "" */ 0x1e0b, /* "" */ 0x1e0d, /* "" */ 0x1e0f, /* "" */ 0x1e11,
            /* "" */ 0x1e13, /* "" */ 0x24d3, /* "" */ 0xa7aa, /* "" */ 0xff44,
        ],
    ],
    [[/* "d" */ 0x0064, /* "h" */ 0x0068], [/* "" */ 0x00f0]],
    [
        [/* "d" */ 0x0064, /* "z" */ 0x007a],
        [/* "" */ 0x01c6, /* "" */ 0x01f3],
    ],
    [
        [/* "e" */ 0x0065],
        [
            /* "" */ 0x00e8, /* "" */ 0x00e9, /* "" */ 0x00ea, /* "" */ 0x00eb,
            /* "" */ 0x0113, /* "" */ 0x0115, /* "" */ 0x0117, /* "" */ 0x0119,
            /* "" */ 0x011b, /* "" */ 0x01dd, /* "" */ 0x0205, /* "" */ 0x0207,
            /* "" */ 0x0229, /* "" */ 0x0247, /* "" */ 0x1e15, /* "" */ 0x1e17,
            /* "" */ 0x1e19, /* "" */ 0x1e1b, /* "" */ 0x1e1d, /* "" */ 0x1eb9,
            /* "" */ 0x1ebb, /* "" */ 0x1ebd, /* "" */ 0x1ebf, /* "" */ 0x1ec1,
            /* "" */ 0x1ec3, /* "" */ 0x1ec5, /* "" */ 0x1ec7, /* "" */ 0x24d4,
            /* "" */ 0xff45,
        ],
    ],
    [
        [/* "f" */ 0x0066],
        [/* "" */ 0x0192, /* "" */ 0x1e1f, /* "" */ 0x24d5, /* "" */ 0xff46],
    ],
    [[/* "f" */ 0x0066, /* "f" */ 0x0066], [/* "" */ 0xfb00]],
    [[/* "f" */ 0x0066, /* "f" */ 0x0066, /* "i" */ 0x0069], [/* "" */ 0xfb03]],
    [[/* "f" */ 0x0066, /* "f" */ 0x0066, /* "l" */ 0x006c], [/* "" */ 0xfb04]],
    [[/* "f" */ 0x0066, /* "i" */ 0x0069], [/* "" */ 0xfb01]],
    [[/* "f" */ 0x0066, /* "l" */ 0x006c], [/* "" */ 0xfb02]],
    [
        [/* "g" */ 0x0067],
        [
            /* "" */ 0x011d, /* "" */ 0x011f, /* "" */ 0x0121, /* "" */ 0x0123,
            /* "" */ 0x01e5, /* "" */ 0x01e7, /* "" */ 0x01f5, /* "" */ 0x0260,
            /* "" */ 0x1d79, /* "" */ 0x1e21, /* "" */ 0x24d6, /* "" */ 0xa77f,
            /* "" */ 0xa7a1, /* "" */ 0xff47,
        ],
    ],
    [
        [/* "h" */ 0x0068],
        [
            /* "" */ 0x0125, /* "" */ 0x0127, /* "" */ 0x021f, /* "" */ 0x0265,
            /* "" */ 0x1e23, /* "" */ 0x1e25, /* "" */ 0x1e27, /* "" */ 0x1e29,
            /* "" */ 0x1e2b, /* "" */ 0x1e96, /* "" */ 0x24d7, /* "" */ 0x2c68,
            /* "" */ 0x2c76, /* "" */ 0xff48,
        ],
    ],
    [[/* "h" */ 0x0068, /* "v" */ 0x0076], [/* "" */ 0x0195]],
    [
        [/* "i" */ 0x0069],
        [
            /* "" */ 0x00ec, /* "" */ 0x00ed, /* "" */ 0x00ee, /* "" */ 0x00ef,
            /* "" */ 0x0129, /* "" */ 0x012b, /* "" */ 0x012d, /* "" */ 0x012f,
            /* "" */ 0x0131, /* "" */ 0x01d0, /* "" */ 0x0209, /* "" */ 0x020b,
            /* "" */ 0x0268, /* "" */ 0x1e2d, /* "" */ 0x1e2f, /* "" */ 0x1ec9,
            /* "" */ 0x1ecb, /* "" */ 0x24d8, /* "" */ 0xff49,
        ],
    ],
    [
        [/* "j" */ 0x006a],
        [
            /* "" */ 0x0135, /* "" */ 0x01f0, /* "" */ 0x0249, /* "" */ 0x24d9,
            /* "" */ 0xff4a,
        ],
    ],
    [
        [/* "k" */ 0x006b],
        [
            /* "" */ 0x0137, /* "" */ 0x0199, /* "" */ 0x01e9, /* "" */ 0x1e31,
            /* "" */ 0x1e33, /* "" */ 0x1e35, /* "" */ 0x24da, /* "" */ 0x2c6a,
            /* "" */ 0xa741, /* "" */ 0xa743, /* "" */ 0xa745, /* "" */ 0xa7a3,
            /* "" */ 0xff4b,
        ],
    ],
    [
        [/* "l" */ 0x006c],
        [
            /* "" */ 0x013a, /* "" */ 0x013c, /* "" */ 0x013e, /* "" */ 0x0140,
            /* "" */ 0x0142, /* "" */ 0x017f, /* "" */ 0x019a, /* "" */ 0x026b,
            /* "" */ 0x026d, /* "" */ 0x1e37, /* "" */ 0x1e39, /* "" */ 0x1e3b,
            /* "" */ 0x1e3d, /* "" */ 0x24db, /* "" */ 0x2c61, /* "" */ 0xa747,
            /* "" */ 0xa749, /* "" */ 0xa781, /* "" */ 0xff4c,
        ],
    ],
    [[/* "l" */ 0x006c, /* "j" */ 0x006a], [/* "" */ 0x01c9]],
    [
        [/* "m" */ 0x006d],
        [
            /* "" */ 0x026f, /* "" */ 0x0271, /* "" */ 0x1e3f, /* "" */ 0x1e41,
            /* "" */ 0x1e43, /* "" */ 0x24dc, /* "" */ 0xff4d,
        ],
    ],
    [
        [/* "n" */ 0x006e],
        [
            /* "" */ 0x00f1, /* "" */ 0x0144, /* "" */ 0x0146, /* "" */ 0x0148,
            /* "" */ 0x0149, /* "" */ 0x019e, /* "" */ 0x01f9, /* "" */ 0x0272,
            /* "" */ 0x043b, /* "" */ 0x0509, /* "" */ 0x1e45, /* "" */ 0x1e47,
            /* "" */ 0x1e49, /* "" */ 0x1e4b, /* "" */ 0x24dd, /* "" */ 0xa791,
            /* "" */ 0xa7a5, /* "" */ 0xff4e,
        ],
    ],
    [[/* "n" */ 0x006e, /* "j" */ 0x006a], [/* "" */ 0x01cc]],
    [
        [/* "o" */ 0x006f],
        [
            /* "" */ 0x00f2, /* "" */ 0x00f3, /* "" */ 0x00f4, /* "" */ 0x00f5,
            /* "" */ 0x00f6, /* "" */ 0x00f8, /* "" */ 0x014d, /* "" */ 0x014f,
            /* "" */ 0x0151, /* "" */ 0x01a1, /* "" */ 0x01d2, /* "" */ 0x01eb,
            /* "" */ 0x01ed, /* "" */ 0x01ff, /* "" */ 0x020d, /* "" */ 0x020f,
            /* "" */ 0x022b, /* "" */ 0x022d, /* "" */ 0x022f, /* "" */ 0x0231,
            /* "" */ 0x0254, /* "" */ 0x0275, /* "" */ 0x1d11, /* "" */ 0x1e4d,
            /* "" */ 0x1e4f, /* "" */ 0x1e51, /* "" */ 0x1e53, /* "" */ 0x1ecd,
            /* "" */ 0x1ecf, /* "" */ 0x1ed1, /* "" */ 0x1ed3, /* "" */ 0x1ed5,
            /* "" */ 0x1ed7, /* "" */ 0x1ed9, /* "" */ 0x1edb, /* "" */ 0x1edd,
            /* "" */ 0x1edf, /* "" */ 0x1ee1, /* "" */ 0x1ee3, /* "" */ 0x24de,
            /* "" */ 0xa74b, /* "" */ 0xa74d, /* "" */ 0xff4f,
        ],
    ],
    [[/* "o" */ 0x006f, /* "e" */ 0x0065], [/* "" */ 0x0153]],
    [[/* "o" */ 0x006f, /* "i" */ 0x0069], [/* "" */ 0x01a3]],
    [[/* "o" */ 0x006f, /* "o" */ 0x006f], [/* "" */ 0xa74f]],
    [[/* "o" */ 0x006f, /* "u" */ 0x0075], [/* "" */ 0x0223]],
    [
        [/* "p" */ 0x0070],
        [
            /* "" */ 0x01a5, /* "" */ 0x03c1, /* "" */ 0x1d7d, /* "" */ 0x1e55,
            /* "" */ 0x1e57, /* "" */ 0x24df, /* "" */ 0xa751, /* "" */ 0xa753,
            /* "" */ 0xa755, /* "" */ 0xff50,
        ],
    ],
    [
        [/* "q" */ 0x0071],
        [
            /* "" */ 0x024b, /* "" */ 0x24e0, /* "" */ 0xa757, /* "" */ 0xa759,
            /* "" */ 0xff51,
        ],
    ],
    [
        [/* "r" */ 0x0072],
        [
            /* "" */ 0x0155, /* "" */ 0x0157, /* "" */ 0x0159, /* "" */ 0x0211,
            /* "" */ 0x0213, /* "" */ 0x024d, /* "" */ 0x027d, /* "" */ 0x1e59,
            /* "" */ 0x1e5b, /* "" */ 0x1e5d, /* "" */ 0x1e5f, /* "" */ 0x24e1,
            /* "" */ 0xa75b, /* "" */ 0xa783, /* "" */ 0xa7a7, /* "" */ 0xff52,
        ],
    ],
    [
        [/* "s" */ 0x0073],
        [
            /* "" */ 0x015b, /* "" */ 0x015d, /* "" */ 0x015f, /* "" */ 0x0161,
            /* "" */ 0x0219, /* "" */ 0x023f, /* "" */ 0x0282, /* "" */ 0x1e61,
            /* "" */ 0x1e63, /* "" */ 0x1e65, /* "" */ 0x1e67, /* "" */ 0x1e69,
            /* "" */ 0x1e9b, /* "" */ 0x24e2, /* "" */ 0xa785, /* "" */ 0xa7a9,
            /* "" */ 0xff53,
        ],
    ],
    [[/* "s" */ 0x0073, /* "s" */ 0x0073], [/* "" */ 0x00df]],
    [
        [/* "t" */ 0x0074],
        [
            /* "" */ 0x0163, /* "" */ 0x0165, /* "" */ 0x0167, /* "" */ 0x01ad,
            /* "" */ 0x021b, /* "" */ 0x0288, /* "" */ 0x1e6b, /* "" */ 0x1e6d,
            /* "" */ 0x1e6f, /* "" */ 0x1e71, /* "" */ 0x1e97, /* "" */ 0x24e3,
            /* "" */ 0x2c66, /* "" */ 0xa787, /* "" */ 0xff54,
        ],
    ],
    [[/* "t" */ 0x0074, /* "h" */ 0x0068], [/* "" */ 0x00fe]],
    [[/* "t" */ 0x0074, /* "z" */ 0x007a], [/* "" */ 0xa729]],
    [
        [/* "u" */ 0x0075],
        [
            /* "" */ 0x00f9, /* "" */ 0x00fa, /* "" */ 0x00fb, /* "" */ 0x00fc,
            /* "" */ 0x0169, /* "" */ 0x016b, /* "" */ 0x016d, /* "" */ 0x016f,
            /* "" */ 0x0171, /* "" */ 0x0173, /* "" */ 0x01b0, /* "" */ 0x01d4,
            /* "" */ 0x01d6, /* "" */ 0x01d8, /* "" */ 0x01da, /* "" */ 0x01dc,
            /* "" */ 0x0215, /* "" */ 0x0217, /* "" */ 0x0289, /* "" */ 0x1e73,
            /* "" */ 0x1e75, /* "" */ 0x1e77, /* "" */ 0x1e79, /* "" */ 0x1e7b,
            /* "" */ 0x1ee5, /* "" */ 0x1ee7, /* "" */ 0x1ee9, /* "" */ 0x1eeb,
            /* "" */ 0x1eed, /* "" */ 0x1eef, /* "" */ 0x1ef1, /* "" */ 0x24e4,
            /* "" */ 0xff55,
        ],
    ],
    [
        [/* "v" */ 0x0076],
        [
            /* "" */ 0x028b, /* "" */ 0x028c, /* "" */ 0x1e7d, /* "" */ 0x1e7f,
            /* "" */ 0x24e5, /* "" */ 0xa75f, /* "" */ 0xff56,
        ],
    ],
    [[/* "v" */ 0x0076, /* "y" */ 0x0079], [/* "" */ 0xa761]],
    [
        [/* "w" */ 0x0077],
        [
            /* "" */ 0x0175, /* "" */ 0x1e81, /* "" */ 0x1e83, /* "" */ 0x1e85,
            /* "" */ 0x1e87, /* "" */ 0x1e89, /* "" */ 0x1e98, /* "" */ 0x24e6,
            /* "" */ 0x2c73, /* "" */ 0xff57,
        ],
    ],
    [
        [/* "x" */ 0x0078],
        [/* "" */ 0x1e8b, /* "" */ 0x1e8d, /* "" */ 0x24e7, /* "" */ 0xff58],
    ],
    [
        [/* "y" */ 0x0079],
        [
            /* "" */ 0x00fd, /* "" */ 0x00ff, /* "" */ 0x0177, /* "" */ 0x01b4,
            /* "" */ 0x0233, /* "" */ 0x024f, /* "" */ 0x1e8f, /* "" */ 0x1e99,
            /* "" */ 0x1ef3, /* "" */ 0x1ef5, /* "" */ 0x1ef7, /* "" */ 0x1ef9,
            /* "" */ 0x1eff, /* "" */ 0x24e8, /* "" */ 0xff59,
        ],
    ],
    [
        [/* "z" */ 0x007a],
        [
            /* "" */ 0x017a, /* "" */ 0x017c, /* "" */ 0x017e, /* "" */ 0x01b6,
            /* "" */ 0x0225, /* "" */ 0x0240, /* "" */ 0x1e91, /* "" */ 0x1e93,
            /* "" */ 0x1e95, /* "" */ 0x24e9, /* "" */ 0x2c6c, /* "" */ 0xa763,
            /* "" */ 0xff5a,
        ],
    ],
    // ----- Punctuators -----
    [
        [/* "." */ 0x002e, /* "." */ 0x002e, /* "." */ 0x002e],
        [/* HORIZONTAL ELLIPSIS */ 0x2026],
    ],
    [[/* "?" */ 0x003f, /* "?" */ 0x003f], [/* DOUBLE QUESTION MARK */ 0x2047]],
    [
        [/* "?" */ 0x003f, /* "!" */ 0x0021],
        [/* QUESTION EXCLAMATION MARK */ 0x2048],
    ],
]);
const replaceMap = ((data) => {
    const map = new Map();
    for (const [to, from] of data) {
        for (const codePoint of from) {
            map.set(codePoint, to);
        }
    }
    return map;
})([
    [/* "!" */ 0x0021, [/* INVERTED EXCLAMATION MARK */ 0x00a1]],
    [
        /* '"' */ 0x0022,
        [
            /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab,
            /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb,
            /* LEFT DOUBLE QUOTATION MARK */ 0x201c,
            /* RIGHT DOUBLE QUOTATION MARK */ 0x201d,
            /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e,
            /* DOUBLE HIGH-REVERSED-9 QUOTATION MARK */ 0x201f,
            /* SINGLE LEFT-POINTING ANGLE QUOTATION MARK */ 0x2039,
            /* SINGLE RIGHT-POINTING ANGLE QUOTATION MARK */ 0x203a,
        ],
    ],
    [
        /* "'" */ 0x0027,
        [
            /* LEFT SINGLE QUOTATION MARK */ 0x2018,
            /* RIGHT SINGLE QUOTATION MARK */ 0x2019,
        ],
    ],
    [
        /* "-" */ 0x002d,
        [
            /* HYPHEN */ 0x2010, /* NON-BREAKING HYPHEN */ 0x2011,
            /* FIGURE DASH */ 0x2012, /* EN DASH */ 0x2013, /* EM DASH */ 0x2014,
        ],
    ],
    [/* "?" */ 0x003f, [/* INVERTED QUESTION MARK */ 0x00bf]],
]);

;// ./packages/keybr-unicode/lib/whitespace.ts
const isControl = (codePoint) => codePoint < 0x0020;
const isLinebreak = (codePoint) => codePoint === /* LINE FEED */ 0x000a ||
    codePoint === /* LINE TABULATION */ 0x000b ||
    codePoint === /* FORM FEED */ 0x000c ||
    codePoint === /* CARRIAGE RETURN */ 0x000d ||
    codePoint === /* LINE SEPARATOR */ 0x2028 ||
    codePoint === /* PARAGRAPH SEPARATOR */ 0x2029;
const isWhitespace = (codePoint) => codePoint === /* CHARACTER TABULATION */ 0x0009 ||
    codePoint === /* LINE FEED */ 0x000a ||
    codePoint === /* LINE TABULATION */ 0x000b ||
    codePoint === /* FORM FEED */ 0x000c ||
    codePoint === /* CARRIAGE RETURN */ 0x000d ||
    codePoint === /* SPACE */ 0x0020 ||
    codePoint === /* NO-BREAK SPACE */ 0x00a0 ||
    codePoint === /* EN QUAD */ 0x2000 ||
    codePoint === /* EM QUAD */ 0x2001 ||
    codePoint === /* EN SPACE */ 0x2002 ||
    codePoint === /* EM SPACE */ 0x2003 ||
    codePoint === /* THREE-PER-EM SPACE */ 0x2004 ||
    codePoint === /* FOUR-PER-EM SPACE */ 0x2005 ||
    codePoint === /* SIX-PER-EM SPACE */ 0x2006 ||
    codePoint === /* FIGURE SPACE */ 0x2007 ||
    codePoint === /* PUNCTUATION SPACE */ 0x2008 ||
    codePoint === /* THIN SPACE */ 0x2009 ||
    codePoint === /* HAIR SPACE */ 0x200a ||
    codePoint === /* LINE SEPARATOR */ 0x2028 ||
    codePoint === /* PARAGRAPH SEPARATOR */ 0x2029;

;// ./packages/keybr-unicode/lib/index.ts








;// ./packages/keybr-keyboard/lib/keymodifier.ts
class keymodifier_KeyModifier {
    static None = new keymodifier_KeyModifier(/* shift= */ false, /* alt= */ false);
    static Shift = new keymodifier_KeyModifier(/* shift= */ true, /* alt= */ false);
    static Alt = new keymodifier_KeyModifier(/* shift= */ false, /* alt= */ true);
    static ShiftAlt = new keymodifier_KeyModifier(
    /* shift= */ true, 
    /* alt= */ true);
    static from(shift, alt) {
        if (shift && alt) {
            return keymodifier_KeyModifier.ShiftAlt;
        }
        if (shift) {
            return keymodifier_KeyModifier.Shift;
        }
        if (alt) {
            return keymodifier_KeyModifier.Alt;
        }
        return keymodifier_KeyModifier.None;
    }
    shift;
    alt;
    complexity;
    constructor(shift, alt) {
        this.shift = shift;
        this.alt = alt;
        this.complexity = complexityOf(shift, alt);
    }
}
function complexityOf(shift, alt) {
    if (shift && alt) {
        return 2;
    }
    if (shift || alt) {
        return 1;
    }
    return 0;
}

;// ./packages/keybr-keyboard/lib/keycharacters.ts


class keycharacters_KeyCharacters {
    static isCodePoint = (/* unused pure expression or super */ null && ((ch) => {
        return isNumber(ch) && ch > 0x0000;
    }));
    static isDead = (/* unused pure expression or super */ null && ((ch) => {
        return isObject(ch) && "dead" in ch;
    }));
    static isSpecial = (/* unused pure expression or super */ null && ((ch) => {
        return isObject(ch) && "special" in ch;
    }));
    static isLigature = (/* unused pure expression or super */ null && ((ch) => {
        return isObject(ch) && "ligature" in ch;
    }));
    id;
    a;
    b;
    c;
    d;
    constructor(id, a, b, c, d) {
        this.id = id;
        this.a = a || null;
        this.b = b || null;
        this.c = c || null;
        this.d = d || null;
    }
    getCodePoint(modifier) {
        switch (modifier) {
            case KeyModifier.None:
                return keycharacters_select(this.a);
            case KeyModifier.Shift:
                return keycharacters_select(this.b, this.a);
            case KeyModifier.Alt:
                return keycharacters_select(this.c, this.b, this.a);
            case KeyModifier.ShiftAlt:
                return keycharacters_select(this.d, this.c, this.b, this.a);
            default:
                throw new Error();
        }
    }
    get valid() {
        return Boolean(this.a || this.b || this.c || this.d);
    }
}
function keycharacters_select(...characters) {
    for (const character of characters) {
        if (character != null) {
            if (keycharacters_KeyCharacters.isCodePoint(character)) {
                return character;
            }
            else {
                break;
            }
        }
    }
    return null;
}

;// ./packages/keybr-keyboard/lib/language.ts


class language_Language {
    static AR = new language_Language(
    /* id= */ "ar", 
    /* script= */ "arabic", 
    /* direction= */ "rtl", 
    /* alphabet= */ "");
    static BE = new language_Language(
    /* id= */ "be", 
    /* script= */ "cyrillic", 
    /* direction= */ "ltr", 
    /* alphabet= */ "");
    static CS = new language_Language(
    /* id= */ "cs", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuvxyz");
    static DE = new language_Language(
    /* id= */ "de", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnopqrstuvwxyz");
    static EL = new language_Language(
    /* id= */ "el", 
    /* script= */ "greek", 
    /* direction= */ "ltr", 
    /* alphabet= */ "");
    static EN = new language_Language(
    /* id= */ "en", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnopqrstuvwxyz");
    static ES = new language_Language(
    /* id= */ "es", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijlmnopqrstuvxyz");
    static FA = new language_Language(
    /* id= */ "fa", 
    /* script= */ "arabic", 
    /* direction= */ "rtl", 
    /* alphabet= */ "");
    static FR = new language_Language(
    /* id= */ "fr", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijlmnopqrstuvxyz");
    static HE = new language_Language(
    /* id= */ "he", 
    /* script= */ "hebrew", 
    /* direction= */ "rtl", 
    /* alphabet= */ "");
    static HR = new language_Language(
    /* id= */ "hr", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuvz");
    static HU = new language_Language(
    /* id= */ "hu", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnopqrstuvwxyz");
    static IT = new language_Language(
    /* id= */ "it", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnopqrstuvwxyz");
    static LT = new language_Language(
    /* id= */ "lt", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghiyjklmnoprstuvz");
    static NB = new language_Language(
    /* id= */ "nb", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuvwy");
    static NL = new language_Language(
    /* id= */ "nl", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnopqrstuvwxyz");
    static PL = new language_Language(
    /* id= */ "pl", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuwyz");
    static PT = new language_Language(
    /* id= */ "pt", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijlmnopqrstuvxz");
    static RO = new language_Language(
    /* id= */ "ro", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijlmnoprstuvxz");
    static RU = new language_Language(
    /* id= */ "ru", 
    /* script= */ "cyrillic", 
    /* direction= */ "ltr", 
    /* alphabet= */ "");
    static SL = new language_Language(
    /* id= */ "sl", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuvz");
    static SV = new language_Language(
    /* id= */ "sv", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuvwxy");
    static TH = new language_Language(
    /* id= */ "th", 
    /* script= */ "thai", 
    /* direction= */ "ltr", 
    /* alphabet= */ "");
    static TR = new language_Language(
    /* id= */ "tr", 
    /* script= */ "latin", 
    /* direction= */ "ltr", 
    /* alphabet= */ "abcdefghijklmnoprstuvyz");
    static UK = new language_Language(
    /* id= */ "uk", 
    /* script= */ "cyrillic", 
    /* direction= */ "ltr", 
    /* alphabet= */ "");
    static ALL = new Enum(language_Language.AR, language_Language.BE, language_Language.CS, language_Language.DE, language_Language.EL, language_Language.EN, language_Language.ES, language_Language.FA, language_Language.FR, language_Language.HE, language_Language.HR, language_Language.HU, language_Language.IT, language_Language.LT, language_Language.NB, language_Language.NL, language_Language.PL, language_Language.PT, language_Language.RO, language_Language.RU, language_Language.SL, language_Language.SV, language_Language.TH, language_Language.TR, language_Language.UK);
    /** ISO 639-1 language code, https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes */
    id;
    /** The writing system, such as Cyrillic, Georgian, Greek, Hebrew, Latin, Thai, etc. */
    script;
    /** The direction of the writing system, either "ltr" for left-to-right, or "rtl" for right-to-left. */
    direction;
    /** The list of alphabet code points. */
    alphabet;
    /** The locale. */
    locale;
    /** The collator for sorting strings. */
    collator;
    /** A locale-sensitive string comparison function. */
    compare;
    /** A locale-sensitive string uppercase function. */
    upperCase;
    /** A locale-sensitive string lowercase function. */
    lowerCase;
    /** A locale-sensitive string capitalize function. */
    capitalCase;
    constructor(id, script, direction, alphabet) {
        const locale = new Intl.Locale(id).maximize();
        const collator = new Intl.Collator(locale);
        this.id = id;
        this.script = script;
        this.direction = direction;
        this.alphabet = Object.freeze([...codepoints_toCodePoints(alphabet)]);
        this.locale = locale;
        this.collator = collator;
        this.compare = (a, b) => collator.compare(a, b);
        this.upperCase = (v) => v.toLocaleUpperCase(locale);
        this.lowerCase = (v) => v.toLocaleLowerCase(locale);
        this.capitalCase = (v) => v.substring(0, 1).toLocaleUpperCase(locale) +
            v.substring(1).toLocaleLowerCase(locale);
        Object.freeze(this);
    }
    /**
     * Checks whether the given string is composed only of the language letters,
     * case-insensitive.
     */
    test = (v) => {
        for (const codePoint of codepoints_toCodePoints(this.lowerCase(v))) {
            if (!this.alphabet.includes(codePoint)) {
                return false;
            }
        }
        return true;
    };
    letterName = (codePoint) => {
        if (codePoint === /* "" */ 0x00df) {
            // German uppercase letter Eszett.
            return "";
        }
        if (codePoint >= 0x0590 && codePoint <= 0x05ff) {
            // Hebrew Unicode block.
            // There are no lower or uppercase letters in the Hebrew script.
            return String.fromCodePoint(codePoint);
        }
        if (codePoint >= 0x0600 && codePoint <= 0x06ff) {
            // Arabic Unicode block.
            // There are no lower or uppercase letters in the Arabic script.
            // Arabic script is cursive, which means that the letters
            // change shape when joined together.
            // Here we break letters apart by prepending them with
            // the Zero Width Non-Joiner character.
            return String.fromCodePoint(
            /* ZERO WIDTH NON-JOINER */ 0x200c, codePoint);
        }
        if (codePoint >= 0x0e00 && codePoint <= 0x0e7f) {
            // Thai Unicode block.
            if (codePoint === 0x0e31 ||
                (codePoint >= 0x0e34 && codePoint <= 0x0e3a) ||
                (codePoint >= 0x0e47 && codePoint <= 0x0e4e)) {
                // Thai combining marks.
                return String.fromCodePoint(/* DOTTED CIRCLE */ 0x25cc, codePoint);
            }
        }
        // Locale-specific uppercase variant of a letter.
        // For example in Turkish there are dotted and dotless letter I,
        // each with its own lower and uppercase variant.
        return this.upperCase(String.fromCodePoint(codePoint));
    };
    /**
     * Returns a value indicating whether the given code point
     * can be a letter of this language.
     */
    includes(codePoint) {
        // We consider these Unicode ranges to contain letters only in a given script.
        // The ranges were manually built from Unicode tables and may not be accurate.
        switch (this.script) {
            case "arabic":
                return codePoint >= 0x0600 && codePoint <= 0x06ff;
            case "cyrillic":
                return codePoint >= 0x0400 && codePoint <= 0x04ff;
            case "greek":
                return codePoint >= 0x0370 && codePoint <= 0x03ff;
            case "hebrew":
                return codePoint >= 0x0590 && codePoint <= 0x05ff;
            case "latin":
                // A few Unicode blocks of the Latin script to include only
                // a reasonable list of letter codepoints.
                return ((codePoint >= /* "A" */ 0x0041 && codePoint <= /* "Z" */ 0x005a) ||
                    (codePoint >= /* "a" */ 0x0061 && codePoint <= /* "z" */ 0x007a) ||
                    (codePoint >= /* "" */ 0x00c0 && codePoint <= /* "" */ 0x00d6) ||
                    (codePoint >= /* "" */ 0x00d8 && codePoint <= /* "" */ 0x00f6) ||
                    (codePoint >= /* "" */ 0x00f8 && codePoint <= /* "" */ 0x00ff) ||
                    (codePoint >= /* "" */ 0x0100 && codePoint <= /* "" */ 0x017f) ||
                    (codePoint >= /* "" */ 0x0180 && codePoint <= /* "" */ 0x024f));
            case "thai":
                return codePoint >= 0x0e00 && codePoint <= 0x0e7f;
            default:
                return false;
        }
    }
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}
function language_getExampleText({ script }) {
    switch (script) {
        case "arabic":
            return "    .";
        case "cyrillic":
            return "    .";
        case "greek":
            return "    .";
        case "hebrew":
            return "   .";
        case "thai":
            return " ";
        default:
            return "Eat more apples and oranges.";
    }
}
function language_getExampleLetters({ script }) {
    switch (script) {
        case "arabic":
            return [0x0627, 0x0628, 0x067e, 0x062a, 0x062b, 0x062c];
        case "cyrillic":
            return [0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435];
        case "greek":
            return [0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6];
        case "hebrew":
            return [0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5];
        case "latin":
            return [0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066];
        case "thai":
            return [0x0e01, 0x0e02, 0x0e04, 0x0e06, 0x0e07, 0x0e08];
    }
}

;// ./packages/keybr-keyboard/lib/keyboard.ts






class keyboard_Keyboard {
    layout;
    geometry;
    characterDict;
    geometryDict;
    characters;
    combos;
    shapes;
    zones;
    constructor(layout, geometry, characterDict, geometryDict) {
        this.layout = layout;
        this.geometry = geometry;
        this.characterDict = characterDict;
        this.geometryDict = geometryDict;
        const characters = new Map();
        const combos = new Map();
        const shapes = new Map();
        const zones = new Map();
        for (const [id, [a = null, b = null, c = null, d = null]] of Object.entries(characterDict)) {
            characters.set(id, new KeyCharacters(id, a, b, c, d));
        }
        for (const { id, a, b, c, d } of characters.values()) {
            if (KeyCharacters.isCodePoint(a)) {
                addCombo(combos, a, id, KeyModifier.None);
            }
            if (KeyCharacters.isCodePoint(b)) {
                addCombo(combos, b, id, KeyModifier.Shift);
            }
            if (KeyCharacters.isCodePoint(c)) {
                addCombo(combos, c, id, KeyModifier.Alt);
            }
            if (KeyCharacters.isCodePoint(d)) {
                addCombo(combos, d, id, KeyModifier.ShiftAlt);
            }
        }
        for (const { id, a, b, c, d } of characters.values()) {
            if (KeyCharacters.isDead(a)) {
                addDeadCombo(combos, a, id, KeyModifier.None);
            }
            if (KeyCharacters.isDead(b)) {
                addDeadCombo(combos, b, id, KeyModifier.Shift);
            }
            if (KeyCharacters.isDead(c)) {
                addDeadCombo(combos, c, id, KeyModifier.Alt);
            }
            if (KeyCharacters.isDead(d)) {
                addDeadCombo(combos, d, id, KeyModifier.ShiftAlt);
            }
        }
        for (const [id, data] of Object.entries(layout.mod(geometry, geometryDict))) {
            const shape = new KeyShape(id, data, characterDict[id] ?? null);
            shapes.set(id, shape);
            for (const zone of shape.zones) {
                let list = zones.get(zone);
                if (list == null) {
                    zones.set(zone, (list = []));
                }
                list.push(shape);
            }
        }
        this.layout = layout;
        this.geometry = geometry;
        this.characters = characters;
        this.combos = combos;
        this.shapes = shapes;
        this.zones = zones;
    }
    getCharacters(id) {
        return this.characters.get(id) ?? null;
    }
    getCombo(codePoint) {
        return this.combos.get(codePoint) ?? null;
    }
    getShape(id) {
        return this.shapes.get(id) ?? null;
    }
    getCodePoints({ zones, dead = true, shift = true, alt = true, } = {}) {
        const list = [];
        const weights = new Map();
        for (const combo of this.combos.values()) {
            const shape = this.getShape(combo.id);
            if ((combo.prefix == null || dead) &&
                (!combo.shift || shift) &&
                (!combo.alt || alt) &&
                (zones == null || shape?.inAnyZone(zones))) {
                list.push(combo.codePoint);
                switch (shape?.row) {
                    case "home":
                        weights.set(combo.codePoint, 1);
                        break;
                    case "top":
                        weights.set(combo.codePoint, 2);
                        break;
                }
            }
        }
        const codePoints = new Set(list.sort((a, b) => a - b));
        return new (class {
            [Symbol.iterator]() {
                return codePoints[Symbol.iterator]();
            }
            get size() {
                return codePoints.size;
            }
            has(codePoint) {
                return codePoints.has(codePoint);
            }
            weight(codePoint) {
                return weights.get(codePoint) ?? 1000;
            }
        })();
    }
    getExampleText() {
        return getExampleText(this.layout.language);
    }
    getExampleLetters() {
        const codePoints = this.getCodePoints();
        return getExampleLetters(this.layout.language).filter(codePoints.has);
    }
}
function setCombo(map, combo) {
    const oldCombo = map.get(combo.codePoint);
    if (oldCombo == null || oldCombo.complexity > combo.complexity) {
        map.set(combo.codePoint, combo);
    }
}
function addCombo(map, character, id, modifier) {
    setCombo(map, new KeyCombo(character, id, modifier));
}
function addDeadCombo(map, { dead }, id, modifier) {
    if (isDiacritic(dead)) {
        const prefix = new KeyCombo(dead, id, modifier);
        for (const combo of map.values()) {
            if (combo.prefix == null) {
                const combinedCodePoint = combineDiacritic(combo.codePoint, dead);
                if (combinedCodePoint !== combo.codePoint) {
                    setCombo(map, new KeyCombo(combinedCodePoint, combo.id, combo.modifier, prefix));
                }
            }
        }
    }
}

;// ./packages/keybr-keyboard/lib/mod.ts

const mod_nullMod = (geometry, dict) => dict;
const angleMod = ({ form }, dict) => {
    if (form === "staggered") {
        return mod_remapZones(dict, ANGLE_MOD);
    }
    else {
        return dict;
    }
};
const angleWideMod = ({ form }, dict) => {
    if (form === "staggered") {
        return mod_remapZones(dict, ANGLE_WIDE_MOD);
    }
    else {
        return dict;
    }
};
function mod_remapZones(dict, mod) {
    return Object.fromEntries(Object.entries(dict).map(([id, { x, y, w, h, labels, shape, zones, homing }]) => [
        id,
        { x, y, w, h, labels, shape, zones: mod[id] ?? zones, homing },
    ]));
}

;// ./packages/keybr-keyboard/lib/layout.ts




class layout_Layout {
    id;
    xid;
    name;
    family;
    language;
    emulate;
    geometries;
    mod;
    static custom(language) {
        return new layout_Layout(
        /* id= */ "custom", 
        /* xid= */ 0xff, 
        /* name= */ "Custom", 
        /* family= */ "custom", 
        /* language= */ language, 
        /* emulate= */ true, 
        /* geometries= */ geometry_Geometry.ALL);
    }
    static EN_US = new layout_Layout(
    /* id= */ "en-us", 
    /* xid= */ 0x10, 
    /* name= */ "{US}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.EN, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_DVORAK = new layout_Layout(
    /* id= */ "en-dvorak", 
    /* xid= */ 0x18, 
    /* name= */ "Dvorak", 
    /* family= */ "dvorak", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_DVORAK_PROG = new layout_Layout(
    /* id= */ "en-dvorak-prog", 
    /* xid= */ 0x15, 
    /* name= */ "Dvorak (Programmers)", 
    /* family= */ "dvorak", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_COLEMAK = new layout_Layout(
    /* id= */ "en-colemak", 
    /* xid= */ 0x19, 
    /* name= */ "Colemak", 
    /* family= */ "colemak", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_COLEMAK_DH_ANSI = new layout_Layout(
    /* id= */ "en-colemak-dh", 
    /* xid= */ 0x1b, 
    /* name= */ "Colemak-DH (ANSI)", 
    /* family= */ "colemak-dh", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX), 
    /* mod= */ angleMod);
    static EN_COLEMAK_DH_ANSI_WIDE = new layout_Layout(
    /* id= */ "en-colemak-dh-wide", 
    /* xid= */ 0x1f, 
    /* name= */ "Colemak-DH Wide (ANSI)", 
    /* family= */ "colemak-dh-wide", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX), 
    /* mod= */ angleWideMod);
    static EN_COLEMAK_DH_ISO = new layout_Layout(
    /* id= */ "en-colemak-dh-iso", 
    /* xid= */ 0x16, 
    /* name= */ "Colemak-DH (ISO)", 
    /* family= */ "colemak-dh-iso", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX), 
    /* mod= */ angleMod);
    static EN_COLEMAK_DH_ISO_WIDE = new layout_Layout(
    /* id= */ "en-colemak-dh-iso-wide", 
    /* xid= */ 0x17, 
    /* name= */ "Colemak-DH Wide (ISO)", 
    /* family= */ "colemak-dh-iso-wide", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX), 
    /* mod= */ angleWideMod);
    static EN_COLEMAK_DH_MATRIX = new layout_Layout(
    /* id= */ "en-colemak-dh-matrix", 
    /* xid= */ 0x1c, 
    /* name= */ "Colemak-DH (matrix)", 
    /* family= */ "colemak-dh-matrix", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX));
    static EN_WORKMAN = new layout_Layout(
    /* id= */ "en-workman", 
    /* xid= */ 0x1a, 
    /* name= */ "Workman", 
    /* family= */ "workman", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_UK = new layout_Layout(
    /* id= */ "en-uk", 
    /* xid= */ 0x11, 
    /* name= */ "{UK}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.EN, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static EN_JP = new layout_Layout(
    /* id= */ "en-jp", 
    /* xid= */ 0x12, 
    /* name= */ "{JP}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.EN, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.JAPANESE_106, geometry_Geometry.JAPANESE_106_FULL));
    static DE_DE = new layout_Layout(
    /* id= */ "de-de", 
    /* xid= */ 0x20, 
    /* name= */ "{DE}", 
    /* family= */ "qwertz", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static DE_CH = new layout_Layout(
    /* id= */ "de-ch", 
    /* xid= */ 0x21, 
    /* name= */ "{CH}", 
    /* family= */ "qwertz", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static DE_NEO_2 = new layout_Layout(
    /* id= */ "de-neo-2", 
    /* xid= */ 0x22, 
    /* name= */ "Neo 2", 
    /* family= */ "de-neo-2", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static DE_BONE = new layout_Layout(
    /* id= */ "de-bone", 
    /* xid= */ 0x23, 
    /* name= */ "Bone", 
    /* family= */ "de-bone", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static DE_MINE = new layout_Layout(
    /* id= */ "de-mine", 
    /* xid= */ 0x24, 
    /* name= */ "Mine", 
    /* family= */ "de-mine", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static DE_NOTED = new layout_Layout(
    /* id= */ "de-noted", 
    /* xid= */ 0x25, 
    /* name= */ "Noted", 
    /* family= */ "de-noted", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static DE_CMOS = new layout_Layout(
    /* id= */ "de-cmos", 
    /* xid= */ 0x26, 
    /* name= */ "CMOS", 
    /* family= */ "de-cmos", 
    /* language= */ language_Language.DE, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_FR = new layout_Layout(
    /* id= */ "fr-fr", 
    /* xid= */ 0x30, 
    /* name= */ "{FR}", 
    /* family= */ "azerty", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_CA = new layout_Layout(
    /* id= */ "fr-ca", 
    /* xid= */ 0x31, 
    /* name= */ "{CA}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_CH = new layout_Layout(
    /* id= */ "fr-ch", 
    /* xid= */ 0x32, 
    /* name= */ "{CH}", 
    /* family= */ "qwertz", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_BEPO = new layout_Layout(
    /* id= */ "fr-bepo", 
    /* xid= */ 0x33, 
    /* name= */ "Bepo", 
    /* family= */ "fr-bepo", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_ERGO_L = new layout_Layout(
    /* id= */ "fr-ergol", 
    /* xid= */ 0x34, 
    /* name= */ "Ergo-L", 
    /* family= */ "fr-ergol", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_OPTIMOT_ERGO = new layout_Layout(
    /* id= */ "fr-optimot-ergo", 
    /* xid= */ 0x35, 
    /* name= */ "Optimot Ergo", 
    /* family= */ "fr-optimot-ergo", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FR_ERGLACE = new layout_Layout(
    /* id= */ "fr-erglace", 
    /* xid= */ 0x36, 
    /* name= */ "Erglace", 
    /* family= */ "fr-erglace", 
    /* language= */ language_Language.FR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static IT_IT = new layout_Layout(
    /* id= */ "it-it", 
    /* xid= */ 0x40, 
    /* name= */ "{IT}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.IT, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static LT_LT = new layout_Layout(
    /* id= */ "lt-lt", 
    /* xid= */ 0x48, 
    /* name= */ "{LT}", 
    /* family= */ "lt-lt", 
    /* language= */ language_Language.LT, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static ES_ES = new layout_Layout(
    /* id= */ "es-es", 
    /* xid= */ 0x50, 
    /* name= */ "{ES}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.ES, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static PL_PL = new layout_Layout(
    /* id= */ "pl-pl", 
    /* xid= */ 0x58, 
    /* name= */ "{PL}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.PL, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static PT_BR = new layout_Layout(
    /* id= */ "pt-br", 
    /* xid= */ 0x60, 
    /* name= */ "{BR} (ABNT2)", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.PT, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.BRAZILIAN_104, geometry_Geometry.BRAZILIAN_104_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static PT_PT = new layout_Layout(
    /* id= */ "pt-pt", 
    /* xid= */ 0x62, 
    /* name= */ "{PT}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.PT, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static RU_RU = new layout_Layout(
    /* id= */ "ru-ru", 
    /* xid= */ 0x70, 
    /* name= */ "{RU}", 
    /* family= */ "", 
    /* language= */ language_Language.RU, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static BE_BY = new layout_Layout(
    /* id= */ "be-by", 
    /* xid= */ 0x74, 
    /* name= */ "{BY}", 
    /* family= */ "", 
    /* language= */ language_Language.BE, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static UK_UA = new layout_Layout(
    /* id= */ "uk-ua", 
    /* xid= */ 0x78, 
    /* name= */ "{UA}", 
    /* family= */ "", 
    /* language= */ language_Language.UK, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static SV_SE = new layout_Layout(
    /* id= */ "sv-se", 
    /* xid= */ 0x80, 
    /* name= */ "{SE}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.SV, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static CS_CZ = new layout_Layout(
    /* id= */ "cs-cz", 
    /* xid= */ 0x81, 
    /* name= */ "{CZ}", 
    /* family= */ "qwertz", 
    /* language= */ language_Language.CS, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static SL_SI = new layout_Layout(
    /* id= */ "sl-si", 
    /* xid= */ 0x82, 
    /* name= */ "{SI}", 
    /* family= */ "qwertz", 
    /* language= */ language_Language.SL, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static EL_GR = new layout_Layout(
    /* id= */ "el-gr", 
    /* xid= */ 0x83, 
    /* name= */ "{GR}", 
    /* family= */ "greek", 
    /* language= */ language_Language.EL, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static NB_NO = new layout_Layout(
    /* id= */ "nb-no", 
    /* xid= */ 0x88, 
    /* name= */ "{NO}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.NB, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static HE_IL = new layout_Layout(
    /* id= */ "he-il", 
    /* xid= */ 0x84, 
    /* name= */ "{IL} ()", 
    /* family= */ "hebrew", 
    /* language= */ language_Language.HE, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static NL_NL = new layout_Layout(
    /* id= */ "nl-nl", 
    /* xid= */ 0x85, 
    /* name= */ "{NL}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.NL, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static NL_BE = new layout_Layout(
    /* id= */ "nl-be", 
    /* xid= */ 0x86, 
    /* name= */ "{BE}", 
    /* family= */ "azerty", 
    /* language= */ language_Language.NL, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static HU_HU = new layout_Layout(
    /* id= */ "hu-hu", 
    /* xid= */ 0x87, 
    /* name= */ "{HU}", 
    /* family= */ "qwertz", 
    /* language= */ language_Language.HU, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static TR_TR_Q = new layout_Layout(
    /* id= */ "tr-tr-q", 
    /* xid= */ 0x89, 
    /* name= */ "{TR} Q", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.TR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static TR_TR_F = new layout_Layout(
    /* id= */ "tr-tr-f", 
    /* xid= */ 0x8a, 
    /* name= */ "{TR} F", 
    /* family= */ "tr-tr-f", 
    /* language= */ language_Language.TR, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static EN_CANARY = new layout_Layout(
    /* id= */ "en-canary", 
    /* xid= */ 0x1e, 
    /* name= */ "Canary", 
    /* family= */ "canary", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_CANARY_MATRIX = new layout_Layout(
    /* id= */ "en-canary-matrix", 
    /* xid= */ 0x1d, 
    /* name= */ "Canary (matrix)", 
    /* family= */ "canary-matrix", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX));
    static EN_NORMAN = new layout_Layout(
    /* id= */ "en-norman", 
    /* xid= */ 0x8b, 
    /* name= */ "Norman", 
    /* family= */ "norman", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_HALMAK = new layout_Layout(
    /* id= */ "en-halmak", 
    /* xid= */ 0x8c, 
    /* name= */ "Halmak", 
    /* family= */ "halmak", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static AR_SA = new layout_Layout(
    /* id= */ "ar-sa", 
    /* xid= */ 0x8d, 
    /* name= */ "{SA} (101)", 
    /* family= */ "arabic", 
    /* language= */ language_Language.AR, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static AR_SA_102 = new layout_Layout(
    /* id= */ "ar-sa-102", 
    /* xid= */ 0x8e, 
    /* name= */ "{SA} (102)", 
    /* family= */ "arabic", 
    /* language= */ language_Language.AR, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static FA_IR_LEGACY = new layout_Layout(
    /* id= */ "fa-ir-legacy", 
    /* xid= */ 0x8f, 
    /* name= */ "Persian Legacy   ", 
    /* family= */ "persian", 
    /* language= */ language_Language.FA, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static HE_IL_ARKN = new layout_Layout(
    /* id= */ "he-il-arkn", 
    /* xid= */ 0x90, 
    /* name= */ "{IL} ()", 
    /* family= */ "hebrew-arkn", 
    /* language= */ language_Language.HE, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static FA_IR = new layout_Layout(
    /* id= */ "fa-ir", 
    /* xid= */ 0x91, 
    /* name= */ "Persian Standard  ", 
    /* family= */ "persian", 
    /* language= */ language_Language.FA, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_ENGRAM = new layout_Layout(
    /* id= */ "en-engram", 
    /* xid= */ 0x92, 
    /* name= */ "Engram", 
    /* family= */ "en-engram", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_NERPS = new layout_Layout(
    /* id= */ "en-nerps", 
    /* xid= */ 0x93, 
    /* name= */ "Nerps", 
    /* family= */ "nerps", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_NERPS_MATRIX = new layout_Layout(
    /* id= */ "en-nerps-matrix", 
    /* xid= */ 0x94, 
    /* name= */ "Nerps (matrix)", 
    /* family= */ "nerps-matrix", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX));
    static EN_HANDS_DOWN_NEU = new layout_Layout(
    /* id= */ "en-hands-down-neu", 
    /* xid= */ 0x95, 
    /* name= */ "Hands Down Neu", 
    /* family= */ "hands-down-neu", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL));
    static EN_STURDY = new layout_Layout(
    /* id= */ "en-sturdy", 
    /* xid= */ 0x96, 
    /* name= */ "Sturdy", 
    /* family= */ "sturdy", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX));
    static ES_MX = new layout_Layout(
    /* id= */ "es-mx", 
    /* xid= */ 0x97, 
    /* name= */ "{MX}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.ES, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static PL_FWYR = new layout_Layout(
    /* id= */ "pl-fwyr", 
    /* xid= */ 0x98, 
    /* name= */ "FWYR", 
    /* family= */ "fwyr", 
    /* language= */ language_Language.PL, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static EN_GRAPHITE = new layout_Layout(
    /* id= */ "en-graphite", 
    /* xid= */ 0x99, 
    /* name= */ "Graphite", 
    /* family= */ "en-graphite", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static TH_TH = new layout_Layout(
    /* id= */ "th-th", 
    /* xid= */ 0x9a, 
    /* name= */ "Thai Kedmanee", 
    /* family= */ "th-th", 
    /* language= */ language_Language.TH, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static TH_PAT = new layout_Layout(
    /* id= */ "th-th-pat", 
    /* xid= */ 0x9b, 
    /* name= */ "Thai Pattachote", 
    /* family= */ "th-th-pat", 
    /* language= */ language_Language.TH, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static TH_MAN = new layout_Layout(
    /* id= */ "th-th-man", 
    /* xid= */ 0x9c, 
    /* name= */ "Thai Manoonchai V1", 
    /* family= */ "th-th-man", 
    /* language= */ language_Language.TH, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static NB_KVIKK = new layout_Layout(
    /* id= */ "nb-no-kvikk", 
    /* xid= */ 0x9d, 
    /* name= */ "Kvikk", 
    /* family= */ "kvikk", 
    /* language= */ language_Language.NB, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static NB_SKARP = new layout_Layout(
    /* id= */ "nb-no-skarp", 
    /* xid= */ 0x9e, 
    /* name= */ "Skarp", 
    /* family= */ "skarp", 
    /* language= */ language_Language.NB, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static RO_RO = new layout_Layout(
    /* id= */ "ro-ro", 
    /* xid= */ 0xa0, 
    /* name= */ "{RO}", 
    /* family= */ "qwerty", 
    /* language= */ language_Language.RO, 
    /* emulate= */ false, 
    /* geometries= */ new Enum(geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.MATRIX));
    static EN_GALLIUM = new layout_Layout(
    /* id= */ "en-gallium", 
    /* xid= */ 0xa1, 
    /* name= */ "Gallium", 
    /* family= */ "gallium", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.ANSI_101, geometry_Geometry.ANSI_101_FULL, geometry_Geometry.ISO_102, geometry_Geometry.ISO_102_FULL, geometry_Geometry.MATRIX));
    static EN_GALLIUM_MATRIX = new layout_Layout(
    /* id= */ "en-gallium-matrix", 
    /* xid= */ 0xa2, 
    /* name= */ "Gallium (matrix)", 
    /* family= */ "gallium-matrix", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX));
    static EN_HANDS_DOWN_PROMETHIUM = new layout_Layout(
    /* id= */ "en-hands-down-promethium", 
    /* xid= */ 0xa3, 
    /* name= */ "Hands Down Promethium (Matrix)", 
    /* family= */ "en-hands-down-promethium", 
    /* language= */ language_Language.EN, 
    /* emulate= */ true, 
    /* geometries= */ new Enum(geometry_Geometry.MATRIX));
    static ALL = new XEnum(layout_Layout.EN_US, layout_Layout.EN_DVORAK, layout_Layout.EN_DVORAK_PROG, layout_Layout.EN_COLEMAK, layout_Layout.EN_COLEMAK_DH_ANSI, layout_Layout.EN_COLEMAK_DH_ANSI_WIDE, layout_Layout.EN_COLEMAK_DH_ISO, layout_Layout.EN_COLEMAK_DH_ISO_WIDE, layout_Layout.EN_COLEMAK_DH_MATRIX, layout_Layout.EN_WORKMAN, layout_Layout.EN_CANARY, layout_Layout.EN_CANARY_MATRIX, layout_Layout.EN_NERPS, layout_Layout.EN_NERPS_MATRIX, layout_Layout.EN_HANDS_DOWN_NEU, layout_Layout.EN_HANDS_DOWN_PROMETHIUM, layout_Layout.EN_STURDY, layout_Layout.EN_NORMAN, layout_Layout.EN_HALMAK, layout_Layout.EN_ENGRAM, layout_Layout.EN_GALLIUM, layout_Layout.EN_GALLIUM_MATRIX, layout_Layout.EN_GRAPHITE, layout_Layout.EN_UK, layout_Layout.EN_JP, layout_Layout.EL_GR, layout_Layout.CS_CZ, layout_Layout.DE_DE, layout_Layout.DE_CH, layout_Layout.DE_NEO_2, layout_Layout.DE_BONE, layout_Layout.DE_MINE, layout_Layout.DE_NOTED, layout_Layout.DE_CMOS, layout_Layout.FR_FR, layout_Layout.FR_CA, layout_Layout.FR_CH, layout_Layout.FR_BEPO, layout_Layout.FR_ERGO_L, layout_Layout.FR_ERGLACE, layout_Layout.FR_OPTIMOT_ERGO, layout_Layout.HE_IL, layout_Layout.HE_IL_ARKN, layout_Layout.HU_HU, layout_Layout.IT_IT, layout_Layout.LT_LT, layout_Layout.NB_NO, layout_Layout.NB_KVIKK, layout_Layout.NB_SKARP, layout_Layout.NL_NL, layout_Layout.NL_BE, layout_Layout.ES_ES, layout_Layout.ES_MX, layout_Layout.PL_PL, layout_Layout.PL_FWYR, layout_Layout.PT_BR, layout_Layout.PT_PT, layout_Layout.BE_BY, layout_Layout.SL_SI, layout_Layout.SV_SE, layout_Layout.UK_UA, layout_Layout.RU_RU, layout_Layout.TR_TR_Q, layout_Layout.TR_TR_F, layout_Layout.AR_SA, layout_Layout.AR_SA_102, layout_Layout.FA_IR, layout_Layout.FA_IR_LEGACY, layout_Layout.TH_TH, layout_Layout.TH_PAT, layout_Layout.TH_MAN, layout_Layout.RO_RO);
    static findLayout(localeId) {
        const { language = null, region = null } = (() => {
            try {
                return new Intl.Locale(localeId);
            }
            catch {
                return {};
            }
        })();
        if (language != null && region != null) {
            const id = `${language}-${region}`.toLowerCase();
            for (const layout of layout_Layout.ALL) {
                if (layout.id === id) {
                    return layout;
                }
            }
        }
        if (language != null) {
            const id = `${language}-`.toLowerCase();
            for (const layout of layout_Layout.ALL) {
                if (layout.id.startsWith(id)) {
                    return layout;
                }
            }
        }
        return null;
    }
    static selectableLayouts(language) {
        const list = layout_Layout.ALL.filter((layout) => layout.language.script === language.script);
        return [
            ...list.filter((layout) => layout.language.id === language.id),
            ...list.filter((layout) => layout.language.id !== language.id),
        ];
    }
    static selectLayout(language) {
        const [layout] = layout_Layout.selectableLayouts(language);
        if (layout == null) {
            throw new Error(); // Unreachable.
        }
        return layout;
    }
    constructor(id, xid, name, family, language, emulate, geometries, mod = mod_nullMod) {
        this.id = id;
        this.xid = xid;
        this.name = name;
        this.family = family;
        this.language = language;
        this.emulate = emulate;
        this.geometries = geometries;
        this.mod = mod;
        Object.freeze(this);
    }
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}

;// ./packages/keybr-keyboard/lib/layout/ar_sa.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_AR_SA = {
    Backquote: [/* ARABIC LETTER THAL */ 0x0630, /* ARABIC SHADDA */ 0x0651],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* LEFT PARENTHESIS */ 0x0028],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* ARABIC LETTER DAD */ 0x0636, /* ARABIC FATHA */ 0x064e],
    KeyW: [/* ARABIC LETTER SAD */ 0x0635, /* ARABIC FATHATAN */ 0x064b],
    KeyE: [/* ARABIC LETTER THEH */ 0x062b, /* ARABIC DAMMA */ 0x064f],
    KeyR: [/* ARABIC LETTER QAF */ 0x0642, /* ARABIC DAMMATAN */ 0x064c],
    KeyT: [/* ARABIC LETTER FEH */ 0x0641, { ligature: "" }],
    KeyY: [/* ARABIC LETTER GHAIN */ 0x063a, /* ARABIC LETTER ALEF WITH HAMZA BELOW */ 0x0625],
    KeyU: [/* ARABIC LETTER AIN */ 0x0639, /* LEFT SINGLE QUOTATION MARK */ 0x2018],
    KeyI: [/* ARABIC LETTER HEH */ 0x0647, /* DIVISION SIGN */ 0x00f7],
    KeyO: [/* ARABIC LETTER KHAH */ 0x062e, /* MULTIPLICATION SIGN */ 0x00d7],
    KeyP: [/* ARABIC LETTER HAH */ 0x062d, /* ARABIC SEMICOLON */ 0x061b],
    BracketLeft: [/* ARABIC LETTER JEEM */ 0x062c, /* LESS-THAN SIGN */ 0x003c],
    BracketRight: [/* ARABIC LETTER DAL */ 0x062f, /* GREATER-THAN SIGN */ 0x003e],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* ARABIC LETTER SHEEN */ 0x0634, /* ARABIC KASRA */ 0x0650],
    KeyS: [/* ARABIC LETTER SEEN */ 0x0633, /* ARABIC KASRATAN */ 0x064d],
    KeyD: [/* ARABIC LETTER YEH */ 0x064a, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyF: [/* ARABIC LETTER BEH */ 0x0628, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyG: [/* ARABIC LETTER LAM */ 0x0644, { ligature: "" }],
    KeyH: [/* ARABIC LETTER ALEF */ 0x0627, /* ARABIC LETTER ALEF WITH HAMZA ABOVE */ 0x0623],
    KeyJ: [/* ARABIC LETTER TEH */ 0x062a, /* ARABIC TATWEEL */ 0x0640],
    KeyK: [/* ARABIC LETTER NOON */ 0x0646, /* ARABIC COMMA */ 0x060c],
    KeyL: [/* ARABIC LETTER MEEM */ 0x0645, /* SOLIDUS */ 0x002f],
    Semicolon: [/* ARABIC LETTER KAF */ 0x0643, /* COLON */ 0x003a],
    Quote: [/* ARABIC LETTER TAH */ 0x0637, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* ARABIC LETTER YEH WITH HAMZA ABOVE */ 0x0626, /* TILDE */ 0x007e],
    KeyX: [/* ARABIC LETTER HAMZA */ 0x0621, /* ARABIC SUKUN */ 0x0652],
    KeyC: [/* ARABIC LETTER WAW WITH HAMZA ABOVE */ 0x0624, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyV: [/* ARABIC LETTER REH */ 0x0631, /* LEFT CURLY BRACKET */ 0x007b],
    KeyB: [{ ligature: "" }, { ligature: "" }],
    KeyN: [/* ARABIC LETTER ALEF MAKSURA */ 0x0649, /* ARABIC LETTER ALEF WITH MADDA ABOVE */ 0x0622],
    KeyM: [/* ARABIC LETTER TEH MARBUTA */ 0x0629, /* RIGHT SINGLE QUOTATION MARK */ 0x2019],
    Comma: [/* ARABIC LETTER WAW */ 0x0648, /* COMMA */ 0x002c],
    Period: [/* ARABIC LETTER ZAIN */ 0x0632, /* FULL STOP */ 0x002e],
    Slash: [/* ARABIC LETTER ZAH */ 0x0638, /* ARABIC QUESTION MARK */ 0x061f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/ar_sa_102.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_AR_SA_102 = {
    Backquote: [/* GREATER-THAN SIGN */ 0x003e, /* LESS-THAN SIGN */ 0x003c],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* CURRENCY SIGN */ 0x00a4],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* LEFT PARENTHESIS */ 0x0028],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* ARABIC LETTER DAD */ 0x0636, /* ARABIC FATHA */ 0x064e, { ligature: "" }],
    KeyW: [/* ARABIC LETTER SAD */ 0x0635, /* ARABIC FATHATAN */ 0x064b, { ligature: "" }],
    KeyE: [/* ARABIC LETTER THEH */ 0x062b, /* ARABIC DAMMA */ 0x064f, { ligature: "" }],
    KeyR: [/* ARABIC LETTER QAF */ 0x0642, /* ARABIC DAMMATAN */ 0x064c, { ligature: "" }],
    KeyT: [/* ARABIC LETTER FEH */ 0x0641, { ligature: "" }],
    KeyY: [/* ARABIC LETTER GHAIN */ 0x063a, /* ARABIC LETTER ALEF WITH HAMZA BELOW */ 0x0625],
    KeyU: [/* ARABIC LETTER AIN */ 0x0639, /* LEFT SINGLE QUOTATION MARK */ 0x2018],
    KeyI: [/* ARABIC LETTER HEH */ 0x0647, /* DIVISION SIGN */ 0x00f7],
    KeyO: [/* ARABIC LETTER KHAH */ 0x062e, /* MULTIPLICATION SIGN */ 0x00d7],
    KeyP: [/* ARABIC LETTER HAH */ 0x062d, /* ARABIC SEMICOLON */ 0x061b],
    BracketLeft: [/* ARABIC LETTER JEEM */ 0x062c, /* RIGHT CURLY BRACKET */ 0x007d],
    BracketRight: [/* ARABIC LETTER DAL */ 0x062f, /* LEFT CURLY BRACKET */ 0x007b],
    Backslash: [/* ARABIC LETTER THAL */ 0x0630, /* ARABIC SHADDA */ 0x0651],
    KeyA: [/* ARABIC LETTER SHEEN */ 0x0634, /* REVERSE SOLIDUS */ 0x005c],
    KeyS: [/* ARABIC LETTER SEEN */ 0x0633],
    KeyD: [/* ARABIC LETTER YEH */ 0x064a, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyF: [/* ARABIC LETTER BEH */ 0x0628, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyG: [/* ARABIC LETTER LAM */ 0x0644, { ligature: "" }],
    KeyH: [/* ARABIC LETTER ALEF */ 0x0627, /* ARABIC LETTER ALEF WITH HAMZA ABOVE */ 0x0623],
    KeyJ: [/* ARABIC LETTER TEH */ 0x062a, /* ARABIC TATWEEL */ 0x0640],
    KeyK: [/* ARABIC LETTER NOON */ 0x0646, /* ARABIC COMMA */ 0x060c],
    KeyL: [/* ARABIC LETTER MEEM */ 0x0645, /* SOLIDUS */ 0x002f],
    Semicolon: [/* ARABIC LETTER KAF */ 0x0643, /* COLON */ 0x003a],
    Quote: [/* ARABIC LETTER TAH */ 0x0637, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* ARABIC TATWEEL */ 0x0640, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* ARABIC LETTER YEH WITH HAMZA ABOVE */ 0x0626, /* TILDE */ 0x007e],
    KeyX: [/* ARABIC LETTER HAMZA */ 0x0621, /* ARABIC SUKUN */ 0x0652],
    KeyC: [/* ARABIC LETTER WAW WITH HAMZA ABOVE */ 0x0624, /* ARABIC KASRA */ 0x0650, { ligature: "" }],
    KeyV: [/* ARABIC LETTER REH */ 0x0631, /* ARABIC KASRATAN */ 0x064d, { ligature: "" }],
    KeyB: [{ ligature: "" }, { ligature: "" }],
    KeyN: [/* ARABIC LETTER ALEF MAKSURA */ 0x0649, /* ARABIC LETTER ALEF WITH MADDA ABOVE */ 0x0622],
    KeyM: [/* ARABIC LETTER TEH MARBUTA */ 0x0629, /* RIGHT SINGLE QUOTATION MARK */ 0x2019],
    Comma: [/* ARABIC LETTER WAW */ 0x0648, /* COMMA */ 0x002c],
    Period: [/* ARABIC LETTER ZAIN */ 0x0632, /* FULL STOP */ 0x002e],
    Slash: [/* ARABIC LETTER ZAH */ 0x0638, /* ARABIC QUESTION MARK */ 0x061f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/be_by.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_BE_BY = {
    Backquote: [/* CYRILLIC SMALL LETTER IO */ 0x0451, /* CYRILLIC CAPITAL LETTER IO */ 0x0401],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMERO SIGN */ 0x2116],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* SEMICOLON */ 0x003b],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* COLON */ 0x003a],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* QUESTION MARK */ 0x003f],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* CYRILLIC SMALL LETTER SHORT I */ 0x0439, /* CYRILLIC CAPITAL LETTER SHORT I */ 0x0419],
    KeyW: [/* CYRILLIC SMALL LETTER TSE */ 0x0446, /* CYRILLIC CAPITAL LETTER TSE */ 0x0426],
    KeyE: [/* CYRILLIC SMALL LETTER U */ 0x0443, /* CYRILLIC CAPITAL LETTER U */ 0x0423],
    KeyR: [/* CYRILLIC SMALL LETTER KA */ 0x043a, /* CYRILLIC CAPITAL LETTER KA */ 0x041a],
    KeyT: [/* CYRILLIC SMALL LETTER IE */ 0x0435, /* CYRILLIC CAPITAL LETTER IE */ 0x0415],
    KeyY: [/* CYRILLIC SMALL LETTER EN */ 0x043d, /* CYRILLIC CAPITAL LETTER EN */ 0x041d],
    KeyU: [/* CYRILLIC SMALL LETTER GHE */ 0x0433, /* CYRILLIC CAPITAL LETTER GHE */ 0x0413],
    KeyI: [/* CYRILLIC SMALL LETTER SHA */ 0x0448, /* CYRILLIC CAPITAL LETTER SHA */ 0x0428],
    KeyO: [/* CYRILLIC SMALL LETTER SHORT U */ 0x045e, /* CYRILLIC CAPITAL LETTER SHORT U */ 0x040e],
    KeyP: [/* CYRILLIC SMALL LETTER ZE */ 0x0437, /* CYRILLIC CAPITAL LETTER ZE */ 0x0417],
    BracketLeft: [/* CYRILLIC SMALL LETTER HA */ 0x0445, /* CYRILLIC CAPITAL LETTER HA */ 0x0425],
    BracketRight: [/* APOSTROPHE */ 0x0027, /* APOSTROPHE */ 0x0027],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* SOLIDUS */ 0x002f],
    KeyA: [/* CYRILLIC SMALL LETTER EF */ 0x0444, /* CYRILLIC CAPITAL LETTER EF */ 0x0424],
    KeyS: [/* CYRILLIC SMALL LETTER YERU */ 0x044b, /* CYRILLIC CAPITAL LETTER YERU */ 0x042b],
    KeyD: [/* CYRILLIC SMALL LETTER VE */ 0x0432, /* CYRILLIC CAPITAL LETTER VE */ 0x0412],
    KeyF: [/* CYRILLIC SMALL LETTER A */ 0x0430, /* CYRILLIC CAPITAL LETTER A */ 0x0410],
    KeyG: [/* CYRILLIC SMALL LETTER PE */ 0x043f, /* CYRILLIC CAPITAL LETTER PE */ 0x041f],
    KeyH: [/* CYRILLIC SMALL LETTER ER */ 0x0440, /* CYRILLIC CAPITAL LETTER ER */ 0x0420],
    KeyJ: [/* CYRILLIC SMALL LETTER O */ 0x043e, /* CYRILLIC CAPITAL LETTER O */ 0x041e],
    KeyK: [/* CYRILLIC SMALL LETTER EL */ 0x043b, /* CYRILLIC CAPITAL LETTER EL */ 0x041b],
    KeyL: [/* CYRILLIC SMALL LETTER DE */ 0x0434, /* CYRILLIC CAPITAL LETTER DE */ 0x0414],
    Semicolon: [/* CYRILLIC SMALL LETTER ZHE */ 0x0436, /* CYRILLIC CAPITAL LETTER ZHE */ 0x0416],
    Quote: [/* CYRILLIC SMALL LETTER E */ 0x044d, /* CYRILLIC CAPITAL LETTER E */ 0x042d],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* SOLIDUS */ 0x002f],
    KeyZ: [/* CYRILLIC SMALL LETTER YA */ 0x044f, /* CYRILLIC CAPITAL LETTER YA */ 0x042f],
    KeyX: [/* CYRILLIC SMALL LETTER CHE */ 0x0447, /* CYRILLIC CAPITAL LETTER CHE */ 0x0427],
    KeyC: [/* CYRILLIC SMALL LETTER ES */ 0x0441, /* CYRILLIC CAPITAL LETTER ES */ 0x0421],
    KeyV: [/* CYRILLIC SMALL LETTER EM */ 0x043c, /* CYRILLIC CAPITAL LETTER EM */ 0x041c],
    KeyB: [/* CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */ 0x0456, /* CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */ 0x0406],
    KeyN: [/* CYRILLIC SMALL LETTER TE */ 0x0442, /* CYRILLIC CAPITAL LETTER TE */ 0x0422],
    KeyM: [/* CYRILLIC SMALL LETTER SOFT SIGN */ 0x044c, /* CYRILLIC CAPITAL LETTER SOFT SIGN */ 0x042c],
    Comma: [/* CYRILLIC SMALL LETTER BE */ 0x0431, /* CYRILLIC CAPITAL LETTER BE */ 0x0411],
    Period: [/* CYRILLIC SMALL LETTER YU */ 0x044e, /* CYRILLIC CAPITAL LETTER YU */ 0x042e],
    Slash: [/* FULL STOP */ 0x002e, /* COMMA */ 0x002c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/cs_cz.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_CS_CZ = {
    Backquote: [/* SEMICOLON */ 0x003b, { dead: /* COMBINING RING ABOVE */ 0x030a }],
    Digit1: [/* PLUS SIGN */ 0x002b, /* DIGIT ONE */ 0x0031, /* TILDE */ 0x007e],
    Digit2: [/* LATIN SMALL LETTER E WITH CARON */ 0x011b, /* DIGIT TWO */ 0x0032, { dead: /* COMBINING CARON */ 0x030c }],
    Digit3: [/* LATIN SMALL LETTER S WITH CARON */ 0x0161, /* DIGIT THREE */ 0x0033, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    Digit4: [/* LATIN SMALL LETTER C WITH CARON */ 0x010d, /* DIGIT FOUR */ 0x0034, { dead: /* COMBINING BREVE */ 0x0306 }],
    Digit5: [/* LATIN SMALL LETTER R WITH CARON */ 0x0159, /* DIGIT FIVE */ 0x0035, { dead: /* COMBINING RING ABOVE */ 0x030a }],
    Digit6: [/* LATIN SMALL LETTER Z WITH CARON */ 0x017e, /* DIGIT SIX */ 0x0036, { dead: /* COMBINING OGONEK */ 0x0328 }],
    Digit7: [/* LATIN SMALL LETTER Y WITH ACUTE */ 0x00fd, /* DIGIT SEVEN */ 0x0037, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    Digit8: [/* LATIN SMALL LETTER A WITH ACUTE */ 0x00e1, /* DIGIT EIGHT */ 0x0038, { dead: /* COMBINING DOT ABOVE */ 0x0307 }],
    Digit9: [/* LATIN SMALL LETTER I WITH ACUTE */ 0x00ed, /* DIGIT NINE */ 0x0039, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Digit0: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* DIGIT ZERO */ 0x0030, { dead: /* COMBINING DOUBLE ACUTE ACCENT */ 0x030b }],
    Minus: [/* EQUALS SIGN */ 0x003d, /* PERCENT SIGN */ 0x0025, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    Equal: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING CARON */ 0x030c }, { dead: /* COMBINING CEDILLA */ 0x0327 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* REVERSE SOLIDUS */ 0x005c],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* VERTICAL LINE */ 0x007c],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER U WITH ACUTE */ 0x00fa, /* SOLIDUS */ 0x002f, /* DIVISION SIGN */ 0x00f7],
    BracketRight: [/* RIGHT PARENTHESIS */ 0x0029, /* LEFT PARENTHESIS */ 0x0028, /* MULTIPLICATION SIGN */ 0x00d7],
    Backslash: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, /* APOSTROPHE */ 0x0027, /* CURRENCY SIGN */ 0x00a4],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER D WITH STROKE */ 0x0111],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* LATIN CAPITAL LETTER D WITH STROKE */ 0x0110],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* LATIN SMALL LETTER L WITH STROKE */ 0x0142],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* LATIN CAPITAL LETTER L WITH STROKE */ 0x0141],
    Semicolon: [/* LATIN SMALL LETTER U WITH RING ABOVE */ 0x016f, /* QUOTATION MARK */ 0x0022, /* DOLLAR SIGN */ 0x0024],
    Quote: [/* SECTION SIGN */ 0x00a7, /* EXCLAMATION MARK */ 0x0021, /* LATIN SMALL LETTER SHARP S */ 0x00df],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* NUMBER SIGN */ 0x0023],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* AMPERSAND */ 0x0026],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* COMMERCIAL AT */ 0x0040],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* LEFT CURLY BRACKET */ 0x007b],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* QUESTION MARK */ 0x003f, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* ASTERISK */ 0x002a],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_bone.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_BONE = {
    Backquote: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING CARON */ 0x030c }],
    Digit1: [/* DIGIT ONE */ 0x0031, /* DEGREE SIGN */ 0x00b0, /* SUPERSCRIPT ONE */ 0x00b9, /* SUBSCRIPT ONE */ 0x2081],
    Digit2: [/* DIGIT TWO */ 0x0032, /* SECTION SIGN */ 0x00a7, /* SUPERSCRIPT TWO */ 0x00b2, /* SUBSCRIPT TWO */ 0x2082],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SCRIPT SMALL L */ 0x2113, /* SUPERSCRIPT THREE */ 0x00b3, /* SUBSCRIPT THREE */ 0x2083],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb, /* SINGLE RIGHT-POINTING ANGLE QUOTATION MARK */ 0x203a, /* FEMALE SIGN */ 0x2640],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* SINGLE LEFT-POINTING ANGLE QUOTATION MARK */ 0x2039, /* MALE SIGN */ 0x2642],
    Digit6: [/* DIGIT SIX */ 0x0036, /* DOLLAR SIGN */ 0x0024, /* CENT SIGN */ 0x00a2, /* MALE AND FEMALE SIGN */ 0x26a5],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* EURO SIGN */ 0x20ac, /* YEN SIGN */ 0x00a5, /* GREEK KAPPA SYMBOL */ 0x03f0],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e, /* SINGLE LOW-9 QUOTATION MARK */ 0x201a, /* MATHEMATICAL LEFT ANGLE BRACKET */ 0x27e8],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT DOUBLE QUOTATION MARK */ 0x201c, /* LEFT SINGLE QUOTATION MARK */ 0x2018, /* MATHEMATICAL RIGHT ANGLE BRACKET */ 0x27e9],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d, /* RIGHT SINGLE QUOTATION MARK */ 0x2019, /* SUBSCRIPT ZERO */ 0x2080],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* EM DASH */ 0x2014, null, /* NON-BREAKING HYPHEN */ 0x2011],
    Equal: [{ dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING CEDILLA */ 0x0327 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    KeyQ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a, /* HORIZONTAL ELLIPSIS */ 0x2026, /* GREEK SMALL LETTER THETA */ 0x03b8],
    KeyW: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* LOW LINE */ 0x005f, /* GREEK SMALL LETTER DELTA */ 0x03b4],
    KeyE: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyR: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* RIGHT SQUARE BRACKET */ 0x005d, /* GREEK SMALL LETTER ALPHA */ 0x03b1],
    KeyT: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* CIRCUMFLEX ACCENT */ 0x005e, /* GREEK SMALL LETTER XI */ 0x03be],
    KeyY: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* EXCLAMATION MARK */ 0x0021, /* GREEK SMALL LETTER PI */ 0x03c0],
    KeyU: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048, /* LESS-THAN SIGN */ 0x003c, /* GREEK SMALL LETTER PSI */ 0x03c8],
    KeyI: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* GREATER-THAN SIGN */ 0x003e, /* GREEK SMALL LETTER LAMDA */ 0x03bb],
    KeyO: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* EQUALS SIGN */ 0x003d, /* GREEK SMALL LETTER MU */ 0x03bc],
    KeyP: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* AMPERSAND */ 0x0026, /* GREEK SMALL LETTER OMEGA */ 0x03c9],
    BracketLeft: [/* LATIN SMALL LETTER SHARP S */ 0x00df, /* LATIN CAPITAL LETTER SHARP S */ 0x1e9e, /* LATIN SMALL LETTER LONG S */ 0x017f, /* GREEK RHO SYMBOL */ 0x03f1],
    BracketRight: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyA: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* REVERSE SOLIDUS */ 0x005c, /* GREEK SMALL LETTER CHI */ 0x03c7],
    KeyS: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054, /* SOLIDUS */ 0x002f, /* GREEK SMALL LETTER TAU */ 0x03c4],
    KeyD: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* LEFT CURLY BRACKET */ 0x007b, /* GREEK SMALL LETTER IOTA */ 0x03b9],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* RIGHT CURLY BRACKET */ 0x007d, /* GREEK SMALL LETTER EPSILON */ 0x03b5],
    KeyG: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* ASTERISK */ 0x002a, /* GREEK SMALL LETTER GAMMA */ 0x03b3],
    KeyH: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* QUESTION MARK */ 0x003f, /* GREEK SMALL LETTER BETA */ 0x03b2],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* LEFT PARENTHESIS */ 0x0028, /* GREEK SMALL LETTER NU */ 0x03bd],
    KeyK: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052, /* RIGHT PARENTHESIS */ 0x0029, /* GREEK SMALL LETTER KAPPA */ 0x03ba],
    KeyL: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* HYPHEN-MINUS */ 0x002d, /* GREEK SMALL LETTER SIGMA */ 0x03c3],
    Semicolon: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, /* COLON */ 0x003a, /* GREEK SMALL LETTER GAMMA */ 0x03b3],
    Quote: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* COMMERCIAL AT */ 0x0040, /* GREEK PHI SYMBOL */ 0x03d5],
    KeyZ: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* NUMBER SIGN */ 0x0023],
    KeyX: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* DOLLAR SIGN */ 0x0024],
    KeyC: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc, /* VERTICAL LINE */ 0x007c],
    KeyV: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4, /* TILDE */ 0x007e, /* GREEK SMALL LETTER ETA */ 0x03b7],
    KeyB: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6, /* GRAVE ACCENT */ 0x0060, /* GREEK LUNATE EPSILON SYMBOL */ 0x03f5],
    KeyN: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, /* PLUS SIGN */ 0x002b, /* GREEK SMALL LETTER UPSILON */ 0x03c5],
    KeyM: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, /* PERCENT SIGN */ 0x0025, /* GREEK SMALL LETTER ZETA */ 0x03b6],
    Comma: [/* COMMA */ 0x002c, /* EN DASH */ 0x2013, /* QUOTATION MARK */ 0x0022, /* GREEK RHO SYMBOL */ 0x03f1],
    Period: [/* FULL STOP */ 0x002e, /* BULLET */ 0x2022, /* SEMICOLON */ 0x003b, /* GREEK THETA SYMBOL */ 0x03d1],
    Slash: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* SEMICOLON */ 0x003b, /* GREEK SMALL LETTER KAPPA */ 0x03ba],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_ch.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_CH = {
    Backquote: [/* SECTION SIGN */ 0x00a7, /* DEGREE SIGN */ 0x00b0],
    Digit1: [/* DIGIT ONE */ 0x0031, /* PLUS SIGN */ 0x002b, /* BROKEN BAR */ 0x00a6],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* ASTERISK */ 0x002a, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* DEGREE SIGN */ 0x00b0],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* SECTION SIGN */ 0x00a7],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, /* NOT SIGN */ 0x00ac],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* VERTICAL LINE */ 0x007c],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* CENT SIGN */ 0x00a2],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Equal: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* LEFT SQUARE BRACKET */ 0x005b],
    BracketRight: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, /* EXCLAMATION MARK */ 0x0021, /* RIGHT SQUARE BRACKET */ 0x005d],
    Backslash: [/* DOLLAR SIGN */ 0x0024, /* POUND SIGN */ 0x00a3, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9],
    Quote: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* LEFT CURLY BRACKET */ 0x007b],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* REVERSE SOLIDUS */ 0x005c],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_cmos.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_CMOS = {
    Backquote: [/* CIRCUMFLEX ACCENT */ 0x005e, /* CARON */ 0x02c7],
    Digit1: [/* DIGIT ONE */ 0x0031, /* DEGREE SIGN */ 0x00b0],
    Digit2: [/* DIGIT TWO */ 0x0032, /* SECTION SIGN */ 0x00a7],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SCRIPT SMALL L */ 0x2113],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    Digit6: [/* DIGIT SIX */ 0x0036, /* DOLLAR SIGN */ 0x0024],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* EURO SIGN */ 0x20ac],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* EM DASH */ 0x2014],
    Equal: [/* GRAVE ACCENT */ 0x0060, /* CEDILLA */ 0x00b8],
    KeyQ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyW: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyE: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyR: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyT: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    KeyY: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyU: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyI: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyO: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyP: [/* LATIN SMALL LETTER SHARP S */ 0x00df],
    BracketLeft: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    BracketRight: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyA: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyS: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyD: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyG: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyH: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyJ: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyK: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyL: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    Semicolon: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    Quote: [/* ACUTE ACCENT */ 0x00b4, /* SMALL TILDE */ 0x02dc],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyX: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    KeyC: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc],
    KeyV: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    KeyB: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    KeyN: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyM: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    Comma: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    Period: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Slash: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_de.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_DE = {
    Backquote: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* DEGREE SIGN */ 0x00b0],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SECTION SIGN */ 0x00a7, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* LEFT CURLY BRACKET */ 0x007b],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT SQUARE BRACKET */ 0x005d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* LATIN SMALL LETTER SHARP S */ 0x00df, /* QUESTION MARK */ 0x003f, /* REVERSE SOLIDUS */ 0x005c, /* LATIN CAPITAL LETTER SHARP S */ 0x1e9e],
    Equal: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* COMMERCIAL AT */ 0x0040],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc],
    BracketRight: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, /* TILDE */ 0x007e],
    Backslash: [/* NUMBER SIGN */ 0x0023, /* APOSTROPHE */ 0x0027],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    Quote: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* MICRO SIGN */ 0x00b5],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_mine.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_MINE = {
    Backquote: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING CARON */ 0x030c }],
    Digit1: [/* DIGIT ONE */ 0x0031, /* DEGREE SIGN */ 0x00b0],
    Digit2: [/* DIGIT TWO */ 0x0032, /* SECTION SIGN */ 0x00a7],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SCRIPT SMALL L */ 0x2113],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    Digit6: [/* DIGIT SIX */ 0x0036, /* DOLLAR SIGN */ 0x0024],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* EURO SIGN */ 0x20ac],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* EM DASH */ 0x2014],
    Equal: [{ dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING CEDILLA */ 0x0327 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    KeyQ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyR: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyT: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyY: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyU: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyI: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyO: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyP: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    BracketLeft: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    BracketRight: [/* LATIN SMALL LETTER SHARP S */ 0x00df, /* LATIN CAPITAL LETTER SHARP S */ 0x1e9e],
    Backslash: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyA: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyG: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyH: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyL: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    Semicolon: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyZ: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc],
    KeyV: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    KeyB: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    KeyN: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyM: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Comma: [/* COMMA */ 0x002c, /* EN DASH */ 0x2013],
    Period: [/* FULL STOP */ 0x002e, /* BULLET */ 0x2022],
    Slash: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_neo_2.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_NEO_2 = {
    Backquote: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING CARON */ 0x030c }],
    Digit1: [/* DIGIT ONE */ 0x0031, /* DEGREE SIGN */ 0x00b0],
    Digit2: [/* DIGIT TWO */ 0x0032, /* SECTION SIGN */ 0x00a7],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SCRIPT SMALL L */ 0x2113],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    Digit6: [/* DIGIT SIX */ 0x0036, /* DOLLAR SIGN */ 0x0024],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* EURO SIGN */ 0x20ac],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* EM DASH */ 0x2014],
    Equal: [{ dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING CEDILLA */ 0x0327 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    KeyQ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyW: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyE: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyR: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyT: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyY: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyU: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyI: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyO: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyP: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    BracketLeft: [/* LATIN SMALL LETTER SHARP S */ 0x00df, /* LATIN CAPITAL LETTER SHARP S */ 0x1e9e],
    BracketRight: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyA: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyS: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyD: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyG: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyH: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyL: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    Semicolon: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    Quote: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyZ: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc],
    KeyX: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    KeyC: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    KeyV: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyB: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* EN DASH */ 0x2013],
    Period: [/* FULL STOP */ 0x002e, /* BULLET */ 0x2022],
    Slash: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/de_noted.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_DE_NOTED = {
    Backquote: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING CARON */ 0x030c }],
    Digit1: [/* DIGIT ONE */ 0x0031, /* DEGREE SIGN */ 0x00b0],
    Digit2: [/* DIGIT TWO */ 0x0032, /* SECTION SIGN */ 0x00a7],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SCRIPT SMALL L */ 0x2113],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    Digit6: [/* DIGIT SIX */ 0x0036, /* DOLLAR SIGN */ 0x0024],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* EURO SIGN */ 0x20ac],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* EM DASH */ 0x2014],
    Equal: [{ dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING CEDILLA */ 0x0327 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    KeyQ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyW: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyE: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyR: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyT: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyY: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyU: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyI: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyO: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyP: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    BracketLeft: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    BracketRight: [/* LATIN SMALL LETTER SHARP S */ 0x00df, /* LATIN CAPITAL LETTER SHARP S */ 0x1e9e],
    Backslash: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyA: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyG: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyH: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyJ: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyK: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyL: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    Semicolon: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyZ: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc],
    KeyV: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    KeyB: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    KeyN: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyM: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    Comma: [/* COMMA */ 0x002c, /* EN DASH */ 0x2013],
    Period: [/* FULL STOP */ 0x002e, /* BULLET */ 0x2022],
    Slash: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/el_gr.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EL_GR = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* POUND SIGN */ 0x00a3],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* SECTION SIGN */ 0x00a7],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, /* PILCROW SIGN */ 0x00b6],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* CURRENCY SIGN */ 0x00a4],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028, /* BROKEN BAR */ 0x00a6],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029, /* DEGREE SIGN */ 0x00b0],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* PLUS-MINUS SIGN */ 0x00b1],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    KeyQ: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyW: [/* GREEK SMALL LETTER FINAL SIGMA */ 0x03c2],
    KeyE: [/* GREEK SMALL LETTER EPSILON */ 0x03b5, /* GREEK CAPITAL LETTER EPSILON */ 0x0395, /* EURO SIGN */ 0x20ac],
    KeyR: [/* GREEK SMALL LETTER RHO */ 0x03c1, /* GREEK CAPITAL LETTER RHO */ 0x03a1, /* REGISTERED SIGN */ 0x00ae],
    KeyT: [/* GREEK SMALL LETTER TAU */ 0x03c4, /* GREEK CAPITAL LETTER TAU */ 0x03a4],
    KeyY: [/* GREEK SMALL LETTER UPSILON */ 0x03c5, /* GREEK CAPITAL LETTER UPSILON */ 0x03a5, /* YEN SIGN */ 0x00a5],
    KeyU: [/* GREEK SMALL LETTER THETA */ 0x03b8, /* GREEK CAPITAL LETTER THETA */ 0x0398],
    KeyI: [/* GREEK SMALL LETTER IOTA */ 0x03b9, /* GREEK CAPITAL LETTER IOTA */ 0x0399],
    KeyO: [/* GREEK SMALL LETTER OMICRON */ 0x03bf, /* GREEK CAPITAL LETTER OMICRON */ 0x039f],
    KeyP: [/* GREEK SMALL LETTER PI */ 0x03c0, /* GREEK CAPITAL LETTER PI */ 0x03a0],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c, /* NOT SIGN */ 0x00ac],
    KeyA: [/* GREEK SMALL LETTER ALPHA */ 0x03b1, /* GREEK CAPITAL LETTER ALPHA */ 0x0391],
    KeyS: [/* GREEK SMALL LETTER SIGMA */ 0x03c3, /* GREEK CAPITAL LETTER SIGMA */ 0x03a3],
    KeyD: [/* GREEK SMALL LETTER DELTA */ 0x03b4, /* GREEK CAPITAL LETTER DELTA */ 0x0394],
    KeyF: [/* GREEK SMALL LETTER PHI */ 0x03c6, /* GREEK CAPITAL LETTER PHI */ 0x03a6],
    KeyG: [/* GREEK SMALL LETTER GAMMA */ 0x03b3, /* GREEK CAPITAL LETTER GAMMA */ 0x0393],
    KeyH: [/* GREEK SMALL LETTER ETA */ 0x03b7, /* GREEK CAPITAL LETTER ETA */ 0x0397],
    KeyJ: [/* GREEK SMALL LETTER XI */ 0x03be, /* GREEK CAPITAL LETTER XI */ 0x039e],
    KeyK: [/* GREEK SMALL LETTER KAPPA */ 0x03ba, /* GREEK CAPITAL LETTER KAPPA */ 0x039a],
    KeyL: [/* GREEK SMALL LETTER LAMDA */ 0x03bb, /* GREEK CAPITAL LETTER LAMDA */ 0x039b],
    Semicolon: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* GREEK SMALL LETTER ZETA */ 0x03b6, /* GREEK CAPITAL LETTER ZETA */ 0x0396],
    KeyX: [/* GREEK SMALL LETTER CHI */ 0x03c7, /* GREEK CAPITAL LETTER CHI */ 0x03a7],
    KeyC: [/* GREEK SMALL LETTER PSI */ 0x03c8, /* GREEK CAPITAL LETTER PSI */ 0x03a8, /* COPYRIGHT SIGN */ 0x00a9],
    KeyV: [/* GREEK SMALL LETTER OMEGA */ 0x03c9, /* GREEK CAPITAL LETTER OMEGA */ 0x03a9],
    KeyB: [/* GREEK SMALL LETTER BETA */ 0x03b2, /* GREEK CAPITAL LETTER BETA */ 0x0392],
    KeyN: [/* GREEK SMALL LETTER NU */ 0x03bd, /* GREEK CAPITAL LETTER NU */ 0x039d],
    KeyM: [/* GREEK SMALL LETTER MU */ 0x03bc, /* GREEK CAPITAL LETTER MU */ 0x039c],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_canary.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_CANARY = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyH: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyX: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyC: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyV: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyB: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyN: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Comma: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Period: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_canary_matrix.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_CANARY_MATRIX = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    Quote: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyX: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyC: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyV: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyB: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyN: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Comma: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Period: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_colemak.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_COLEMAK = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyI: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyO: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_colemak_dh_ansi.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_COLEMAK_DH_ANSI = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyI: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyO: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyC: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_colemak_dh_ansi_wide.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_COLEMAK_DH_ANSI_WIDE = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    Digit8: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit9: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit0: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Minus: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Equal: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    KeyU: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyI: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    BracketLeft: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketRight: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyJ: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyK: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyL: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    IntlBackslash: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyC: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyN: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    KeyM: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Comma: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Period: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_colemak_dh_iso.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_COLEMAK_DH_ISO = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* NOT SIGN */ 0x00ac],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyI: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyO: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* NUMBER SIGN */ 0x0023, /* TILDE */ 0x007e],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Quote: [/* APOSTROPHE */ 0x0027, /* COMMERCIAL AT */ 0x0040],
    IntlBackslash: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyC: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_colemak_dh_iso_wide.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_COLEMAK_DH_ISO_WIDE = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* NOT SIGN */ 0x00ac],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    Digit8: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit9: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit0: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Minus: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Equal: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    KeyU: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyI: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    BracketLeft: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketRight: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Backslash: [/* APOSTROPHE */ 0x0027, /* COMMERCIAL AT */ 0x0040],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyJ: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyK: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyL: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    IntlBackslash: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyC: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyN: [/* NUMBER SIGN */ 0x0023, /* TILDE */ 0x007e],
    KeyM: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Comma: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Period: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_colemak_dh_matrix.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_COLEMAK_DH_MATRIX = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyI: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyO: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyB: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_dvorak.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_DVORAK = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    Equal: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyQ: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    KeyW: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    KeyE: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyY: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyU: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyI: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyO: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyP: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    BracketLeft: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    BracketRight: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyF: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyG: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyH: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyL: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    Semicolon: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    Quote: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyX: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyC: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyV: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyB: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    Period: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    Slash: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_dvorak_prog.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_DVORAK_PROG = {
    Backquote: [/* DOLLAR SIGN */ 0x0024, /* TILDE */ 0x007e],
    Digit1: [/* AMPERSAND */ 0x0026, /* PERCENT SIGN */ 0x0025],
    Digit2: [/* LEFT SQUARE BRACKET */ 0x005b, /* DIGIT SEVEN */ 0x0037],
    Digit3: [/* LEFT CURLY BRACKET */ 0x007b, /* DIGIT FIVE */ 0x0035],
    Digit4: [/* RIGHT CURLY BRACKET */ 0x007d, /* DIGIT THREE */ 0x0033],
    Digit5: [/* LEFT PARENTHESIS */ 0x0028, /* DIGIT ONE */ 0x0031],
    Digit6: [/* EQUALS SIGN */ 0x003d, /* DIGIT NINE */ 0x0039],
    Digit7: [/* ASTERISK */ 0x002a, /* DIGIT ZERO */ 0x0030],
    Digit8: [/* RIGHT PARENTHESIS */ 0x0029, /* DIGIT TWO */ 0x0032],
    Digit9: [/* PLUS SIGN */ 0x002b, /* DIGIT FOUR */ 0x0034],
    Digit0: [/* RIGHT SQUARE BRACKET */ 0x005d, /* DIGIT SIX */ 0x0036],
    Minus: [/* EXCLAMATION MARK */ 0x0021, /* DIGIT EIGHT */ 0x0038],
    Equal: [/* NUMBER SIGN */ 0x0023, /* GRAVE ACCENT */ 0x0060],
    KeyQ: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyW: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    KeyE: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyY: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyU: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyI: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyO: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyP: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    BracketLeft: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    BracketRight: [/* COMMERCIAL AT */ 0x0040, /* CIRCUMFLEX ACCENT */ 0x005e],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyF: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyG: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyH: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyL: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    Semicolon: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    Quote: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    KeyX: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyC: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyV: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyB: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    Period: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    Slash: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_engram.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_ENGRAM = {
    Backquote: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    Digit1: [/* DIGIT ONE */ 0x0031, /* VERTICAL LINE */ 0x007c],
    Digit2: [/* DIGIT TWO */ 0x0032, /* EQUALS SIGN */ 0x003d],
    Digit3: [/* DIGIT THREE */ 0x0033, /* TILDE */ 0x007e],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* PLUS SIGN */ 0x002b],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* LESS-THAN SIGN */ 0x003c],
    Digit6: [/* DIGIT SIX */ 0x0036, /* GREATER-THAN SIGN */ 0x003e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* AMPERSAND */ 0x0026],
    Digit9: [/* DIGIT NINE */ 0x0039, /* PERCENT SIGN */ 0x0025],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* ASTERISK */ 0x002a],
    Minus: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Equal: [/* SOLIDUS */ 0x002f, /* REVERSE SOLIDUS */ 0x005c],
    KeyQ: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyW: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyE: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyR: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyT: [/* APOSTROPHE */ 0x0027, /* LEFT PARENTHESIS */ 0x0028],
    KeyY: [/* QUOTATION MARK */ 0x0022, /* RIGHT PARENTHESIS */ 0x0029],
    KeyU: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyI: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyO: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyP: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    BracketLeft: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    BracketRight: [/* NUMBER SIGN */ 0x0023, /* DOLLAR SIGN */ 0x0024],
    Backslash: [/* COMMERCIAL AT */ 0x0040, /* GRAVE ACCENT */ 0x0060],
    KeyA: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyS: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyF: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyG: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    KeyH: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyL: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    Semicolon: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    Quote: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyV: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyB: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyN: [/* QUESTION MARK */ 0x003f, /* EXCLAMATION MARK */ 0x0021],
    KeyM: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    Comma: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Period: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Slash: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_gallium.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_GALLIUM = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyT: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyL: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyC: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyV: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyB: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    Comma: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    Period: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_gallium_matrix.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_GALLIUM_MATRIX = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyT: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyL: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyC: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyV: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyB: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Comma: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    Period: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_graphite.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_GRAPHITE = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    Equal: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyQ: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyT: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyY: [/* APOSTROPHE */ 0x0027, /* LOW LINE */ 0x005f],
    KeyU: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    BracketLeft: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketRight: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyL: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* COMMA */ 0x002c, /* QUESTION MARK */ 0x003f],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyV: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyB: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    Comma: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Period: [/* HYPHEN-MINUS */ 0x002d, /* QUOTATION MARK */ 0x0022],
    Slash: [/* SOLIDUS */ 0x002f, /* LESS-THAN SIGN */ 0x003c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_halmak.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_HALMAK = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LESS-THAN SIGN */ 0x003c],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* GREATER-THAN SIGN */ 0x003e],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyR: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyT: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyY: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyU: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyI: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyO: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyP: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyS: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyD: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* COMMA */ 0x002c, /* LEFT PARENTHESIS */ 0x0028],
    KeyH: [/* FULL STOP */ 0x002e, /* RIGHT PARENTHESIS */ 0x0029],
    KeyJ: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyX: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyC: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyV: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyB: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    KeyN: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyM: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    Comma: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    Period: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Slash: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_hands_down_neu.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_HANDS_DOWN_NEU = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Equal: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    KeyQ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyW: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyE: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyY: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    KeyU: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    KeyI: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyO: [/* QUOTATION MARK */ 0x0022],
    KeyP: [/* APOSTROPHE */ 0x0027],
    BracketLeft: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Backslash: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyA: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyH: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    KeyJ: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Quote: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    IntlBackslash: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyC: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyV: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyB: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyN: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyM: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    Comma: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Period: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    Slash: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_hands_down_promethium.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_HANDS_DOWN_PROMETHIUM = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Equal: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    KeyQ: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyW: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyT: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyY: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyP: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    BracketLeft: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Backslash: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyA: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyS: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyG: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyH: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    KeyJ: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    Quote: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    IntlBackslash: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyZ: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyX: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyC: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyV: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyB: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyN: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyM: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Comma: [/* APOSTROPHE */ 0x0027],
    Period: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_nerps.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_NERPS = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    Quote: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyX: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyB: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Comma: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    Period: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_nerps_matrix.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_NERPS_MATRIX = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyW: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyT: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyG: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyH: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyJ: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Semicolon: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    Quote: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyX: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyC: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyV: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyB: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Comma: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    Period: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_norman.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_NORMAN = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyT: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyO: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyL: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Semicolon: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_sturdy.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_STURDY = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Equal: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    KeyQ: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyW: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyE: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyR: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyT: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyY: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyU: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyP: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    BracketLeft: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Backslash: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    KeyA: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyS: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyD: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyF: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyG: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyH: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyL: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* APOSTROPHE */ 0x0027],
    IntlBackslash: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyC: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyV: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyB: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Comma: [/* APOSTROPHE */ 0x0027],
    Period: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Slash: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_uk.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_UK = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* NOT SIGN */ 0x00ac, /* BROKEN BAR */ 0x00a6],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* EURO SIGN */ 0x20ac],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LATIN CAPITAL LETTER E WITH ACUTE */ 0x00c9],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* LATIN SMALL LETTER U WITH ACUTE */ 0x00fa, /* LATIN CAPITAL LETTER U WITH ACUTE */ 0x00da],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* LATIN SMALL LETTER I WITH ACUTE */ 0x00ed, /* LATIN CAPITAL LETTER I WITH ACUTE */ 0x00cd],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* LATIN SMALL LETTER O WITH ACUTE */ 0x00f3, /* LATIN CAPITAL LETTER O WITH ACUTE */ 0x00d3],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* NUMBER SIGN */ 0x0023, /* TILDE */ 0x007e, /* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER A WITH ACUTE */ 0x00e1, /* LATIN CAPITAL LETTER A WITH ACUTE */ 0x00c1],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Quote: [/* APOSTROPHE */ 0x0027, /* COMMERCIAL AT */ 0x0040],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_us.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_US = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/en_workman.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_EN_WORKMAN = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyE: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyR: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyU: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyI: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyO: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyP: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyF: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyJ: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    Semicolon: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyV: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyB: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyN: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyM: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/es_es.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_ES_ES = {
    Backquote: [/* MASCULINE ORDINAL INDICATOR */ 0x00ba, /* FEMININE ORDINAL INDICATOR */ 0x00aa, /* REVERSE SOLIDUS */ 0x005c],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* VERTICAL LINE */ 0x007c],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* MIDDLE DOT */ 0x00b7, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, { dead: /* COMBINING TILDE */ 0x0303 }],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* EURO SIGN */ 0x20ac],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, /* NOT SIGN */ 0x00ac],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f],
    Equal: [/* INVERTED EXCLAMATION MARK */ 0x00a1, /* INVERTED QUESTION MARK */ 0x00bf],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [{ dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* LEFT SQUARE BRACKET */ 0x005b],
    BracketRight: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, /* RIGHT SQUARE BRACKET */ 0x005d],
    Backslash: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER N WITH TILDE */ 0x00f1, /* LATIN CAPITAL LETTER N WITH TILDE */ 0x00d1],
    Quote: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }, /* LEFT CURLY BRACKET */ 0x007b],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/es_mx.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_ES_MX = {
    Backquote: [/* VERTICAL LINE */ 0x007c, /* DEGREE SIGN */ 0x00b0, /* NOT SIGN */ 0x00ac],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f, /* REVERSE SOLIDUS */ 0x005c],
    Equal: [/* INVERTED QUESTION MARK */ 0x00bf, /* INVERTED EXCLAMATION MARK */ 0x00a1],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* COMMERCIAL AT */ 0x0040],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    BracketRight: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, /* TILDE */ 0x007e],
    Backslash: [/* RIGHT CURLY BRACKET */ 0x007d, /* RIGHT SQUARE BRACKET */ 0x005d, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER N WITH TILDE */ 0x00f1, /* LATIN CAPITAL LETTER N WITH TILDE */ 0x00d1],
    Quote: [/* LEFT CURLY BRACKET */ 0x007b, /* LEFT SQUARE BRACKET */ 0x005b, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fa_ir.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FA_IR = {
    Backquote: [{ special: /* ZERO WIDTH JOINER */ 0x200d }, { special: /* ZERO WIDTH JOINER */ 0x200d }],
    Digit1: [/* EXTENDED ARABIC-INDIC DIGIT ONE */ 0x06f1, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* EXTENDED ARABIC-INDIC DIGIT TWO */ 0x06f2, /* ARABIC THOUSANDS SEPARATOR */ 0x066c],
    Digit3: [/* EXTENDED ARABIC-INDIC DIGIT THREE */ 0x06f3, /* ARABIC DECIMAL SEPARATOR */ 0x066b],
    Digit4: [/* EXTENDED ARABIC-INDIC DIGIT FOUR */ 0x06f4, { ligature: "" }],
    Digit5: [/* EXTENDED ARABIC-INDIC DIGIT FIVE */ 0x06f5, /* ARABIC PERCENT SIGN */ 0x066a],
    Digit6: [/* EXTENDED ARABIC-INDIC DIGIT SIX */ 0x06f6, /* MULTIPLICATION SIGN */ 0x00d7],
    Digit7: [/* EXTENDED ARABIC-INDIC DIGIT SEVEN */ 0x06f7, /* ARABIC COMMA */ 0x060c],
    Digit8: [/* EXTENDED ARABIC-INDIC DIGIT EIGHT */ 0x06f8, /* ASTERISK */ 0x002a],
    Digit9: [/* EXTENDED ARABIC-INDIC DIGIT NINE */ 0x06f9, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* EXTENDED ARABIC-INDIC DIGIT ZERO */ 0x06f0, /* LEFT PARENTHESIS */ 0x0028],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* ARABIC TATWEEL */ 0x0640],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* ARABIC LETTER DAD */ 0x0636, /* ARABIC SUKUN */ 0x0652],
    KeyW: [/* ARABIC LETTER SAD */ 0x0635, /* ARABIC DAMMATAN */ 0x064c],
    KeyE: [/* ARABIC LETTER THEH */ 0x062b, /* ARABIC KASRATAN */ 0x064d],
    KeyR: [/* ARABIC LETTER QAF */ 0x0642, /* ARABIC FATHATAN */ 0x064b],
    KeyT: [/* ARABIC LETTER FEH */ 0x0641, /* ARABIC DAMMA */ 0x064f],
    KeyY: [/* ARABIC LETTER GHAIN */ 0x063a, /* ARABIC KASRA */ 0x0650],
    KeyU: [/* ARABIC LETTER AIN */ 0x0639, /* ARABIC FATHA */ 0x064e],
    KeyI: [/* ARABIC LETTER HEH */ 0x0647, /* ARABIC SHADDA */ 0x0651],
    KeyO: [/* ARABIC LETTER KHAH */ 0x062e, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyP: [/* ARABIC LETTER HAH */ 0x062d, /* LEFT SQUARE BRACKET */ 0x005b],
    BracketLeft: [/* ARABIC LETTER JEEM */ 0x062c, /* RIGHT CURLY BRACKET */ 0x007d],
    BracketRight: [/* ARABIC LETTER TCHEH */ 0x0686, /* LEFT CURLY BRACKET */ 0x007b],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* ARABIC LETTER SHEEN */ 0x0634, /* ARABIC LETTER WAW WITH HAMZA ABOVE */ 0x0624],
    KeyS: [/* ARABIC LETTER SEEN */ 0x0633, /* ARABIC LETTER YEH WITH HAMZA ABOVE */ 0x0626],
    KeyD: [/* ARABIC LETTER FARSI YEH */ 0x06cc, /* ARABIC LETTER YEH */ 0x064a],
    KeyF: [/* ARABIC LETTER BEH */ 0x0628, /* ARABIC LETTER ALEF WITH HAMZA BELOW */ 0x0625],
    KeyG: [/* ARABIC LETTER LAM */ 0x0644, /* ARABIC LETTER ALEF WITH HAMZA ABOVE */ 0x0623],
    KeyH: [/* ARABIC LETTER ALEF */ 0x0627, /* ARABIC LETTER ALEF WITH MADDA ABOVE */ 0x0622],
    KeyJ: [/* ARABIC LETTER TEH */ 0x062a, /* ARABIC LETTER TEH MARBUTA */ 0x0629],
    KeyK: [/* ARABIC LETTER NOON */ 0x0646, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    KeyL: [/* ARABIC LETTER MEEM */ 0x0645, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    Semicolon: [/* ARABIC LETTER KEHEH */ 0x06a9, /* COLON */ 0x003a],
    Quote: [/* ARABIC LETTER GAF */ 0x06af, /* ARABIC SEMICOLON */ 0x061b],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* ARABIC LETTER ZAH */ 0x0638, /* ARABIC LETTER KAF */ 0x0643],
    KeyX: [/* ARABIC LETTER TAH */ 0x0637, /* ARABIC LETTER TAH */ 0x0637],
    KeyC: [/* ARABIC LETTER ZAIN */ 0x0632, /* ARABIC LETTER JEH */ 0x0698],
    KeyV: [/* ARABIC LETTER REH */ 0x0631, /* ARABIC LETTER SUPERSCRIPT ALEF */ 0x0670],
    KeyB: [/* ARABIC LETTER THAL */ 0x0630, { special: /* ZERO WIDTH NON-JOINER */ 0x200c }],
    KeyN: [/* ARABIC LETTER DAL */ 0x062f, /* ARABIC HAMZA ABOVE */ 0x0654],
    KeyM: [/* ARABIC LETTER PEH */ 0x067e, /* ARABIC LETTER HAMZA */ 0x0621],
    Comma: [/* ARABIC LETTER WAW */ 0x0648, /* GREATER-THAN SIGN */ 0x003e],
    Period: [/* FULL STOP */ 0x002e, /* LESS-THAN SIGN */ 0x003c],
    Slash: [/* SOLIDUS */ 0x002f, /* ARABIC QUESTION MARK */ 0x061f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fa_ir_legacy.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FA_IR_LEGACY = {
    Backquote: [/* DIVISION SIGN */ 0x00f7, /* MULTIPLICATION SIGN */ 0x00d7],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* LEFT PARENTHESIS */ 0x0028],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* ARABIC LETTER DAD */ 0x0636, /* ARABIC FATHATAN */ 0x064b],
    KeyW: [/* ARABIC LETTER SAD */ 0x0635, /* ARABIC DAMMATAN */ 0x064c],
    KeyE: [/* ARABIC LETTER THEH */ 0x062b, /* ARABIC KASRATAN */ 0x064d],
    KeyR: [/* ARABIC LETTER QAF */ 0x0642, { ligature: "" }],
    KeyT: [/* ARABIC LETTER FEH */ 0x0641, /* ARABIC COMMA */ 0x060c],
    KeyY: [/* ARABIC LETTER GHAIN */ 0x063a, /* ARABIC SEMICOLON */ 0x061b],
    KeyU: [/* ARABIC LETTER AIN */ 0x0639, /* COMMA */ 0x002c],
    KeyI: [/* ARABIC LETTER HEH */ 0x0647, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyO: [/* ARABIC LETTER KHAH */ 0x062e, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyP: [/* ARABIC LETTER HAH */ 0x062d, /* REVERSE SOLIDUS */ 0x005c],
    BracketLeft: [/* ARABIC LETTER JEEM */ 0x062c, /* RIGHT CURLY BRACKET */ 0x007d],
    BracketRight: [/* ARABIC LETTER TCHEH */ 0x0686, /* LEFT CURLY BRACKET */ 0x007b],
    Backslash: [/* ARABIC LETTER PEH */ 0x067e, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* ARABIC LETTER SHEEN */ 0x0634, /* ARABIC FATHA */ 0x064e],
    KeyS: [/* ARABIC LETTER SEEN */ 0x0633, /* ARABIC DAMMA */ 0x064f],
    KeyD: [/* ARABIC LETTER FARSI YEH */ 0x06cc, /* ARABIC KASRA */ 0x0650],
    KeyF: [/* ARABIC LETTER BEH */ 0x0628, /* ARABIC SHADDA */ 0x0651],
    KeyG: [/* ARABIC LETTER LAM */ 0x0644, /* ARABIC LETTER HEH WITH YEH ABOVE */ 0x06c0],
    KeyH: [/* ARABIC LETTER ALEF */ 0x0627, /* ARABIC LETTER ALEF WITH MADDA ABOVE */ 0x0622],
    KeyJ: [/* ARABIC LETTER TEH */ 0x062a, /* ARABIC TATWEEL */ 0x0640],
    KeyK: [/* ARABIC LETTER NOON */ 0x0646, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    KeyL: [/* ARABIC LETTER MEEM */ 0x0645, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Semicolon: [/* ARABIC LETTER KEHEH */ 0x06a9, /* COLON */ 0x003a],
    Quote: [/* ARABIC LETTER GAF */ 0x06af, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* ARABIC LETTER PEH */ 0x067e, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* ARABIC LETTER ZAH */ 0x0638, /* ARABIC LETTER TEH MARBUTA */ 0x0629],
    KeyX: [/* ARABIC LETTER TAH */ 0x0637, /* ARABIC LETTER YEH */ 0x064a],
    KeyC: [/* ARABIC LETTER ZAIN */ 0x0632, /* ARABIC LETTER JEH */ 0x0698],
    KeyV: [/* ARABIC LETTER REH */ 0x0631, /* ARABIC LETTER WAW WITH HAMZA ABOVE */ 0x0624],
    KeyB: [/* ARABIC LETTER THAL */ 0x0630, /* ARABIC LETTER ALEF WITH HAMZA BELOW */ 0x0625],
    KeyN: [/* ARABIC LETTER DAL */ 0x062f, /* ARABIC LETTER ALEF WITH HAMZA ABOVE */ 0x0623],
    KeyM: [/* ARABIC LETTER YEH WITH HAMZA ABOVE */ 0x0626, /* ARABIC LETTER HAMZA */ 0x0621],
    Comma: [/* ARABIC LETTER WAW */ 0x0648, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* ARABIC QUESTION MARK */ 0x061f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_bepo.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_BEPO = {
    Backquote: [/* DOLLAR SIGN */ 0x0024, /* NUMBER SIGN */ 0x0023, /* EN DASH */ 0x2013],
    Digit1: [/* QUOTATION MARK */ 0x0022, /* DIGIT ONE */ 0x0031, /* EM DASH */ 0x2014, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e],
    Digit2: [/* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* DIGIT TWO */ 0x0032, /* LESS-THAN SIGN */ 0x003c, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Digit3: [/* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb, /* DIGIT THREE */ 0x0033, /* GREATER-THAN SIGN */ 0x003e, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Digit4: [/* LEFT PARENTHESIS */ 0x0028, /* DIGIT FOUR */ 0x0034, /* LEFT SQUARE BRACKET */ 0x005b, /* LESS-THAN OR EQUAL TO */ 0x2264],
    Digit5: [/* RIGHT PARENTHESIS */ 0x0029, /* DIGIT FIVE */ 0x0035, /* RIGHT SQUARE BRACKET */ 0x005d, /* GREATER-THAN OR EQUAL TO */ 0x2265],
    Digit6: [/* COMMERCIAL AT */ 0x0040, /* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* PLUS SIGN */ 0x002b, /* DIGIT SEVEN */ 0x0037, /* PLUS-MINUS SIGN */ 0x00b1, /* NOT SIGN */ 0x00ac],
    Digit8: [/* HYPHEN-MINUS */ 0x002d, /* DIGIT EIGHT */ 0x0038, /* MINUS SIGN */ 0x2212, /* VULGAR FRACTION ONE QUARTER */ 0x00bc],
    Digit9: [/* SOLIDUS */ 0x002f, /* DIGIT NINE */ 0x0039, /* DIVISION SIGN */ 0x00f7, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Digit0: [/* ASTERISK */ 0x002a, /* DIGIT ZERO */ 0x0030, /* MULTIPLICATION SIGN */ 0x00d7, /* VULGAR FRACTION THREE QUARTERS */ 0x00be],
    Minus: [/* EQUALS SIGN */ 0x003d, /* DEGREE SIGN */ 0x00b0, /* NOT EQUAL TO */ 0x2260],
    Equal: [/* PERCENT SIGN */ 0x0025, /* GRAVE ACCENT */ 0x0060, /* PER MILLE SIGN */ 0x2030],
    KeyQ: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* VERTICAL LINE */ 0x007c, /* BROKEN BAR */ 0x00a6],
    KeyW: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LATIN CAPITAL LETTER E WITH ACUTE */ 0x00c9, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    KeyE: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* AMPERSAND */ 0x0026, /* SECTION SIGN */ 0x00a7],
    KeyR: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* LATIN SMALL LIGATURE OE */ 0x0153, /* LATIN CAPITAL LIGATURE OE */ 0x0152],
    KeyT: [/* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* LATIN CAPITAL LETTER E WITH GRAVE */ 0x00c8, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyY: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* EXCLAMATION MARK */ 0x0021, /* INVERTED EXCLAMATION MARK */ 0x00a1],
    KeyU: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyI: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyO: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyP: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    BracketLeft: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    BracketRight: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    Backslash: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    KeyS: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* LATIN SMALL LETTER U WITH GRAVE */ 0x00f9, /* LATIN CAPITAL LETTER U WITH GRAVE */ 0x00d9],
    KeyD: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyG: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    KeyH: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyJ: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyK: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER SHARP S */ 0x00df, /* LATIN CAPITAL LETTER SHARP S */ 0x1e9e],
    KeyL: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    Semicolon: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, { dead: /* COMBINING TILDE */ 0x0303 }],
    Quote: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    IntlBackslash: [/* LATIN SMALL LETTER E WITH CIRCUMFLEX */ 0x00ea, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX */ 0x00ca, /* SOLIDUS */ 0x002f],
    KeyZ: [/* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* LATIN CAPITAL LETTER A WITH GRAVE */ 0x00c0, /* REVERSE SOLIDUS */ 0x005c],
    KeyX: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, /* LEFT CURLY BRACKET */ 0x007b],
    KeyC: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyV: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* HORIZONTAL ELLIPSIS */ 0x2026, /* MIDDLE DOT */ 0x00b7],
    KeyB: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* TILDE */ 0x007e],
    KeyN: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f, /* INVERTED QUESTION MARK */ 0x00bf],
    KeyM: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    Comma: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    Period: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    Slash: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_ca.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_CA = {
    Backquote: [/* NUMBER SIGN */ 0x0023, /* VERTICAL LINE */ 0x007c, /* REVERSE SOLIDUS */ 0x005c],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* PLUS-MINUS SIGN */ 0x00b1],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* SOLIDUS */ 0x002f, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* CENT SIGN */ 0x00a2],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* CURRENCY SIGN */ 0x00a4],
    Digit6: [/* DIGIT SIX */ 0x0036, /* QUESTION MARK */ 0x003f, /* NOT SIGN */ 0x00ac],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, /* BROKEN BAR */ 0x00a6],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029, /* VULGAR FRACTION ONE QUARTER */ 0x00bc],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* VULGAR FRACTION THREE QUARTERS */ 0x00be],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* SECTION SIGN */ 0x00a7],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* PILCROW SIGN */ 0x00b6],
    BracketLeft: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* LEFT SQUARE BRACKET */ 0x005b],
    BracketRight: [{ dead: /* COMBINING CEDILLA */ 0x0327 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }, /* RIGHT SQUARE BRACKET */ 0x005d],
    Backslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a, /* TILDE */ 0x007e],
    Quote: [{ dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, /* LEFT CURLY BRACKET */ 0x007b],
    IntlBackslash: [/* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb, /* DEGREE SIGN */ 0x00b0],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* MICRO SIGN */ 0x00b5],
    Comma: [/* COMMA */ 0x002c, /* APOSTROPHE */ 0x0027, /* MACRON */ 0x00af],
    Period: [/* FULL STOP */ 0x002e, /* FULL STOP */ 0x002e, /* SOFT HYPHEN */ 0x00ad],
    Slash: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LATIN CAPITAL LETTER E WITH ACUTE */ 0x00c9, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_ch.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_CH = {
    Backquote: [/* SECTION SIGN */ 0x00a7, /* DEGREE SIGN */ 0x00b0],
    Digit1: [/* DIGIT ONE */ 0x0031, /* PLUS SIGN */ 0x002b, /* BROKEN BAR */ 0x00a6],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* ASTERISK */ 0x002a, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* DEGREE SIGN */ 0x00b0],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* SECTION SIGN */ 0x00a7],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, /* NOT SIGN */ 0x00ac],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* VERTICAL LINE */ 0x007c],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* CENT SIGN */ 0x00a2],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Equal: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LEFT SQUARE BRACKET */ 0x005b],
    BracketRight: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, /* EXCLAMATION MARK */ 0x0021, /* RIGHT SQUARE BRACKET */ 0x005d],
    Backslash: [/* DOLLAR SIGN */ 0x0024, /* POUND SIGN */ 0x00a3, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6],
    Quote: [/* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LEFT CURLY BRACKET */ 0x007b],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* REVERSE SOLIDUS */ 0x005c],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_erglace.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_ERGLACE = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* SUBSCRIPT ONE */ 0x2081, /* SUPERSCRIPT ONE */ 0x00b9],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040, /* SUBSCRIPT TWO */ 0x2082, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* SUBSCRIPT THREE */ 0x2083, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* SUBSCRIPT FOUR */ 0x2084, /* SUPERSCRIPT FOUR */ 0x2074],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* SUBSCRIPT FIVE */ 0x2085, /* SUPERSCRIPT FIVE */ 0x2075],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, /* SUBSCRIPT SIX */ 0x2086, /* SUPERSCRIPT SIX */ 0x2076],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, /* SUBSCRIPT SEVEN */ 0x2087, /* SUPERSCRIPT SEVEN */ 0x2077],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* SUBSCRIPT EIGHT */ 0x2088, /* SUPERSCRIPT EIGHT */ 0x2078],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028, /* SUBSCRIPT NINE */ 0x2089, /* SUPERSCRIPT NINE */ 0x2079],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029, /* SUBSCRIPT ZERO */ 0x2080, /* SUPERSCRIPT ZERO */ 0x2070],
    Minus: [/* SOLIDUS */ 0x002f, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, /* COMMERCIAL AT */ 0x0040],
    KeyW: [{ dead: /* ASTERISK */ 0x002a }, { dead: /* ASTERISK */ 0x002a }, /* LESS-THAN SIGN */ 0x003c, /* LESS-THAN OR EQUAL TO */ 0x2264],
    KeyE: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* GREATER-THAN SIGN */ 0x003e, /* GREATER-THAN OR EQUAL TO */ 0x2265],
    KeyR: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* DOLLAR SIGN */ 0x0024],
    KeyT: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* PERCENT SIGN */ 0x0025, /* PER MILLE SIGN */ 0x2030],
    KeyY: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* CIRCUMFLEX ACCENT */ 0x005e, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    KeyU: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* AMPERSAND */ 0x0026],
    KeyI: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* ASTERISK */ 0x002a, /* MULTIPLICATION SIGN */ 0x00d7],
    KeyO: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* APOSTROPHE */ 0x0027, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    KeyP: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* GRAVE ACCENT */ 0x0060, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* LEFT CURLY BRACKET */ 0x007b],
    KeyS: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LEFT PARENTHESIS */ 0x0028, /* SUPERSCRIPT LEFT PARENTHESIS */ 0x207d],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* RIGHT PARENTHESIS */ 0x0029, /* SUPERSCRIPT RIGHT PARENTHESIS */ 0x207e],
    KeyF: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyG: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* EQUALS SIGN */ 0x003d, /* NOT EQUAL TO */ 0x2260],
    KeyH: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, /* REVERSE SOLIDUS */ 0x005c],
    KeyJ: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054, /* PLUS SIGN */ 0x002b, /* PLUS-MINUS SIGN */ 0x00b1],
    KeyK: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* HYPHEN-MINUS */ 0x002d, /* EM DASH */ 0x2014],
    KeyL: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* SOLIDUS */ 0x002f, /* DIVISION SIGN */ 0x00f7],
    Semicolon: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052, /* QUOTATION MARK */ 0x0022, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a, /* TILDE */ 0x007e, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyX: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyC: [/* HYPHEN-MINUS */ 0x002d, /* QUESTION MARK */ 0x003f, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyV: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048, /* LOW LINE */ 0x005f, /* EN DASH */ 0x2013],
    KeyB: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, /* NUMBER SIGN */ 0x0023],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* VERTICAL LINE */ 0x007c, /* BROKEN BAR */ 0x00a6],
    KeyM: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* EXCLAMATION MARK */ 0x0021, /* NOT SIGN */ 0x00ac],
    Comma: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* SEMICOLON */ 0x003b, { dead: /* COMBINING CEDILLA */ 0x0327 }],
    Period: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* COLON */ 0x003a],
    Slash: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_ergo_l.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_ERGO_L = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EURO SIGN */ 0x20ac, /* SUBSCRIPT ONE */ 0x2081, /* SUPERSCRIPT ONE */ 0x00b9],
    Digit2: [/* DIGIT TWO */ 0x0032, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* SUBSCRIPT TWO */ 0x2082, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb, /* SUBSCRIPT THREE */ 0x2083, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* SUBSCRIPT FOUR */ 0x2084, /* SUPERSCRIPT FOUR */ 0x2074],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* SUBSCRIPT FIVE */ 0x2085, /* SUPERSCRIPT FIVE */ 0x2075],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, /* SUBSCRIPT SIX */ 0x2086, /* SUPERSCRIPT SIX */ 0x2076],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, /* SUBSCRIPT SEVEN */ 0x2087, /* SUPERSCRIPT SEVEN */ 0x2077],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* SUBSCRIPT EIGHT */ 0x2088, /* SUPERSCRIPT EIGHT */ 0x2078],
    Digit9: [/* DIGIT NINE */ 0x0039, /* NUMBER SIGN */ 0x0023, /* SUBSCRIPT NINE */ 0x2089, /* SUPERSCRIPT NINE */ 0x2079],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* COMMERCIAL AT */ 0x0040, /* SUBSCRIPT ZERO */ 0x2080, /* SUPERSCRIPT ZERO */ 0x2070],
    Minus: [/* SOLIDUS */ 0x002f, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* CIRCUMFLEX ACCENT */ 0x005e, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    KeyW: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* LESS-THAN SIGN */ 0x003c, /* LESS-THAN OR EQUAL TO */ 0x2264],
    KeyE: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* GREATER-THAN SIGN */ 0x003e, /* GREATER-THAN OR EQUAL TO */ 0x2265],
    KeyR: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* DOLLAR SIGN */ 0x0024],
    KeyT: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* PERCENT SIGN */ 0x0025, /* PER MILLE SIGN */ 0x2030],
    KeyY: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a, /* COMMERCIAL AT */ 0x0040],
    KeyU: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* AMPERSAND */ 0x0026],
    KeyI: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* ASTERISK */ 0x002a, /* MULTIPLICATION SIGN */ 0x00d7],
    KeyO: [{ dead: /* ASTERISK */ 0x002a }, /* EXCLAMATION MARK */ 0x0021, /* APOSTROPHE */ 0x0027, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    KeyP: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, /* GRAVE ACCENT */ 0x0060, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LEFT CURLY BRACKET */ 0x007b, { dead: /* COMBINING CARON */ 0x030c }],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LEFT PARENTHESIS */ 0x0028],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* RIGHT PARENTHESIS */ 0x0029],
    KeyF: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* RIGHT CURLY BRACKET */ 0x007d, { dead: /* COMBINING DOT ABOVE */ 0x0307 }],
    KeyG: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* EQUALS SIGN */ 0x003d, /* NOT EQUAL TO */ 0x2260],
    KeyH: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* REVERSE SOLIDUS */ 0x005c],
    KeyJ: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052, /* PLUS SIGN */ 0x002b, /* PLUS-MINUS SIGN */ 0x00b1],
    KeyK: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054, /* HYPHEN-MINUS */ 0x002d, { dead: /* COMBINING MACRON */ 0x0304 }],
    KeyL: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* SOLIDUS */ 0x002f, /* DIVISION SIGN */ 0x00f7],
    Semicolon: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* QUOTATION MARK */ 0x0022],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, /* TILDE */ 0x007e, { dead: /* COMBINING TILDE */ 0x0303 }],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyC: [/* HYPHEN-MINUS */ 0x002d, /* QUESTION MARK */ 0x003f, /* RIGHT SQUARE BRACKET */ 0x005d, { dead: /* COMBINING OGONEK */ 0x0328 }],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* LOW LINE */ 0x005f, /* EN DASH */ 0x2013],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* NUMBER SIGN */ 0x0023],
    KeyN: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* VERTICAL LINE */ 0x007c, /* BROKEN BAR */ 0x00a6],
    KeyM: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048, /* EXCLAMATION MARK */ 0x0021, /* NOT SIGN */ 0x00ac],
    Comma: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, /* SEMICOLON */ 0x003b, { dead: /* COMBINING CEDILLA */ 0x0327 }],
    Period: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* COLON */ 0x003a, /* COLON */ 0x003a],
    Slash: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* QUESTION MARK */ 0x003f, { dead: /* COMBINING BREVE */ 0x0306 }],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_fr.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_FR = {
    Backquote: [/* SUPERSCRIPT TWO */ 0x00b2],
    Digit1: [/* AMPERSAND */ 0x0026, /* DIGIT ONE */ 0x0031],
    Digit2: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* DIGIT TWO */ 0x0032, { dead: /* COMBINING TILDE */ 0x0303 }],
    Digit3: [/* QUOTATION MARK */ 0x0022, /* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* APOSTROPHE */ 0x0027, /* DIGIT FOUR */ 0x0034, /* LEFT CURLY BRACKET */ 0x007b],
    Digit5: [/* LEFT PARENTHESIS */ 0x0028, /* DIGIT FIVE */ 0x0035, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit6: [/* HYPHEN-MINUS */ 0x002d, /* DIGIT SIX */ 0x0036, /* VERTICAL LINE */ 0x007c],
    Digit7: [/* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* DIGIT SEVEN */ 0x0037, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    Digit8: [/* LOW LINE */ 0x005f, /* DIGIT EIGHT */ 0x0038, /* REVERSE SOLIDUS */ 0x005c],
    Digit9: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* DIGIT NINE */ 0x0039, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit0: [/* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* DIGIT ZERO */ 0x0030, /* COMMERCIAL AT */ 0x0040],
    Minus: [/* RIGHT PARENTHESIS */ 0x0029, /* DEGREE SIGN */ 0x00b0, /* RIGHT SQUARE BRACKET */ 0x005d],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyQ: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyW: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    BracketRight: [/* DOLLAR SIGN */ 0x0024, /* POUND SIGN */ 0x00a3, /* CURRENCY SIGN */ 0x00a4],
    Backslash: [/* ASTERISK */ 0x002a, /* MICRO SIGN */ 0x00b5],
    KeyA: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Quote: [/* LATIN SMALL LETTER U WITH GRAVE */ 0x00f9, /* PERCENT SIGN */ 0x0025],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* COMMA */ 0x002c, /* QUESTION MARK */ 0x003f],
    Comma: [/* SEMICOLON */ 0x003b, /* FULL STOP */ 0x002e],
    Period: [/* COLON */ 0x003a, /* SOLIDUS */ 0x002f],
    Slash: [/* EXCLAMATION MARK */ 0x0021, /* SECTION SIGN */ 0x00a7],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/fr_optimot_ergo.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_FR_OPTIMOT_ERGO = {
    Backquote: [/* DOLLAR SIGN */ 0x0024, /* EURO SIGN */ 0x20ac, /* POUND SIGN */ 0x00a3, /* COPYRIGHT SIGN */ 0x00a9],
    Digit1: [/* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* DIGIT ONE */ 0x0031, /* LEFT DOUBLE QUOTATION MARK */ 0x201c, /* VULGAR FRACTION ONE QUARTER */ 0x00bc],
    Digit2: [/* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb, /* DIGIT TWO */ 0x0032, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Digit3: [/* QUOTATION MARK */ 0x0022, /* DIGIT THREE */ 0x0033, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e, /* VULGAR FRACTION THREE QUARTERS */ 0x00be],
    Digit4: [/* HYPHEN-MINUS */ 0x002d, /* DIGIT FOUR */ 0x0034, /* NON-BREAKING HYPHEN */ 0x2011, /* VULGAR FRACTION ONE THIRD */ 0x2153],
    Digit5: [/* PLUS SIGN */ 0x002b, /* DIGIT FIVE */ 0x0035, /* PLUS-MINUS SIGN */ 0x00b1, /* VULGAR FRACTION TWO THIRDS */ 0x2154],
    Digit6: [/* ASTERISK */ 0x002a, /* DIGIT SIX */ 0x0036, /* MULTIPLICATION SIGN */ 0x00d7, /* TEARDROP-SPOKED ASTERISK */ 0x273b],
    Digit7: [/* SOLIDUS */ 0x002f, /* DIGIT SEVEN */ 0x0037, /* REVERSE SOLIDUS */ 0x005c, /* DIVISION SIGN */ 0x00f7],
    Digit8: [/* EQUALS SIGN */ 0x003d, /* DIGIT EIGHT */ 0x0038, /* NOT EQUAL TO */ 0x2260, /* ALMOST EQUAL TO */ 0x2248],
    Digit9: [/* LEFT PARENTHESIS */ 0x0028, /* DIGIT NINE */ 0x0039, /* LEFT SQUARE BRACKET */ 0x005b, /* PRIME */ 0x2032],
    Digit0: [/* RIGHT PARENTHESIS */ 0x0029, /* DIGIT ZERO */ 0x0030, /* RIGHT SQUARE BRACKET */ 0x005d, /* DOUBLE PRIME */ 0x2033],
    Minus: [/* COMMERCIAL AT */ 0x0040, /* LOW LINE */ 0x005f, /* MINUS SIGN */ 0x2212, /* FIGURE DASH */ 0x2012],
    Equal: [/* NUMBER SIGN */ 0x0023, /* PERCENT SIGN */ 0x0025, /* DEGREE SIGN */ 0x00b0, /* MASCULINE ORDINAL INDICATOR */ 0x00ba],
    KeyQ: [/* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* LATIN CAPITAL LETTER A WITH GRAVE */ 0x00c0, /* LESS-THAN SIGN */ 0x003c, /* LESS-THAN OR EQUAL TO */ 0x2264],
    KeyW: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a, /* GREATER-THAN SIGN */ 0x003e, /* GREATER-THAN OR EQUAL TO */ 0x2265],
    KeyE: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* LATIN SMALL LIGATURE OE */ 0x0153, /* LATIN CAPITAL LIGATURE OE */ 0x0152],
    KeyR: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LATIN CAPITAL LETTER E WITH ACUTE */ 0x00c9, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    KeyT: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* EM DASH */ 0x2014, /* LOWER RIGHT DROP-SHADOWED WHITE SQUARE */ 0x274f],
    KeyY: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* LEFT SINGLE QUOTATION MARK */ 0x2018, /* BLACK FOUR POINTED STAR */ 0x2726],
    KeyU: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* LEFT CURLY BRACKET */ 0x007b, /* DAGGER */ 0x2020],
    KeyI: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* RIGHT CURLY BRACKET */ 0x007d, /* DOUBLE DAGGER */ 0x2021],
    KeyO: [/* RIGHT SINGLE QUOTATION MARK */ 0x2019, /* QUESTION MARK */ 0x003f, /* RIGHT SINGLE QUOTATION MARK */ 0x2019, /* INVERTED QUESTION MARK */ 0x00bf],
    KeyP: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, { dead: /* COMBINING RING ABOVE */ 0x030a }, /* REVERSED QUESTION MARK */ 0x2e2e],
    BracketLeft: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* VERTICAL LINE */ 0x007c, /* BROKEN BAR */ 0x00a6],
    BracketRight: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, null, /* TRADE MARK SIGN */ 0x2122],
    Backslash: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, /* COPYLEFT SYMBOL */ 0x1f12f],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    KeyS: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* SUBSCRIPT TWO */ 0x2082, /* SECTION SIGN */ 0x00a7],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* SUPERSCRIPT TWO */ 0x00b2, /* PILCROW SIGN */ 0x00b6],
    KeyF: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* LATIN SMALL LETTER U WITH GRAVE */ 0x00f9, /* LATIN CAPITAL LETTER U WITH GRAVE */ 0x00d9],
    KeyG: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* EN DASH */ 0x2013, /* CHECK MARK */ 0x2713],
    KeyH: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* GRAVE ACCENT */ 0x0060, /* BLACK STAR */ 0x2605],
    KeyJ: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054, /* AMPERSAND */ 0x0026, /* LEFTWARDS BLACK ARROW */ 0x2b05],
    KeyK: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, null, /* DOWNWARDS BLACK ARROW */ 0x2b07],
    KeyL: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052, null, /* UPWARDS BLACK ARROW */ 0x2b06],
    Semicolon: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, { dead: /* COMBINING TILDE */ 0x0303 }, /* RIGHTWARDS BLACK ARROW */ 0x2b95],
    Quote: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* EXCLAMATION MARK */ 0x0021, { dead: /* COMBINING DIAERESIS */ 0x0308 }, /* INVERTED EXCLAMATION MARK */ 0x00a1],
    IntlBackslash: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, /* INTERROBANG */ 0x203d, /* LATIN SMALL LETTER O WITH STROKE */ 0x00f8, /* LATIN CAPITAL LETTER O WITH STROKE */ 0x00d8],
    KeyZ: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyX: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, { dead: /* COMBINING DOT ABOVE */ 0x0307 }, /* OPTION KEY */ 0x2325],
    KeyC: [/* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* LATIN CAPITAL LETTER E WITH GRAVE */ 0x00c8, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, /* PLACE OF INTEREST SIGN */ 0x2318],
    KeyV: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* HORIZONTAL ELLIPSIS */ 0x2026, /* MIDDLE DOT */ 0x00b7],
    KeyB: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* BULLET */ 0x2022, /* BALLOT X */ 0x2717],
    KeyN: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, null, /* FOUR BALLOON-SPOKED ASTERISK */ 0x2723],
    KeyM: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, { dead: /* COMBINING CEDILLA */ 0x0327 }, /* BLACK SPADE SUIT */ 0x2660],
    Comma: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, { dead: /* COMBINING MACRON */ 0x0304 }, /* BLACK HEART SUIT */ 0x2665],
    Period: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048, { dead: /* COMBINING BREVE */ 0x0306 }, /* BLACK DIAMOND SUIT */ 0x2666],
    Slash: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, { dead: /* COMBINING CARON */ 0x030c }, /* BLACK CLUB SUIT */ 0x2663],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/he_il.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_HE_IL = {
    Backquote: [/* SEMICOLON */ 0x003b, /* TILDE */ 0x007e, /* HEBREW PUNCTUATION GERESH */ 0x05f3],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* EURO SIGN */ 0x20ac],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* NEW SHEQEL SIGN */ 0x20aa],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* DEGREE SIGN */ 0x00b0],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, /* HEBREW ACCENT OLE */ 0x05ab],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, /* HEBREW POINT METEG */ 0x05bd],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* MULTIPLICATION SIGN */ 0x00d7],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, { special: /* LEFT-TO-RIGHT MARK */ 0x200e }],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* LEFT PARENTHESIS */ 0x0028, { special: /* RIGHT-TO-LEFT MARK */ 0x200f }],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* HEBREW PUNCTUATION MAQAF */ 0x05be],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* EN DASH */ 0x2013],
    KeyQ: [/* SOLIDUS */ 0x002f, /* LATIN CAPITAL LETTER Q */ 0x0051, /* HEBREW POINT SIN DOT */ 0x05c2],
    KeyW: [/* APOSTROPHE */ 0x0027, /* LATIN CAPITAL LETTER W */ 0x0057, /* HEBREW POINT SHIN DOT */ 0x05c1],
    KeyE: [/* HEBREW LETTER QOF */ 0x05e7, /* LATIN CAPITAL LETTER E */ 0x0045, /* HEBREW POINT QAMATS */ 0x05b8],
    KeyR: [/* HEBREW LETTER RESH */ 0x05e8, /* LATIN CAPITAL LETTER R */ 0x0052, /* HEBREW POINT HATAF QAMATS */ 0x05b3],
    KeyT: [/* HEBREW LETTER ALEF */ 0x05d0, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* HEBREW LETTER TET */ 0x05d8, /* LATIN CAPITAL LETTER Y */ 0x0059, /* HEBREW LIGATURE YIDDISH DOUBLE VAV */ 0x05f0],
    KeyU: [/* HEBREW LETTER VAV */ 0x05d5, /* LATIN CAPITAL LETTER U */ 0x0055, /* HEBREW POINT HOLAM */ 0x05b9, /* HEBREW POINT HOLAM HASER FOR VAV */ 0x05ba],
    KeyI: [/* HEBREW LETTER FINAL NUN */ 0x05df, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* HEBREW LETTER FINAL MEM */ 0x05dd, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* HEBREW LETTER PE */ 0x05e4, /* LATIN CAPITAL LETTER P */ 0x0050, /* HEBREW POINT PATAH */ 0x05b7],
    BracketLeft: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d, /* HEBREW POINT HATAF PATAH */ 0x05b2],
    BracketRight: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b, /* HEBREW POINT RAFE */ 0x05bf],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c, /* HEBREW POINT QUBUTS */ 0x05bb],
    KeyA: [/* HEBREW LETTER SHIN */ 0x05e9, /* LATIN CAPITAL LETTER A */ 0x0041, /* HEBREW POINT SHEVA */ 0x05b0],
    KeyS: [/* HEBREW LETTER DALET */ 0x05d3, /* LATIN CAPITAL LETTER S */ 0x0053, /* HEBREW POINT DAGESH OR MAPIQ */ 0x05bc],
    KeyD: [/* HEBREW LETTER GIMEL */ 0x05d2, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* HEBREW LETTER KAF */ 0x05db, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* HEBREW LETTER AYIN */ 0x05e2, /* LATIN CAPITAL LETTER G */ 0x0047, /* HEBREW LIGATURE YIDDISH VAV YOD */ 0x05f1],
    KeyH: [/* HEBREW LETTER YOD */ 0x05d9, /* LATIN CAPITAL LETTER H */ 0x0048, /* HEBREW LIGATURE YIDDISH DOUBLE YOD */ 0x05f2],
    KeyJ: [/* HEBREW LETTER HET */ 0x05d7, /* LATIN CAPITAL LETTER J */ 0x004a, /* HEBREW POINT HIRIQ */ 0x05b4, { special: /* ZERO WIDTH JOINER */ 0x200d }],
    KeyK: [/* HEBREW LETTER LAMED */ 0x05dc, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* HEBREW LETTER FINAL KAF */ 0x05da, /* LATIN CAPITAL LETTER L */ 0x004c, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Semicolon: [/* HEBREW LETTER FINAL PE */ 0x05e3, /* COLON */ 0x003a, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Quote: [/* COMMA */ 0x002c, /* QUOTATION MARK */ 0x0022, /* HEBREW PUNCTUATION GERSHAYIM */ 0x05f4],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* HEBREW LETTER ZAYIN */ 0x05d6, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* HEBREW LETTER SAMEKH */ 0x05e1, /* LATIN CAPITAL LETTER X */ 0x0058, /* HEBREW POINT SEGOL */ 0x05b6],
    KeyC: [/* HEBREW LETTER BET */ 0x05d1, /* LATIN CAPITAL LETTER C */ 0x0043, /* HEBREW POINT HATAF SEGOL */ 0x05b1, { special: /* COMBINING GRAPHEME JOINER */ 0x034f }],
    KeyV: [/* HEBREW LETTER HE */ 0x05d4, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* HEBREW LETTER NUN */ 0x05e0, /* LATIN CAPITAL LETTER B */ 0x0042, null, /* HEBREW PUNCTUATION NUN HAFUKHA */ 0x05c6],
    KeyN: [/* HEBREW LETTER MEM */ 0x05de, /* LATIN CAPITAL LETTER N */ 0x004e, null, { special: /* ZERO WIDTH NON-JOINER */ 0x200c }],
    KeyM: [/* HEBREW LETTER TSADI */ 0x05e6, /* LATIN CAPITAL LETTER M */ 0x004d, /* HEBREW POINT TSERE */ 0x05b5],
    Comma: [/* HEBREW LETTER TAV */ 0x05ea, /* GREATER-THAN SIGN */ 0x003e, /* RIGHT SINGLE QUOTATION MARK */ 0x2019, /* LEFT SINGLE QUOTATION MARK */ 0x2018],
    Period: [/* HEBREW LETTER FINAL TSADI */ 0x05e5, /* LESS-THAN SIGN */ 0x003c, /* SINGLE LOW-9 QUOTATION MARK */ 0x201a, /* RIGHT SINGLE QUOTATION MARK */ 0x2019],
    Slash: [/* FULL STOP */ 0x002e, /* QUESTION MARK */ 0x003f, /* DIVISION SIGN */ 0x00f7],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/he_il_arkn.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_HE_IL_ARKN = {
    Backquote: [/* SEMICOLON */ 0x003b, /* TILDE */ 0x007e, /* HEBREW PUNCTUATION GERESH */ 0x05f3],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* EURO SIGN */ 0x20ac],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* NEW SHEQEL SIGN */ 0x20aa],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* DEGREE SIGN */ 0x00b0],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, /* HEBREW ACCENT OLE */ 0x05ab],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, /* HEBREW POINT METEG */ 0x05bd],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* MULTIPLICATION SIGN */ 0x00d7],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, { special: /* LEFT-TO-RIGHT MARK */ 0x200e }],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* LEFT PARENTHESIS */ 0x0028, { special: /* RIGHT-TO-LEFT MARK */ 0x200f }],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* HEBREW PUNCTUATION MAQAF */ 0x05be],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* EN DASH */ 0x2013],
    KeyQ: [/* HEBREW LETTER FINAL TSADI */ 0x05e5, /* LATIN CAPITAL LETTER Q */ 0x0051, /* HEBREW POINT SIN DOT */ 0x05c2],
    KeyW: [/* HEBREW LETTER FINAL NUN */ 0x05df, /* LATIN CAPITAL LETTER W */ 0x0057, /* HEBREW POINT SHIN DOT */ 0x05c1],
    KeyE: [/* HEBREW LETTER QOF */ 0x05e7, /* LATIN CAPITAL LETTER E */ 0x0045, /* HEBREW POINT QAMATS */ 0x05b8],
    KeyR: [/* HEBREW LETTER RESH */ 0x05e8, /* LATIN CAPITAL LETTER R */ 0x0052, /* HEBREW POINT HATAF QAMATS */ 0x05b3],
    KeyT: [/* HEBREW LETTER ALEF */ 0x05d0, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* HEBREW LETTER TET */ 0x05d8, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* HEBREW LETTER VAV */ 0x05d5, /* LATIN CAPITAL LETTER U */ 0x0055, /* HEBREW POINT HOLAM */ 0x05b9, /* HEBREW POINT HOLAM HASER FOR VAV */ 0x05ba],
    KeyI: [/* HEBREW LETTER TAV */ 0x05ea, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* HEBREW LETTER FINAL MEM */ 0x05dd, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* HEBREW LETTER PE */ 0x05e4, /* LATIN CAPITAL LETTER P */ 0x0050, /* HEBREW POINT PATAH */ 0x05b7],
    BracketLeft: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d, /* HEBREW POINT HATAF PATAH */ 0x05b2],
    BracketRight: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b, /* HEBREW POINT RAFE */ 0x05bf],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c, /* HEBREW POINT QUBUTS */ 0x05bb],
    KeyA: [/* HEBREW LETTER SHIN */ 0x05e9, /* LATIN CAPITAL LETTER A */ 0x0041, /* HEBREW POINT SHEVA */ 0x05b0],
    KeyS: [/* HEBREW LETTER DALET */ 0x05d3, /* LATIN CAPITAL LETTER S */ 0x0053, /* HEBREW POINT DAGESH OR MAPIQ */ 0x05bc],
    KeyD: [/* HEBREW LETTER GIMEL */ 0x05d2, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* HEBREW LETTER KAF */ 0x05db, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* HEBREW LETTER AYIN */ 0x05e2, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* HEBREW LETTER YOD */ 0x05d9, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* HEBREW LETTER HET */ 0x05d7, /* LATIN CAPITAL LETTER J */ 0x004a, /* HEBREW POINT HIRIQ */ 0x05b4, { special: /* ZERO WIDTH JOINER */ 0x200d }],
    KeyK: [/* HEBREW LETTER LAMED */ 0x05dc, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* HEBREW LETTER FINAL KAF */ 0x05da, /* LATIN CAPITAL LETTER L */ 0x004c, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Semicolon: [/* HEBREW LETTER FINAL PE */ 0x05e3, /* COLON */ 0x003a, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022, /* HEBREW PUNCTUATION GERSHAYIM */ 0x05f4],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* HEBREW LETTER ZAYIN */ 0x05d6, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* HEBREW LETTER SAMEKH */ 0x05e1, /* LATIN CAPITAL LETTER X */ 0x0058, /* HEBREW POINT SEGOL */ 0x05b6],
    KeyC: [/* HEBREW LETTER BET */ 0x05d1, /* LATIN CAPITAL LETTER C */ 0x0043, /* HEBREW POINT HATAF SEGOL */ 0x05b1, { special: /* COMBINING GRAPHEME JOINER */ 0x034f }],
    KeyV: [/* HEBREW LETTER HE */ 0x05d4, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* HEBREW LETTER NUN */ 0x05e0, /* LATIN CAPITAL LETTER B */ 0x0042, null, /* HEBREW PUNCTUATION NUN HAFUKHA */ 0x05c6],
    KeyN: [/* HEBREW LETTER MEM */ 0x05de, /* LATIN CAPITAL LETTER N */ 0x004e, null, { special: /* ZERO WIDTH NON-JOINER */ 0x200c }],
    KeyM: [/* HEBREW LETTER TSADI */ 0x05e6, /* LATIN CAPITAL LETTER M */ 0x004d, /* HEBREW POINT TSERE */ 0x05b5],
    Comma: [/* COMMA */ 0x002c, /* GREATER-THAN SIGN */ 0x003e, /* RIGHT SINGLE QUOTATION MARK */ 0x2019, /* LEFT SINGLE QUOTATION MARK */ 0x2018],
    Period: [/* FULL STOP */ 0x002e, /* LESS-THAN SIGN */ 0x003c, /* SINGLE LOW-9 QUOTATION MARK */ 0x201a, /* RIGHT SINGLE QUOTATION MARK */ 0x2019],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f, /* DIVISION SIGN */ 0x00f7],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/hu_hu.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_HU_HU = {
    Backquote: [/* DIGIT ZERO */ 0x0030, /* SECTION SIGN */ 0x00a7],
    Digit1: [/* DIGIT ONE */ 0x0031, /* APOSTROPHE */ 0x0027, /* TILDE */ 0x007e],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, { dead: /* COMBINING CARON */ 0x030c }],
    Digit3: [/* DIGIT THREE */ 0x0033, /* PLUS SIGN */ 0x002b, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* EXCLAMATION MARK */ 0x0021, { dead: /* COMBINING BREVE */ 0x0306 }],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, { dead: /* COMBINING RING ABOVE */ 0x030a }],
    Digit6: [/* DIGIT SIX */ 0x0036, /* SOLIDUS */ 0x002f, { dead: /* COMBINING OGONEK */ 0x0328 }],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* EQUALS SIGN */ 0x003d, /* GRAVE ACCENT */ 0x0060],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, { dead: /* COMBINING DOT ABOVE */ 0x0307 }],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Digit0: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6, { dead: /* COMBINING DOUBLE ACUTE ACCENT */ 0x030b }],
    Minus: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    Equal: [/* LATIN SMALL LETTER O WITH ACUTE */ 0x00f3, /* LATIN CAPITAL LETTER O WITH ACUTE */ 0x00d3, { dead: /* COMBINING CEDILLA */ 0x0327 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* REVERSE SOLIDUS */ 0x005c],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* VERTICAL LINE */ 0x007c],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* EURO SIGN */ 0x20ac],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* LATIN CAPITAL LETTER I WITH ACUTE */ 0x00cd],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER O WITH DOUBLE ACUTE */ 0x0151, /* LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */ 0x0150, /* DIVISION SIGN */ 0x00f7],
    BracketRight: [/* LATIN SMALL LETTER U WITH ACUTE */ 0x00fa, /* LATIN CAPITAL LETTER U WITH ACUTE */ 0x00da, /* MULTIPLICATION SIGN */ 0x00d7],
    Backslash: [/* LATIN SMALL LETTER U WITH DOUBLE ACUTE */ 0x0171, /* LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */ 0x0170, /* CURRENCY SIGN */ 0x00a4],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER D WITH STROKE */ 0x0111],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* LATIN CAPITAL LETTER D WITH STROKE */ 0x0110],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a, /* LATIN SMALL LETTER I WITH ACUTE */ 0x00ed],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* LATIN SMALL LETTER L WITH STROKE */ 0x0142],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* LATIN CAPITAL LETTER L WITH STROKE */ 0x0141],
    Semicolon: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LATIN CAPITAL LETTER E WITH ACUTE */ 0x00c9, /* DOLLAR SIGN */ 0x0024],
    Quote: [/* LATIN SMALL LETTER A WITH ACUTE */ 0x00e1, /* LATIN CAPITAL LETTER A WITH ACUTE */ 0x00c1, /* LATIN SMALL LETTER SHARP S */ 0x00df],
    IntlBackslash: [/* LATIN SMALL LETTER I WITH ACUTE */ 0x00ed, /* LATIN CAPITAL LETTER I WITH ACUTE */ 0x00cd, /* LESS-THAN SIGN */ 0x003c],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, /* GREATER-THAN SIGN */ 0x003e],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* NUMBER SIGN */ 0x0023],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* AMPERSAND */ 0x0026],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* COMMERCIAL AT */ 0x0040],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* LEFT CURLY BRACKET */ 0x007b],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* LESS-THAN SIGN */ 0x003c],
    Comma: [/* COMMA */ 0x002c, /* QUESTION MARK */ 0x003f, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* ASTERISK */ 0x002a],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/it_it.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_IT_IT = {
    Backquote: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* EURO SIGN */ 0x20ac],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f],
    Equal: [/* LATIN SMALL LETTER I WITH GRAVE */ 0x00ec, /* CIRCUMFLEX ACCENT */ 0x005e],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, /* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* LATIN SMALL LETTER U WITH GRAVE */ 0x00f9, /* SECTION SIGN */ 0x00a7],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER O WITH GRAVE */ 0x00f2, /* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* COMMERCIAL AT */ 0x0040],
    Quote: [/* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* DEGREE SIGN */ 0x00b0, /* NUMBER SIGN */ 0x0023],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/ja_jp_jis.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_JA_JP_JIS = {
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* HIRAGANA LETTER NU */ 0x306c],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* HIRAGANA LETTER HU */ 0x3075],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* HIRAGANA LETTER A */ 0x3042, /* HIRAGANA LETTER SMALL A */ 0x3041],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* HIRAGANA LETTER U */ 0x3046, /* HIRAGANA LETTER SMALL U */ 0x3045],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* HIRAGANA LETTER E */ 0x3048, /* HIRAGANA LETTER SMALL E */ 0x3047],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, /* HIRAGANA LETTER O */ 0x304a, /* HIRAGANA LETTER SMALL O */ 0x3049],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* APOSTROPHE */ 0x0027, /* HIRAGANA LETTER YA */ 0x3084, /* HIRAGANA LETTER SMALL YA */ 0x3083],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* HIRAGANA LETTER YU */ 0x3086, /* HIRAGANA LETTER SMALL YU */ 0x3085],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* HIRAGANA LETTER YO */ 0x3088, /* HIRAGANA LETTER SMALL YO */ 0x3087],
    Digit0: [/* DIGIT ZERO */ 0x0030, null, /* HIRAGANA LETTER WA */ 0x308f, /* HIRAGANA LETTER WO */ 0x3092],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* EQUALS SIGN */ 0x003d, /* HIRAGANA LETTER HO */ 0x307b],
    Equal: [/* CIRCUMFLEX ACCENT */ 0x005e, /* TILDE */ 0x007e, /* HIRAGANA LETTER HE */ 0x3078],
    IntlYen: [/* YEN SIGN */ 0x00a5, /* LOW LINE */ 0x005f],
    KeyQ: [/* LATIN CAPITAL LETTER Q */ 0x0051, /* LATIN SMALL LETTER Q */ 0x0071, /* HIRAGANA LETTER TA */ 0x305f],
    KeyW: [/* LATIN CAPITAL LETTER W */ 0x0057, /* LATIN SMALL LETTER W */ 0x0077, /* HIRAGANA LETTER TE */ 0x3066],
    KeyE: [/* LATIN CAPITAL LETTER E */ 0x0045, /* LATIN SMALL LETTER E */ 0x0065, /* HIRAGANA LETTER I */ 0x3044, /* HIRAGANA LETTER SMALL I */ 0x3043],
    KeyR: [/* LATIN CAPITAL LETTER R */ 0x0052, /* LATIN SMALL LETTER R */ 0x0072, /* HIRAGANA LETTER SU */ 0x3059],
    KeyT: [/* LATIN CAPITAL LETTER T */ 0x0054, /* LATIN SMALL LETTER T */ 0x0074, /* HIRAGANA LETTER KA */ 0x304b],
    KeyY: [/* LATIN CAPITAL LETTER Y */ 0x0059, /* LATIN SMALL LETTER Y */ 0x0079, /* HIRAGANA LETTER N */ 0x3093],
    KeyU: [/* LATIN CAPITAL LETTER U */ 0x0055, /* LATIN SMALL LETTER U */ 0x0075, /* HIRAGANA LETTER NA */ 0x306a],
    KeyI: [/* LATIN CAPITAL LETTER I */ 0x0049, /* LATIN SMALL LETTER I */ 0x0069, /* HIRAGANA LETTER NI */ 0x306b],
    KeyO: [/* LATIN CAPITAL LETTER O */ 0x004f, /* LATIN SMALL LETTER O */ 0x006f, /* HIRAGANA LETTER RA */ 0x3089],
    KeyP: [/* LATIN CAPITAL LETTER P */ 0x0050, /* LATIN SMALL LETTER P */ 0x0070, /* HIRAGANA LETTER SE */ 0x305b],
    BracketLeft: [/* COMMERCIAL AT */ 0x0040, /* GRAVE ACCENT */ 0x0060, /* KATAKANA-HIRAGANA VOICED SOUND MARK */ 0x309b],
    BracketRight: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b, /* WHITE CIRCLE */ 0x25cb, /* LEFT CORNER BRACKET */ 0x300c],
    Backslash: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d, /* HIRAGANA LETTER MU */ 0x3080, /* RIGHT CORNER BRACKET */ 0x300d],
    KeyA: [/* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER A */ 0x0061, /* HIRAGANA LETTER TI */ 0x3061],
    KeyS: [/* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER S */ 0x0073, /* HIRAGANA LETTER TO */ 0x3068],
    KeyD: [/* LATIN CAPITAL LETTER D */ 0x0044, /* LATIN SMALL LETTER D */ 0x0064, /* HIRAGANA LETTER SI */ 0x3057],
    KeyF: [/* LATIN CAPITAL LETTER F */ 0x0046, /* LATIN SMALL LETTER F */ 0x0066, /* HIRAGANA LETTER HA */ 0x306f],
    KeyG: [/* LATIN CAPITAL LETTER G */ 0x0047, /* LATIN SMALL LETTER G */ 0x0067, /* HIRAGANA LETTER KI */ 0x304d],
    KeyH: [/* LATIN CAPITAL LETTER H */ 0x0048, /* LATIN SMALL LETTER H */ 0x0068, /* HIRAGANA LETTER KU */ 0x304f],
    KeyJ: [/* LATIN CAPITAL LETTER J */ 0x004a, /* LATIN SMALL LETTER J */ 0x006a, /* HIRAGANA LETTER MA */ 0x307e],
    KeyK: [/* LATIN CAPITAL LETTER K */ 0x004b, /* LATIN SMALL LETTER K */ 0x006b, /* HIRAGANA LETTER NO */ 0x306e],
    KeyL: [/* LATIN CAPITAL LETTER L */ 0x004c, /* LATIN SMALL LETTER L */ 0x006c, /* HIRAGANA LETTER RI */ 0x308a],
    Semicolon: [/* SEMICOLON */ 0x003b, /* PLUS SIGN */ 0x002b, /* HIRAGANA LETTER RE */ 0x308c],
    Quote: [/* COLON */ 0x003a, /* ASTERISK */ 0x002a, /* HIRAGANA LETTER KE */ 0x3051],
    IntlBackslash: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d, /* HIRAGANA LETTER MU */ 0x3080, /* RIGHT CORNER BRACKET */ 0x300d],
    KeyZ: [/* LATIN CAPITAL LETTER Z */ 0x005a, /* LATIN SMALL LETTER Z */ 0x007a, /* HIRAGANA LETTER TU */ 0x3064, /* HIRAGANA LETTER SMALL TU */ 0x3063],
    KeyX: [/* LATIN CAPITAL LETTER X */ 0x0058, /* LATIN SMALL LETTER X */ 0x0078, /* HIRAGANA LETTER SA */ 0x3055],
    KeyC: [/* LATIN CAPITAL LETTER C */ 0x0043, /* LATIN SMALL LETTER C */ 0x0063, /* HIRAGANA LETTER SO */ 0x305d],
    KeyV: [/* LATIN CAPITAL LETTER V */ 0x0056, /* LATIN SMALL LETTER V */ 0x0076, /* HIRAGANA LETTER HI */ 0x3072],
    KeyB: [/* LATIN CAPITAL LETTER B */ 0x0042, /* LATIN SMALL LETTER B */ 0x0062, /* HIRAGANA LETTER KO */ 0x3053],
    KeyN: [/* LATIN CAPITAL LETTER N */ 0x004e, /* LATIN SMALL LETTER N */ 0x006e, /* HIRAGANA LETTER MI */ 0x307f],
    KeyM: [/* LATIN CAPITAL LETTER M */ 0x004d, /* LATIN SMALL LETTER M */ 0x006d, /* HIRAGANA LETTER MO */ 0x3082],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c, /* HIRAGANA LETTER NE */ 0x306d, /* GRAVE ACCENT */ 0x0060],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e, /* HIRAGANA LETTER RU */ 0x308b, /* WHITE CIRCLE */ 0x25cb],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f, /* HIRAGANA LETTER ME */ 0x3081, /* BLACK CIRCLE */ 0x25cf],
    IntlRo: [/* REVERSE SOLIDUS */ 0x005c, /* HIRAGANA LETTER RO */ 0x308d],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/lt_lt.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_LT_LT = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e, /* ACUTE ACCENT */ 0x00b4],
    Digit1: [/* EXCLAMATION MARK */ 0x0021, /* DIGIT ONE */ 0x0031, /* COMMERCIAL AT */ 0x0040],
    Digit2: [/* HYPHEN-MINUS */ 0x002d, /* DIGIT TWO */ 0x0032, /* LOW LINE */ 0x005f],
    Digit3: [/* SOLIDUS */ 0x002f, /* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* SEMICOLON */ 0x003b, /* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* COLON */ 0x003a, /* DIGIT FIVE */ 0x0035, /* SECTION SIGN */ 0x00a7],
    Digit6: [/* COMMA */ 0x002c, /* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* FULL STOP */ 0x002e, /* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* EQUALS SIGN */ 0x003d, /* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* LEFT PARENTHESIS */ 0x0028, /* DIGIT NINE */ 0x0039, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit0: [/* RIGHT PARENTHESIS */ 0x0029, /* DIGIT ZERO */ 0x0030, /* RIGHT SQUARE BRACKET */ 0x005d],
    Minus: [/* QUESTION MARK */ 0x003f, /* PLUS SIGN */ 0x002b, /* APOSTROPHE */ 0x0027],
    Equal: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* PERCENT SIGN */ 0x0025],
    KeyQ: [/* LATIN SMALL LETTER A WITH OGONEK */ 0x0105, /* LATIN CAPITAL LETTER A WITH OGONEK */ 0x0104],
    KeyW: [/* LATIN SMALL LETTER Z WITH CARON */ 0x017e, /* LATIN CAPITAL LETTER Z WITH CARON */ 0x017d],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER I WITH OGONEK */ 0x012f, /* LATIN CAPITAL LETTER I WITH OGONEK */ 0x012e, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER S WITH CARON */ 0x0161, /* LATIN CAPITAL LETTER S WITH CARON */ 0x0160],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER U WITH OGONEK */ 0x0173, /* LATIN CAPITAL LETTER U WITH OGONEK */ 0x0172],
    Quote: [/* LATIN SMALL LETTER E WITH DOT ABOVE */ 0x0117, /* LATIN CAPITAL LETTER E WITH DOT ABOVE */ 0x0116, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* EN DASH */ 0x2013],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER U WITH MACRON */ 0x016b, /* LATIN CAPITAL LETTER U WITH MACRON */ 0x016a],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* LATIN SMALL LETTER C WITH CARON */ 0x010d, /* LATIN CAPITAL LETTER C WITH CARON */ 0x010c, /* DOUBLE LOW-9 QUOTATION MARK */ 0x201e],
    Period: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* LEFT DOUBLE QUOTATION MARK */ 0x201c],
    Slash: [/* LATIN SMALL LETTER E WITH OGONEK */ 0x0119, /* LATIN CAPITAL LETTER E WITH OGONEK */ 0x0118, /* REVERSE SOLIDUS */ 0x005c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/nb_kvikk.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_NB_KVIKK = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyW: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyE: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyR: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyT: [/* LATIN SMALL LETTER O WITH STROKE */ 0x00f8, /* LATIN CAPITAL LETTER O WITH STROKE */ 0x00d8],
    KeyY: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyU: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyI: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyO: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyP: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    BracketLeft: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyA: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    KeyS: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyF: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyG: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyH: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyJ: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyK: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyL: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    Semicolon: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    Quote: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyC: [/* LATIN SMALL LETTER A WITH RING ABOVE */ 0x00e5, /* LATIN CAPITAL LETTER A WITH RING ABOVE */ 0x00c5],
    KeyV: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyB: [/* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    KeyN: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyM: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/nb_no.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_NB_NO = {
    Backquote: [/* VERTICAL LINE */ 0x007c, /* SECTION SIGN */ 0x00a7],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* CURRENCY SIGN */ 0x00a4, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* EURO SIGN */ 0x20ac],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* LEFT CURLY BRACKET */ 0x007b],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT SQUARE BRACKET */ 0x005d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* PLUS SIGN */ 0x002b, /* QUESTION MARK */ 0x003f],
    Equal: [/* REVERSE SOLIDUS */ 0x005c, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER A WITH RING ABOVE */ 0x00e5, /* LATIN CAPITAL LETTER A WITH RING ABOVE */ 0x00c5],
    BracketRight: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    Backslash: [/* APOSTROPHE */ 0x0027, /* ASTERISK */ 0x002a],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER O WITH STROKE */ 0x00f8, /* LATIN CAPITAL LETTER O WITH STROKE */ 0x00d8],
    Quote: [/* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* MICRO SIGN */ 0x00b5],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/nb_skarp.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_NB_SKARP = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyW: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyE: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyR: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyT: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyY: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyU: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyI: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyO: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyP: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    BracketLeft: [/* HYPHEN-MINUS */ 0x002d],
    KeyA: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyS: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyD: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyH: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045],
    KeyL: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    Semicolon: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Quote: [/* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    KeyZ: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    KeyX: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    KeyC: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyV: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyB: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyN: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyM: [/* LATIN SMALL LETTER A WITH RING ABOVE */ 0x00e5, /* LATIN CAPITAL LETTER A WITH RING ABOVE */ 0x00c5],
    Comma: [/* LATIN SMALL LETTER O WITH STROKE */ 0x00f8, /* LATIN CAPITAL LETTER O WITH STROKE */ 0x00d8],
    Period: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    Slash: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/nl_be.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_NL_BE = {
    Backquote: [/* SUPERSCRIPT TWO */ 0x00b2, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit1: [/* AMPERSAND */ 0x0026, /* DIGIT ONE */ 0x0031, /* VERTICAL LINE */ 0x007c],
    Digit2: [/* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* QUOTATION MARK */ 0x0022, /* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* APOSTROPHE */ 0x0027, /* DIGIT FOUR */ 0x0034, /* LEFT CURLY BRACKET */ 0x007b],
    Digit5: [/* LEFT PARENTHESIS */ 0x0028, /* DIGIT FIVE */ 0x0035, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit6: [/* SECTION SIGN */ 0x00a7, /* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* LATIN SMALL LETTER E WITH GRAVE */ 0x00e8, /* DIGIT SEVEN */ 0x0037],
    Digit8: [/* EXCLAMATION MARK */ 0x0021, /* DIGIT EIGHT */ 0x0038],
    Digit9: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* DIGIT NINE */ 0x0039, /* LEFT CURLY BRACKET */ 0x007b],
    Digit0: [/* LATIN SMALL LETTER A WITH GRAVE */ 0x00e0, /* DIGIT ZERO */ 0x0030, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* RIGHT PARENTHESIS */ 0x0029, /* DEGREE SIGN */ 0x00b0],
    Equal: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    KeyQ: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyW: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [{ dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }, /* LEFT SQUARE BRACKET */ 0x005b],
    BracketRight: [/* DOLLAR SIGN */ 0x0024, /* ASTERISK */ 0x002a, /* RIGHT SQUARE BRACKET */ 0x005d],
    Backslash: [/* MICRO SIGN */ 0x00b5, /* POUND SIGN */ 0x00a3, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyA: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Quote: [/* LATIN SMALL LETTER U WITH GRAVE */ 0x00f9, /* PERCENT SIGN */ 0x0025, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* REVERSE SOLIDUS */ 0x005c],
    KeyZ: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* COMMA */ 0x002c, /* QUESTION MARK */ 0x003f],
    Comma: [/* SEMICOLON */ 0x003b, /* FULL STOP */ 0x002e],
    Period: [/* COLON */ 0x003a, /* SOLIDUS */ 0x002f],
    Slash: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, { dead: /* COMBINING TILDE */ 0x0303 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/nl_nl.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_NL_NL = {
    Backquote: [/* COMMERCIAL AT */ 0x0040, /* SECTION SIGN */ 0x00a7, /* NOT SIGN */ 0x00ac],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* SUPERSCRIPT ONE */ 0x00b9],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* VULGAR FRACTION ONE QUARTER */ 0x00bc],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, /* VULGAR FRACTION THREE QUARTERS */ 0x00be],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* LOW LINE */ 0x005f, /* POUND SIGN */ 0x00a3],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT CURLY BRACKET */ 0x007b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT CURLY BRACKET */ 0x007d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* APOSTROPHE */ 0x0027],
    Minus: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f, /* REVERSE SOLIDUS */ 0x005c],
    Equal: [/* DEGREE SIGN */ 0x00b0, { dead: /* COMBINING TILDE */ 0x0303 }, { dead: /* COMBINING CEDILLA */ 0x0327 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052, /* PILCROW SIGN */ 0x00b6],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    BracketRight: [/* ASTERISK */ 0x002a, /* VERTICAL LINE */ 0x007c],
    Backslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER SHARP S */ 0x00df],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* PLUS SIGN */ 0x002b, /* PLUS-MINUS SIGN */ 0x00b1],
    Quote: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    IntlBackslash: [/* RIGHT SQUARE BRACKET */ 0x005d, /* LEFT SQUARE BRACKET */ 0x005b, /* BROKEN BAR */ 0x00a6],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* CENT SIGN */ 0x00a2],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* MICRO SIGN */ 0x00b5],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* MIDDLE DOT */ 0x00b7],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* EQUALS SIGN */ 0x003d],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/pl_fwyr.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_PL_FWYR = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* AMPERSAND */ 0x0026],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* VERTICAL LINE */ 0x007c],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* SOLIDUS */ 0x002f],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    Equal: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyQ: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyW: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyE: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyR: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* LATIN SMALL LETTER O WITH ACUTE */ 0x00f3, /* LATIN CAPITAL LETTER O WITH ACUTE */ 0x00d3],
    KeyT: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    KeyY: [/* HYPHEN-MINUS */ 0x002d, /* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyU: [/* ASTERISK */ 0x002a, /* NUMBER SIGN */ 0x0023, /* MIDDLE DOT */ 0x00b7],
    KeyI: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyO: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyP: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    BracketLeft: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    BracketRight: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    Backslash: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER S WITH ACUTE */ 0x015b, /* LATIN CAPITAL LETTER S WITH ACUTE */ 0x015a],
    KeyA: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyS: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* LATIN SMALL LETTER C WITH ACUTE */ 0x0107, /* LATIN CAPITAL LETTER C WITH ACUTE */ 0x0106],
    KeyD: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049, /* LATIN SMALL LETTER L WITH STROKE */ 0x0142, /* LATIN CAPITAL LETTER L WITH STROKE */ 0x0141],
    KeyF: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* LATIN SMALL LETTER E WITH OGONEK */ 0x0119, /* LATIN CAPITAL LETTER E WITH OGONEK */ 0x0118],
    KeyG: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* LATIN SMALL LETTER N WITH ACUTE */ 0x0144, /* LATIN CAPITAL LETTER N WITH ACUTE */ 0x0143],
    KeyH: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* EXCLAMATION MARK */ 0x0021],
    KeyJ: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* QUESTION MARK */ 0x003f],
    KeyK: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyL: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052, /* LATIN SMALL LETTER Z WITH ACUTE */ 0x017a, /* LATIN CAPITAL LETTER Z WITH ACUTE */ 0x0179],
    Semicolon: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER A WITH OGONEK */ 0x0105, /* LATIN CAPITAL LETTER A WITH OGONEK */ 0x0104],
    Quote: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, /* LATIN SMALL LETTER Z WITH DOT ABOVE */ 0x017c, /* LATIN CAPITAL LETTER Z WITH DOT ABOVE */ 0x017b],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyX: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* LESS-THAN SIGN */ 0x003c],
    KeyC: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* GREATER-THAN SIGN */ 0x003e],
    KeyV: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyB: [/* SOLIDUS */ 0x002f, /* LESS-THAN SIGN */ 0x003c],
    KeyN: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022, /* LOW LINE */ 0x005f],
    KeyM: [/* REVERSE SOLIDUS */ 0x005c, /* GREATER-THAN SIGN */ 0x003e],
    Comma: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Period: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    Slash: [/* FULL STOP */ 0x002e, /* FULL STOP */ 0x002e],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/pl_pl.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_PL_PL = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, { dead: /* COMBINING TILDE */ 0x0303 }],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* LATIN SMALL LETTER E WITH OGONEK */ 0x0119, /* LATIN CAPITAL LETTER E WITH OGONEK */ 0x0118],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* EURO SIGN */ 0x20ac],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f, /* LATIN SMALL LETTER O WITH ACUTE */ 0x00f3, /* LATIN CAPITAL LETTER O WITH ACUTE */ 0x00d3],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER A WITH OGONEK */ 0x0105, /* LATIN CAPITAL LETTER A WITH OGONEK */ 0x0104],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER S WITH ACUTE */ 0x015b, /* LATIN CAPITAL LETTER S WITH ACUTE */ 0x015a],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* LATIN SMALL LETTER L WITH STROKE */ 0x0142, /* LATIN CAPITAL LETTER L WITH STROKE */ 0x0141],
    Semicolon: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Quote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a, /* LATIN SMALL LETTER Z WITH DOT ABOVE */ 0x017c, /* LATIN CAPITAL LETTER Z WITH DOT ABOVE */ 0x017b],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, /* LATIN SMALL LETTER Z WITH ACUTE */ 0x017a, /* LATIN CAPITAL LETTER Z WITH ACUTE */ 0x0179],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* LATIN SMALL LETTER C WITH ACUTE */ 0x0107, /* LATIN CAPITAL LETTER C WITH ACUTE */ 0x0106],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* LATIN SMALL LETTER N WITH ACUTE */ 0x0144, /* LATIN CAPITAL LETTER N WITH ACUTE */ 0x0143],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/pt_br.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_PT_BR = {
    Backquote: [/* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* SUPERSCRIPT ONE */ 0x00b9],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* POUND SIGN */ 0x00a3],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* CENT SIGN */ 0x00a2],
    Digit6: [/* DIGIT SIX */ 0x0036, { dead: /* COMBINING DIAERESIS */ 0x0308 }, /* NOT SIGN */ 0x00ac],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* SECTION SIGN */ 0x00a7],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* SOLIDUS */ 0x002f],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* QUESTION MARK */ 0x003f],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* DEGREE SIGN */ 0x00b0],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    BracketRight: [/* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b, /* FEMININE ORDINAL INDICATOR */ 0x00aa],
    Backslash: [/* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d, /* MASCULINE ORDINAL INDICATOR */ 0x00ba],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7],
    Quote: [{ dead: /* COMBINING TILDE */ 0x0303 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* CRUZEIRO SIGN */ 0x20a2],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    IntlRo: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f, /* DEGREE SIGN */ 0x00b0],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/pt_pt.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_PT_PT = {
    Backquote: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* SECTION SIGN */ 0x00a7],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* EURO SIGN */ 0x20ac],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* LEFT CURLY BRACKET */ 0x007b],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT SQUARE BRACKET */ 0x005d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f],
    Equal: [/* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    BracketRight: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }, /* RIGHT SQUARE BRACKET */ 0x005d],
    Backslash: [{ dead: /* COMBINING TILDE */ 0x0303 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7],
    Quote: [/* MASCULINE ORDINAL INDICATOR */ 0x00ba, /* FEMININE ORDINAL INDICATOR */ 0x00aa],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/ro_ro.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_RO_RO = {
    Backquote: [/* DOUBLE LOW-9 QUOTATION MARK */ 0x201e, /* RIGHT DOUBLE QUOTATION MARK */ 0x201d, /* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, { dead: /* COMBINING TILDE */ 0x0303 }],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040, { dead: /* COMBINING CARON */ 0x030c }],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, { dead: /* COMBINING BREVE */ 0x0306 }],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, { dead: /* COMBINING RING ABOVE */ 0x030a }],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, { dead: /* COMBINING OGONEK */ 0x0328 }],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, { dead: /* COMBINING DOT ABOVE */ 0x0307 }],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029, { dead: /* COMBINING DOUBLE ACUTE ACCENT */ 0x030b }],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, { dead: /* COMBINING DIAERESIS */ 0x0308 }, /* EN DASH */ 0x2013],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, { dead: /* COMBINING CEDILLA */ 0x0327 }, /* PLUS-MINUS SIGN */ 0x00b1],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* SECTION SIGN */ 0x00a7],
    BracketLeft: [/* LATIN SMALL LETTER A WITH BREVE */ 0x0103, /* LATIN CAPITAL LETTER A WITH BREVE */ 0x0102, /* LEFT SQUARE BRACKET */ 0x005b, /* LEFT CURLY BRACKET */ 0x007b],
    BracketRight: [/* LATIN SMALL LETTER I WITH CIRCUMFLEX */ 0x00ee, /* LATIN CAPITAL LETTER I WITH CIRCUMFLEX */ 0x00ce, /* RIGHT SQUARE BRACKET */ 0x005d, /* RIGHT CURLY BRACKET */ 0x007d],
    Backslash: [/* LATIN SMALL LETTER A WITH CIRCUMFLEX */ 0x00e2, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX */ 0x00c2, /* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER SHARP S */ 0x00df],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* LATIN SMALL LETTER D WITH STROKE */ 0x0111, /* LATIN CAPITAL LETTER D WITH STROKE */ 0x0110],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* LATIN SMALL LETTER L WITH STROKE */ 0x0142, /* LATIN CAPITAL LETTER L WITH STROKE */ 0x0141],
    Semicolon: [/* LATIN SMALL LETTER S WITH COMMA BELOW */ 0x0219, /* LATIN CAPITAL LETTER S WITH COMMA BELOW */ 0x0218, /* SEMICOLON */ 0x003b, /* COLON */ 0x003a],
    Quote: [/* LATIN SMALL LETTER T WITH COMMA BELOW */ 0x021b, /* LATIN CAPITAL LETTER T WITH COMMA BELOW */ 0x021a, /* APOSTROPHE */ 0x0027, /* QUOTATION MARK */ 0x0022],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043, /* COPYRIGHT SIGN */ 0x00a9],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* LESS-THAN SIGN */ 0x003c, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* GREATER-THAN SIGN */ 0x003e, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb],
    Slash: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/ru_ru.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_RU_RU = {
    Backquote: [/* CYRILLIC SMALL LETTER IO */ 0x0451, /* CYRILLIC CAPITAL LETTER IO */ 0x0401],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMERO SIGN */ 0x2116],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* SEMICOLON */ 0x003b],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* COLON */ 0x003a],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* QUESTION MARK */ 0x003f],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* RUBLE SIGN */ 0x20bd],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* CYRILLIC SMALL LETTER SHORT I */ 0x0439, /* CYRILLIC CAPITAL LETTER SHORT I */ 0x0419],
    KeyW: [/* CYRILLIC SMALL LETTER TSE */ 0x0446, /* CYRILLIC CAPITAL LETTER TSE */ 0x0426],
    KeyE: [/* CYRILLIC SMALL LETTER U */ 0x0443, /* CYRILLIC CAPITAL LETTER U */ 0x0423],
    KeyR: [/* CYRILLIC SMALL LETTER KA */ 0x043a, /* CYRILLIC CAPITAL LETTER KA */ 0x041a],
    KeyT: [/* CYRILLIC SMALL LETTER IE */ 0x0435, /* CYRILLIC CAPITAL LETTER IE */ 0x0415],
    KeyY: [/* CYRILLIC SMALL LETTER EN */ 0x043d, /* CYRILLIC CAPITAL LETTER EN */ 0x041d],
    KeyU: [/* CYRILLIC SMALL LETTER GHE */ 0x0433, /* CYRILLIC CAPITAL LETTER GHE */ 0x0413],
    KeyI: [/* CYRILLIC SMALL LETTER SHA */ 0x0448, /* CYRILLIC CAPITAL LETTER SHA */ 0x0428],
    KeyO: [/* CYRILLIC SMALL LETTER SHCHA */ 0x0449, /* CYRILLIC CAPITAL LETTER SHCHA */ 0x0429],
    KeyP: [/* CYRILLIC SMALL LETTER ZE */ 0x0437, /* CYRILLIC CAPITAL LETTER ZE */ 0x0417],
    BracketLeft: [/* CYRILLIC SMALL LETTER HA */ 0x0445, /* CYRILLIC CAPITAL LETTER HA */ 0x0425],
    BracketRight: [/* CYRILLIC SMALL LETTER HARD SIGN */ 0x044a, /* CYRILLIC CAPITAL LETTER HARD SIGN */ 0x042a],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* SOLIDUS */ 0x002f],
    KeyA: [/* CYRILLIC SMALL LETTER EF */ 0x0444, /* CYRILLIC CAPITAL LETTER EF */ 0x0424],
    KeyS: [/* CYRILLIC SMALL LETTER YERU */ 0x044b, /* CYRILLIC CAPITAL LETTER YERU */ 0x042b],
    KeyD: [/* CYRILLIC SMALL LETTER VE */ 0x0432, /* CYRILLIC CAPITAL LETTER VE */ 0x0412],
    KeyF: [/* CYRILLIC SMALL LETTER A */ 0x0430, /* CYRILLIC CAPITAL LETTER A */ 0x0410],
    KeyG: [/* CYRILLIC SMALL LETTER PE */ 0x043f, /* CYRILLIC CAPITAL LETTER PE */ 0x041f],
    KeyH: [/* CYRILLIC SMALL LETTER ER */ 0x0440, /* CYRILLIC CAPITAL LETTER ER */ 0x0420],
    KeyJ: [/* CYRILLIC SMALL LETTER O */ 0x043e, /* CYRILLIC CAPITAL LETTER O */ 0x041e],
    KeyK: [/* CYRILLIC SMALL LETTER EL */ 0x043b, /* CYRILLIC CAPITAL LETTER EL */ 0x041b],
    KeyL: [/* CYRILLIC SMALL LETTER DE */ 0x0434, /* CYRILLIC CAPITAL LETTER DE */ 0x0414],
    Semicolon: [/* CYRILLIC SMALL LETTER ZHE */ 0x0436, /* CYRILLIC CAPITAL LETTER ZHE */ 0x0416],
    Quote: [/* CYRILLIC SMALL LETTER E */ 0x044d, /* CYRILLIC CAPITAL LETTER E */ 0x042d],
    IntlBackslash: [/* REVERSE SOLIDUS */ 0x005c, /* SOLIDUS */ 0x002f],
    KeyZ: [/* CYRILLIC SMALL LETTER YA */ 0x044f, /* CYRILLIC CAPITAL LETTER YA */ 0x042f],
    KeyX: [/* CYRILLIC SMALL LETTER CHE */ 0x0447, /* CYRILLIC CAPITAL LETTER CHE */ 0x0427],
    KeyC: [/* CYRILLIC SMALL LETTER ES */ 0x0441, /* CYRILLIC CAPITAL LETTER ES */ 0x0421],
    KeyV: [/* CYRILLIC SMALL LETTER EM */ 0x043c, /* CYRILLIC CAPITAL LETTER EM */ 0x041c],
    KeyB: [/* CYRILLIC SMALL LETTER I */ 0x0438, /* CYRILLIC CAPITAL LETTER I */ 0x0418],
    KeyN: [/* CYRILLIC SMALL LETTER TE */ 0x0442, /* CYRILLIC CAPITAL LETTER TE */ 0x0422],
    KeyM: [/* CYRILLIC SMALL LETTER SOFT SIGN */ 0x044c, /* CYRILLIC CAPITAL LETTER SOFT SIGN */ 0x042c],
    Comma: [/* CYRILLIC SMALL LETTER BE */ 0x0431, /* CYRILLIC CAPITAL LETTER BE */ 0x0411],
    Period: [/* CYRILLIC SMALL LETTER YU */ 0x044e, /* CYRILLIC CAPITAL LETTER YU */ 0x042e],
    Slash: [/* FULL STOP */ 0x002e, /* COMMA */ 0x002c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/sl_si.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_SL_SI = {
    Backquote: [{ dead: /* COMBINING CEDILLA */ 0x0327 }, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* TILDE */ 0x007e],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, { dead: /* COMBINING CARON */ 0x030c }],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, { dead: /* COMBINING BREVE */ 0x0306 }],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, { dead: /* COMBINING RING ABOVE */ 0x030a }],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, { dead: /* COMBINING OGONEK */ 0x0328 }],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* GRAVE ACCENT */ 0x0060],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, { dead: /* COMBINING DOT ABOVE */ 0x0307 }],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, { dead: /* COMBINING DOUBLE ACUTE ACCENT */ 0x030b }],
    Minus: [/* APOSTROPHE */ 0x0027, /* QUESTION MARK */ 0x003f, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    Equal: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, { dead: /* COMBINING CEDILLA */ 0x0327 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* REVERSE SOLIDUS */ 0x005c],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, /* VERTICAL LINE */ 0x007c],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER S WITH CARON */ 0x0161, /* LATIN CAPITAL LETTER S WITH CARON */ 0x0160, /* DIVISION SIGN */ 0x00f7],
    BracketRight: [/* LATIN SMALL LETTER D WITH STROKE */ 0x0111, /* LATIN CAPITAL LETTER D WITH STROKE */ 0x0110, /* MULTIPLICATION SIGN */ 0x00d7],
    Backslash: [/* LATIN SMALL LETTER Z WITH CARON */ 0x017e, /* LATIN CAPITAL LETTER Z WITH CARON */ 0x017d, /* CURRENCY SIGN */ 0x00a4],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* LEFT SQUARE BRACKET */ 0x005b],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047, /* RIGHT SQUARE BRACKET */ 0x005d],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b, /* LATIN SMALL LETTER L WITH STROKE */ 0x0142],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c, /* LATIN CAPITAL LETTER L WITH STROKE */ 0x0141],
    Semicolon: [/* LATIN SMALL LETTER C WITH CARON */ 0x010d, /* LATIN CAPITAL LETTER C WITH CARON */ 0x010c],
    Quote: [/* LATIN SMALL LETTER C WITH ACUTE */ 0x0107, /* LATIN CAPITAL LETTER C WITH ACUTE */ 0x0106, /* LATIN SMALL LETTER SHARP S */ 0x00df],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e],
    KeyZ: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* COMMERCIAL AT */ 0x0040],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* LEFT CURLY BRACKET */ 0x007b],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e, /* RIGHT CURLY BRACKET */ 0x007d],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* SECTION SIGN */ 0x00a7],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* LESS-THAN SIGN */ 0x003c],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* GREATER-THAN SIGN */ 0x003e],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/sv_se.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_SV_SE = {
    Backquote: [/* SECTION SIGN */ 0x00a7, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* COMMERCIAL AT */ 0x0040],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* POUND SIGN */ 0x00a3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* CURRENCY SIGN */ 0x00a4, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* EURO SIGN */ 0x20ac],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* LEFT CURLY BRACKET */ 0x007b],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT SQUARE BRACKET */ 0x005d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* PLUS SIGN */ 0x002b, /* QUESTION MARK */ 0x003f, /* REVERSE SOLIDUS */ 0x005c],
    Equal: [{ dead: /* COMBINING ACUTE ACCENT */ 0x0301 }, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I */ 0x0049],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER A WITH RING ABOVE */ 0x00e5, /* LATIN CAPITAL LETTER A WITH RING ABOVE */ 0x00c5],
    BracketRight: [{ dead: /* COMBINING DIAERESIS */ 0x0308 }, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, { dead: /* COMBINING TILDE */ 0x0303 }],
    Backslash: [/* APOSTROPHE */ 0x0027, /* ASTERISK */ 0x002a],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    Quote: [/* LATIN SMALL LETTER A WITH DIAERESIS */ 0x00e4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */ 0x00c4],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d, /* MICRO SIGN */ 0x00b5],
    Comma: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Slash: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/th_th.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_TH_TH = {
    Backquote: [/* LOW LINE */ 0x005f, /* PERCENT SIGN */ 0x0025],
    Digit1: [/* THAI CHARACTER LAKKHANGYAO */ 0x0e45, /* PLUS SIGN */ 0x002b],
    Digit2: [/* SOLIDUS */ 0x002f, /* THAI DIGIT ONE */ 0x0e51],
    Digit3: [/* HYPHEN-MINUS */ 0x002d, /* THAI DIGIT TWO */ 0x0e52],
    Digit4: [/* THAI CHARACTER PHO SAMPHAO */ 0x0e20, /* THAI DIGIT THREE */ 0x0e53],
    Digit5: [/* THAI CHARACTER THO THUNG */ 0x0e16, /* THAI DIGIT FOUR */ 0x0e54],
    Digit6: [/* THAI CHARACTER SARA U */ 0x0e38, /* THAI CHARACTER SARA UU */ 0x0e39],
    Digit7: [/* THAI CHARACTER SARA UE */ 0x0e36, /* THAI CURRENCY SYMBOL BAHT */ 0x0e3f],
    Digit8: [/* THAI CHARACTER KHO KHWAI */ 0x0e04, /* THAI DIGIT FIVE */ 0x0e55],
    Digit9: [/* THAI CHARACTER TO TAO */ 0x0e15, /* THAI DIGIT SIX */ 0x0e56],
    Digit0: [/* THAI CHARACTER CHO CHAN */ 0x0e08, /* THAI DIGIT SEVEN */ 0x0e57],
    Minus: [/* THAI CHARACTER KHO KHAI */ 0x0e02, /* THAI DIGIT EIGHT */ 0x0e58],
    Equal: [/* THAI CHARACTER CHO CHANG */ 0x0e0a, /* THAI DIGIT NINE */ 0x0e59],
    KeyQ: [/* THAI CHARACTER MAIYAMOK */ 0x0e46, /* THAI DIGIT ZERO */ 0x0e50],
    KeyW: [/* THAI CHARACTER SARA AI MAIMALAI */ 0x0e44, /* QUOTATION MARK */ 0x0022],
    KeyE: [/* THAI CHARACTER SARA AM */ 0x0e33, /* THAI CHARACTER DO CHADA */ 0x0e0e],
    KeyR: [/* THAI CHARACTER PHO PHAN */ 0x0e1e, /* THAI CHARACTER THO NANGMONTHO */ 0x0e11],
    KeyT: [/* THAI CHARACTER SARA A */ 0x0e30, /* THAI CHARACTER THO THONG */ 0x0e18],
    KeyY: [/* THAI CHARACTER MAI HAN-AKAT */ 0x0e31, /* THAI CHARACTER NIKHAHIT */ 0x0e4d],
    KeyU: [/* THAI CHARACTER SARA II */ 0x0e35, /* THAI CHARACTER MAI TRI */ 0x0e4a],
    KeyI: [/* THAI CHARACTER RO RUA */ 0x0e23, /* THAI CHARACTER NO NEN */ 0x0e13],
    KeyO: [/* THAI CHARACTER NO NU */ 0x0e19, /* THAI CHARACTER PAIYANNOI */ 0x0e2f],
    KeyP: [/* THAI CHARACTER YO YAK */ 0x0e22, /* THAI CHARACTER YO YING */ 0x0e0d],
    BracketLeft: [/* THAI CHARACTER BO BAIMAI */ 0x0e1a, /* THAI CHARACTER THO THAN */ 0x0e10],
    BracketRight: [/* THAI CHARACTER LO LING */ 0x0e25, /* COMMA */ 0x002c],
    Backslash: [/* THAI CHARACTER KHO KHUAT */ 0x0e03, /* THAI CHARACTER KHO KHON */ 0x0e05],
    KeyA: [/* THAI CHARACTER FO FAN */ 0x0e1f, /* THAI CHARACTER RU */ 0x0e24],
    KeyS: [/* THAI CHARACTER HO HIP */ 0x0e2b, /* THAI CHARACTER KHO RAKHANG */ 0x0e06],
    KeyD: [/* THAI CHARACTER KO KAI */ 0x0e01, /* THAI CHARACTER TO PATAK */ 0x0e0f],
    KeyF: [/* THAI CHARACTER DO DEK */ 0x0e14, /* THAI CHARACTER SARA O */ 0x0e42],
    KeyG: [/* THAI CHARACTER SARA E */ 0x0e40, /* THAI CHARACTER CHO CHOE */ 0x0e0c],
    KeyH: [/* THAI CHARACTER MAI THO */ 0x0e49, /* THAI CHARACTER MAITAIKHU */ 0x0e47],
    KeyJ: [/* THAI CHARACTER MAI EK */ 0x0e48, /* THAI CHARACTER MAI CHATTAWA */ 0x0e4b],
    KeyK: [/* THAI CHARACTER SARA AA */ 0x0e32, /* THAI CHARACTER SO RUSI */ 0x0e29],
    KeyL: [/* THAI CHARACTER SO SUA */ 0x0e2a, /* THAI CHARACTER SO SALA */ 0x0e28],
    Semicolon: [/* THAI CHARACTER WO WAEN */ 0x0e27, /* THAI CHARACTER SO SO */ 0x0e0b],
    Quote: [/* THAI CHARACTER NGO NGU */ 0x0e07, /* FULL STOP */ 0x002e],
    IntlBackslash: [/* THAI CHARACTER KHO KHUAT */ 0x0e03, /* THAI CHARACTER KHO KHON */ 0x0e05],
    KeyZ: [/* THAI CHARACTER PHO PHUNG */ 0x0e1c, /* LEFT PARENTHESIS */ 0x0028],
    KeyX: [/* THAI CHARACTER PO PLA */ 0x0e1b, /* RIGHT PARENTHESIS */ 0x0029],
    KeyC: [/* THAI CHARACTER SARA AE */ 0x0e41, /* THAI CHARACTER CHO CHING */ 0x0e09],
    KeyV: [/* THAI CHARACTER O ANG */ 0x0e2d, /* THAI CHARACTER HO NOKHUK */ 0x0e2e],
    KeyB: [/* THAI CHARACTER SARA I */ 0x0e34, /* THAI CHARACTER PHINTHU */ 0x0e3a],
    KeyN: [/* THAI CHARACTER SARA UEE */ 0x0e37, /* THAI CHARACTER THANTHAKHAT */ 0x0e4c],
    KeyM: [/* THAI CHARACTER THO THAHAN */ 0x0e17, /* QUESTION MARK */ 0x003f],
    Comma: [/* THAI CHARACTER MO MA */ 0x0e21, /* THAI CHARACTER THO PHUTHAO */ 0x0e12],
    Period: [/* THAI CHARACTER SARA AI MAIMUAN */ 0x0e43, /* THAI CHARACTER LO CHULA */ 0x0e2c],
    Slash: [/* THAI CHARACTER FO FA */ 0x0e1d, /* THAI CHARACTER LU */ 0x0e26],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/th_th_man.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_TH_TH_MAN = {
    Backquote: [/* GRAVE ACCENT */ 0x0060, /* TILDE */ 0x007e],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* THAI DIGIT ONE */ 0x0e51],
    Digit2: [/* DIGIT TWO */ 0x0032, /* COMMERCIAL AT */ 0x0040, /* THAI DIGIT TWO */ 0x0e52],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMBER SIGN */ 0x0023, /* THAI DIGIT THREE */ 0x0e53],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* THAI DIGIT FOUR */ 0x0e54],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* THAI DIGIT FIVE */ 0x0e55],
    Digit6: [/* DIGIT SIX */ 0x0036, /* CIRCUMFLEX ACCENT */ 0x005e, /* THAI DIGIT SIX */ 0x0e56],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* AMPERSAND */ 0x0026, /* THAI DIGIT SEVEN */ 0x0e57],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a, /* THAI DIGIT EIGHT */ 0x0e58],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028, /* THAI DIGIT NINE */ 0x0e59],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029, /* THAI DIGIT ZERO */ 0x0e50],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* DIVISION SIGN */ 0x00f7],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b, /* MULTIPLICATION SIGN */ 0x00d7],
    KeyQ: [/* THAI CHARACTER SARA AI MAIMUAN */ 0x0e43, /* THAI CHARACTER THO PHUTHAO */ 0x0e12],
    KeyW: [/* THAI CHARACTER TO TAO */ 0x0e15, /* THAI CHARACTER TO PATAK */ 0x0e0f],
    KeyE: [/* THAI CHARACTER HO HIP */ 0x0e2b, /* THAI CHARACTER SO SO */ 0x0e0b],
    KeyR: [/* THAI CHARACTER LO LING */ 0x0e25, /* THAI CHARACTER YO YING */ 0x0e0d],
    KeyT: [/* THAI CHARACTER SO SUA */ 0x0e2a, /* THAI CHARACTER FO FAN */ 0x0e1f],
    KeyY: [/* THAI CHARACTER PO PLA */ 0x0e1b, /* THAI CHARACTER CHO CHING */ 0x0e09],
    KeyU: [/* THAI CHARACTER MAI HAN-AKAT */ 0x0e31, /* THAI CHARACTER SARA UE */ 0x0e36],
    KeyI: [/* THAI CHARACTER KO KAI */ 0x0e01, /* THAI CHARACTER THO THONG */ 0x0e18],
    KeyO: [/* THAI CHARACTER SARA I */ 0x0e34, /* THAI CHARACTER THO THAN */ 0x0e10],
    KeyP: [/* THAI CHARACTER BO BAIMAI */ 0x0e1a, /* THAI CHARACTER DO CHADA */ 0x0e0e],
    BracketLeft: [/* THAI CHARACTER MAITAIKHU */ 0x0e47, /* THAI CHARACTER KHO RAKHANG */ 0x0e06],
    BracketRight: [/* THAI CHARACTER LO CHULA */ 0x0e2c, /* THAI CHARACTER THO NANGMONTHO */ 0x0e11],
    Backslash: [/* THAI CHARACTER PAIYANNOI */ 0x0e2f, /* THAI CHARACTER CHO CHOE */ 0x0e0c],
    KeyA: [/* THAI CHARACTER NGO NGU */ 0x0e07, /* THAI CHARACTER SO RUSI */ 0x0e29],
    KeyS: [/* THAI CHARACTER SARA E */ 0x0e40, /* THAI CHARACTER THO THUNG */ 0x0e16],
    KeyD: [/* THAI CHARACTER RO RUA */ 0x0e23, /* THAI CHARACTER SARA AE */ 0x0e41],
    KeyF: [/* THAI CHARACTER NO NU */ 0x0e19, /* THAI CHARACTER CHO CHANG */ 0x0e0a],
    KeyG: [/* THAI CHARACTER MO MA */ 0x0e21, /* THAI CHARACTER PHO PHAN */ 0x0e1e],
    KeyH: [/* THAI CHARACTER O ANG */ 0x0e2d, /* THAI CHARACTER PHO PHUNG */ 0x0e1c],
    KeyJ: [/* THAI CHARACTER SARA AA */ 0x0e32, /* THAI CHARACTER SARA AM */ 0x0e33, /* THAI CHARACTER LAKKHANGYAO */ 0x0e45],
    KeyK: [/* THAI CHARACTER MAI EK */ 0x0e48, /* THAI CHARACTER KHO KHAI */ 0x0e02, /* THAI CHARACTER KHO KHUAT */ 0x0e03],
    KeyL: [/* THAI CHARACTER MAI THO */ 0x0e49, /* THAI CHARACTER SARA O */ 0x0e42],
    Semicolon: [/* THAI CHARACTER WO WAEN */ 0x0e27, /* THAI CHARACTER PHO SAMPHAO */ 0x0e20],
    Quote: [/* THAI CHARACTER SARA UEE */ 0x0e37, /* QUOTATION MARK */ 0x0022],
    KeyZ: [/* THAI CHARACTER SARA U */ 0x0e38, /* THAI CHARACTER RU */ 0x0e24, /* THAI CHARACTER LU */ 0x0e26],
    KeyX: [/* THAI CHARACTER SARA AI MAIMALAI */ 0x0e44, /* THAI CHARACTER FO FA */ 0x0e1d],
    KeyC: [/* THAI CHARACTER THO THAHAN */ 0x0e17, /* THAI CHARACTER MAIYAMOK */ 0x0e46],
    KeyV: [/* THAI CHARACTER YO YAK */ 0x0e22, /* THAI CHARACTER NO NEN */ 0x0e13],
    KeyB: [/* THAI CHARACTER CHO CHAN */ 0x0e08, /* THAI CHARACTER MAI TRI */ 0x0e4a],
    KeyN: [/* THAI CHARACTER KHO KHWAI */ 0x0e04, /* THAI CHARACTER MAI CHATTAWA */ 0x0e4b, /* THAI CHARACTER KHO KHON */ 0x0e05],
    KeyM: [/* THAI CHARACTER SARA II */ 0x0e35, /* THAI CHARACTER THANTHAKHAT */ 0x0e4c],
    Comma: [/* THAI CHARACTER DO DEK */ 0x0e14, /* THAI CHARACTER SO SALA */ 0x0e28],
    Period: [/* THAI CHARACTER SARA A */ 0x0e30, /* THAI CHARACTER HO NOKHUK */ 0x0e2e],
    Slash: [/* THAI CHARACTER SARA UU */ 0x0e39, /* QUESTION MARK */ 0x003f],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/th_th_pat.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_TH_TH_PAT = {
    Backquote: [/* LOW LINE */ 0x005f, /* THAI CURRENCY SYMBOL BAHT */ 0x0e3f],
    Digit1: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    Digit2: [/* THAI DIGIT TWO */ 0x0e52, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* THAI DIGIT THREE */ 0x0e53, /* SOLIDUS */ 0x002f],
    Digit4: [/* THAI DIGIT FOUR */ 0x0e54, /* COMMA */ 0x002c],
    Digit5: [/* THAI DIGIT FIVE */ 0x0e55, /* QUESTION MARK */ 0x003f],
    Digit6: [/* THAI CHARACTER SARA UU */ 0x0e39, /* THAI CHARACTER SARA U */ 0x0e38],
    Digit7: [/* THAI DIGIT SEVEN */ 0x0e57, /* LOW LINE */ 0x005f],
    Digit8: [/* THAI DIGIT EIGHT */ 0x0e58, /* FULL STOP */ 0x002e],
    Digit9: [/* THAI DIGIT NINE */ 0x0e59, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* THAI DIGIT ZERO */ 0x0e50, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* THAI DIGIT ONE */ 0x0e51, /* HYPHEN-MINUS */ 0x002d],
    Equal: [/* THAI DIGIT SIX */ 0x0e56, /* PERCENT SIGN */ 0x0025],
    KeyQ: [/* THAI CHARACTER MAITAIKHU */ 0x0e47, /* THAI CHARACTER MAI TRI */ 0x0e4a],
    KeyW: [/* THAI CHARACTER TO TAO */ 0x0e15, /* THAI CHARACTER RU */ 0x0e24],
    KeyE: [/* THAI CHARACTER YO YAK */ 0x0e22, /* THAI CHARACTER MAIYAMOK */ 0x0e46],
    KeyR: [/* THAI CHARACTER O ANG */ 0x0e2d, /* THAI CHARACTER YO YING */ 0x0e0d],
    KeyT: [/* THAI CHARACTER RO RUA */ 0x0e23, /* THAI CHARACTER SO RUSI */ 0x0e29],
    KeyY: [/* THAI CHARACTER MAI EK */ 0x0e48, /* THAI CHARACTER SARA UE */ 0x0e36],
    KeyU: [/* THAI CHARACTER DO DEK */ 0x0e14, /* THAI CHARACTER FO FA */ 0x0e1d],
    KeyI: [/* THAI CHARACTER MO MA */ 0x0e21, /* THAI CHARACTER SO SO */ 0x0e0b],
    KeyO: [/* THAI CHARACTER WO WAEN */ 0x0e27, /* THAI CHARACTER THO THUNG */ 0x0e16],
    KeyP: [/* THAI CHARACTER SARA AE */ 0x0e41, /* THAI CHARACTER THO PHUTHAO */ 0x0e12],
    BracketLeft: [/* THAI CHARACTER SARA AI MAIMUAN */ 0x0e43, /* THAI CHARACTER PAIYANNOI */ 0x0e2f],
    BracketRight: [/* THAI CHARACTER CHO CHOE */ 0x0e0c, /* THAI CHARACTER LU */ 0x0e26],
    Backslash: [/* Private Use */ 0xf8c7, /* THAI CHARACTER NIKHAHIT */ 0x0e4d],
    KeyA: [/* THAI CHARACTER MAI THO */ 0x0e49, /* THAI CHARACTER MAI CHATTAWA */ 0x0e4b],
    KeyS: [/* THAI CHARACTER THO THAHAN */ 0x0e17, /* THAI CHARACTER THO THONG */ 0x0e18],
    KeyD: [/* THAI CHARACTER NGO NGU */ 0x0e07, /* THAI CHARACTER SARA AM */ 0x0e33],
    KeyF: [/* THAI CHARACTER KO KAI */ 0x0e01, /* THAI CHARACTER NO NEN */ 0x0e13],
    KeyG: [/* THAI CHARACTER MAI HAN-AKAT */ 0x0e31, /* THAI CHARACTER THANTHAKHAT */ 0x0e4c],
    KeyH: [/* THAI CHARACTER SARA II */ 0x0e35, /* THAI CHARACTER SARA UEE */ 0x0e37],
    KeyJ: [/* THAI CHARACTER SARA AA */ 0x0e32, /* THAI CHARACTER PHO PHUNG */ 0x0e1c],
    KeyK: [/* THAI CHARACTER NO NU */ 0x0e19, /* THAI CHARACTER CHO CHANG */ 0x0e0a],
    KeyL: [/* THAI CHARACTER SARA E */ 0x0e40, /* THAI CHARACTER SARA O */ 0x0e42],
    Semicolon: [/* THAI CHARACTER SARA AI MAIMALAI */ 0x0e44, /* THAI CHARACTER KHO RAKHANG */ 0x0e06],
    Quote: [/* THAI CHARACTER KHO KHAI */ 0x0e02, /* THAI CHARACTER THO NANGMONTHO */ 0x0e11],
    IntlBackslash: [/* Private Use */ 0xf8c7, /* THAI CHARACTER NIKHAHIT */ 0x0e4d],
    KeyZ: [/* THAI CHARACTER BO BAIMAI */ 0x0e1a, /* THAI CHARACTER DO CHADA */ 0x0e0e],
    KeyX: [/* THAI CHARACTER PO PLA */ 0x0e1b, /* THAI CHARACTER TO PATAK */ 0x0e0f],
    KeyC: [/* THAI CHARACTER LO LING */ 0x0e25, /* THAI CHARACTER THO THAN */ 0x0e10],
    KeyV: [/* THAI CHARACTER HO HIP */ 0x0e2b, /* THAI CHARACTER PHO SAMPHAO */ 0x0e20],
    KeyB: [/* THAI CHARACTER SARA I */ 0x0e34, /* THAI CHARACTER MAI HAN-AKAT */ 0x0e31],
    KeyN: [/* THAI CHARACTER KHO KHWAI */ 0x0e04, /* THAI CHARACTER SO SALA */ 0x0e28],
    KeyM: [/* THAI CHARACTER SO SUA */ 0x0e2a, /* THAI CHARACTER HO NOKHUK */ 0x0e2e],
    Comma: [/* THAI CHARACTER SARA A */ 0x0e30, /* THAI CHARACTER FO FAN */ 0x0e1f],
    Period: [/* THAI CHARACTER CHO CHAN */ 0x0e08, /* THAI CHARACTER CHO CHING */ 0x0e09],
    Slash: [/* THAI CHARACTER PHO PHAN */ 0x0e1e, /* THAI CHARACTER LO CHULA */ 0x0e2c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/tr_tr_f.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_TR_TR_F = {
    Backquote: [/* PLUS SIGN */ 0x002b, /* ASTERISK */ 0x002a, /* NOT SIGN */ 0x00ac],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* SUPERSCRIPT ONE */ 0x00b9, /* INVERTED EXCLAMATION MARK */ 0x00a1],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022, /* SUPERSCRIPT TWO */ 0x00b2],
    Digit3: [/* DIGIT THREE */ 0x0033, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* NUMBER SIGN */ 0x0023, /* SUPERSCRIPT THREE */ 0x00b3],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* DOLLAR SIGN */ 0x0024, /* VULGAR FRACTION ONE QUARTER */ 0x00bc, /* CURRENCY SIGN */ 0x00a4],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026, /* VULGAR FRACTION THREE QUARTERS */ 0x00be],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* APOSTROPHE */ 0x0027, /* LEFT CURLY BRACKET */ 0x007b],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT SQUARE BRACKET */ 0x005d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* SOLIDUS */ 0x002f, /* QUESTION MARK */ 0x003f, /* REVERSE SOLIDUS */ 0x005c, /* INVERTED QUESTION MARK */ 0x00bf],
    Equal: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* VERTICAL LINE */ 0x007c],
    KeyQ: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046, /* COMMERCIAL AT */ 0x0040],
    KeyW: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyE: [/* LATIN SMALL LETTER G WITH BREVE */ 0x011f, /* LATIN CAPITAL LETTER G WITH BREVE */ 0x011e],
    KeyR: [/* LATIN SMALL LETTER DOTLESS I */ 0x0131, /* LATIN CAPITAL LETTER I */ 0x0049, /* PILCROW SIGN */ 0x00b6, /* REGISTERED SIGN */ 0x00ae],
    KeyT: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyY: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044, /* YEN SIGN */ 0x00a5],
    KeyU: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyI: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyO: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048, /* LATIN SMALL LETTER O WITH STROKE */ 0x00f8, /* LATIN CAPITAL LETTER O WITH STROKE */ 0x00d8],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050, /* POUND SIGN */ 0x00a3],
    BracketLeft: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    BracketRight: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057, { dead: /* COMBINING TILDE */ 0x0303 }],
    Backslash: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyA: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055, /* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    KeyS: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I WITH DOT ABOVE */ 0x0130, /* LATIN SMALL LETTER SHARP S */ 0x00df, /* SECTION SIGN */ 0x00a7],
    KeyD: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyF: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, null, /* FEMININE ORDINAL INDICATOR */ 0x00aa],
    KeyG: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc],
    KeyH: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054, /* TURKISH LIRA SIGN */ 0x20ba],
    KeyJ: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyK: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Quote: [/* LATIN SMALL LETTER S WITH CEDILLA */ 0x015f, /* LATIN CAPITAL LETTER S WITH CEDILLA */ 0x015e],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* VERTICAL LINE */ 0x007c, /* BROKEN BAR */ 0x00a6],
    KeyZ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00ab, /* LESS-THAN SIGN */ 0x003c],
    KeyX: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ 0x00bb, /* GREATER-THAN SIGN */ 0x003e],
    KeyC: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056, /* CENT SIGN */ 0x00a2, /* COPYRIGHT SIGN */ 0x00a9],
    KeyV: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyB: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7],
    KeyN: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyM: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* MICRO SIGN */ 0x00b5, /* MASCULINE ORDINAL INDICATOR */ 0x00ba],
    Comma: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042, /* MULTIPLICATION SIGN */ 0x00d7],
    Period: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a, /* DIVISION SIGN */ 0x00f7],
    Slash: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, /* SOFT HYPHEN */ 0x00ad],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/tr_tr_q.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_TR_TR_Q = {
    Backquote: [/* QUOTATION MARK */ 0x0022, /* LATIN SMALL LETTER E WITH ACUTE */ 0x00e9, /* LESS-THAN SIGN */ 0x003c],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021, /* GREATER-THAN SIGN */ 0x003e],
    Digit2: [/* DIGIT TWO */ 0x0032, /* APOSTROPHE */ 0x0027, /* POUND SIGN */ 0x00a3],
    Digit3: [/* DIGIT THREE */ 0x0033, { dead: /* COMBINING CIRCUMFLEX ACCENT */ 0x0302 }, /* NUMBER SIGN */ 0x0023],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* PLUS SIGN */ 0x002b, /* DOLLAR SIGN */ 0x0024],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025, /* VULGAR FRACTION ONE HALF */ 0x00bd],
    Digit6: [/* DIGIT SIX */ 0x0036, /* AMPERSAND */ 0x0026],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* SOLIDUS */ 0x002f, /* LEFT CURLY BRACKET */ 0x007b],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* LEFT PARENTHESIS */ 0x0028, /* LEFT SQUARE BRACKET */ 0x005b],
    Digit9: [/* DIGIT NINE */ 0x0039, /* RIGHT PARENTHESIS */ 0x0029, /* RIGHT SQUARE BRACKET */ 0x005d],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* EQUALS SIGN */ 0x003d, /* RIGHT CURLY BRACKET */ 0x007d],
    Minus: [/* ASTERISK */ 0x002a, /* QUESTION MARK */ 0x003f, /* REVERSE SOLIDUS */ 0x005c],
    Equal: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f, /* VERTICAL LINE */ 0x007c],
    KeyQ: [/* LATIN SMALL LETTER Q */ 0x0071, /* LATIN CAPITAL LETTER Q */ 0x0051, /* COMMERCIAL AT */ 0x0040],
    KeyW: [/* LATIN SMALL LETTER W */ 0x0077, /* LATIN CAPITAL LETTER W */ 0x0057],
    KeyE: [/* LATIN SMALL LETTER E */ 0x0065, /* LATIN CAPITAL LETTER E */ 0x0045, /* EURO SIGN */ 0x20ac],
    KeyR: [/* LATIN SMALL LETTER R */ 0x0072, /* LATIN CAPITAL LETTER R */ 0x0052],
    KeyT: [/* LATIN SMALL LETTER T */ 0x0074, /* LATIN CAPITAL LETTER T */ 0x0054, /* TURKISH LIRA SIGN */ 0x20ba],
    KeyY: [/* LATIN SMALL LETTER Y */ 0x0079, /* LATIN CAPITAL LETTER Y */ 0x0059],
    KeyU: [/* LATIN SMALL LETTER U */ 0x0075, /* LATIN CAPITAL LETTER U */ 0x0055],
    KeyI: [/* LATIN SMALL LETTER DOTLESS I */ 0x0131, /* LATIN CAPITAL LETTER I */ 0x0049, /* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I WITH DOT ABOVE */ 0x0130],
    KeyO: [/* LATIN SMALL LETTER O */ 0x006f, /* LATIN CAPITAL LETTER O */ 0x004f],
    KeyP: [/* LATIN SMALL LETTER P */ 0x0070, /* LATIN CAPITAL LETTER P */ 0x0050],
    BracketLeft: [/* LATIN SMALL LETTER G WITH BREVE */ 0x011f, /* LATIN CAPITAL LETTER G WITH BREVE */ 0x011e, { dead: /* COMBINING DIAERESIS */ 0x0308 }],
    BracketRight: [/* LATIN SMALL LETTER U WITH DIAERESIS */ 0x00fc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */ 0x00dc, { dead: /* COMBINING TILDE */ 0x0303 }],
    Backslash: [/* COMMA */ 0x002c, /* SEMICOLON */ 0x003b, { dead: /* COMBINING GRAVE ACCENT */ 0x0300 }],
    KeyA: [/* LATIN SMALL LETTER A */ 0x0061, /* LATIN CAPITAL LETTER A */ 0x0041, /* LATIN SMALL LETTER AE */ 0x00e6, /* LATIN CAPITAL LETTER AE */ 0x00c6],
    KeyS: [/* LATIN SMALL LETTER S */ 0x0073, /* LATIN CAPITAL LETTER S */ 0x0053, /* LATIN SMALL LETTER SHARP S */ 0x00df],
    KeyD: [/* LATIN SMALL LETTER D */ 0x0064, /* LATIN CAPITAL LETTER D */ 0x0044],
    KeyF: [/* LATIN SMALL LETTER F */ 0x0066, /* LATIN CAPITAL LETTER F */ 0x0046],
    KeyG: [/* LATIN SMALL LETTER G */ 0x0067, /* LATIN CAPITAL LETTER G */ 0x0047],
    KeyH: [/* LATIN SMALL LETTER H */ 0x0068, /* LATIN CAPITAL LETTER H */ 0x0048],
    KeyJ: [/* LATIN SMALL LETTER J */ 0x006a, /* LATIN CAPITAL LETTER J */ 0x004a],
    KeyK: [/* LATIN SMALL LETTER K */ 0x006b, /* LATIN CAPITAL LETTER K */ 0x004b],
    KeyL: [/* LATIN SMALL LETTER L */ 0x006c, /* LATIN CAPITAL LETTER L */ 0x004c],
    Semicolon: [/* LATIN SMALL LETTER S WITH CEDILLA */ 0x015f, /* LATIN CAPITAL LETTER S WITH CEDILLA */ 0x015e, { dead: /* COMBINING ACUTE ACCENT */ 0x0301 }],
    Quote: [/* LATIN SMALL LETTER I */ 0x0069, /* LATIN CAPITAL LETTER I WITH DOT ABOVE */ 0x0130],
    IntlBackslash: [/* LESS-THAN SIGN */ 0x003c, /* GREATER-THAN SIGN */ 0x003e, /* VERTICAL LINE */ 0x007c],
    KeyZ: [/* LATIN SMALL LETTER Z */ 0x007a, /* LATIN CAPITAL LETTER Z */ 0x005a],
    KeyX: [/* LATIN SMALL LETTER X */ 0x0078, /* LATIN CAPITAL LETTER X */ 0x0058],
    KeyC: [/* LATIN SMALL LETTER C */ 0x0063, /* LATIN CAPITAL LETTER C */ 0x0043],
    KeyV: [/* LATIN SMALL LETTER V */ 0x0076, /* LATIN CAPITAL LETTER V */ 0x0056],
    KeyB: [/* LATIN SMALL LETTER B */ 0x0062, /* LATIN CAPITAL LETTER B */ 0x0042],
    KeyN: [/* LATIN SMALL LETTER N */ 0x006e, /* LATIN CAPITAL LETTER N */ 0x004e],
    KeyM: [/* LATIN SMALL LETTER M */ 0x006d, /* LATIN CAPITAL LETTER M */ 0x004d],
    Comma: [/* LATIN SMALL LETTER O WITH DIAERESIS */ 0x00f6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */ 0x00d6],
    Period: [/* LATIN SMALL LETTER C WITH CEDILLA */ 0x00e7, /* LATIN CAPITAL LETTER C WITH CEDILLA */ 0x00c7],
    Slash: [/* FULL STOP */ 0x002e, /* COLON */ 0x003a],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/layout/uk_ua.ts
// Generated file, do not edit.
// prettier-ignore
const LAYOUT_UK_UA = {
    Backquote: [/* CYRILLIC SMALL LETTER IO */ 0x0451, /* CYRILLIC CAPITAL LETTER IO */ 0x0401],
    Digit1: [/* DIGIT ONE */ 0x0031, /* EXCLAMATION MARK */ 0x0021],
    Digit2: [/* DIGIT TWO */ 0x0032, /* QUOTATION MARK */ 0x0022],
    Digit3: [/* DIGIT THREE */ 0x0033, /* NUMERO SIGN */ 0x2116],
    Digit4: [/* DIGIT FOUR */ 0x0034, /* SEMICOLON */ 0x003b],
    Digit5: [/* DIGIT FIVE */ 0x0035, /* PERCENT SIGN */ 0x0025],
    Digit6: [/* DIGIT SIX */ 0x0036, /* COLON */ 0x003a],
    Digit7: [/* DIGIT SEVEN */ 0x0037, /* QUESTION MARK */ 0x003f],
    Digit8: [/* DIGIT EIGHT */ 0x0038, /* ASTERISK */ 0x002a],
    Digit9: [/* DIGIT NINE */ 0x0039, /* LEFT PARENTHESIS */ 0x0028],
    Digit0: [/* DIGIT ZERO */ 0x0030, /* RIGHT PARENTHESIS */ 0x0029],
    Minus: [/* HYPHEN-MINUS */ 0x002d, /* LOW LINE */ 0x005f],
    Equal: [/* EQUALS SIGN */ 0x003d, /* PLUS SIGN */ 0x002b],
    KeyQ: [/* CYRILLIC SMALL LETTER SHORT I */ 0x0439, /* CYRILLIC CAPITAL LETTER SHORT I */ 0x0419],
    KeyW: [/* CYRILLIC SMALL LETTER TSE */ 0x0446, /* CYRILLIC CAPITAL LETTER TSE */ 0x0426],
    KeyE: [/* CYRILLIC SMALL LETTER U */ 0x0443, /* CYRILLIC CAPITAL LETTER U */ 0x0423],
    KeyR: [/* CYRILLIC SMALL LETTER KA */ 0x043a, /* CYRILLIC CAPITAL LETTER KA */ 0x041a],
    KeyT: [/* CYRILLIC SMALL LETTER IE */ 0x0435, /* CYRILLIC CAPITAL LETTER IE */ 0x0415],
    KeyY: [/* CYRILLIC SMALL LETTER EN */ 0x043d, /* CYRILLIC CAPITAL LETTER EN */ 0x041d],
    KeyU: [/* CYRILLIC SMALL LETTER GHE */ 0x0433, /* CYRILLIC CAPITAL LETTER GHE */ 0x0413, /* CYRILLIC SMALL LETTER GHE WITH UPTURN */ 0x0491, /* CYRILLIC CAPITAL LETTER GHE WITH UPTURN */ 0x0490],
    KeyI: [/* CYRILLIC SMALL LETTER SHA */ 0x0448, /* CYRILLIC CAPITAL LETTER SHA */ 0x0428],
    KeyO: [/* CYRILLIC SMALL LETTER SHCHA */ 0x0449, /* CYRILLIC CAPITAL LETTER SHCHA */ 0x0429],
    KeyP: [/* CYRILLIC SMALL LETTER ZE */ 0x0437, /* CYRILLIC CAPITAL LETTER ZE */ 0x0417],
    BracketLeft: [/* CYRILLIC SMALL LETTER HA */ 0x0445, /* CYRILLIC CAPITAL LETTER HA */ 0x0425],
    BracketRight: [/* CYRILLIC SMALL LETTER YI */ 0x0457, /* CYRILLIC CAPITAL LETTER YI */ 0x0407],
    Backslash: [/* REVERSE SOLIDUS */ 0x005c, /* SOLIDUS */ 0x002f],
    KeyA: [/* CYRILLIC SMALL LETTER EF */ 0x0444, /* CYRILLIC CAPITAL LETTER EF */ 0x0424],
    KeyS: [/* CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */ 0x0456, /* CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */ 0x0406],
    KeyD: [/* CYRILLIC SMALL LETTER VE */ 0x0432, /* CYRILLIC CAPITAL LETTER VE */ 0x0412],
    KeyF: [/* CYRILLIC SMALL LETTER A */ 0x0430, /* CYRILLIC CAPITAL LETTER A */ 0x0410],
    KeyG: [/* CYRILLIC SMALL LETTER PE */ 0x043f, /* CYRILLIC CAPITAL LETTER PE */ 0x041f],
    KeyH: [/* CYRILLIC SMALL LETTER ER */ 0x0440, /* CYRILLIC CAPITAL LETTER ER */ 0x0420],
    KeyJ: [/* CYRILLIC SMALL LETTER O */ 0x043e, /* CYRILLIC CAPITAL LETTER O */ 0x041e],
    KeyK: [/* CYRILLIC SMALL LETTER EL */ 0x043b, /* CYRILLIC CAPITAL LETTER EL */ 0x041b],
    KeyL: [/* CYRILLIC SMALL LETTER DE */ 0x0434, /* CYRILLIC CAPITAL LETTER DE */ 0x0414],
    Semicolon: [/* CYRILLIC SMALL LETTER ZHE */ 0x0436, /* CYRILLIC CAPITAL LETTER ZHE */ 0x0416],
    Quote: [/* CYRILLIC SMALL LETTER UKRAINIAN IE */ 0x0454, /* CYRILLIC CAPITAL LETTER UKRAINIAN IE */ 0x0404],
    IntlBackslash: [/* CYRILLIC SMALL LETTER GHE WITH UPTURN */ 0x0491, /* CYRILLIC CAPITAL LETTER GHE WITH UPTURN */ 0x0490],
    KeyZ: [/* CYRILLIC SMALL LETTER YA */ 0x044f, /* CYRILLIC CAPITAL LETTER YA */ 0x042f],
    KeyX: [/* CYRILLIC SMALL LETTER CHE */ 0x0447, /* CYRILLIC CAPITAL LETTER CHE */ 0x0427],
    KeyC: [/* CYRILLIC SMALL LETTER ES */ 0x0441, /* CYRILLIC CAPITAL LETTER ES */ 0x0421],
    KeyV: [/* CYRILLIC SMALL LETTER EM */ 0x043c, /* CYRILLIC CAPITAL LETTER EM */ 0x041c],
    KeyB: [/* CYRILLIC SMALL LETTER I */ 0x0438, /* CYRILLIC CAPITAL LETTER I */ 0x0418],
    KeyN: [/* CYRILLIC SMALL LETTER TE */ 0x0442, /* CYRILLIC CAPITAL LETTER TE */ 0x0422],
    KeyM: [/* CYRILLIC SMALL LETTER SOFT SIGN */ 0x044c, /* CYRILLIC CAPITAL LETTER SOFT SIGN */ 0x042c],
    Comma: [/* CYRILLIC SMALL LETTER BE */ 0x0431, /* CYRILLIC CAPITAL LETTER BE */ 0x0411],
    Period: [/* CYRILLIC SMALL LETTER YU */ 0x044e, /* CYRILLIC CAPITAL LETTER YU */ 0x042e],
    Slash: [/* FULL STOP */ 0x002e, /* COMMA */ 0x002c],
    Space: [/* SPACE */ 0x0020],
};

;// ./packages/keybr-keyboard/lib/settings.ts





var Emulation;
(function (Emulation) {
    /**
     * No emulation.
     */
    Emulation[Emulation["None"] = 0] = "None";
    /**
     * Assumes that the physical key locations are correct,
     * fixes the character codes.
     */
    Emulation[Emulation["Forward"] = 1] = "Forward";
    /**
     * Assumes that the character codes are correct,
     * fixes the physical key locations.
     * It reverses the effect of layout emulation in hardware.
     */
    Emulation[Emulation["Reverse"] = 2] = "Reverse";
})(Emulation || (Emulation = {}));
const keyboardProps = {
    language: itemProp("keyboard.language", language_Language.ALL, language_Language.EN),
    layout: xitemProp("keyboard.layout", layout_Layout.ALL, layout_Layout.EN_US),
    geometry: itemProp("keyboard.geometry", geometry_Geometry.ALL, geometry_Geometry.ANSI_101),
    zones: itemProp("keyboard.zones", geometry_ZoneMod.ALL, geometry_ZoneMod.STANDARD),
    emulation: enumProp("keyboard.emulation", Emulation, Emulation.Forward),
    colors: booleanProp("keyboard.colors", true),
    pointers: booleanProp("keyboard.pointers", true),
};
class settings_KeyboardOptions {
    static default() {
        return new settings_KeyboardOptions(Language.EN, Layout.EN_US, Geometry.ANSI_101, ZoneMod.STANDARD);
    }
    static from(settings) {
        const language = settings.get(keyboardProps.language);
        const layout = settings.get(keyboardProps.layout);
        const geometry = settings.get(keyboardProps.geometry);
        const zones = settings.get(keyboardProps.zones);
        return settings_KeyboardOptions.default()
            .withLanguage(language)
            .withLayout(layout)
            .withGeometry(geometry)
            .withZones(zones);
    }
    #language;
    #layout;
    #geometry;
    #zones;
    constructor(language, layout, geometry, zones) {
        this.#language = language;
        this.#layout = layout;
        this.#geometry = geometry;
        this.#zones = zones;
    }
    get language() {
        return this.#language;
    }
    get layout() {
        return this.#layout;
    }
    get geometry() {
        return this.#geometry;
    }
    get zones() {
        return this.#zones;
    }
    selectableLanguages() {
        return [...Language.ALL];
    }
    selectableLayouts() {
        return Layout.selectableLayouts(this.#language);
    }
    selectableGeometries() {
        return [...this.#layout.geometries];
    }
    selectableZones() {
        if (this.#layout.mod !== nullMod) {
            return [];
        }
        return [...this.#geometry.zones];
    }
    withLanguage(language) {
        const layout = Layout.selectLayout(language);
        const geometry = Geometry.first(layout.geometries);
        const zones = ZoneMod.first(geometry.zones);
        return new settings_KeyboardOptions(language, //
        layout, geometry, zones);
    }
    withLayout(layout) {
        if (this.#language.script === layout.language.script) {
            const geometry = Geometry.first(layout.geometries);
            const zones = ZoneMod.first(geometry.zones);
            return new settings_KeyboardOptions(this.#language, //
            layout, geometry, zones);
        }
        else {
            return this;
        }
    }
    withGeometry(geometry) {
        if (this.#layout.geometries.has(geometry)) {
            const zones = ZoneMod.first(geometry.zones);
            return new settings_KeyboardOptions(this.#language, //
            this.#layout, geometry, zones);
        }
        else {
            return this;
        }
    }
    withZones(zones) {
        if (this.#layout.mod !== nullMod) {
            return this;
        }
        if (this.#geometry.zones.has(zones)) {
            return new settings_KeyboardOptions(this.#language, this.#layout, this.#geometry, zones);
        }
        else {
            return this;
        }
    }
    save(settings) {
        return settings
            .set(keyboardProps.language, this.#language)
            .set(keyboardProps.layout, this.#layout)
            .set(keyboardProps.geometry, this.#geometry)
            .set(keyboardProps.zones, this.#zones);
    }
}

;// ./packages/keybr-keyboard/lib/load.ts
























































































const layouts = new Map([
    [layout_Layout.AR_SA, LAYOUT_AR_SA],
    [layout_Layout.AR_SA_102, LAYOUT_AR_SA_102],
    [layout_Layout.BE_BY, LAYOUT_BE_BY],
    [layout_Layout.CS_CZ, LAYOUT_CS_CZ],
    [layout_Layout.DE_BONE, LAYOUT_DE_BONE],
    [layout_Layout.DE_CH, LAYOUT_DE_CH],
    [layout_Layout.DE_CMOS, LAYOUT_DE_CMOS],
    [layout_Layout.DE_DE, LAYOUT_DE_DE],
    [layout_Layout.DE_MINE, LAYOUT_DE_MINE],
    [layout_Layout.DE_NEO_2, LAYOUT_DE_NEO_2],
    [layout_Layout.DE_NOTED, LAYOUT_DE_NOTED],
    [layout_Layout.EL_GR, LAYOUT_EL_GR],
    [layout_Layout.EN_CANARY, LAYOUT_EN_CANARY],
    [layout_Layout.EN_CANARY_MATRIX, LAYOUT_EN_CANARY_MATRIX],
    [layout_Layout.EN_COLEMAK, LAYOUT_EN_COLEMAK],
    [layout_Layout.EN_COLEMAK_DH_ANSI, LAYOUT_EN_COLEMAK_DH_ANSI],
    [layout_Layout.EN_COLEMAK_DH_ANSI_WIDE, LAYOUT_EN_COLEMAK_DH_ANSI_WIDE],
    [layout_Layout.EN_COLEMAK_DH_ISO, LAYOUT_EN_COLEMAK_DH_ISO],
    [layout_Layout.EN_COLEMAK_DH_ISO_WIDE, LAYOUT_EN_COLEMAK_DH_ISO_WIDE],
    [layout_Layout.EN_COLEMAK_DH_MATRIX, LAYOUT_EN_COLEMAK_DH_MATRIX],
    [layout_Layout.EN_DVORAK, LAYOUT_EN_DVORAK],
    [layout_Layout.EN_DVORAK_PROG, LAYOUT_EN_DVORAK_PROG],
    [layout_Layout.EN_ENGRAM, LAYOUT_EN_ENGRAM],
    [layout_Layout.EN_GALLIUM, LAYOUT_EN_GALLIUM],
    [layout_Layout.EN_GALLIUM_MATRIX, LAYOUT_EN_GALLIUM_MATRIX],
    [layout_Layout.EN_GRAPHITE, LAYOUT_EN_GRAPHITE],
    [layout_Layout.EN_HALMAK, LAYOUT_EN_HALMAK],
    [layout_Layout.EN_HANDS_DOWN_NEU, LAYOUT_EN_HANDS_DOWN_NEU],
    [layout_Layout.EN_HANDS_DOWN_PROMETHIUM, LAYOUT_EN_HANDS_DOWN_PROMETHIUM],
    [layout_Layout.EN_JP, LAYOUT_JA_JP_JIS],
    [layout_Layout.EN_NERPS, LAYOUT_EN_NERPS],
    [layout_Layout.EN_NERPS_MATRIX, LAYOUT_EN_NERPS_MATRIX],
    [layout_Layout.EN_NORMAN, LAYOUT_EN_NORMAN],
    [layout_Layout.EN_STURDY, LAYOUT_EN_STURDY],
    [layout_Layout.EN_UK, LAYOUT_EN_UK],
    [layout_Layout.EN_US, LAYOUT_EN_US],
    [layout_Layout.EN_WORKMAN, LAYOUT_EN_WORKMAN],
    [layout_Layout.ES_ES, LAYOUT_ES_ES],
    [layout_Layout.ES_MX, LAYOUT_ES_MX],
    [layout_Layout.FA_IR, LAYOUT_FA_IR],
    [layout_Layout.FA_IR_LEGACY, LAYOUT_FA_IR_LEGACY],
    [layout_Layout.FR_BEPO, LAYOUT_FR_BEPO],
    [layout_Layout.FR_CA, LAYOUT_FR_CA],
    [layout_Layout.FR_CH, LAYOUT_FR_CH],
    [layout_Layout.FR_ERGLACE, LAYOUT_FR_ERGLACE],
    [layout_Layout.FR_ERGO_L, LAYOUT_FR_ERGO_L],
    [layout_Layout.FR_FR, LAYOUT_FR_FR],
    [layout_Layout.FR_OPTIMOT_ERGO, LAYOUT_FR_OPTIMOT_ERGO],
    [layout_Layout.HE_IL, LAYOUT_HE_IL],
    [layout_Layout.HE_IL_ARKN, LAYOUT_HE_IL_ARKN],
    [layout_Layout.HU_HU, LAYOUT_HU_HU],
    [layout_Layout.IT_IT, LAYOUT_IT_IT],
    [layout_Layout.LT_LT, LAYOUT_LT_LT],
    [layout_Layout.NB_KVIKK, LAYOUT_NB_KVIKK],
    [layout_Layout.NB_NO, LAYOUT_NB_NO],
    [layout_Layout.NB_SKARP, LAYOUT_NB_SKARP],
    [layout_Layout.NL_BE, LAYOUT_NL_BE],
    [layout_Layout.NL_NL, LAYOUT_NL_NL],
    [layout_Layout.PL_FWYR, LAYOUT_PL_FWYR],
    [layout_Layout.PL_PL, LAYOUT_PL_PL],
    [layout_Layout.PT_BR, LAYOUT_PT_BR],
    [layout_Layout.PT_PT, LAYOUT_PT_PT],
    [layout_Layout.RO_RO, LAYOUT_RO_RO],
    [layout_Layout.RU_RU, LAYOUT_RU_RU],
    [layout_Layout.SL_SI, LAYOUT_SL_SI],
    [layout_Layout.SV_SE, LAYOUT_SV_SE],
    [layout_Layout.TH_MAN, LAYOUT_TH_TH_MAN],
    [layout_Layout.TH_PAT, LAYOUT_TH_TH_PAT],
    [layout_Layout.TH_TH, LAYOUT_TH_TH],
    [layout_Layout.TR_TR_F, LAYOUT_TR_TR_F],
    [layout_Layout.TR_TR_Q, LAYOUT_TR_TR_Q],
    [layout_Layout.UK_UA, LAYOUT_UK_UA],
]);
const geometries = new Map([
    [geometry_Geometry.ANSI_101, ANSI_101],
    [geometry_Geometry.ANSI_101_FULL, ANSI_101_FULL],
    [geometry_Geometry.BRAZILIAN_104, BRAZILIAN_104],
    [geometry_Geometry.BRAZILIAN_104_FULL, BRAZILIAN_104_FULL],
    [geometry_Geometry.ISO_102, ISO_102],
    [geometry_Geometry.ISO_102_FULL, ISO_102_FULL],
    [geometry_Geometry.JAPANESE_106, JAPANESE_106],
    [geometry_Geometry.JAPANESE_106_FULL, JAPANESE_106_FULL],
    [geometry_Geometry.KOREAN_103, KOREAN_103],
    [geometry_Geometry.KOREAN_103_FULL, KOREAN_103_FULL],
    [geometry_Geometry.MATRIX, MATRIX],
]);
function load_loadKeyboard(...args) {
    const { length } = args;
    let options;
    if (length === 1 && (options = args[0]) instanceof KeyboardOptions) {
        return loadImpl(options.layout, options.geometry, options.zones);
    }
    let layout;
    if (length === 1 && (layout = args[0]) instanceof Layout) {
        return loadImpl(layout);
    }
    let geometry;
    if (length === 2 &&
        (layout = args[0]) instanceof Layout &&
        (geometry = args[1]) instanceof Geometry) {
        return loadImpl(layout, geometry);
    }
    throw new TypeError();
}
function loadImpl(layout, geometry = Geometry.first(layout.geometries), zones = ZoneMod.first(geometry.zones)) {
    let characterDict = layouts.get(layout);
    let geometryDict = geometries.get(geometry);
    if (layout.mod === nullMod && zones !== ZoneMod.STANDARD) {
        geometryDict = remapZones(geometryDict, zones.mod);
    }
    return new Keyboard(layout, geometry, characterDict, geometryDict);
}

;// ./packages/keybr-keyboard/lib/context.tsx





const KeyboardContext = (0,react.createContext)(null);
function useKeyboard() {
    const value = useContext(KeyboardContext);
    if (value == null) {
        throw new Error( false
            ? 0
            : undefined);
    }
    return value;
}
function KeyboardProvider({ children, }) {
    const { settings } = useSettings();
    const keyboard = useMemo(() => loadKeyboard(KeyboardOptions.from(settings)), [settings]);
    return (_jsx(KeyboardContext.Provider, { value: keyboard, children: children }));
}

;// ./packages/keybr-keyboard/lib/fakes.ts

function allCodePoints() {
    const begin = 0x0000;
    const end = 0xffff; // For tests, it is enough to have BMP code points only.
    return new (class {
        *[Symbol.iterator]() {
            for (let i = begin; i <= end; i++) {
                yield i;
            }
        }
        get size() {
            return end - begin + 1;
        }
        has(codePoint) {
            if (!isCodePoint(codePoint)) {
                throw new TypeError();
            }
            return codePoint >= begin && codePoint <= end;
        }
        weight(codePoint) {
            if (!isCodePoint(codePoint)) {
                throw new TypeError();
            }
            return 1;
        }
    })();
}
function codePointsFrom(alphabet) {
    const set = new Set(typeof alphabet === "string" ? toCodePoints(alphabet) : alphabet);
    return new (class {
        [Symbol.iterator]() {
            return set[Symbol.iterator]();
        }
        get size() {
            return set.size;
        }
        has(codePoint) {
            if (!isCodePoint(codePoint)) {
                throw new TypeError();
            }
            return set.has(codePoint);
        }
        weight(codePoint) {
            if (!isCodePoint(codePoint)) {
                throw new TypeError();
            }
            return 1;
        }
    })();
}

;// ./packages/keybr-keyboard/lib/filter.ts

/**
 * Removes any illegal characters from the specified text, collapses whitespace.
 */
function filter_filterText(text, set) {
    let result = "";
    let ws = "";
    const append = (codePoint, s = String.fromCodePoint(codePoint)) => {
        if (set.has(codePoint)) {
            if (ws !== "") {
                result += ws;
                ws = "";
            }
            result += s;
            return true;
        }
        return false;
    };
    const space = (char) => {
        if (result !== "" && ws !== "\n") {
            ws = char;
        }
    };
    for (let codePoint of codepoints_toCodePoints(text.normalize())) {
        if (isLinebreak(codePoint)) {
            space("\n");
            continue;
        }
        if (isWhitespace(codePoint)) {
            space(" ");
            continue;
        }
        if (isControl(codePoint)) {
            space(" ");
            continue;
        }
        if (diacritics_isDiacritic(codePoint)) {
            continue;
        }
        if (!append(codePoint)) {
            const a = expand(codePoint);
            if (a != null) {
                for (const letter of a) {
                    append(letter);
                }
                continue;
            }
            const b = replace(codePoint);
            if (b != null) {
                if (!append(b, String.fromCodePoint(codePoint))) {
                    space(" ");
                }
                continue;
            }
            space(" ");
        }
    }
    return result;
}
filter_filterText.normalize = (codePoint) => {
    return replace(codePoint) ?? codePoint;
};

;// ./packages/keybr-keyboard/lib/keycode.ts
var KeyCode;
(function (KeyCode) {
    //
    // Writing System Keys
    //
    /** ` and ~ on a US keyboard. */
    KeyCode[KeyCode["Backquote"] = 0] = "Backquote";
    /** \ and | on a US keyboard. Found only on standard 101-key layouts. */
    KeyCode[KeyCode["Backslash"] = 1] = "Backslash";
    /** Labelled Delete on Macintosh keyboards. */
    KeyCode[KeyCode["Backspace"] = 2] = "Backspace";
    /** [ and { on a US keyboard. */
    KeyCode[KeyCode["BracketLeft"] = 3] = "BracketLeft";
    /** ] and } on a US keyboard. */
    KeyCode[KeyCode["BracketRight"] = 4] = "BracketRight";
    /** , and < on a US keyboard. */
    KeyCode[KeyCode["Comma"] = 5] = "Comma";
    /** 0 and ) on a US keyboard. */
    KeyCode[KeyCode["Digit0"] = 6] = "Digit0";
    /** 1 and ! on a US keyboard. */
    KeyCode[KeyCode["Digit1"] = 7] = "Digit1";
    /** 2 and @ on a US keyboard. */
    KeyCode[KeyCode["Digit2"] = 8] = "Digit2";
    /** 3 and # on a US keyboard. */
    KeyCode[KeyCode["Digit3"] = 9] = "Digit3";
    /** 4 and $ on a US keyboard. */
    KeyCode[KeyCode["Digit4"] = 10] = "Digit4";
    /** 5 and % on a US keyboard. */
    KeyCode[KeyCode["Digit5"] = 11] = "Digit5";
    /** 6 and ^ on a US keyboard. */
    KeyCode[KeyCode["Digit6"] = 12] = "Digit6";
    /** 7 and & on a US keyboard. */
    KeyCode[KeyCode["Digit7"] = 13] = "Digit7";
    /** 8 and * on a US keyboard. */
    KeyCode[KeyCode["Digit8"] = 14] = "Digit8";
    /** 9 and ( on a US keyboard. */
    KeyCode[KeyCode["Digit9"] = 15] = "Digit9";
    /** = and + on a US keyboard. */
    KeyCode[KeyCode["Equal"] = 16] = "Equal";
    /** Located between the ShiftLeft and KeyZ keys. The \ and | key on a UK keyboard. */
    KeyCode[KeyCode["IntlBackslash"] = 17] = "IntlBackslash";
    /** Located between the Quote and Enter keys on row E of the keyboard. The # and ~ key on a UK keyboard. */
    KeyCode[KeyCode["IntlHash"] = 18] = "IntlHash";
    /** Located between the Slash and ShiftRight keys. The \ and  (ro) key on a Japanese keyboard. */
    KeyCode[KeyCode["IntlRo"] = 19] = "IntlRo";
    /** Located between the Equal and Backspace keys. The  (yen) key on a Japanese keyboard. The \ and / key on a Russian keyboard. */
    KeyCode[KeyCode["IntlYen"] = 20] = "IntlYen";
    /** a on a US keyboard. Labelled q on an AZERTY (e.g., French) keyboard. */
    KeyCode[KeyCode["KeyA"] = 21] = "KeyA";
    /** b on a US keyboard. */
    KeyCode[KeyCode["KeyB"] = 22] = "KeyB";
    /** c on a US keyboard. */
    KeyCode[KeyCode["KeyC"] = 23] = "KeyC";
    /** d on a US keyboard. */
    KeyCode[KeyCode["KeyD"] = 24] = "KeyD";
    /** e on a US keyboard. */
    KeyCode[KeyCode["KeyE"] = 25] = "KeyE";
    /** f on a US keyboard. */
    KeyCode[KeyCode["KeyF"] = 26] = "KeyF";
    /** g on a US keyboard. */
    KeyCode[KeyCode["KeyG"] = 27] = "KeyG";
    /** h on a US keyboard. */
    KeyCode[KeyCode["KeyH"] = 28] = "KeyH";
    /** i on a US keyboard. */
    KeyCode[KeyCode["KeyI"] = 29] = "KeyI";
    /** j on a US keyboard. */
    KeyCode[KeyCode["KeyJ"] = 30] = "KeyJ";
    /** k on a US keyboard. */
    KeyCode[KeyCode["KeyK"] = 31] = "KeyK";
    /** l on a US keyboard. */
    KeyCode[KeyCode["KeyL"] = 32] = "KeyL";
    /** m on a US keyboard. */
    KeyCode[KeyCode["KeyM"] = 33] = "KeyM";
    /** n on a US keyboard. */
    KeyCode[KeyCode["KeyN"] = 34] = "KeyN";
    /** o on a US keyboard. */
    KeyCode[KeyCode["KeyO"] = 35] = "KeyO";
    /** p on a US keyboard. */
    KeyCode[KeyCode["KeyP"] = 36] = "KeyP";
    /** q on a US keyboard. Labelled a on an AZERTY (e.g., French) keyboard. */
    KeyCode[KeyCode["KeyQ"] = 37] = "KeyQ";
    /** r on a US keyboard. */
    KeyCode[KeyCode["KeyR"] = 38] = "KeyR";
    /** s on a US keyboard. */
    KeyCode[KeyCode["KeyS"] = 39] = "KeyS";
    /** t on a US keyboard. */
    KeyCode[KeyCode["KeyT"] = 40] = "KeyT";
    /** u on a US keyboard. */
    KeyCode[KeyCode["KeyU"] = 41] = "KeyU";
    /** v on a US keyboard. */
    KeyCode[KeyCode["KeyV"] = 42] = "KeyV";
    /** w on a US keyboard. Labelled z on an AZERTY (e.g., French) keyboard. */
    KeyCode[KeyCode["KeyW"] = 43] = "KeyW";
    /** x on a US keyboard. */
    KeyCode[KeyCode["KeyX"] = 44] = "KeyX";
    /** y on a US keyboard. Labelled z on a QWERTZ (e.g., German) keyboard. */
    KeyCode[KeyCode["KeyY"] = 45] = "KeyY";
    /** z on a US keyboard. Labelled w on an AZERTY (e.g., French) keyboard, and y on a QWERTZ (e.g., German) keyboard. */
    KeyCode[KeyCode["KeyZ"] = 46] = "KeyZ";
    /** - and _ on a US keyboard. */
    KeyCode[KeyCode["Minus"] = 47] = "Minus";
    /** . and > on a US keyboard. */
    KeyCode[KeyCode["Period"] = 48] = "Period";
    /** and " on a US keyboard. */
    KeyCode[KeyCode["Quote"] = 49] = "Quote";
    /** ; and : on a US keyboard. */
    KeyCode[KeyCode["Semicolon"] = 50] = "Semicolon";
    /** / and ? on a US keyboard. */
    KeyCode[KeyCode["Slash"] = 51] = "Slash";
    //
    // Functional keys
    //
    /** Labelled Alt or Option. */
    KeyCode[KeyCode["AltLeft"] = 52] = "AltLeft";
    /** Labelled Alt or Option. This is the AltGr key on many keyboard layouts. */
    KeyCode[KeyCode["AltRight"] = 53] = "AltRight";
    /** The Caps Lock key. */
    KeyCode[KeyCode["CapsLock"] = 54] = "CapsLock";
    /** The application context menu key, which is typically found between the right OS key and the right Control key. */
    KeyCode[KeyCode["ContextMenu"] = 55] = "ContextMenu";
    /** The left Control key. */
    KeyCode[KeyCode["ControlLeft"] = 56] = "ControlLeft";
    /** The right Control key. */
    KeyCode[KeyCode["ControlRight"] = 57] = "ControlRight";
    /** Labelled Enter and Return on Macintosh keyboards. */
    KeyCode[KeyCode["Enter"] = 58] = "Enter";
    /** The Windows, , Command or other OS symbol key. */
    KeyCode[KeyCode["OSLeft"] = 59] = "OSLeft";
    /** The Windows, , Command or other OS symbol key. */
    KeyCode[KeyCode["OSRight"] = 60] = "OSRight";
    /** The left Shift key. */
    KeyCode[KeyCode["ShiftLeft"] = 61] = "ShiftLeft";
    /** The right Shift key. */
    KeyCode[KeyCode["ShiftRight"] = 62] = "ShiftRight";
    /** The space key. */
    KeyCode[KeyCode["Space"] = 63] = "Space";
    /** The tab key. */
    KeyCode[KeyCode["Tab"] = 64] = "Tab";
    /** The / (Hankaku/Zenkaku) key */
    KeyCode[KeyCode["IntlHanZen"] = 65] = "IntlHanZen";
    /** The  (Muhenkan) key found on Japanese keyboards to the left of the
     * Space key */
    KeyCode[KeyCode["IntlMuhenkan"] = 66] = "IntlMuhenkan";
    /** The  (Henkan) key found on Japanese keyboards to the right of the
     * Space key */
    KeyCode[KeyCode["IntlHenkan"] = 67] = "IntlHenkan";
    /** The  (Hiragana/Katakana) key found on Japanese keyboards
     * to the right of the Henkan key */
    KeyCode[KeyCode["IntlHiraKata"] = 68] = "IntlHiraKata";
    /** The Menu key typically located to the left of the Right Shift key on
     * Japanese Keyboards. */
    KeyCode[KeyCode["IntlMenu"] = 69] = "IntlMenu";
    //
    // Control Pad Section
    //
    /** ? */
    KeyCode[KeyCode["Delete"] = 70] = "Delete";
    /** ?  */
    KeyCode[KeyCode["End"] = 71] = "End";
    /** ? */
    KeyCode[KeyCode["Home"] = 72] = "Home";
    /** Not present on Apple keyboards. */
    KeyCode[KeyCode["Insert"] = 73] = "Insert";
    /** ? */
    KeyCode[KeyCode["PageDown"] = 74] = "PageDown";
    /** ? */
    KeyCode[KeyCode["PageUp"] = 75] = "PageUp";
    //
    // Arrow Pad Section
    //
    /** ? */
    KeyCode[KeyCode["ArrowDown"] = 76] = "ArrowDown";
    /** ? */
    KeyCode[KeyCode["ArrowLeft"] = 77] = "ArrowLeft";
    /** ? */
    KeyCode[KeyCode["ArrowRight"] = 78] = "ArrowRight";
    /** ? */
    KeyCode[KeyCode["ArrowUp"] = 79] = "ArrowUp";
    //
    // Numpad Section
    //
    /** On the Mac, the 'NumLock' code should be used for the numpad 'Clear' key. */
    KeyCode[KeyCode["NumLock"] = 80] = "NumLock";
    /** 0/Insert on a keyboard; 0 on a phone or remote control */
    KeyCode[KeyCode["Numpad0"] = 81] = "Numpad0";
    /** 1/End on a keyboard; 1 or 1/QZ on a phone or remote control */
    KeyCode[KeyCode["Numpad1"] = 82] = "Numpad1";
    /** 2/ArrowDown on a keyboard; 2/ABC on a phone or remote control */
    KeyCode[KeyCode["Numpad2"] = 83] = "Numpad2";
    /** 3/PageDown on a keyboard; 3/DEF on a phone or remote control */
    KeyCode[KeyCode["Numpad3"] = 84] = "Numpad3";
    /** 4/ArrowLeft on a keyboard; 4/GHI on a phone or remote control */
    KeyCode[KeyCode["Numpad4"] = 85] = "Numpad4";
    /** 5 on a keyboard; 5/JKL on a phone or remote control */
    KeyCode[KeyCode["Numpad5"] = 86] = "Numpad5";
    /** 6/ArrowRight on a keyboard; 6/MNO on a phone or remote control */
    KeyCode[KeyCode["Numpad6"] = 87] = "Numpad6";
    /** 7/Home on a keyboard; 7/PQRS or 7/PRS on a phone or remote control */
    KeyCode[KeyCode["Numpad7"] = 88] = "Numpad7";
    /** 8/ArrowUp on a keyboard; 8/TUV on a phone or remote control */
    KeyCode[KeyCode["Numpad8"] = 89] = "Numpad8";
    /** 9/PageUp on a keyboard; 9/WXYZ or 9/WXY on a phone or remote control */
    KeyCode[KeyCode["Numpad9"] = 90] = "Numpad9";
    /** + */
    KeyCode[KeyCode["NumpadAdd"] = 91] = "NumpadAdd";
    /** For use with numpads that have a 'Clear' key that is separate from the 'NumLock' key. On the Mac, the numpad 'Clear' key should always be encoded as 'NumLock'. */
    KeyCode[KeyCode["NumpadClear"] = 92] = "NumpadClear";
    /** , (thousands separator). For locales where the thousands separator is a '.' (e.g., Brazil), this key may generate a '.' */
    KeyCode[KeyCode["NumpadComma"] = 93] = "NumpadComma";
    /** . (decimal separator) and Delete. For locales where the decimal separator is ',' (e.g., Brazil), this key may generate a ','. */
    KeyCode[KeyCode["NumpadDecimal"] = 94] = "NumpadDecimal";
    /** / */
    KeyCode[KeyCode["NumpadDivide"] = 95] = "NumpadDivide";
    /** ? */
    KeyCode[KeyCode["NumpadEnter"] = 96] = "NumpadEnter";
    /** * on a keyboard. For use with numpads that provide mathematical operations (+, -, * and /). See 'NumpadStar' for the * key on phones and remote controls. */
    KeyCode[KeyCode["NumpadMultiply"] = 97] = "NumpadMultiply";
    /** - */
    KeyCode[KeyCode["NumpadSubtract"] = 98] = "NumpadSubtract";
    //
    // Function Section
    //
    /** ? */
    KeyCode[KeyCode["Escape"] = 99] = "Escape";
    /** ? */
    KeyCode[KeyCode["F1"] = 100] = "F1";
    /** ? */
    KeyCode[KeyCode["F2"] = 101] = "F2";
    /** ? */
    KeyCode[KeyCode["F3"] = 102] = "F3";
    /** ? */
    KeyCode[KeyCode["F4"] = 103] = "F4";
    /** ? */
    KeyCode[KeyCode["F5"] = 104] = "F5";
    /** ? */
    KeyCode[KeyCode["F6"] = 105] = "F6";
    /** ? */
    KeyCode[KeyCode["F7"] = 106] = "F7";
    /** ? */
    KeyCode[KeyCode["F8"] = 107] = "F8";
    /** ? */
    KeyCode[KeyCode["F9"] = 108] = "F9";
    /** ? */
    KeyCode[KeyCode["F10"] = 109] = "F10";
    /** ? */
    KeyCode[KeyCode["F11"] = 110] = "F11";
    /** ? */
    KeyCode[KeyCode["F12"] = 111] = "F12";
    /** PrintScreen and SysReq */
    KeyCode[KeyCode["PrintScreen"] = 112] = "PrintScreen";
    /** ? */
    KeyCode[KeyCode["ScrollLock"] = 113] = "ScrollLock";
    /** Pause and Break */
    KeyCode[KeyCode["Pause"] = 114] = "Pause";
})(KeyCode || (KeyCode = {}));

;// ./packages/keybr-keyboard/lib/ngram.ts
/**
 * The unigram frequency table.
 */
class ngram_Ngram1 {
    #alphabet;
    #data;
    constructor(alphabet) {
        if (alphabet.length === 0) {
            throw new TypeError();
        }
        this.#alphabet = alphabet;
        this.#data = new Float64Array(alphabet.length);
    }
    *[Symbol.iterator]() {
        const size = this.#alphabet.length;
        for (let i = 0; i < size; i++) {
            const f = this.#data[i];
            if (f > 0) {
                yield [this.#alphabet[i], f];
            }
        }
    }
    set(a, f) {
        this.#data[this.#indexOf(a)] = f;
    }
    add(a, f) {
        this.#data[this.#indexOf(a)] += f;
    }
    get(a) {
        return this.#data[this.#indexOf(a)];
    }
    normalize() {
        normalize(this.#data);
    }
    toJSON() {
        return [...this];
    }
    #indexOf(codePoint) {
        const index = this.#alphabet.indexOf(codePoint);
        if (index < 0) {
            throw new TypeError();
        }
        return index;
    }
}
/**
 * The bigram frequency table.
 */
class ngram_Ngram2 {
    #alphabet;
    #data;
    constructor(alphabet) {
        if (alphabet.length === 0) {
            throw new TypeError();
        }
        this.#alphabet = alphabet;
        this.#data = new Float64Array(alphabet.length * alphabet.length);
    }
    *[Symbol.iterator]() {
        const size = this.#alphabet.length;
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const f = this.#data[i * size + j];
                if (f > 0) {
                    yield [this.#alphabet[i], this.#alphabet[j], f];
                }
            }
        }
    }
    set(a, b, f) {
        const size = this.#alphabet.length;
        const i = this.#indexOf(a);
        const j = this.#indexOf(b);
        this.#data[i * size + j] = f;
    }
    add(a, b, f) {
        const size = this.#alphabet.length;
        const i = this.#indexOf(a);
        const j = this.#indexOf(b);
        this.#data[i * size + j] += f;
    }
    get(a, b) {
        const size = this.#alphabet.length;
        const i = this.#indexOf(a);
        const j = this.#indexOf(b);
        return this.#data[i * size + j];
    }
    normalize() {
        normalize(this.#data);
    }
    toJSON() {
        return [...this];
    }
    #indexOf(codePoint) {
        const index = this.#alphabet.indexOf(codePoint);
        if (index < 0) {
            throw new TypeError();
        }
        return index;
    }
}
function normalize(data) {
    const { length } = data;
    const sum = data.reduce((sum, f) => sum + f, 0);
    if (sum > 0) {
        for (let i = 0; i < length; i++) {
            data[i] = data[i] / sum;
        }
    }
}

;// ./packages/keybr-intl/lib/memo.ts
const intlMemo = (key, factory) => {
    return (intl) => {
        let v = intl[key];
        if (v == null) {
            intl[key] = v = factory(intl);
        }
        return v;
    };
};

;// ./packages/keybr-intl/lib/collator.ts


const factory = ({ locale }) => {
    return new Intl.Collator(locale);
};
const makeIntlCollator = intlMemo(Symbol("collator"), factory);
const useCollator = () => {
    return makeIntlCollator(useIntl());
};

;// ./packages/keybr-intl/lib/locale.ts

const locale_defaultLocale = "zh-hans";
const allLocales = [
    locale_defaultLocale,
    "ar",
    "bg",
    "ca",
    "cs",
    "da",
    "de",
    "el",
    "en",
    "eo",
    "es",
    "et",
    "fa",
    "fr",
    "ga",
    "he",
    "hr",
    "hu",
    "id",
    "it",
    "ja",
    "ko",
    "ne",
    "nl",
    "pl",
    "pt-br",
    "pt-pt",
    "ro",
    "ru",
    "sv",
    "th",
    "tr",
    "uk",
    "vi",
    "zh-hans",
    "zh-hant",
];
function locale_getDir(locale) {
    switch (locale) {
        case "ar":
        case "fa":
        case "he":
            return "rtl";
        default:
            return "ltr";
    }
}
const PreferredLocaleContext = (0,react.createContext)(locale_defaultLocale);
function usePreferredLocale() {
    return useContext(PreferredLocaleContext);
}
const map = (() => {
    const tmp = new Map();
    for (const id of allLocales) {
        const { language, region } = new Intl.Locale(id).maximize();
        tmp.set(language + "-" + region, id);
        if (!tmp.has(language)) {
            tmp.set(language, id);
        }
    }
    return tmp;
})();
function selectLocale(filter) {
    return map.get(filter(...map.keys()) ?? "") ?? locale_defaultLocale;
}

;// ./packages/keybr-intl/lib/Dir.tsx




/**
 * Expects exactly two child components and swaps their properties depending
 * on the reading direction, "ltr" or "rtl".
 */
function Dir({ children, swap, }) {
    const { locale } = useIntl();
    if (!(Array.isArray(children) && children.length === 2)) {
        throw new Error( false
            ? 0
            : undefined);
    }
    const [a, b] = children;
    const { props: ap } = a;
    const { props: bp } = b;
    if (!(swap in ap && swap in bp)) {
        throw new Error( false
            ? 0
            : undefined);
    }
    if (getDir(locale) === "rtl") {
        return (_jsxs(_Fragment, { children: [cloneElement(a, { ...ap, [swap]: bp[swap] }), cloneElement(b, { ...bp, [swap]: ap[swap] })] }));
    }
    else {
        return (_jsxs(_Fragment, { children: [cloneElement(a, { ...ap, [swap]: ap[swap] }), cloneElement(b, { ...bp, [swap]: bp[swap] })] }));
    }
}

;// ./packages/keybr-intl/lib/displaynames.ts


const capitalize = (value, locale) => value.replaceAll(/\p{Letter}+/gu, (word) => word.substring(0, 1).toLocaleUpperCase(locale) +
    word.substring(1).toLocaleLowerCase(locale));
const displaynames_factory = (intl) => {
    const { locale } = intl;
    const formatRegionName = (id) => {
        const dn = intl.formatters.getDisplayNames(locale, {
            type: "region",
            fallback: "none",
        });
        return capitalize(dn.of(id) || "", locale) || id;
    };
    const formatLanguageName = (id) => {
        const dn = intl.formatters.getDisplayNames(locale, {
            type: "language",
            fallback: "none",
        });
        return capitalize(dn.of(id) || "", locale) || id;
    };
    const formatLocalLanguageName = (id) => {
        const dn = intl.formatters.getDisplayNames(id, {
            type: "language",
            fallback: "none",
        });
        return capitalize(dn.of(id) || "", id) || id;
    };
    return {
        formatRegionName,
        formatLanguageName,
        formatLocalLanguageName,
    };
};
const makeIntlDisplayNames = intlMemo(Symbol("displayNames"), displaynames_factory);
const displaynames_useIntlDisplayNames = () => {
    return makeIntlDisplayNames(useIntl());
};

;// ./packages/keybr-intl/lib/durations.ts


const durations_factory = (intl) => {
    const formatDuration = (duration) => {
        const { seconds = 0, minutes = 0, hours = 0 } = duration;
        const parts = [];
        if (hours > 0) {
            parts.push(intl.formatNumber(hours, {
                style: "unit",
                unit: "hour",
                unitDisplay: "long",
            }));
        }
        if (minutes > 0) {
            parts.push(intl.formatNumber(minutes, {
                style: "unit",
                unit: "minute",
                unitDisplay: "long",
            }));
        }
        if (seconds > 0) {
            parts.push(intl.formatNumber(seconds, {
                style: "unit",
                unit: "second",
                unitDisplay: "long",
            }));
        }
        return intl.formatList(parts, {
            style: "long",
            type: "conjunction",
        });
    };
    const humanizeDuration = (duration) => {
        if (duration < 1) {
            return intl.formatNumber(0, {
                style: "unit",
                unit: "second",
                unitDisplay: "long",
            });
        }
        const hours = Math.floor(duration / 3600);
        duration = duration - hours * 3600;
        const minutes = Math.floor(duration / 60);
        duration = duration - minutes * 60;
        const seconds = Math.floor(duration);
        return formatDuration({ hours, minutes, seconds });
    };
    return {
        formatDuration,
        humanizeDuration,
    };
};
const makeIntlDurations = intlMemo(Symbol("durations"), durations_factory);
const useIntlDurations = () => {
    return makeIntlDurations(useIntl());
};

;// ./packages/keybr-intl/lib/markup.tsx

const markup_defaultRichTextElements = {
    h1: (...chunks) => (0,jsx_runtime.jsx)("h1", { children: chunks }),
    h2: (...chunks) => (0,jsx_runtime.jsx)("h2", { children: chunks }),
    h3: (...chunks) => (0,jsx_runtime.jsx)("h3", { children: chunks }),
    p: (...chunks) => (0,jsx_runtime.jsx)("p", { children: chunks }),
    ol: (...chunks) => (0,jsx_runtime.jsx)("ol", { children: chunks }),
    ul: (...chunks) => (0,jsx_runtime.jsx)("ul", { children: chunks }),
    li: (...chunks) => (0,jsx_runtime.jsx)("li", { children: chunks }),
    dl: (...chunks) => (0,jsx_runtime.jsx)("dl", { children: chunks }),
    dt: (...chunks) => (0,jsx_runtime.jsx)("dt", { children: chunks }),
    dd: (...chunks) => (0,jsx_runtime.jsx)("dd", { children: chunks }),
    em: (...chunks) => (0,jsx_runtime.jsx)("em", { children: chunks }),
    strong: (...chunks) => (0,jsx_runtime.jsx)("strong", { children: chunks }),
    br: () => (0,jsx_runtime.jsx)("br", {}),
};

;// ./packages/keybr-intl/lib/FakeIntlProvider.tsx




function FakeIntlProvider({ children, }) {
    return (_jsx(IntlProvider, { locale: defaultLocale, timeZone: "UTC", defaultRichTextElements: defaultRichTextElements, children: children }));
}

;// ./packages/keybr-intl/lib/intl.ts




const intl_cache = new Map(); // Server loads multiple intls.
async function loadIntl(locale) {
    let intl = intl_cache.get(locale);
    if (intl == null) {
        const messages = await loadMessages(locale);
        intl_cache.set(locale, (intl = createIntl({
            locale,
            defaultLocale,
            defaultRichTextElements,
            messages,
            onWarn,
            onError,
        }, createIntlCache())));
    }
    return intl;
}
function onWarn(warn) {
    console.warn(warn);
}
function onError(err) {
    if (false) {}
    console.error("I18N error:", err);
}

;// ./packages/keybr-intl/lib/numbers.ts


const formatIntegerOpts = {
    maximumFractionDigits: 0,
};
const formatNumberOpts = {
    maximumFractionDigits: 3,
};
const formatPercentsOpts = {
    style: "percent",
    maximumFractionDigits: 2,
};
const numbers_factory = (intl) => {
    const formatInteger = (value) => {
        return intl.formatNumber(value, formatIntegerOpts);
    };
    const formatNumber = (value, opts = formatNumberOpts) => {
        if (typeof opts === "number") {
            opts = {
                maximumFractionDigits: opts,
            };
        }
        return intl.formatNumber(value, opts);
    };
    const formatPercents = (value, opts = formatPercentsOpts) => {
        if (typeof opts === "number") {
            opts = {
                style: "percent",
                maximumFractionDigits: opts,
            };
        }
        else if (opts.style !== "percent") {
            opts = {
                ...opts,
                style: "percent",
            };
        }
        // Do not round up to 100% if the value is less than one.
        // Add decimal digits instead.
        let s = intl.formatNumber(value, opts);
        for (let i = opts.maximumFractionDigits ?? 0; i <= 5; i++) {
            if (value < 1.0 && s === intl.formatNumber(1.0, opts)) {
                opts = {
                    ...opts,
                    maximumFractionDigits: i + 1,
                };
                s = intl.formatNumber(value, opts);
            }
            else {
                break;
            }
        }
        return s;
    };
    return {
        formatInteger,
        formatNumber,
        formatPercents,
    };
};
const makeIntlNumbers = intlMemo(Symbol("numbers"), numbers_factory);
const useIntlNumbers = () => {
    return makeIntlNumbers(useIntl());
};

;// ./packages/keybr-intl/lib/index.ts










;// ./packages/keybr-keyboard/lib/use-formatted-names.ts

const useFormattedNames = () => {
    const dn = useIntlDisplayNames();
    const formatLanguageName = (language) => {
        return dn.formatLanguageName(language.id);
    };
    const formatLayoutName = (layout) => {
        return layout.name.replaceAll(/\{([-A-Z]+)\}/g, (regionId) => {
            return dn.formatRegionName(regionId.substring(1, regionId.length - 1));
        });
    };
    const formatFullLayoutName = (layout) => {
        return `${formatLanguageName(layout.language)}/${formatLayoutName(layout)}`;
    };
    return {
        formatLanguageName,
        formatLayoutName,
        formatFullLayoutName,
    };
};

;// ./packages/keybr-keyboard/lib/index.ts



















;// ./packages/keybr-phonetic-model/lib/Alphabet.tsx

function Alphabet({ as: Component = "strong", className, id, title, model: { language, letters }, }) {
    return (_jsx(Component, { id: id, className: className, title: title, dir: language.direction, children: letters.map(({ label }) => label).join("") }));
}

;// ./packages/keybr-binary/lib/errors.ts
class errors_DataError extends Error {
    name = "DataError";
    constructor(message, options) {
        super(message, options);
    }
    get [Symbol.toStringTag]() {
        return "DataError";
    }
}

;// ./packages/keybr-binary/lib/utf8.ts

/**
 * Get number of UTF8 bytes for the specified string.
 * @param value A string.
 * @return Number of UTF8 bytes.
 */
function encodedByteCount(value) {
    // length   byte[0]    byte[1]    byte[2]    byte[3]
    // 1        0b0xxxxxxx
    // 2        0b110xxxxx 0b10xxxxxx
    // 3        0b1110xxxx 0b10xxxxxx 0b10xxxxxx
    // 4        0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx
    let byteCount = 0;
    let i = 0;
    while (i < value.length) {
        const codePoint = value.codePointAt(i) ?? 0;
        if (codePoint <= 0x7f) {
            byteCount += 1;
            i += 1;
        }
        else if (codePoint <= 0x7ff) {
            byteCount += 2;
            i += 1;
        }
        else if (codePoint <= 0xffff) {
            byteCount += 3;
            i += 1;
        }
        else if (codePoint <= 0x10ffff) {
            byteCount += 4;
            i += 2;
        }
    }
    return byteCount;
}
/**
 * Write string as UTF8 bytes.
 * @param value A string to encode.
 * @param buffer An array to write bytes to.
 * @param byteOffset Byte offset in the array.
 * @return Updated byte offset in the array.
 */
function encode(value, buffer, byteOffset) {
    let i = 0;
    while (i < value.length) {
        const codePoint = value.codePointAt(i) ?? 0;
        if (codePoint <= 0x7f) {
            buffer.setUint8(byteOffset++, codePoint);
            i += 1;
        }
        else if (codePoint <= 0x7ff) {
            buffer.setUint8(byteOffset++, ((codePoint >> 6) & 0x1f) | 0xc0);
            buffer.setUint8(byteOffset++, ((codePoint >> 0) & 0x3f) | 0x80);
            i += 1;
        }
        else if (codePoint <= 0xffff) {
            buffer.setUint8(byteOffset++, ((codePoint >> 12) & 0x0f) | 0xe0);
            buffer.setUint8(byteOffset++, ((codePoint >> 6) & 0x3f) | 0x80);
            buffer.setUint8(byteOffset++, ((codePoint >> 0) & 0x3f) | 0x80);
            i += 1;
        }
        else if (codePoint <= 0x10ffff) {
            buffer.setUint8(byteOffset++, ((codePoint >> 18) & 0x7f) | 0xf0);
            buffer.setUint8(byteOffset++, ((codePoint >> 12) & 0x3f) | 0x80);
            buffer.setUint8(byteOffset++, ((codePoint >> 6) & 0x3f) | 0x80);
            buffer.setUint8(byteOffset++, ((codePoint >> 0) & 0x3f) | 0x80);
            i += 2;
        }
    }
    return byteOffset;
}
/**
 * Read string from UTF8 bytes.
 * @param buffer An array to read bytes from.
 * @param byteOffset Byte offset in the array.
 * @param byteLength Number of bytes to read.
 * @return String from UTF8 bytes.
 */
function decode(buffer, byteOffset, byteLength) {
    let value = "";
    const endOffset = byteOffset + byteLength;
    while (byteOffset < endOffset) {
        const b0 = buffer.getUint8(byteOffset++);
        if (b0 < 0x80) {
            value += String.fromCodePoint(b0);
        }
        else if ((b0 & 0xe0) === 0xc0) {
            if (byteOffset + 1 > endOffset) {
                throw new errors_DataError("Truncated UTF-8 stream");
            }
            const b1 = buffer.getUint8(byteOffset++);
            const codePoint = ((b0 & 0x1f) << 6) | ((b1 & 0x3f) << 0);
            value += String.fromCodePoint(codePoint);
        }
        else if ((b0 & 0xf0) === 0xe0) {
            if (byteOffset + 2 > endOffset) {
                throw new errors_DataError("Truncated UTF-8 stream");
            }
            const b1 = buffer.getUint8(byteOffset++);
            const b2 = buffer.getUint8(byteOffset++);
            const codePoint = ((b0 & 0x0f) << 12) | ((b1 & 0x3f) << 6) | ((b2 & 0x3f) << 0);
            value += String.fromCodePoint(codePoint);
        }
        else if ((b0 & 0xf8) === 0xf0) {
            if (byteOffset + 3 > endOffset) {
                throw new errors_DataError("Truncated UTF-8 stream");
            }
            const b1 = buffer.getUint8(byteOffset++);
            const b2 = buffer.getUint8(byteOffset++);
            const b3 = buffer.getUint8(byteOffset++);
            const codePoint = ((b0 & 0x07) << 18) |
                ((b1 & 0x3f) << 12) |
                ((b2 & 0x3f) << 6) |
                ((b3 & 0x3f) << 0);
            if (codePoint > 0x10ffff) {
                throw new errors_DataError("Invalid code point");
            }
            value += String.fromCodePoint(codePoint);
        }
        else {
            throw new errors_DataError("Broken UTF-8 stream");
        }
    }
    return value;
}

;// ./packages/keybr-binary/lib/util.ts
function util_asUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
        return buffer;
    }
    if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    return new Uint8Array(buffer);
}

;// ./packages/keybr-binary/lib/io.ts



class io_Writer {
    #dataView;
    #byteOffset;
    constructor(byteLength = 64) {
        this.#dataView = new DataView(new ArrayBuffer(Math.max(byteLength, 64)));
        this.#byteOffset = 0;
    }
    #ensureSize(byteLength) {
        if (this.#dataView.byteLength < byteLength) {
            let totalSize = 64;
            while (totalSize < byteLength) {
                totalSize *= totalSize;
            }
            const buffer = new ArrayBuffer(totalSize);
            new Uint8Array(buffer).set(new Uint8Array(this.#dataView.buffer));
            this.#dataView = new DataView(buffer);
        }
    }
    #ensureAvailable(byteLength) {
        this.#ensureSize(this.#byteOffset + byteLength);
    }
    putInt8(value) {
        if (!Number.isInteger(value) || value < -0x80 || value > 0x7f) {
            throw new TypeError("Value is not int8");
        }
        this.#ensureAvailable(1);
        this.#dataView.setInt8(this.#byteOffset, value);
        this.#byteOffset += 1;
        return this;
    }
    putUint8(value) {
        if (!Number.isInteger(value) || value < 0 || value > 0xff) {
            throw new TypeError("Value is not uint8");
        }
        this.#ensureAvailable(1);
        this.#dataView.setUint8(this.#byteOffset, value);
        this.#byteOffset += 1;
        return this;
    }
    putInt16(value) {
        if (!Number.isInteger(value) || value < -0x8000 || value > 0x7fff) {
            throw new TypeError("Value is not int16");
        }
        this.#ensureAvailable(2);
        this.#dataView.setInt16(this.#byteOffset, value, false);
        this.#byteOffset += 2;
        return this;
    }
    putUint16(value) {
        if (!Number.isInteger(value) || value < 0 || value > 0xffff) {
            throw new TypeError("Value is not uint16");
        }
        this.#ensureAvailable(2);
        this.#dataView.setUint16(this.#byteOffset, value, false);
        this.#byteOffset += 2;
        return this;
    }
    putInt32(value) {
        if (!Number.isInteger(value) || value < -0x80000000 || value > 0x7fffffff) {
            throw new TypeError("Value is not int32");
        }
        this.#ensureAvailable(4);
        this.#dataView.setInt32(this.#byteOffset, value, false);
        this.#byteOffset += 4;
        return this;
    }
    putUint32(value) {
        if (!Number.isInteger(value) || value < 0 || value > 0xffffffff) {
            throw new TypeError("Value is not uint32");
        }
        this.#ensureAvailable(4);
        this.#dataView.setUint32(this.#byteOffset, value, false);
        this.#byteOffset += 4;
        return this;
    }
    putFloat32(value) {
        this.#ensureAvailable(4);
        this.#dataView.setFloat32(this.#byteOffset, value, false);
        this.#byteOffset += 4;
        return this;
    }
    putFloat64(value) {
        this.#ensureAvailable(8);
        this.#dataView.setFloat64(this.#byteOffset, value, false);
        this.#byteOffset += 8;
        return this;
    }
    putIntVlq(value) {
        if (!Number.isInteger(value) || value < -0x80000000 || value > 0x7fffffff) {
            throw new TypeError("Value is not int32");
        }
        this.putUintVlq(((value << 1) ^ (value >> 31)) >>> 0);
        return this;
    }
    putUintVlq(value) {
        if (!Number.isInteger(value) || value < 0 || value > 0xffffffff) {
            throw new TypeError("Value is not uint32");
        }
        this.#putVlq(value);
        return this;
    }
    #putVlq(value) {
        if (value > 266338304) {
            this.putUint8(((value >>> 28) & 15) | 128);
        }
        if (value > 2080768) {
            this.putUint8(((value >>> 21) & 127) | 128);
        }
        if (value > 16256) {
            this.putUint8(((value >>> 14) & 127) | 128);
        }
        if (value > 127) {
            this.putUint8(((value >>> 7) & 127) | 128);
        }
        this.putUint8(value & 127);
    }
    putString(value) {
        const byteLength = encodedByteCount(value);
        this.putUintVlq(byteLength);
        this.#ensureAvailable(byteLength);
        encode(value, this.#dataView, this.#byteOffset);
        this.#byteOffset += byteLength;
        return this;
    }
    putBuffer(buffer) {
        const array = util_asUint8Array(buffer);
        this.#ensureAvailable(array.byteLength);
        new Uint8Array(this.#dataView.buffer).set(array, this.#byteOffset);
        this.#byteOffset += array.byteLength;
        return this;
    }
    buffer() {
        return new Uint8Array(this.#dataView.buffer, 0, this.#byteOffset);
    }
}
class io_Reader {
    #dataView;
    #byteOffset = 0;
    constructor(buffer) {
        if (ArrayBuffer.isView(buffer)) {
            this.#dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        }
        else {
            this.#dataView = new DataView(buffer);
        }
    }
    #ensureAvailable(byteLength) {
        if (this.#byteOffset + byteLength > this.#dataView.byteLength) {
            throw new errors_DataError("Premature end of data");
        }
    }
    getInt8() {
        this.#ensureAvailable(1);
        const value = this.#dataView.getInt8(this.#byteOffset);
        this.#byteOffset += 1;
        return value;
    }
    getUint8() {
        this.#ensureAvailable(1);
        const value = this.#dataView.getUint8(this.#byteOffset);
        this.#byteOffset += 1;
        return value;
    }
    getInt16() {
        this.#ensureAvailable(2);
        const value = this.#dataView.getInt16(this.#byteOffset, false);
        this.#byteOffset += 2;
        return value;
    }
    getUint16() {
        this.#ensureAvailable(2);
        const value = this.#dataView.getUint16(this.#byteOffset, false);
        this.#byteOffset += 2;
        return value;
    }
    getInt32() {
        this.#ensureAvailable(4);
        const value = this.#dataView.getInt32(this.#byteOffset, false);
        this.#byteOffset += 4;
        return value;
    }
    getUint32() {
        this.#ensureAvailable(4);
        const value = this.#dataView.getUint32(this.#byteOffset, false);
        this.#byteOffset += 4;
        return value;
    }
    getFloat32() {
        this.#ensureAvailable(4);
        const value = this.#dataView.getFloat32(this.#byteOffset, false);
        this.#byteOffset += 4;
        return value;
    }
    getFloat64() {
        this.#ensureAvailable(8);
        const value = this.#dataView.getFloat64(this.#byteOffset, false);
        this.#byteOffset += 8;
        return value;
    }
    getIntVlq() {
        const value = this.getUintVlq();
        return (value >>> 1) ^ -(value & 1); // from zig-zag back to two's-complement
    }
    getUintVlq() {
        return this.#getVlq();
    }
    #getVlq() {
        let value = 0;
        const b0 = this.getUint8();
        value = ((value << 7) | (b0 & 0x7f)) >>> 0;
        if ((b0 & 0x80) === 0) {
            return value;
        }
        const b1 = this.getUint8();
        value = ((value << 7) | (b1 & 0x7f)) >>> 0;
        if ((b1 & 0x80) === 0) {
            return value;
        }
        const b2 = this.getUint8();
        value = ((value << 7) | (b2 & 0x7f)) >>> 0;
        if ((b2 & 0x80) === 0) {
            return value;
        }
        const b3 = this.getUint8();
        value = ((value << 7) | (b3 & 0x7f)) >>> 0;
        if ((b3 & 0x80) === 0) {
            return value;
        }
        const b4 = this.getUint8();
        value = ((value << 7) | (b4 & 0x7f)) >>> 0;
        if ((b4 & 0x80) === 0) {
            if ((b0 & 0x7f) > 15) {
                throw new errors_DataError("Too many leading bits");
            }
            return value;
        }
        throw new errors_DataError("Too many trailing bits");
    }
    getString() {
        const byteLength = this.getUintVlq();
        this.#ensureAvailable(byteLength);
        const value = decode(this.#dataView, this.#byteOffset, byteLength);
        this.#byteOffset += byteLength;
        return value;
    }
    getBuffer(byteLength) {
        this.#ensureAvailable(byteLength);
        const buffer = new Uint8Array(this.#dataView.buffer, this.#byteOffset, byteLength);
        this.#byteOffset += byteLength;
        return buffer;
    }
    position() {
        return this.#byteOffset;
    }
    remaining() {
        return this.#dataView.byteLength - this.#byteOffset;
    }
}

;// ./packages/keybr-binary/lib/crc32.ts

const table = (() => {
    const table = [];
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
        }
        table[i] = c;
    }
    return table;
})();
/**
 * Calculate CRC32 of the specified array.
 */
function crc32_crc32(buffer) {
    const array = asUint8Array(buffer);
    let crc = 0xffffffff;
    for (let i = 0; i < array.length; i++) {
        crc = (crc >>> 8) ^ table[(crc ^ array[i]) & 0xff];
    }
    return (crc ^ 0xffffffff) >>> 0;
}

;// ./packages/keybr-binary/lib/secret.ts



function secret_scramble(buffer) {
    const array = asUint8Array(buffer);
    const k = key();
    const r = new Uint8Array(array.length + 8);
    setUint32(r, 0, k);
    setUint32(r, 4, crc32(array));
    r.set(array, 8);
    update(k, r);
    return r;
}
function secret_unscramble(buffer) {
    const array = asUint8Array(buffer);
    if (array.length < 8) {
        throw new DataError();
    }
    const k = getUint32(array, 0);
    update(k, array);
    const c = getUint32(array, 4);
    const r = array.subarray(8);
    if (crc32(r) !== c) {
        throw new DataError();
    }
    return r;
}
function update(k, a) {
    const g = stream(k);
    for (let i = 4; i < a.length; i++) {
        a[i] = a[i] ^ g();
    }
}
function key() {
    return Math.floor(Math.random() * 0x100000000);
}
function stream(seed) {
    let v = (secret_modMultiply(seed, 0x7fffffed) + 0x00c39ec3) >>> 0;
    return function () {
        return (v = (secret_modMultiply(v, 0x0019660d) + 0x3c6ef35f) >>> 0);
    };
}
function getUint32(a, p) {
    const v0 = (a[p + 0] << 0x18) >>> 0;
    const v1 = (a[p + 1] << 0x10) >>> 0;
    const v2 = (a[p + 2] << 0x08) >>> 0;
    const v3 = (a[p + 3] << 0x00) >>> 0;
    return (v0 | v1 | v2 | v3) >>> 0;
}
function setUint32(a, p, v) {
    a[p + 0] = v >>> 0x18;
    a[p + 1] = v >>> 0x10;
    a[p + 2] = v >>> 0x08;
    a[p + 3] = v >>> 0x00;
}
/**
 * Multiply modulo 0xFFFFFFFF.
 */
function secret_modMultiply(a, b) {
    a = a >>> 0;
    b = b >>> 0;
    let r = 0;
    for (let i = 0; i < 32; i++) {
        if (((b >>> i) & 1) === 1) {
            r += a << i;
        }
    }
    return r >>> 0;
}

;// ./packages/keybr-binary/lib/index.ts




;// ./packages/keybr-phonetic-model/lib/letter.ts
class letter_Letter {
    codePoint;
    f;
    label;
    constructor(
    /** Unicode character code point. */
    codePoint, 
    /** Relative frequency. */
    f, 
    /** Letter display label. */
    label = String.fromCodePoint(codePoint)) {
        this.codePoint = codePoint;
        this.f = f;
        this.label = label;
    }
    toString() {
        return this.label;
    }
}
(function (Letter) {
    Letter.digits = [
        new Letter(/* "0" */ 0x0030, 0.0),
        new Letter(/* "1" */ 0x0031, 0.301),
        new Letter(/* "2" */ 0x0032, 0.176),
        new Letter(/* "3" */ 0x0033, 0.125),
        new Letter(/* "4" */ 0x0034, 0.097),
        new Letter(/* "5" */ 0x0035, 0.079),
        new Letter(/* "6" */ 0x0036, 0.067),
        new Letter(/* "7" */ 0x0037, 0.058),
        new Letter(/* "8" */ 0x0038, 0.051),
        new Letter(/* "9" */ 0x0039, 0.046),
    ];
    Letter.punctuators = [
        new Letter(/* "," */ 0x002c, 9.0),
        new Letter(/* "." */ 0x002e, 8.0),
        new Letter(/* "!" */ 0x0021, 2.0),
        new Letter(/* "?" */ 0x003f, 2.0),
        new Letter(/* ";" */ 0x003b, 1.0),
        new Letter(/* ":" */ 0x003a, 1.0),
        new Letter(/* "'" */ 0x0027, 1.0),
        new Letter(/* '"' */ 0x0022, 1.0),
        new Letter(/* "-" */ 0x002d, 1.0),
    ];
    Letter.specials = [
        // new Letter(/* "!" */ 0x0021, 1),
        // new Letter(/* '"' */ 0x0022, 1),
        new Letter(/* "#" */ 0x0023, 1),
        new Letter(/* "$" */ 0x0024, 1),
        new Letter(/* "%" */ 0x0025, 1),
        new Letter(/* "&" */ 0x0026, 1),
        // new Letter(/* "'" */ 0x0027, 1),
        new Letter(/* "(" */ 0x0028, 1),
        new Letter(/* ")" */ 0x0029, 1),
        new Letter(/* "*" */ 0x002a, 1),
        new Letter(/* "+" */ 0x002b, 1),
        // new Letter(/* "," */ 0x002c, 1),
        new Letter(/* "-" */ 0x002d, 1),
        // new Letter(/* "." */ 0x002e, 1),
        new Letter(/* "/" */ 0x002f, 1),
        // new Letter(/* ":" */ 0x003a, 1),
        // new Letter(/* ";" */ 0x003b, 1),
        new Letter(/* "<" */ 0x003c, 1),
        new Letter(/* "=" */ 0x003d, 1),
        new Letter(/* ">" */ 0x003e, 1),
        // new Letter(/* "?" */ 0x003f, 1),
        new Letter(/* "@" */ 0x0040, 1),
        new Letter(/* "[" */ 0x005b, 1),
        new Letter(/* "\" */ 0x005c, 1),
        new Letter(/* "]" */ 0x005d, 1),
        new Letter(/* "^" */ 0x005e, 1),
        new Letter(/* "_" */ 0x005f, 1),
        new Letter(/* "`" */ 0x0060, 1),
        new Letter(/* "{" */ 0x007b, 1),
        new Letter(/* "|" */ 0x007c, 1),
        new Letter(/* "}" */ 0x007d, 1),
        new Letter(/* "~" */ 0x007e, 1),
    ];
    // For paired characters, the frequency is halved to account for the fact that they are used in pairs.
    Letter.programming = [
        new Letter(/* "(" */ 0x0028, 2.5),
        new Letter(/* ")" */ 0x0029, 2.4),
        new Letter(/* "{" */ 0x007b, 1.8),
        new Letter(/* "}" */ 0x007d, 1.7),
        new Letter(/* '"' */ 0x0022, 1.7),
        new Letter(/* "'" */ 0x0027, 1.7),
        new Letter(/* "," */ 0x002c, 1.6),
        new Letter(/* ";" */ 0x003b, 1.5),
        new Letter(/* "[" */ 0x005b, 1.5),
        new Letter(/* "]" */ 0x005d, 1.5),
        new Letter(/* ":" */ 0x003a, 1.4),
        new Letter(/* "." */ 0x002e, 1.3),
        new Letter(/* "=" */ 0x003d, 1.2),
        new Letter(/* "+" */ 0x002b, 1.1),
        new Letter(/* "-" */ 0x002d, 1.0),
        new Letter(/* "*" */ 0x002a, 0.9),
        new Letter(/* "/" */ 0x002f, 0.8),
        new Letter(/* "%" */ 0x0025, 0.7),
        new Letter(/* "|" */ 0x007c, 0.6),
        new Letter(/* "&" */ 0x0026, 0.5),
        new Letter(/* "!" */ 0x0021, 0.4),
        new Letter(/* "?" */ 0x003f, 0.3),
        new Letter(/* "<" */ 0x003c, 0.2),
        new Letter(/* ">" */ 0x003e, 0.1),
        new Letter(/* "_" */ 0x005f, 0.1),
        new Letter(/* "#" */ 0x0023, 0.1),
        new Letter(/* "@" */ 0x0040, 0.1),
        new Letter(/* "$" */ 0x0024, 0.1),
        new Letter(/* "^" */ 0x005e, 0.1),
        new Letter(/* "~" */ 0x007e, 0.1),
        new Letter(/* "\" */ 0x005c, 0.1),
        new Letter(/* "`" */ 0x0060, 0.1),
    ];
    Letter.toLetter = (letter) => {
        return "letter" in letter ? letter.letter : letter;
    };
    Letter.codePointOrder = (letters) => {
        return [...letters].sort((a, b) => a.codePoint - b.codePoint);
    };
    Letter.frequencyOrder = (letters) => {
        return [...letters].sort((a, b) => b.f - a.f || a.codePoint - b.codePoint);
    };
    Letter.weightedFrequencyOrder = (letters, weight) => {
        return [...letters].sort((a, b) => weight(a) - weight(b) || b.f - a.f || a.codePoint - b.codePoint);
    };
    Letter.restrict = (letters, codePoints) => {
        return [...letters].filter(({ codePoint }) => codePoints.has(codePoint));
    };
    Letter.normalize = (letters) => {
        const sum = letters.reduce((sum, { f }) => sum + f, 0);
        return letters.map(({ codePoint, f, label }) => new Letter(codePoint, sum > 0 ? f / sum : 0, label));
    };
})(letter_Letter || (letter_Letter = {}));

;// ./packages/keybr-phonetic-model/lib/transitiontable.ts



const signature = Object.freeze([
    0x6b, 0x65, 0x79, 0x62, 0x72, 0x2e, 0x63, 0x6f, 0x6d,
]);
class transitiontable_TransitionTable {
    static load(buffer) {
        const reader = new Reader(buffer);
        readSignature(reader);
        const chain = readChain(reader);
        const segments = readSegments(reader, chain);
        if (reader.remaining() > 0) {
            throw new DataError();
        }
        return new transitiontable_TransitionTable(chain, segments);
    }
    chain;
    segments;
    constructor(chain, segments) {
        if (segments.length !== chain.segments) {
            throw new Error();
        }
        this.chain = chain;
        this.segments = segments;
    }
    get order() {
        return this.chain.order;
    }
    get alphabet() {
        return this.chain.alphabet;
    }
    get size() {
        return this.chain.size;
    }
    segment(chain) {
        return this.segments[this.chain.segmentIndex(chain)];
    }
    compress() {
        const writer = new Writer();
        writeSignature(writer);
        writeChain(writer, this.chain);
        writeSegments(writer, this.chain, this.segments);
        return writer.buffer();
    }
    letters({ letterName }) {
        const map = new Map(this.alphabet.map((codePoint) => [codePoint, 0]));
        for (const segment of this.segments) {
            for (const { codePoint, frequency } of segment) {
                map.set(codePoint, (map.get(codePoint) ?? 0) + frequency);
            }
        }
        return [...map.entries()].map(([codePoint, f]) => new Letter(codePoint, f, letterName(codePoint)));
    }
    toNgram1() {
        const ngram = new Ngram1(this.alphabet);
        for (const segment of this.segments) {
            for (const { codePoint, frequency } of segment) {
                ngram.add(codePoint, frequency);
            }
        }
        return ngram;
    }
    toNgram2() {
        const ngram = new Ngram2(this.alphabet);
        let index = 0;
        for (const segment of this.segments) {
            const codePoint0 = this.chain.codePoint(index);
            for (const { codePoint, frequency } of segment) {
                ngram.add(codePoint0, codePoint, frequency);
            }
            index += 1;
            if (index === this.chain.size) {
                index = 0;
            }
        }
        return ngram;
    }
}
class transitiontable_Chain {
    order;
    alphabet;
    size;
    segments;
    width;
    offsets;
    constructor(order, alphabet) {
        this.order = order;
        this.alphabet = alphabet;
        this.size = this.alphabet.length;
        this.segments = Math.pow(this.size, this.order - 1);
        this.width = Math.pow(this.size, this.order);
        this.offsets = offsets(this.size, this.order);
    }
    segmentIndex(chain) {
        const { order, offsets } = this;
        const { length } = chain;
        let index = 0;
        for (let i = 0; i < order - 1; i++) {
            const codePoint = chain[length - order + i + 1] || 0x0020;
            index += this.index(codePoint) * offsets[i + 1];
        }
        return index;
    }
    entryIndex(chain) {
        const { order, offsets } = this;
        const { length } = chain;
        let index = 0;
        for (let i = 0; i < order; i++) {
            const codePoint = chain[length - order + i] || 0x0020;
            index += this.index(codePoint) * offsets[i];
        }
        return index;
    }
    codePoint(index) {
        return this.alphabet[index];
    }
    index(codePoint) {
        return this.alphabet.indexOf(codePoint);
    }
}
function writeSignature(writer) {
    for (const c of signature) {
        writer.putUint8(c);
    }
}
function readSignature(reader) {
    for (const c of signature) {
        if (reader.getUint8() !== c) {
            throw new DataError();
        }
    }
}
function writeChain(writer, chain) {
    writer.putUint8(chain.order);
    writer.putUint8(chain.size);
    for (let i = 0; i < chain.size; i++) {
        writer.putUint16(chain.alphabet[i]);
    }
}
function readChain(reader) {
    const order = reader.getUint8();
    const size = reader.getUint8();
    const alphabet = [];
    for (let i = 0; i < size; i++) {
        alphabet.push(reader.getUint16());
    }
    return new transitiontable_Chain(order, alphabet);
}
function writeSegments(writer, chain, segments) {
    for (let segmentIndex = 0; segmentIndex < chain.segments; segmentIndex++) {
        const segment = segments[segmentIndex];
        writer.putUint8(segment.length);
        for (const { codePoint, frequency } of segment) {
            writer.putUint8(chain.index(codePoint));
            writer.putUint8(frequency);
        }
    }
}
function readSegments(reader, chain) {
    const segments = [];
    for (let segmentIndex = 0; segmentIndex < chain.segments; segmentIndex++) {
        const segment = [];
        const length = reader.getUint8();
        if (length >= chain.size) {
            throw new DataError();
        }
        for (let entryIndex = 0; entryIndex < length; entryIndex++) {
            const index = reader.getUint8();
            if (index >= chain.size) {
                throw new DataError();
            }
            const frequency = reader.getUint8();
            if (frequency === 0) {
                throw new DataError();
            }
            segment.push({ codePoint: chain.codePoint(index), frequency });
        }
        segments.push(segment);
    }
    return segments;
}
function offsets(size, order) {
    const offsets = new Array(order);
    for (let i = 0; i < order; i++) {
        offsets[i] = Math.pow(size, order - i - 1);
    }
    return offsets;
}

;// ./packages/keybr-phonetic-model/lib/builder.ts


class TransitionTableBuilder {
    chain;
    frequencies;
    constructor(order, alphabet) {
        this.chain = new Chain(order, alphabet);
        this.frequencies = new Float64Array(this.chain.width);
    }
    set(chain, frequency) {
        if (!(frequency > 0)) {
            throw new TypeError();
        }
        this.frequencies[this.chain.entryIndex(chain)] = frequency;
    }
    add(chain, frequency) {
        if (!(frequency > 0)) {
            throw new TypeError();
        }
        this.frequencies[this.chain.entryIndex(chain)] += frequency;
    }
    append(word) {
        const { order, alphabet } = this.chain;
        const chain = new Array(order).fill(0x0020);
        for (const codePoint of toCodePoints(word)) {
            if (codePoint !== 0x0020 && alphabet.includes(codePoint)) {
                if (push(chain, codePoint)) {
                    this.add(chain, 1);
                }
            }
            else {
                if (push(chain, 0x0020)) {
                    this.add(chain, 1);
                }
            }
        }
        if (push(chain, 0x0020)) {
            this.add(chain, 1);
        }
    }
    build() {
        return new TransitionTable(this.chain, this.buildSegments());
    }
    buildSegments() {
        const { chain, frequencies } = this;
        const segments = [];
        for (let segmentIndex = 0; segmentIndex < chain.segments; segmentIndex++) {
            const segment = [];
            for (let entryIndex = 0; entryIndex < chain.size; entryIndex++) {
                const frequency = frequencies[segmentIndex * chain.size + entryIndex];
                if (frequency > 0) {
                    segment.push({ codePoint: chain.codePoint(entryIndex), frequency });
                }
            }
            segments.push(this.scaleFrequencies(segment));
        }
        return segments;
    }
    scaleFrequencies(segment) {
        if (segment.length > 0) {
            const sorted = [...segment].sort((a, b) => b.frequency - a.frequency);
            scaleRough(sorted);
            scaleFine(sorted);
        }
        return segment;
    }
}
function scaleRough(segment) {
    const sum = sumFrequencies(segment);
    for (const entry of segment) {
        entry.frequency = Math.max(1, Math.round((255 / sum) * entry.frequency));
    }
}
function scaleFine(segment) {
    let sum = sumFrequencies(segment);
    while (sum > 255) {
        let i = 0;
        while (sum > 255 && i < segment.length) {
            const entry = segment[i];
            if (entry.frequency > 1) {
                entry.frequency--;
                sum--;
            }
            i++;
        }
    }
    while (sum < 255) {
        let i = 0;
        while (sum < 255 && i < segment.length) {
            const entry = segment[i];
            entry.frequency++;
            sum++;
            i++;
        }
    }
}
function sumFrequencies(segment) {
    let sum = 0;
    for (const entry of segment) {
        sum += entry.frequency;
    }
    return sum;
}
function push(chain, codePoint) {
    const { length } = chain;
    if (codePoint === 0x0020 && chain[length - 1] === 0x0020) {
        return false;
    }
    for (let i = 0; i < length - 1; i++) {
        chain[i] = chain[i + 1];
    }
    chain[length - 1] = codePoint;
    return true;
}

;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-ar.json
const blacklist_ar_namespaceObject = [];
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-be.json
const blacklist_be_namespaceObject = [];
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-de.json
const blacklist_de_namespaceObject = /*#__PURE__*/JSON.parse('["ahcsbamu","faznawhcsnef","rtlatrneia","hranalverke","ubhcrasm","hrcas","enarschbums","rcfcashik","erarschfick","eocathrzfs","eecaihrggs","rathciseghcs","rckkashes","aherciesrhrkc","erarschleck","rclcashoh","erauberfeig","ugieafeln","aefhecsetnkiibgpcf","aarsdtb","eberuhsbeirt","oibbm","ieulbsxel","lbnesa","lbepmalhcssa","amdlbnn","isdlbnn","eozbn","rbezta","rcbdbuhue","ubsm","ubnesm","rchrcakue","edpp","eerptpd","reppedet","odrettewrenn","rchrdekue","rcscdekak","skcerdua","ehcdukrrse","lkcdekrrse","tncdekrsse","abmmudzt","eumdm","ifmmudkc","okmmudfp","eapdcfukbm","ledd","rrceeashn","rekito","ilgiefgn","ifkc","eikfc","ifnekc","ifrekc","rhkflfieec","siacukf","iftskc","ikttfcsue","tikfc","alzlifsu","lfreshciwhca","ltcefithn","eozft","ofrekcelnezt","rfezta","rmfcfedik","cekftig","egli","kflgieecri","ogtmmadrevtt","eekhsfasrc","gsnhsriiir","ohom","sessrshnoeiceh","nsrhoeuhnh","uher","nuehr","ueshhrnon","tdoii","eshic","eakktbazrc","eakkc","aknekc","akuskcwrt","erkamelfick","eepksfablm","akekan","eimkm","lkreiehcsgu","eebls","ilkc","mls","ulehcs","hcstulne","llemm","uhluamer","imfl","imts","ektsimlr","ittcmssk","temorgenlat","iutmf","umihcs","umrekcifrett","esmp","mes","taknc","reeng","inregg","inlepp","eutnt","nneeoairn","hroralverke","msagrone","msagrosu","seipn","eprenn","resrepes","eerrsvp","evrepresr","iplemm","zwmpueitlm","eirmnpp","eilnnkp","eisps","ipness","ipress","loepp","opnepp","oonpr","upff","sucahtq","ergidu","totseer","uebmrdlus","enrudelbums","asu","asnegu","eaascbckrh","csrekcifefah","ouhrsreaeeinnsszhcf","icshses","cskcerdssieh","siehcses","csfpokessieh","ceseshisn","ceseshisr","rlscheisske","pfscheissko","ichees","ehesuicrh","ciseshesr","malhcsep","clmeshapn","nknseaclch","acnhzws","azushrcwnltcesh","sebewekhnccia","csdnuheniewh","lhwstucech","cwctshuhl","csluwh","nrnieepeegusts","esgnurpsneti","seretpgisnen","hsasia","shseeis","psitsa","psamre","chspermaars","zespermafot","mhaeeacmpplsrs","tespermastu","piiges","npeinns","npeirns","npsitns","etlefu","hcttitne","eittt","itnett","kfttieicnt","itztirpsnett","zrntntpeieistt","zrntrtpeieistt","rtesna","rtlleuxessna","treoltt","eashvrrce","madrevtm","rmdvtaeemr","efctvrike","rkfvtieecr","skfvtieecr","erverflucht","oldovliit","envollpfost","ovneiehcsll","elvolltrott","vnleg","ehdwuearrn","heeiicw","iweshc","siecnhw","siecrhw","obztiwdl","eikzc"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-en.json
const blacklist_en_namespaceObject = /*#__PURE__*/JSON.parse('["nala","snlaa","nasu","nasesu","raes","ohesrael","reoeashls","sreas","sas","sagabs","asgssba","sbniasadt","sbneasagr","sgbaeasrns","istseba","olcssanw","sconaslws","oscskca","rccakrseas","sseas","ascsefa","uscskfa","sfceasukr","sgbiasoln","satahs","esasdha","oslseha","lohssase","shpeasopr","sjceasakr","iscskla","slceasikr","smneasoky","numssahc","rcmahusens","sngeasigr","sprtasiae","hsistsa","ohsssael","ssceasukr","sadaws","ispsewa","salbl","abtopm","aarsdtb","ratsabsd","ebrena","itsaebla","tybeastiali","ylsbitetia","ieasltb","yltbiietas","eilbb","ibselb","hicbt","ahctibss","hietrcb","hietscb","hiitncb","ihctibgn","thctibti","ibyhct","lbydoo","jloobwb","ojwolbsb","collobsk","obxoll","roebn","obsren","obbo","sobbo","aukkekb","hsllubti","ulhtblsis","ubtt","sutbt","iarmlgc","ohwmacer","chnci","hcscni","khnci","hcskni","dhaco","ehdco","hctsir","shtrsic","hchcru","hcruhcse","lcti","aftilcec","uftilckc","rotilcsi","sltci","ckclusterfu","ockc","ibkcocet","rrkcgboeuc","afkcocec","rckckfoeuc","ehkcocda","ynkckmoeoc","onkcoces","tgkcgnoeuc","sokcc","hskcocti","uskcockc","dckcksoeuc","rckcksoeuc","ngcocksucki","okukccscs","hoioecc","ocyhco","ocreto","rcpa","rcyppa","srpca","kroco","ucm","ubblcmube","ercumdumpst","ucremm","iunmgmc","huomtsc","ohsmucst","luumtsc","ulsmucst","aurmttc","uscunilling","uceinn","uscunniling","uctn","aftnucec","ohtnucel","iltnuckc","rctckluein","ngcuntlicki","ruangtc","sutcn","lstnuctu","yefccbruk","edcyberfuck","ercyberfuck","ycgnikcufreb","adog","saodg","adtimm","adnm","oegdg","weedj","weejded","iwejedgn","edswej","idkc","biacgkd","rsdickbeate","afkcidec","ufkcidkc","ehkcidda","ohkcidel","ikucdcjie","imkcidkl","sikdc","lskcidpa","wiacdkd","lakdswieec","ewkcidde","wiocdkd","idek","siedk","oiddl","idkn","hiiptsd","bhcoodga","odeiko","odehcu","oceaduhbg","odelffawehcu","uded","tutdeed","udssam","udbm","ausmsbd","ufbmudkc","hsbmudti","huimtsd","ichec","jclteauae","dacetujela","sacetujela","ngejaculati","onejaculati","afg","afgabg","afcefgukr","iangggf","aftigg","iatgsgf","aftogg","kcgfooactg","oatgsgf","sagfg","taofg","afsg","aargdtf","aftr","afdetr","ianrgtf","yatfr","iassmcf","iasstcf","sicsafst","afssat","teiloaf","hecfl","heelscf","ihclefgn","tallefoi","efhctl","hitfl","kfgfueicrn","ifdekcufregn","ifrekcufregn","fecggunnfiirk","ksfingerfuc","uftsifkc","dctfkfieus","rctfkfieus","ngfistfucki","lfrema","oflo","solfo","krafe","kreedaf","ikaerfgn","rfskae","rfykae","ufkc","auscskf","buacgkf","buocykf","ukrifcban","ubkcuftt","ufdekc","ufrekc","eurcskf","ufrekcusrekc","afkcufec","ehkcufda","ohkcufel","ufnikc","iuncgkf","ufemkc","nuuctkf","unkcuftt","oufcfkf","sukfc","uktcfcsik","atkcufdr","ufpukc","wuacdkf","wuictkf","iwkcuftt","yukfc","erfudgepack","ufk","abgnaggn","dngggbaean","agy","agsy","ogd","aomdndg","odmigdant","eosdsdg","ogsd","hocgo","ogko","rgogni","oudgi","ugor","iyepssg","yysgp","jaonbdh","exhardcores","ehbe","ehll","ehiatn","ohe","ohyl","ohom","ohtihsbmudom","ohyekn","einrohts","yonhr","ohxest","iunmgph","tdoii","distoi","aascskj","ajp","ejze","ejkr","sekjr","ejw","deejw","ejgniw","ejhsiw","ejsw","biogoaj","diajh","ijms","ijz","ijmz","ijzz","ijsezz","ujgg","sugjg","ikek","ikll","silkl","okkc","okmudn","hocko","okhcto","ukm","ruekm","ukremm","iunmgmk","uksm","snikgluuin","uktn","ykek","eleizz","oldr","sodlr","ults","iunsgtl","ggafcmte","imkc","imfl","sifml","eigmn","omm","omsm","noomr","omsnor","ohfcmtauk","auhmcaokft","azmothafuck","edmothafuck","ermothafuck","inmothafuck","omgnikcufaht","suhmcaokft","kfhmueocrt","omdekcufreht","omrekcufreht","omnikcufreht","mecghuntfiork","umff","ufiemfdvr","sufmf","iunnggm","aniz","oerng","aigng","insagg","inregg","eirgsgn","intelg","unt","unst","auctksn","romsag","srmgsao","roseig","royg","apik","oacnhop","eprekc","dhkpeeearc","dspeckerhea","eercskp","epod","seopd","seipn","seensip","erpenisfuck","erpenispuff","senohpxe","hpku","hpdeku","ihnugkp","kheudkp","ikkuhpgn","shkpu","hpqu","ips","sieps","niips","ipgnis","fiops","ipss","ipdess","ipress","ipsess","islppsfas","ipniss","iinsgsp","oifsfsp","roepksoeml","ooclklp","opno","aonoinp","aonoynp","atnoopgn","eyporchmonk","opnr","oonpr","hypornograp","opsonr","sonpr","krcpi","rpskci","etsputrtio","esprostitut","rpnoitutitso","nunnyap","autpn","upseis","iuesssp","yusps","upgnikcilyss","upys","upot","rueqe","uqsree","arep","daerp","saerp","argnip","beorn","irbojm","iusbhbr","iukrs","rgdsgnaein","ocnhgls","wcesr","csetor","csmu","scmsu","hsti","ahsists","bhaigts","rgtsgbheai","htrisiban","hetsabhtri","uctihstn","idtihskc","hsdeti","aftihsec","htaesifcd","uftihsll","ehtihsda","ohtihsel","htossihue","ihnigts","shtsi","ershitspitt","httisisan","theidts","theirts","htissitet","ittihsgn","hsytti","yhtsi","hszi","nhiitzs","kknsa","tkese","klfcsuluk","lstu","blaugts","sltsu","msge","mstu","smtsu","nshcta","hctansse","psci","kpcsi","psskci","opgleos","kpnsu","uskc","iuncgks","suksc","atdr","sadtr","citsetel","ntthundercu","itt","uictkft","cuftitsk","itst","itfcttyuk","suttcyikft","wtta","iltawtsp","swtta","efttfwwlaa","erunclefuck","nuyloh","avg","avanig","naagsiv","awkn","ianngkw","sakwn","aectkbw","ehrwo","berohwga","hrbgwoeas","hrfcwoeae","sarwcehefo","hwsero"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-es.json
const blacklist_es_namespaceObject = /*#__PURE__*/JSON.parse('["laabad","nlnuaiigs","slataatne","ssntaeiao","saon","azdaa","abtopm","iadnodb","ratsabod","atndbsiao","erusabor","ieasltb","adbestialid","obob","soobb","atefobad","loaisob","soabl","eorlalb","rellobsa","orcobrahs","ardbi","simorbat","ubatec","ourbr","ubsorr","aarcb","acsarb","acnorb","norbacse","acnrb","nrbacse","acac","saacc","alfihcod","lhairfc","dhaco","ehdco","ohlcu","hcsolu","ahpcu","ahduapc","aschupapoll","tepuhcn","icp","icat","lcti","rotlcsi","ocac","oiadccnno","ootci","noejsoc","oarjcmdea","sleclpoaom","ouitcmnsa","ssuctnoaim","ocahcn","rascdoooln","ocserodalosn","hoioecc","ocreto","aarcgoofp","airclooifp","iacoprolagn","outacqeer","rerroces","oco","sooc","irteamc","irneotc","nitercso","ucatal","ucol","suocl","snicgluuin","uscunilling","uscunniling","ruangtc","ycsila","coenr","iadendrofil","ooainoemrnmetds","uedsond","ikehdclce","nciditiag","eiudq","eotltcd","ncidinoam","ztidrnoiam","soodm","hosdo","rdsago","alucnead","sitoreom","ircote","diletasuvc","rsmpaee","esestupidec","iptseod","ueocun","uylaace","neyaculaci","ycldeauao","oacenuydla","lucayera","sicsafom","acsofsims","sicsafat","acsafsits","leafc","icalefn","tireolf","idsfjnoe","aolfl","aodlolf","dallofro","nallofod","ofrall","edtforsno","amlelf","oalgl","eiaegntls","scighpiiil","sliglpiaol","eopgl","oodgr","oeamgrgso","nraarzg","rgatei","rgogni","sahamburgue","ehbe","enraoh","eerrorh","upajihat","upojihat","cohomoerti","yokhn","eorhr","diatoi","tdaisoi","doeeiitcs","tdeizoi","diotoi","tdoisoi","cmibli","mieibcls","sntcoei","reifnion","biogoaj","igrojgebo","roejd","ojodid","snikgluuin","aeoolmcs","aeuolmcls","aslanzallam","aibselan","ebaalsins","oebls","elsobs","olatil","toalsil","ruijaul","amazic","aiormczra","adcmliin","iatladm","tidlamsa","iatlodm","tidlamso","amadam","daamsam","nadmoam","raamm","cahpeam","hcapamse","amacir","caarsim","onimacazor","rnimecaaor","carnim","litramol","aiomsqatus","ncrssoaeaeibtm","amnicabrets","ebtmaeatrs","atramsubr","semasturbar","imadre","ohrmidijae","diaesrm","ansagl","unosod","unze","ejtoe","ariog","rosaig","arnoi","apaj","aposay","epsohc","epod","seopd","epatol","tealsop","eejnodp","epen","epatip","lelraip","llirepsa","aerpr","epsarr","epodneiugisr","otvpieedrr","nepz","zicnap","ipehcn","ips","aolpl","opsall","olskplaua","opoz","atsputrtio","upat","suapt","satcair","ararem","irodaz","suprleoocm","oegsnratin","neesm","seosn","esox","assoplagait","assoplapoll","diciusoi","socid","etat","seatt","etanot","niemlot","aottn","otsatn","otratnes","oottn","otsotn","apraar-ertiost","sevartit","aegvr","evsagr","ilcvoain","auvvl","uvsavl","aorzr","ozsarr"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-fa.json
const blacklist_fa_namespaceObject = [];
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-fr.json
const blacklist_fr_namespaceObject = /*#__PURE__*/JSON.parse('["baitur","tmeprua","noiladule","satuas","tnettata","tvoonra","abdrat","feuba","ibhcta","tiobc","ibet","iebibtmos","siebt","obledr","foounfb","onguoblu","ogolbunue","nuiainogolstobu","obresiluongu","obergu","oinuoblu","orilbudle","eouuxsb","lrearnb","elnarbru","qruaenb","uaocc","earcf","codlaceh","hhaarcc","sagahces","hufrcafad","hctnai","nhtieac","tnaihcse","nhtisac","hcei","eaecsnhsni","rheci","hcruei","uhrisec","tenihcco","eoncqehuti","hchuel","qhuneoc","eohcc","ocn","ocdran","sosneac","ihcnocre","aorndnc","rannoced","rannocsd","sannoces","onsecnass","eoncn","rennocei","onrecneis","ocsn","lolueic","lliuocse","lliuocno","ercouillonn","finuocel","atruocdu","rcnite","arredvc","urreevc","rcirci","rcetto","rctto","rulacoilt","liuorcel","rcnit","ucl","ucsl","edelib","eaudseeslg","dremedre","uitsepd","iptndsuet","tupsidre","tupsidse","tupsidze","rdeugo","ureosgd","ureorgd","liuordel","nuodc","nnocudto","onegudxu","aungdld","delib","nnceod","nnocdre","nnocdse","eaudseslg","rdmeed","dremdre","cnammeeh","cnammeh","mednemrat","rmdmeee","mednemret","dremmere","dremmese","meduemrer","seeeurmrdm","eeeeurmsdm","dremmeze","rmdmee","meefap","mefap","eoaeupmtap","oaeupmtap","neeluc","lnecrue","elucneru","neluc","lncsue","unrfele","inrfeoe","inrfoe","neruenilesav","spiea","sigiepnon","ntoer","egasfinse","ifetto","eouurtf","ofertu","zrtfi","ufreim","uildfslae","eacgr","eapgu","dlnga","ednalgru","lnesgadue","lguolliuodna","lgudna","lnugo","ngeluo","loogg","oilngulad","ogeniu","ogedru","negourgandi","rgasgonse","cineugeh","unolgidue","icebmiel","icbmiel","eaucxhl","tatveel","totpeel","taomg","amehcn","tncmdhaoar","molegltrisaui","cassamer","ascemsarr","avetmuite","edilmrale","nldmlaeoir","eedmr","emredr","emsedr","eeurxdm","ieerrdm","qidremeu","edqemrius","emdralliuodr","edmr","imothc","bilneam","siumn","iealmsrbe","ialmsrbe","onilmiale","eiamlcolan","aciromdu","anes","anez","aniz","sainz","oerng","inca","esiainxu","eiunq","inreuq","orng","fuonapel","raitnap","epeuqc","epelad","eped","qeudeop","eunupqead","ept","sesteap","epxuet","oiugfnp","eiusxsp","ipuoss","tlreeup","clupo","opsacr","sacropes","opvacu","opfu","eafpsfosiu","ofaspuise","opednu","opdnu","etrpuroriu","iusneap","upniat","iuntsap","upet","suept","nuipt","pelad","ledsap","ohlpdpie","sioplpehd","qudeop","pd","spd","unupqead","ssteap","pxuet","atueuqdr","uarcelr","naort","piepeor","pipeor","ortorreipseb","orfibs","uoruelr","uaignos","asdual","asel","paosl","apolasdr","aoadslprs","asepol","aoeislpre","srosipaeel","paelsos","aoetslpte","algnastn","agatsnlns","eirsloalut","csbebh","csuelh","csconh","qonhcseu","otsustiex","taiuserqe","taiusrqe","oalfeit","ietantouser","uotnatez","tatpeet","uolratez","eteb","etb","etcltsiue","suttlieecs","etxuet","eebtu","ebtu","otdrac","nreaeit","druocut","saiurtes","txuet","naivg","avsnig","iaeunrv","aiseedv","ivre","ivlo","eilvo","tmlveeinmo","ivrelo","eiuorlv","ilvo","ivelo","aisedv","rnoxepeuir","rnoxepuir","eelyu","oydu","oynipu","ionuepy","yianpsouiiont","oyertu","gguueez","gguuez","spia","ntor"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-he.json
const blacklist_he_namespaceObject = [];
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-it.json
const blacklist_it_namespaceObject = /*#__PURE__*/JSON.parse('["apullaot","taammucchia","enlaa","aparraot","raasur","raosur","onaaatstas","csagabai","sasgaab","rangabis","adacblrca","ealbl","ratsabad","ratsabed","ratsabid","ratsabod","eartetb","oantatb","ebonil","ranrebad","ibag","ehcsibar","ehcsibor","ancbahoric","ihccobon","obolif","obatai","ledrobol","rbacni","oiacubol","uldoib","ubenos","acerac","aaelccrla","aaccc","copaiplcalace","evadacer","acerag","acatag","acetag","tehgacat","aancg","eancg","acenog","iaccs","aatzazc","mizzacam","oazcz","oanzazc","oanzezc","oanzizc","oescs","hcacce","phpiaac","avaihcer","avaihcat","icopso","icitcucaa","oilgocan","oilgocen","oilgocin","uotronc","aozcz","irneatc","irneotc","rcotsi","uatncltia","uatncltoa","uatncltoe","ucol","ucanol","ucenol","ucinol","eeidncetif","ido","ilatidon","afav","iafemminucc","ifac","ifag","ifenog","iocifncho","eortetf","rettofis","uottatf","uottotf","rccnfaioe","rfange","tecorfot","rfoico","oicorfen","crioosf","egus","oonledg","odraugen","meilibcle","meilibcli","nazriczae","iaairznszc","nazticzai","nazticzao","igniooscirnli","nioiog","eccllcauo","ihccelon","oleraf","aoflf","aorfefl","nandaom","angimnaga","nanraom","aedmr","edcimraca","aetradm","ienradm","oenradm","oesrodm","tongimat","atnmoointg","etnmoointg","hiinacm","icinmnhoe","oman","aotmn","aornetm","catromic","ausms","aerng","oerng","heiracn","apolud","ealpl","oaslolp","cactaap","naztaop","irocepan","eecps","oiipc","airnecp","inlnpnooe","aippp","ipcippaca","oinpapp","oinpepp","ipp","ailpr","aicsiper","ipoics","lilsoep","ootptoitls","oiirpmcae","aoppm","ionmopp","aocpr","oocpr","aotpt","aumpipp","auntatp","utntptaae","eitpeaurnt","utnnptaoa","utnnptaoe","luiaagq","ecinrchoe","eranig","rooecirnliign","razziris","eaprliolbm","rilipgnmoooci","eaprliolpm","aiffuron","ettabser","btessatri","bsarro","arrobsat","orrobsen","alosadbtor","csizza","ocmse","acroeps","actoaps","cseraiggerro","esag","lnursigae","lnutsigaa","msatappardna","osaicc","oslemc","aocsr","ongapsal","enmsapprio","hccitsoi","ntzraos","toztsrnaa","ntzroos","toznsrnoe","ucimschai","ucinschoe","itlevsan","enrsagvrie","oeztlaalnr","oenrert","eettt","iterar","otap","arito","ornoeit","abmorter","abmortat","aacvc","ocfvuaalnf","aarnegv","einzn","oolcacz","oclnzcooa"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-nl.json
const blacklist_nl_namespaceObject = /*#__PURE__*/JSON.parse('["agrnanead","gdraiaannn","rfebnea","neearbfebl","ssorfane","kkurfane","frkeatekn","fastaalpkrew","kiezfane","giuzfane","antai","ksaab","sao","naebl","neobrneedd","lsbbtoeerf","ebneff","ebnekk","eaeeblzrn","reesneideetmob","terbu","lemeobne","lereoblu","oblemmupnere","lekkoblu","oegibtrel","rbnetseohkeo","regbppreiu","leffubne","ednela","idkazk","oobdm","odpokm","odroom","rakndaiot","rdlo","erdrooggeil","tlodogroko","lieek","nedreg","oleasmf","kleinkf","kleirkf","megadverdam","agkabl","agt","ezogooengd","eelgi","enliegfe","leugl","aeindag","ueknteg","jepptig","egreteimedos","ansdogma","megodverdom","engodverget","traakfg","rtnugaekt","llpgdpreee","tregi","ahjs","epmeohtr","ohre","ohnere","rthoerenbuu","erhoerenlop","ohgire","tojeerh","ohl","uhretf","rashldueei","naekn","ugkettingze","noakmrleka","lrbekeeer","oljko","ileonok","lkklovsejtoo","otoolkgo","ztoolkka","enklootzakk","lkneto","nkro","oktn","nutkknoeen","rkrekkaketne","ukt","eujkt","tklterkeujeitk","kwiaekk","otliefdesgr","ull","uhnellans","ulnell","ulgill","ultl","ullemm","tekfamle","amsm","ermatennaai","eajmt","emraak","omf","omneff","umst","ania","anneia","taina","takna","reeng","ensreg","enku","enneku","ektenusir","teknu","enetku","tihnc","inrekk","eirkskn","eolult","liegpone","neaornpekk","ttorpone","reesneidpetmoo","tuozpone","ohewuore","neeorhueow","apla","areupadll","naepl","ifodeple","epezon","ipleme","ipnese","egpijpbekki","ipnepj","ipk","ipness","praruleesilia","oppe","opnepe","opto","etportieksl","opt","iepotverdor","nlsrlkaeaa","erte","rdtrdreeie","esoermprn","letuerne","ooetrhr","orkazt","ounkdhr","urnekk","tcjheas","cstjih","tjihcsne","cstfoh","cenerhesrcurmshida","pleenms","lste","lteisetrg","nslo","tpeunis","dtjaens","tehesopor","ktoopms","tsdeno","ttjoeos","tstnor","eurfdfs","uslekk","aitetpjnk","etfe","ieemret","erteringlij","itnete","otrete","ogontnzeg","rotetiojg","ottortri","rtfeetriotto","rttu","modrevem","eglevraln","ekoevrltn","ekahvrrct","enverkracht","teverkracht","enuevrekn","uenrevtk","epseivku","regnivne","lerovesos","eajwt","wimazsilnfeja","iwfj","iwnepp","uwejtf","azejda","azressawnekk","ezneki","ezreki","uznegi","luaippz"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-pl.json
const blacklist_pl_namespaceObject = [];
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-pt.json
const blacklist_pt_namespaceObject = /*#__PURE__*/JSON.parse('["baotro","raonai","oaanssiss","laaloab","ratsabod","atrobsads","aihbc","aitsecb","obatec","obbo","aotbs","ubmubm","ourbr","ubsorr","acoarb","aaobsrc","acorb","aobsrc","aebsrc","acetec","raacg","aiihcmsna","lahroac","aarsac","ohcohcat","hcrapu","rotilcsi","oncaac","ootci","ooelshc","oelshc","ocan","oolnosc","ooncr","ocsonr","uc","rsrpaoe","leafc","ofad","moafd","soafd","roefd","roagz","rgohle","enraoh","diatoi","tdaisoi","olatil","icsabl","cibslsa","amam","saamm","aedmr","emsadr","sainz","aeerpnlio","oavpr","apu","epradi","ipal","siapl","oitpn","aorpr","upat","suapt","seipn","aucqe","aaaescngm","ienrotar","sraarnt","aaivd","oedva","darbivro","axan","ootcahx","nasu"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-ru.json
const blacklist_ru_namespaceObject = /*#__PURE__*/JSON.parse('["","","","","","",""]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-sv.json
const blacklist_sv_namespaceObject = /*#__PURE__*/JSON.parse('["adog","afg","afsg","aftigg","aftogg","agsy","agy","aigng","aniz","arep","asgssba","atdr","awkn","chnci","deejw","eercskp","ehrwo","eirgsgn","ejgniw","eprekc","eurcskf","hcscni","hcskni","hecfl","heelscf","hicbt","hietscb","hsti","hwsero","iatgsgf","idek","idkc","ijsezz","ijzz","imfl","inregg","insagg","ipsess","ipss","itst","itt","iuesssp","khnci","kpcsi","lcti","lohssase","lstu","mstu","nala","nasesu","nasu","oatgsgf","obbo","obsren","ockc","ohesrael","opnr","oslseha","psci","psskci","rcpa","reoeashls","roebn","roseig","rotilcsi","royg","rueqe","sadtr","saerp","sagabs","sakwn","saodg","sas","seensip","seipn","shtsi","siedk","sifml","sikdc","sltci","sltsu","smtsu","snlaa","sobbo","sokcc","sonpr","srpca","sseas","sufmf","sugjg","sukfc","sutbt","sutcn","swtta","ubtt","ucm","uctn","ufkc","ufrekc","ujgg","umff","uqsree","wtta","yusps"]');
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-tr.json
const blacklist_tr_namespaceObject = [];
;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist-uk.json
const blacklist_uk_namespaceObject = /*#__PURE__*/JSON.parse('["","","","","",""]');
;// ./packages/keybr-phonetic-model/lib/blacklist/scramble.ts

const X = 23;
const Y = 13;
function scrambleWord(word) {
    const a = [...toCodePoints(word)];
    const { length } = a;
    const s = new Array(length);
    for (let i = 0; i < length; i++) {
        s[(X * i + Y) % length] = a[i];
    }
    return String.fromCodePoint(...s);
}
function unscrambleWord(word) {
    const a = [...codepoints_toCodePoints(word)];
    const { length } = a;
    const s = new Array(length);
    for (let i = 0; i < length; i++) {
        s[i] = a[(X * i + Y) % length];
    }
    return String.fromCodePoint(...s);
}

;// ./packages/keybr-phonetic-model/lib/blacklist/blacklist.ts


















const blacklistByLanguage = ((items) => new Map(items.map(([language, list]) => [
    language,
    new Set(list.map(unscrambleWord)),
])))([
    [language_Language.AR, blacklist_ar_namespaceObject],
    [language_Language.BE, blacklist_be_namespaceObject],
    [language_Language.DE, blacklist_de_namespaceObject],
    [language_Language.EN, blacklist_en_namespaceObject],
    [language_Language.ES, blacklist_es_namespaceObject],
    [language_Language.FA, blacklist_fa_namespaceObject],
    [language_Language.FR, blacklist_fr_namespaceObject],
    [language_Language.HE, blacklist_he_namespaceObject],
    [language_Language.IT, blacklist_it_namespaceObject],
    [language_Language.NL, blacklist_nl_namespaceObject],
    [language_Language.PL, blacklist_pl_namespaceObject],
    [language_Language.PT, blacklist_pt_namespaceObject],
    [language_Language.RU, blacklist_ru_namespaceObject],
    [language_Language.SV, blacklist_sv_namespaceObject],
    [language_Language.TR, blacklist_tr_namespaceObject],
    [language_Language.UK, blacklist_uk_namespaceObject],
]);
function blacklist_getBlacklist(language) {
    const blacklist = blacklistByLanguage.get(language) ?? null;
    if (blacklist != null && blacklist.size > 0) {
        return new (class {
            allow(word) {
                return !blacklist.has(language.lowerCase(word));
            }
        })();
    }
    else {
        return new (class {
            allow(word) {
                return true;
            }
        })();
    }
}

;// ./packages/keybr-phonetic-model/lib/phoneticmodel.ts



const minLength = 3;
const maxLength = 10;
class phoneticmodel_PhoneticModel {
    language;
    letters;
    constructor(language, letters) {
        this.language = language;
        this.letters = letters;
    }
    static restrict(model, codePoints) {
        return new (class extends phoneticmodel_PhoneticModel {
            constructor() {
                super(model.language, letter_Letter.restrict(model.letters, codePoints));
            }
            nextWord(filter, random) {
                return model.nextWord(filter, random);
            }
            ngram1() {
                return model.ngram1();
            }
            ngram2() {
                return model.ngram2();
            }
        })();
    }
}
function makePhoneticModel(language, data) {
    const table = data instanceof TransitionTable ? data : TransitionTable.load(data);
    const letters = Letter.normalize(table.letters(language).filter(({ codePoint }) => codePoint !== 0x0020));
    const prefixList = new PrefixList(table);
    const nextWord = (filter, random) => {
        const prefixes = prefixList.findPrefixes(filter);
        const word = [];
        let attempt = 0;
        const retry = () => {
            if (attempt < 5) {
                attempt++;
                word.length = 0;
                if (prefixes.length > 0) {
                    word.push(...randomSample(prefixes, random).codePoints);
                }
                return true;
            }
            else {
                return false;
            }
        };
        retry();
        while (true) {
            const entries = table
                .segment(word)
                .filter(({ codePoint }) => {
                if (codePoint === 0x0020) {
                    if (word.length < minLength) {
                        // Remove the space character if the word is still too short.
                        return false;
                    }
                }
                else {
                    if (!filter.includes(codePoint)) {
                        // Remove a letter if it does not match the filter.
                        return false;
                    }
                }
                return true;
            })
                .map(({ codePoint, frequency }) => {
                if (codePoint === 0x0020) {
                    // Boost the space character to generate shorter words.
                    frequency = frequency * Math.pow(1.3, word.length);
                }
                return { codePoint, frequency };
            });
            if (entries.length === 0) {
                // Cannot continue a word from this prefix.
                if (retry()) {
                    continue;
                }
                else {
                    return word;
                }
            }
            const entry = weightedRandomSample(entries, ({ frequency }) => frequency, random);
            if (entry.codePoint === 0x0020) {
                // A whole word was generated.
                return word;
            }
            if (word.length > maxLength) {
                // A word is too long already.
                if (retry()) {
                    continue;
                }
                else {
                    return word;
                }
            }
            word.push(entry.codePoint);
        }
    };
    return new (class extends phoneticmodel_PhoneticModel {
        constructor() {
            super(language, letters);
        }
        nextWord(filter, random = Math.random) {
            return String.fromCodePoint(...nextWord(filter, random));
        }
        ngram1() {
            return table.toNgram1();
        }
        ngram2() {
            return table.toNgram2();
        }
    })();
}
class Prefix {
    codePoints;
    constructor(codePoints) {
        this.codePoints = codePoints;
    }
    matches(filter) {
        return this.codePoints.every((codePoint) => filter.includes(codePoint));
    }
}
class PrefixList {
    table;
    map;
    constructor(table) {
        this.table = table;
        this.map = new Map(table.alphabet.map((codePoint) => [codePoint, []]));
        const walk = (word) => {
            for (const { codePoint } of this.table.segment(word)) {
                if (codePoint !== 0x0020) {
                    word.push(codePoint);
                    const prefix = new Prefix([...word]);
                    for (const index of new Set(word)) {
                        this.map.get(codePoint).push(prefix);
                    }
                    if (word.length < minLength) {
                        walk(word);
                    }
                    word.pop();
                }
            }
        };
        walk([]);
    }
    findPrefixes(filter) {
        const { focusedCodePoint } = filter;
        if (focusedCodePoint != null) {
            const prefixes = this.map
                .get(focusedCodePoint)
                .filter((prefix) => prefix.matches(filter));
            if (prefixes.length > 0) {
                return prefixes;
            }
            else {
                return [new Prefix([focusedCodePoint])];
            }
        }
        else {
            return [];
        }
    }
}

;// ./packages/keybr-phonetic-model/lib/censor.ts


function censor(model) {
    const { language, letters } = model;
    const blacklist = getBlacklist(language);
    return new (class extends PhoneticModel {
        constructor() {
            super(language, letters);
        }
        nextWord(filter, random) {
            while (true) {
                const word = model.nextWord(filter, random);
                if (blacklist.allow(word)) {
                    return word;
                }
            }
        }
        ngram1() {
            return model.ngram1();
        }
        ngram2() {
            return model.ngram2();
        }
    })();
}

;// ./packages/keybr-phonetic-model/lib/context.ts

const PhoneticModelContext = (0,react.createContext)(null);
function usePhoneticModel() {
    const value = useContext(PhoneticModelContext);
    if (value == null) {
        throw new Error( false
            ? 0
            : undefined);
    }
    return value;
}

;// ./packages/keybr-rand/lib/rng/fake.ts
const FakeRNGStream = (length) => {
    let index = 0;
    const rng = () => {
        const r = index / length;
        index += 1;
        if (index === length) {
            index = 0;
        }
        return r;
    };
    rng.mark = () => {
        return index;
    };
    rng.reset = (mark) => {
        index = mark;
    };
    return rng;
};

;// ./packages/keybr-phonetic-model/lib/fake.ts




class fake_FakePhoneticModel extends phoneticmodel_PhoneticModel {
    static loader = async () => new fake_FakePhoneticModel();
    static letter1 = new letter_Letter(/* "a" */ 0x0061, 0.1, "A");
    static letter2 = new letter_Letter(/* "b" */ 0x0062, 0.09, "B");
    static letter3 = new letter_Letter(/* "c" */ 0x0063, 0.08, "C");
    static letter4 = new letter_Letter(/* "d" */ 0x0064, 0.07, "D");
    static letter5 = new letter_Letter(/* "e" */ 0x0065, 0.06, "E");
    static letter6 = new letter_Letter(/* "f" */ 0x0066, 0.05, "F");
    static letter7 = new letter_Letter(/* "g" */ 0x0067, 0.04, "G");
    static letter8 = new letter_Letter(/* "h" */ 0x0068, 0.03, "H");
    static letter9 = new letter_Letter(/* "i" */ 0x0069, 0.02, "I");
    static letter10 = new letter_Letter(/* "j" */ 0x006a, 0.01, "J");
    static letters = [
        fake_FakePhoneticModel.letter1,
        fake_FakePhoneticModel.letter2,
        fake_FakePhoneticModel.letter3,
        fake_FakePhoneticModel.letter4,
        fake_FakePhoneticModel.letter5,
        fake_FakePhoneticModel.letter6,
        fake_FakePhoneticModel.letter7,
        fake_FakePhoneticModel.letter8,
        fake_FakePhoneticModel.letter9,
        fake_FakePhoneticModel.letter10,
    ];
    words;
    rng;
    constructor(words = ["abc", "def", "ghi"], rng = FakeRNGStream(words.length)) {
        super(language_Language.EN, fake_FakePhoneticModel.letters);
        this.words = [...words];
        this.rng = rng;
    }
    nextWord(filter, rng = this.rng) {
        return sample_randomSample(this.words, rng);
    }
    ngram1() {
        const alphabet = this.letters.map(({ codePoint }) => codePoint);
        const { length } = alphabet;
        const ngram = new ngram_Ngram1(alphabet);
        for (let i = 0; i < length; i++) {
            ngram.set(alphabet[i], 1);
        }
        return ngram;
    }
    ngram2() {
        const alphabet = this.letters.map(({ codePoint }) => codePoint);
        const { length } = alphabet;
        const ngram = new ngram_Ngram2(alphabet);
        for (let i = 0; i < length; i++) {
            for (let j = 0; j < length; j++) {
                ngram.set(alphabet[i], alphabet[j], 1);
            }
        }
        return ngram;
    }
}

;// ./packages/keybr-phonetic-model/lib/filter.ts

class Filter {
    static empty = new Filter(null, null);
    /**
     * Codepoints of the letters from which to generate words.
     */
    codePoints;
    /**
     * Codepoint of the letter which must appear in each generated word.
     */
    focusedCodePoint;
    constructor(letters0 = null, focused0 = null) {
        const letters = letters0 && letters0.map(letter_Letter.toLetter);
        const focused = focused0 && letter_Letter.toLetter(focused0);
        if (letters != null && letters.length === 0) {
            throw new Error();
        }
        if (letters != null && focused != null && !letters.includes(focused)) {
            throw new Error();
        }
        this.codePoints = letters && new Set(letters.map(codePointOf));
        this.focusedCodePoint = focused && codePointOf(focused);
    }
    /**
     * Returns a value indicating whether the given codepoint
     * is allowed by this filter.
     *
     * Empty filter allows all characters.
     */
    includes(codePoint) {
        return this.codePoints == null || this.codePoints.has(codePoint);
    }
}
const codePointOf = ({ codePoint }) => {
    return codePoint;
};

;// ./packages/keybr-phonetic-model/lib/index.ts










;// ./packages/keybr-textinput/lib/chars.ts

var chars_Attr;
(function (Attr) {
    Attr[Attr["Normal"] = 0] = "Normal";
    Attr[Attr["Hit"] = 1] = "Hit";
    Attr[Attr["Miss"] = 2] = "Miss";
    Attr[Attr["Garbage"] = 4] = "Garbage";
    Attr[Attr["Cursor"] = 8] = "Cursor";
})(chars_Attr || (chars_Attr = {}));
function chars_flattenStyledText(text) {
    const list = [];
    if (Array.isArray(text)) {
        for (const item of text) {
            list.push(chars_flattenStyledText(item));
        }
    }
    else if (typeof text === "string") {
        list.push(text);
    }
    else if (isStyledTextSpan(text)) {
        list.push(text.text);
    }
    else {
        throw new TypeError();
    }
    return list.join("");
}
function chars_splitStyledText(text, attrs = chars_Attr.Normal) {
    const list = [];
    if (Array.isArray(text)) {
        for (const item of text) {
            list.push(...chars_splitStyledText(item));
        }
    }
    else if (typeof text === "string") {
        list.push(...[...toCodePoints(text)].map((codePoint) => ({
            codePoint,
            cls: null,
            attrs,
        })));
    }
    else if (isStyledTextSpan(text)) {
        list.push(...[...toCodePoints(text.text)].map((codePoint) => ({
            codePoint,
            cls: text.cls,
            attrs,
        })));
    }
    else {
        throw new TypeError();
    }
    return list;
}
function isStyledTextSpan(v) {
    return v != null && typeof v === "object" && "text" in v;
}
function charsAreEqual(a, b) {
    if (a !== b) {
        if (a.codePoint !== b.codePoint) {
            return false;
        }
        if (a.attrs !== b.attrs) {
            return false;
        }
        if (a.cls !== b.cls) {
            return false;
        }
    }
    return true;
}
function charArraysAreEqual(a, b) {
    if (a !== b) {
        const { length } = a;
        if (length !== b.length) {
            return false;
        }
        for (let i = 0; i < length; i++) {
            const x = a[i];
            const y = b[i];
            if (!charsAreEqual(x, y)) {
                return false;
            }
        }
    }
    return true;
}
function toLine(styledText) {
    const text = chars_flattenStyledText(styledText);
    const chars = chars_splitStyledText(styledText);
    return { text, chars };
}
function singleLine(styledText) {
    const text = chars_flattenStyledText(styledText);
    const chars = chars_splitStyledText(styledText);
    return { text, lines: [{ text, chars }] };
}

;// ./packages/keybr-themes/lib/fonts/index.ts
class FontFace {
    family;
    weight;
    style;
    fallbacks;
    scripts;
    name;
    cssProperties;
    constructor(family, weight, style, fallbacks, scripts) {
        this.family = family;
        this.weight = weight;
        this.style = style;
        this.fallbacks = fallbacks;
        this.scripts = scripts;
        this.name = fontName(family, weight, style);
        this.cssProperties = {
            fontFamily: [family, ...fallbacks].join(","),
            fontWeight: weight,
            fontStyle: style,
        };
    }
}
const cl = ["cyrillic", "latin"];
const cgl = ["cyrillic", "greek", "latin"];
const cghl = ["cyrillic", "greek", "hebrew", "latin"];
const achl = ["arabic", "cyrillic", "hebrew", "latin"];
const acghlt = ["arabic", "cyrillic", "greek", "hebrew", "latin", "thai"];
const ARAD = new FontFace("Arad", "400", "normal", ["whitespace"], ["arabic"]);
const ARAD_B = new FontFace("Arad", "700", "normal", ["whitespace"], ["arabic"]);
const CORMORANT = new FontFace("Cormorant", "400", "normal", ["serif"], cl);
const CORMORANT_I = new FontFace("Cormorant", "400", "italic", ["serif"], cl);
const CORMORANT_B = new FontFace("Cormorant", "700", "normal", ["serif"], cl);
const CORMORANT_BI = new FontFace("Cormorant", "700", "italic", ["serif"], cl);
const NEWSREADER = new FontFace("Newsreader", "400", "normal", ["serif"], ["latin"]);
const NEWSREADER_I = new FontFace("Newsreader", "400", "italic", ["serif"], ["latin"]);
const NEWSREADER_B = new FontFace("Newsreader", "700", "normal", ["serif"], ["latin"]);
const NEWSREADER_BI = new FontFace("Newsreader", "700", "italic", ["serif"], ["latin"]);
const NUNITO = new FontFace("Nunito", "400", "normal", ["sans-serif"], cl);
const NUNITO_I = new FontFace("Nunito", "400", "italic", ["sans-serif"], cl);
const NUNITO_B = new FontFace("Nunito", "700", "normal", ["sans-serif"], cl);
const NUNITO_BI = new FontFace("Nunito", "700", "italic", ["sans-serif"], cl);
const OPEN_DYSLEXIC = new FontFace("Open Dyslexic", "400", "normal", ["sans-serif"], cgl);
const OPEN_DYSLEXIC_I = new FontFace("Open Dyslexic", "400", "italic", ["sans-serif"], cgl);
const OPEN_DYSLEXIC_B = new FontFace("Open Dyslexic", "700", "normal", ["sans-serif"], cgl);
const OPEN_DYSLEXIC_BI = new FontFace("Open Dyslexic", "700", "italic", ["sans-serif"], cgl);
const OPEN_SANS = new FontFace("Open Sans", "400", "normal", ["sans-serif"], cghl);
const OPEN_SANS_I = new FontFace("Open Sans", "400", "italic", ["sans-serif"], cghl);
const OPEN_SANS_B = new FontFace("Open Sans", "700", "normal", ["sans-serif"], cghl);
const OPEN_SANS_BI = new FontFace("Open Sans", "700", "italic", ["sans-serif"], cghl);
const ROBOTO = new FontFace("Roboto", "400", "normal", ["sans-serif"], cgl);
const ROBOTO_I = new FontFace("Roboto", "400", "italic", ["sans-serif"], cgl);
const ROBOTO_B = new FontFace("Roboto", "700", "normal", ["sans-serif"], cgl);
const ROBOTO_BI = new FontFace("Roboto", "700", "italic", ["sans-serif"], cgl);
const ROBOTO_MONO = new FontFace("Roboto Mono", "400", "normal", ["monospace"], cgl);
const ROBOTO_MONO_I = new FontFace("Roboto Mono", "400", "italic", ["monospace"], cgl);
const ROBOTO_MONO_B = new FontFace("Roboto Mono", "700", "normal", ["monospace"], cgl);
const ROBOTO_MONO_BI = new FontFace("Roboto Mono", "700", "italic", ["monospace"], cgl);
const RUBIK = new FontFace("Rubik", "400", "normal", ["sans-serif"], achl);
const RUBIK_I = new FontFace("Rubik", "400", "italic", ["sans-serif"], achl);
const RUBIK_B = new FontFace("Rubik", "700", "normal", ["sans-serif"], achl);
const RUBIK_BI = new FontFace("Rubik", "700", "italic", ["sans-serif"], achl);
const SHANTELL_SANS = new FontFace("Shantell Sans", "400", "normal", ["serif"], cl);
const SHANTELL_SANS_I = new FontFace("Shantell Sans", "400", "italic", ["serif"], cl);
const SHANTELL_SANS_B = new FontFace("Shantell Sans", "700", "normal", ["serif"], cl);
const SHANTELL_SANS_BI = new FontFace("Shantell Sans", "700", "italic", ["serif"], cl);
const SPECTRAL = new FontFace("Spectral", "400", "normal", ["serif"], cl);
const SPECTRAL_I = new FontFace("Spectral", "400", "italic", ["serif"], cl);
const SPECTRAL_B = new FontFace("Spectral", "700", "normal", ["serif"], cl);
const SPECTRAL_BI = new FontFace("Spectral", "700", "italic", ["serif"], cl);
const UBUNTU = new FontFace("Ubuntu", "400", "normal", ["sans-serif"], cgl);
const UBUNTU_I = new FontFace("Ubuntu", "400", "italic", ["sans-serif"], cgl);
const UBUNTU_B = new FontFace("Ubuntu", "700", "normal", ["sans-serif"], cgl);
const UBUNTU_BI = new FontFace("Ubuntu", "700", "italic", ["sans-serif"], cgl);
const UBUNTU_MONO = new FontFace("Ubuntu Mono", "400", "normal", ["monospace"], cgl);
const UBUNTU_MONO_I = new FontFace("Ubuntu Mono", "400", "italic", ["monospace"], cgl);
const UBUNTU_MONO_B = new FontFace("Ubuntu Mono", "700", "normal", ["monospace"], cgl);
const UBUNTU_MONO_BI = new FontFace("Ubuntu Mono", "700", "italic", ["monospace"], cgl);
const SERIF = new FontFace("serif", "400", "normal", ["whitespace"], acghlt);
const SERIF_I = new FontFace("serif", "400", "italic", ["whitespace"], acghlt);
const SERIF_B = new FontFace("serif", "700", "normal", ["whitespace"], acghlt);
const SERIF_BI = new FontFace("serif", "700", "italic", ["whitespace"], acghlt);
const SANS_SERIF = new FontFace("sans-serif", "400", "normal", ["whitespace"], acghlt);
const SANS_SERIF_I = new FontFace("sans-serif", "400", "italic", ["whitespace"], acghlt);
const SANS_SERIF_B = new FontFace("sans-serif", "700", "normal", ["whitespace"], acghlt);
const SANS_SERIF_BI = new FontFace("sans-serif", "700", "italic", ["whitespace"], acghlt);
const MONOSPACE = new FontFace("monospace", "400", "normal", ["whitespace"], acghlt);
const MONOSPACE_I = new FontFace("monospace", "400", "italic", ["whitespace"], acghlt);
const MONOSPACE_B = new FontFace("monospace", "700", "normal", ["whitespace"], acghlt);
const MONOSPACE_BI = new FontFace("monospace", "700", "italic", ["whitespace"], acghlt);
const CURSIVE = new FontFace("cursive", "400", "normal", ["whitespace"], acghlt);
const CURSIVE_I = new FontFace("cursive", "400", "italic", ["whitespace"], acghlt);
const CURSIVE_B = new FontFace("cursive", "700", "normal", ["whitespace"], acghlt);
const CURSIVE_BI = new FontFace("cursive", "700", "italic", ["whitespace"], acghlt);
const FONTS_FACES = [
    ARAD,
    ARAD_B,
    CORMORANT,
    CORMORANT_I,
    CORMORANT_B,
    CORMORANT_BI,
    NEWSREADER,
    NEWSREADER_I,
    NEWSREADER_B,
    NEWSREADER_BI,
    NUNITO,
    NUNITO_I,
    NUNITO_B,
    NUNITO_BI,
    OPEN_SANS,
    OPEN_SANS_I,
    OPEN_SANS_B,
    OPEN_SANS_BI,
    ROBOTO,
    ROBOTO_I,
    ROBOTO_B,
    ROBOTO_BI,
    ROBOTO_MONO,
    ROBOTO_MONO_I,
    ROBOTO_MONO_B,
    ROBOTO_MONO_BI,
    RUBIK,
    RUBIK_I,
    RUBIK_B,
    RUBIK_BI,
    SHANTELL_SANS,
    SHANTELL_SANS_I,
    SHANTELL_SANS_B,
    SHANTELL_SANS_BI,
    SPECTRAL,
    SPECTRAL_I,
    SPECTRAL_B,
    SPECTRAL_BI,
    UBUNTU,
    UBUNTU_I,
    UBUNTU_B,
    UBUNTU_BI,
    UBUNTU_MONO,
    UBUNTU_MONO_I,
    UBUNTU_MONO_B,
    UBUNTU_MONO_BI,
    SERIF,
    SERIF_I,
    SERIF_B,
    SERIF_BI,
    SANS_SERIF,
    SANS_SERIF_I,
    SANS_SERIF_B,
    SANS_SERIF_BI,
    MONOSPACE,
    MONOSPACE_I,
    MONOSPACE_B,
    MONOSPACE_BI,
    CURSIVE,
    CURSIVE_I,
    CURSIVE_B,
    CURSIVE_BI,
    OPEN_DYSLEXIC,
    OPEN_DYSLEXIC_I,
    OPEN_DYSLEXIC_B,
    OPEN_DYSLEXIC_BI,
];
function fontName(family, weight, style) {
    let w = "Regular";
    switch (weight) {
        case "100":
            w = "Thin";
            break;
        case "200":
            w = "Extra Light";
            break;
        case "300":
            w = "Light";
            break;
        case "400":
            w = "Regular";
            break;
        case "500":
            w = "Medium";
            break;
        case "600":
            w = "Semi Bold";
            break;
        case "700":
            w = "Bold";
            break;
        case "800":
            w = "Extra Bold";
            break;
        case "900":
            w = "Black";
            break;
    }
    let s = "Regular";
    switch (style) {
        case "normal":
            s = "Regular";
            break;
        case "italic":
            s = "Italic";
            break;
    }
    if (w === "Regular" && s === "Regular") {
        return `${family}`;
    }
    if (w === "Regular") {
        return `${family} (${s})`;
    }
    if (s === "Regular") {
        return `${family} (${w})`;
    }
    return `${family} (${w} ${s})`;
}

;// ./packages/keybr-textinput/lib/font.ts


class font_Font {
    static ALL = new Enum(...FONTS_FACES.map((fontFace) => new font_Font(fontFace)));
    static get default() {
        return (font_Font.ALL.find(({ name }) => name === UBUNTU_MONO.name) ?? font_Font.ALL.at(0));
    }
    static select(language) {
        return new Enum(...font_Font.ALL.filter((font) => font.scripts.includes(language.script)));
    }
    static find(fonts, font) {
        return fonts.has(font) ? font : fonts.at(0);
    }
    id;
    name;
    scripts;
    cssProperties;
    constructor(fontFace) {
        this.id = `${fontFace.family}-${fontFace.weight}-${fontFace.style}`;
        this.name = fontFace.name;
        this.scripts = fontFace.scripts;
        this.cssProperties = Object.freeze({ ...fontFace.cssProperties });
        Object.freeze(this);
    }
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}

;// ./packages/keybr-textinput/lib/histogram.ts
class histogram_Histogram {
    static empty = histogram_Histogram.from([]);
    #data;
    constructor(samples) {
        this.#data = new Map(Array.from(samples)
            .sort((a, b) => a.codePoint - b.codePoint)
            .map((sample) => [sample.codePoint, sample]));
    }
    [Symbol.iterator]() {
        return this.#data.values();
    }
    get complexity() {
        return this.#data.size;
    }
    has(codePoint) {
        return this.#data.has(codePoint);
    }
    get(codePoint) {
        return this.#data.get(codePoint) ?? null;
    }
    validate() {
        if (this.#data.size < 3) {
            return false; // Too few characters.
        }
        for (const sample of this.#data.values()) {
            if (!histogram_validateSample(sample)) {
                return false;
            }
        }
        return true;
    }
    static from(steps) {
        const samples = new Map();
        for (const { codePoint, timeToType, typo } of steps) {
            let sample = samples.get(codePoint);
            if (sample == null) {
                samples.set(codePoint, (sample = {
                    hitCount: 0,
                    missCount: 0,
                    time: 0,
                    count: 0,
                }));
            }
            sample.hitCount += 1;
            if (typo) {
                sample.missCount += 1;
            }
            else if (timeToType > 0) {
                sample.time += timeToType;
                sample.count += 1;
            }
        }
        return new histogram_Histogram([...samples.entries()]
            .map(([codePoint, { hitCount, missCount, time, count }]) => ({
            codePoint,
            hitCount,
            missCount,
            timeToType: time > 0 && count > 0 ? Math.round(time / count) : 0,
        }))
            .filter(histogram_validateSample));
    }
}
function histogram_validateSample({ timeToType }) {
    if (timeToType > 0) {
        if (timeToType < /* 300WPM/1500CPM */ 40) {
            return false; // Too fast.
        }
        if (timeToType > /* 1WPM/5CPM */ 12000) {
            return false; // Too slow.
        }
    }
    return true;
}

;// ./packages/keybr-textinput/lib/settings.ts



const textInputSettings = {
    stopOnError: true,
    forgiveErrors: true,
    spaceSkipsWords: true,
};
const textInputProps = {
    stopOnError: booleanProp("textInput.stopOnError", true),
    forgiveErrors: booleanProp("textInput.forgiveErrors", true),
    spaceSkipsWords: booleanProp("textInput.spaceSkipsWords", false),
};
function toTextInputSettings(settings) {
    return {
        stopOnError: settings.get(textInputProps.stopOnError),
        forgiveErrors: settings.get(textInputProps.forgiveErrors),
        spaceSkipsWords: settings.get(textInputProps.spaceSkipsWords),
    };
}
var CaretShapeStyle;
(function (CaretShapeStyle) {
    CaretShapeStyle[CaretShapeStyle["Block"] = 1] = "Block";
    CaretShapeStyle[CaretShapeStyle["Box"] = 2] = "Box";
    CaretShapeStyle[CaretShapeStyle["Line"] = 3] = "Line";
    CaretShapeStyle[CaretShapeStyle["Underline"] = 4] = "Underline";
})(CaretShapeStyle || (CaretShapeStyle = {}));
var CaretMovementStyle;
(function (CaretMovementStyle) {
    CaretMovementStyle[CaretMovementStyle["Jumping"] = 1] = "Jumping";
    CaretMovementStyle[CaretMovementStyle["Smooth"] = 2] = "Smooth";
})(CaretMovementStyle || (CaretMovementStyle = {}));
var WhitespaceStyle;
(function (WhitespaceStyle) {
    WhitespaceStyle[WhitespaceStyle["Space"] = 1] = "Space";
    WhitespaceStyle[WhitespaceStyle["Bar"] = 2] = "Bar";
    WhitespaceStyle[WhitespaceStyle["Bullet"] = 3] = "Bullet";
})(WhitespaceStyle || (WhitespaceStyle = {}));
const textDisplaySettings = {
    font: font_Font.default,
    caretShapeStyle: CaretShapeStyle.Underline,
    caretMovementStyle: CaretMovementStyle.Smooth,
    whitespaceStyle: WhitespaceStyle.Bullet,
    language: language_Language.EN,
};
const textDisplayProps = {
    font: itemProp("textDisplay.font", font_Font.ALL, font_Font.default),
    caretShapeStyle: enumProp("textDisplay.caretShapeStyle", CaretShapeStyle, CaretShapeStyle.Underline),
    caretMovementStyle: enumProp("textDisplay.caretMovementStyle", CaretMovementStyle, CaretMovementStyle.Smooth),
    whitespaceStyle: enumProp("textDisplay.whitespaceStyle", WhitespaceStyle, WhitespaceStyle.Bullet),
};
function toTextDisplaySettings(settings) {
    const caretShapeStyle = settings.get(textDisplayProps.caretShapeStyle);
    const caretMovementStyle = settings.get(textDisplayProps.caretMovementStyle);
    const whitespaceStyle = settings.get(textDisplayProps.whitespaceStyle);
    const { language } = KeyboardOptions.from(settings);
    const fonts = Font.select(language);
    const font = Font.find(fonts, settings.get(textDisplayProps.font));
    return {
        font,
        caretShapeStyle,
        caretMovementStyle,
        whitespaceStyle,
        language,
    };
}

;// ./packages/keybr-textinput/lib/stats.ts

function stats_makeStats(steps) {
    if (steps.length >= 2) {
        const { timeStamp: startedAt } = steps.at(0);
        const { timeStamp: endedAt } = steps.at(-1);
        const { length } = steps;
        const time = Math.round(endedAt - startedAt);
        const speed = computeSpeed(length, time);
        const errors = countErrors(steps);
        const accuracy = (length - errors) / length;
        return {
            time,
            speed,
            length,
            errors,
            accuracy,
            histogram: Histogram.from(steps.slice(1)), // The trigger step is ignored.
        };
    }
    else {
        return {
            time: 0,
            speed: 0,
            length: 0,
            errors: 0,
            accuracy: 0,
            histogram: Histogram.empty,
        };
    }
}
function countErrors(steps) {
    let errors = 0;
    for (const item of steps) {
        if (item.typo) {
            errors += 1;
        }
    }
    return errors;
}
function computeSpeed(length, time) {
    return time > 0 ? (length / (time / 1000)) * 60 : 0;
}

;// ./packages/keybr-textinput/lib/textinput.ts


var Feedback;
(function (Feedback) {
    Feedback[Feedback["Succeeded"] = 0] = "Succeeded";
    Feedback[Feedback["Recovered"] = 1] = "Recovered";
    Feedback[Feedback["Failed"] = 2] = "Failed";
})(Feedback || (Feedback = {}));
const recoverBufferLength = 3;
const garbageBufferLength = 10;
class TextInput {
    text;
    stopOnError;
    forgiveErrors;
    spaceSkipsWords;
    onStep;
    #text;
    #chars;
    #steps = [];
    #garbage = [];
    #typo;
    #output;
    constructor(text, { stopOnError, forgiveErrors, spaceSkipsWords }, onStep = () => { }) {
        this.text = text;
        this.stopOnError = stopOnError;
        this.forgiveErrors = forgiveErrors;
        this.spaceSkipsWords = spaceSkipsWords;
        this.onStep = onStep;
        this.#text = flattenStyledText(text);
        this.#chars = splitStyledText(text);
        this.reset();
    }
    reset() {
        this.#steps = [];
        this.#garbage = [];
        this.#typo = false;
        this.#update();
    }
    get length() {
        return this.#chars.length;
    }
    at(index) {
        return this.#chars.at(index);
    }
    get pos() {
        return this.#steps.length;
    }
    get completed() {
        return this.pos === this.length;
    }
    get steps() {
        return this.#steps;
    }
    get chars() {
        return this.#output.chars;
    }
    get lines() {
        return this.#output.lines;
    }
    get remaining() {
        return this.#output.remaining;
    }
    onInput({ timeStamp, inputType, codePoint, timeToType, }) {
        switch (inputType) {
            case "appendChar":
                return this.appendChar(timeStamp, codePoint, timeToType);
            case "appendLineBreak":
                return this.appendChar(timeStamp, 0x0020, timeToType);
            case "clearChar":
                return this.clearChar();
            case "clearWord":
                return this.clearWord();
        }
    }
    clearChar() {
        this.#garbage.pop();
        this.#typo = true;
        return this.#return(Feedback.Succeeded);
    }
    clearWord() {
        this.#garbage = [];
        while (this.pos > 0 && this.at(this.pos - 1).codePoint !== 0x0020) {
            this.#steps.pop();
        }
        this.#typo = true;
        return this.#return(Feedback.Succeeded);
    }
    appendChar(timeStamp, codePoint, timeToType) {
        if (this.completed) {
            throw new Error();
        }
        const { codePoint: expected } = this.at(this.pos);
        if (expected !== 0x0020 && codePoint === 0x0020) {
            if (this.spaceSkipsWords &&
                ((this.pos > 0 && this.at(this.pos - 1).codePoint !== 0x0020) ||
                    this.#typo)) {
                this.#skipWord(timeStamp);
                return this.#return(Feedback.Recovered);
            }
            if (this.#garbage.length === 0 && !this.#typo) {
                return this.#return(Feedback.Succeeded);
            }
        }
        if ((expected === codePoint ||
            filterText.normalize(expected) === codePoint) &&
            (this.forgiveErrors || this.#garbage.length === 0)) {
            const typo = this.#typo;
            this.#addStep({
                timeStamp,
                codePoint,
                timeToType,
                typo,
            }, this.at(this.pos));
            this.#garbage = [];
            this.#typo = false;
            if (typo) {
                return this.#return(Feedback.Recovered);
            }
            else {
                return this.#return(Feedback.Succeeded);
            }
        }
        this.#typo = true;
        if (!this.stopOnError || this.forgiveErrors) {
            if (this.#garbage.length < garbageBufferLength) {
                this.#garbage.push({
                    char: {
                        codePoint,
                        attrs: Attr.Garbage,
                        cls: null,
                    },
                    timeStamp,
                    codePoint,
                    timeToType,
                    typo: false,
                });
            }
        }
        if (this.forgiveErrors &&
            (this.#handleReplacedCharacter() || this.#handleSkippedCharacter())) {
            return this.#return(Feedback.Recovered);
        }
        else {
            return this.#return(Feedback.Failed);
        }
    }
    #return(feedback) {
        this.#update();
        return feedback;
    }
    #update() {
        const text = this.#text;
        const remaining = this.#chars.slice(this.pos);
        const chars = [];
        chars.push(...this.#steps.map(({ char }) => char));
        if (!this.stopOnError) {
            chars.push(...this.#garbage.map(({ char }) => char));
        }
        if (remaining.length > 0) {
            const [head, ...tail] = remaining;
            chars.push({ ...head, attrs: Attr.Cursor }, ...tail);
        }
        const lines = { text, lines: [{ text, chars }] };
        this.#output = { chars, lines, remaining };
    }
    #addStep(step, char) {
        const attrs = step.typo ? Attr.Miss : Attr.Hit;
        this.#steps.push({ ...step, char: { ...char, attrs } });
        this.onStep(step);
    }
    #skipWord(timeStamp) {
        // Skip the remaining non-space characters inside the word.
        while (this.pos < this.length && this.at(this.pos).codePoint !== 0x0020) {
            this.#addStep({
                timeStamp,
                codePoint: this.at(this.pos).codePoint,
                timeToType: 0,
                typo: true,
            }, this.at(this.pos));
        }
        // Skip the space character to position at the beginning of the next word.
        if (this.pos < this.length && this.at(this.pos).codePoint === 0x0020) {
            this.#addStep({
                timeStamp,
                codePoint: this.at(this.pos).codePoint,
                timeToType: 0,
                typo: false,
            }, this.at(this.pos));
        }
        this.#garbage = [];
        this.#typo = false;
    }
    #handleReplacedCharacter() {
        // text:    abcd
        // garbage: xbcd
        // offset:  0
        // Check if the buffer size is right.
        if (this.pos + recoverBufferLength + 1 > this.length ||
            this.#garbage.length < recoverBufferLength + 1) {
            return false;
        }
        // Check whether we can recover.
        for (let i = 0; i < recoverBufferLength; i++) {
            const char = this.at(this.pos + i + 1);
            if (char.codePoint !== this.#garbage[i + 1].codePoint) {
                return false;
            }
        }
        // Append a step with an error.
        this.#addStep({
            timeStamp: this.#garbage[0].timeStamp,
            codePoint: this.at(this.pos).codePoint,
            timeToType: 0,
            typo: true,
        }, this.at(this.pos));
        // Append successful steps.
        for (let i = 1; i < this.#garbage.length; i++) {
            this.#addStep(this.#garbage[i], this.#garbage[i].char);
        }
        this.#garbage = [];
        this.#typo = false;
        return true;
    }
    #handleSkippedCharacter() {
        // text:    abcd
        // garbage: bcd
        // offset:  0
        // Check if the buffer size is right.
        if (this.pos + recoverBufferLength + 1 > this.length ||
            this.#garbage.length < recoverBufferLength) {
            return false;
        }
        // Check whether we can recover.
        for (let i = 0; i < recoverBufferLength; i++) {
            const char = this.at(this.pos + i + 1);
            if (char.codePoint !== this.#garbage[i].codePoint) {
                return false;
            }
        }
        // Append a step with an error.
        this.#addStep({
            timeStamp: this.#garbage[0].timeStamp,
            codePoint: this.at(this.pos).codePoint,
            timeToType: 0,
            typo: true,
        }, this.at(this.pos));
        // Append successful steps.
        for (let i = 0; i < this.#garbage.length; i++) {
            this.#addStep(this.#garbage[i], this.#garbage[i].char);
        }
        this.#garbage = [];
        this.#typo = false;
        return true;
    }
}

;// ./packages/keybr-textinput/lib/index.ts







;// ./packages/keybr-result/lib/result.ts
class result_Result {
    layout;
    textType;
    timeStamp;
    length;
    time;
    errors;
    histogram;
    static filter = {
        minLength: 10,
        minTime: 1000,
        minComplexity: 1,
        minSpeed: 1,
        maxSpeed: Infinity,
    };
    static fromStats(layout, textType, timeStamp, stats) {
        return new result_Result(layout, textType, timeStamp, stats.length, stats.time, stats.errors, stats.histogram);
    }
    static isValid = (result) => result.validate();
    complexity;
    speed;
    accuracy;
    score;
    constructor(layout, textType, timeStamp, length, time, errors, histogram) {
        this.layout = layout;
        this.textType = textType;
        this.timeStamp = timeStamp;
        this.length = length;
        this.time = time;
        this.errors = errors;
        this.histogram = histogram;
        const { complexity } = histogram;
        let speed = 0;
        let accuracy = 0;
        let score = 0;
        if (length > 0 && time > 0 && complexity > 0) {
            speed = (length / (time / 1000)) * 60;
            accuracy = (length - errors) / length;
            score = ((speed * complexity) / (errors + 1)) * (length / 50);
        }
        this.complexity = complexity;
        this.speed = speed;
        this.accuracy = accuracy;
        this.score = score;
    }
    validate({ minLength = result_Result.filter.minLength, minTime = result_Result.filter.minTime, minComplexity = result_Result.filter.minComplexity, minSpeed = result_Result.filter.minSpeed, maxSpeed = result_Result.filter.maxSpeed, } = {}) {
        return (this.length >= minLength &&
            this.time >= minTime &&
            this.complexity >= minComplexity &&
            this.speed >= minSpeed &&
            this.speed <= maxSpeed &&
            this.histogram.validate());
    }
    toJSON() {
        return {
            layout: this.layout.id,
            textType: this.textType.id,
            timeStamp: new Date(this.timeStamp),
            length: this.length,
            time: this.time,
            errors: this.errors,
            speed: this.speed,
            histogram: [...this.histogram],
        };
    }
}
/**
 * Convert type-to-type in milliseconds to typing speed in characters per minute.
 * @param v Time-to-type in milliseconds.
 * @return Typing speed in characters per minute.
 */
function timeToSpeed(v) {
    if (!Number.isFinite(v) || v === 0) {
        throw new Error();
    }
    return (60 * 1000) / v;
}
/**
 * Convert typing speed in characters per minute to type-to-type in milliseconds.
 * @param v Typing speed in characters per minute.
 * @return Time-to-type in milliseconds.
 */
function speedToTime(v) {
    if (!Number.isFinite(v) || v === 0) {
        throw new Error();
    }
    return 1000 / (v / 60);
}

;// ./packages/keybr-result/lib/texttype.ts

class texttype_TextType {
    id;
    xid;
    static GENERATED = new texttype_TextType("generated", 1);
    static NATURAL = new texttype_TextType("natural", 2);
    static NUMBERS = new texttype_TextType("numbers", 3);
    static CODE = new texttype_TextType("code", 4);
    static ALL = new XEnum(texttype_TextType.GENERATED, texttype_TextType.NATURAL, texttype_TextType.NUMBERS, texttype_TextType.CODE);
    constructor(id, xid) {
        this.id = id;
        this.xid = xid;
        Object.freeze(this);
    }
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}

;// ./packages/keybr-result/lib/fake.tsx








class ResultFaker {
    letters;
    layout;
    textType;
    timeStamp;
    timeStampIncrement;
    constructor({ letters = FakePhoneticModel.letters, layout = Layout.EN_US, textType = TextType.GENERATED, timeStamp = 0, timeStampIncrement = 1000, } = {}) {
        this.letters = letters;
        this.layout = layout;
        this.textType = textType;
        this.timeStamp = timeStamp;
        this.timeStampIncrement = timeStampIncrement;
    }
    nextResultList(length) {
        const list = [];
        for (let i = 0; i < length; i++) {
            list.push(this.nextResult());
        }
        return list;
    }
    nextResult({ layout = this.layout, textType = this.textType, timeStamp = (this.timeStamp += this.timeStampIncrement), length = 100, time = 50000, errors = 0, histogram = this.nextHistogram(), } = {}) {
        return new Result(layout, textType, timeStamp, length, time, errors, histogram);
    }
    nextHistogram(letters = this.letters) {
        return new Histogram(letters.map(({ codePoint }) => ({
            codePoint,
            hitCount: 10,
            missCount: 0,
            timeToType: 200,
        })));
    }
}
function generateKeySamples(length, { indexStart = 100, indexStep = 1, timeStampStart = 1000, timeStampStep = 60000, timeToTypeStart = 500, timeToTypeStep = 10, } = {}) {
    const samples = [];
    for (let i = 0; i < length; i++) {
        const timeToType = timeToTypeStart - i * timeToTypeStep;
        const filteredTimeToType = timeToType;
        samples.push({
            index: indexStart + i * indexStep,
            timeStamp: timeStampStart + i * timeStampStep,
            hitCount: 10,
            missCount: 1,
            timeToType,
            filteredTimeToType,
        });
    }
    return samples;
}
function FakeResultContext({ initialResults = [], children, }) {
    const [results, setResults] = useState(initialResults);
    return (_jsx(ResultContext.Provider, { value: {
            results,
            appendResults: (newResults) => {
                setResults([...results, ...newResults]);
            },
            clearResults: () => {
                setResults([]);
            },
        }, children: children }));
}

;// ./packages/keybr-math/lib/dist.ts
/**
 * @see https://en.wikipedia.org/wiki/Empirical_distribution_function
 */
class Distribution {
    #samples;
    #pmf;
    #cdf;
    constructor(samples) {
        this.#samples = new Float64Array(samples);
        this.#pmf = new Float64Array(this.#samples.length);
        this.#cdf = new Float64Array(this.#samples.length);
        const totalSum = samples.reduce((sum, value) => sum + value, 0);
        let runningSum = 0;
        for (let i = 0; i < this.#samples.length; i++) {
            this.#pmf[i] = samples[i] / totalSum;
            this.#cdf[i] = runningSum += samples[i] / totalSum;
        }
    }
    *[Symbol.iterator]() {
        for (let i = 0; i < this.#samples.length; i++) {
            yield { index: i, pmf: this.pmf(i), cdf: this.cdf(i) };
        }
    }
    map(fn) {
        return [...this].map((value) => fn(value));
    }
    get length() {
        return this.#samples.length;
    }
    pmf(index) {
        const { length } = this.#samples;
        index = Math.round(index);
        if (index < 0) {
            return 0;
        }
        if (index > length - 1) {
            return 0;
        }
        return this.#pmf[index];
    }
    cdf(index) {
        const { length } = this.#samples;
        index = Math.round(index);
        if (index < 0) {
            return 0;
        }
        if (index > length - 1) {
            return 1;
        }
        return this.#cdf[index];
    }
    /** Scales a value in range [0, 1] to a histogram index. */
    scale(index) {
        const { length } = this.#samples;
        index = Math.round(index * (length - 1));
        if (index < 0) {
            return 0;
        }
        if (index > length - 1) {
            return length - 1;
        }
        return index;
    }
    /** Scales a histogram index to a value in range [0, 1]. */
    unscale(index) {
        const { length } = this.#samples;
        index = Math.round(index);
        if (index < 0) {
            return 0;
        }
        if (index > length - 1) {
            return 1;
        }
        return index / (length - 1);
    }
}

;// ./packages/keybr-math/lib/filter.ts
const makeFilter = (alpha) => {
    let n = 0;
    let value = NaN;
    return {
        get n() {
            return n;
        },
        add: (v) => {
            n++;
            if (n > 1) {
                value = alpha * v + (1 - alpha) * value;
            }
            else {
                value = v;
            }
            return value;
        },
    };
};

;// ./packages/keybr-math/lib/keyset.ts
class KeySet {
    #keys = new Set();
    constructor(keys) {
        for (const key of keys) {
            this.add(key);
        }
    }
    *[Symbol.iterator]() {
        for (const key of this.#keys) {
            yield key;
        }
    }
    add(key) {
        this.#keys.add(key);
    }
}

;// ./packages/keybr-math/lib/vector.ts
class Vector {
    #values = [];
    constructor(values = []) {
        for (const value of values) {
            this.add(value);
        }
    }
    *[Symbol.iterator]() {
        for (const item of this.#values) {
            yield item;
        }
    }
    add(value) {
        if (value !== value) {
            throw new Error();
        }
        this.#values.push(value);
    }
    get length() {
        return this.#values.length;
    }
    at(index) {
        if (!Number.isSafeInteger(index)) {
            throw new RangeError();
        }
        if (index < 0 || index >= this.#values.length) {
            throw new RangeError();
        }
        return this.#values[index];
    }
}

;// ./packages/keybr-math/lib/histogram.ts


class lib_histogram_Histogram {
    #keySet;
    #map;
    static from(items) {
        const histogram = new lib_histogram_Histogram(new KeySet([]));
        for (const [key, value] of items) {
            histogram.set(key, value);
        }
        return histogram;
    }
    constructor(keySet) {
        this.#keySet = keySet;
        this.#map = new Map();
    }
    *[Symbol.iterator]() {
        for (const key of this.#keySet) {
            yield [key, this.get(key)];
        }
    }
    *keys() {
        for (const key of this.#keySet) {
            yield key;
        }
    }
    *values() {
        for (const key of this.#keySet) {
            yield this.get(key);
        }
    }
    asVector() {
        return new Vector(this.values());
    }
    has(key) {
        return this.#map.has(key);
    }
    get(key) {
        return this.#map.get(key) ?? 0;
    }
    set(key, value) {
        if (value !== value || value < 0) {
            throw new Error();
        }
        this.#keySet.add(key);
        this.#map.set(key, value);
    }
    add(key, value) {
        if (value !== value || value < 0) {
            throw new Error();
        }
        this.#keySet.add(key);
        this.#map.set(key, this.get(key) + value);
    }
}

;// ./packages/keybr-math/lib/polynomial.ts
class polynomial_Polynomial {
    static from(coef) {
        coef = trimZeros(coef);
        switch (coef.length) {
            case 0:
                throw new Error();
            case 1:
                return new Polynomial0(coef[0]); // Constant
            case 2:
                return new Polynomial1(coef[0], coef[1]); // Linear.
            case 3:
                return new Polynomial2(coef[0], coef[1], coef[2]); // Quadratic.
            case 4:
                return new Polynomial3(coef[0], coef[1], coef[2], coef[3]); // Cubic.
            default:
                return new PolynomialN(coef);
        }
    }
    coef;
    degree;
    constructor(coef) {
        this.coef = coef;
        this.degree = coef.length - 1;
    }
}
class Polynomial0 extends polynomial_Polynomial {
    y;
    constructor(y) {
        super([y]);
        this.y = y;
    }
    eval(x) {
        return this.y;
    }
    derivative() {
        return new Polynomial0(0);
    }
}
class Polynomial1 extends polynomial_Polynomial {
    a;
    b;
    constructor(a, b) {
        super([a, b]);
        this.a = a;
        this.b = b;
    }
    eval(x) {
        return this.a + this.b * x;
    }
    derivative() {
        return new Polynomial0(this.b);
    }
}
class Polynomial2 extends polynomial_Polynomial {
    a;
    b;
    c;
    constructor(a, b, c) {
        super([a, b, c]);
        this.a = a;
        this.b = b;
        this.c = c;
    }
    eval(x) {
        return this.a + this.b * x + this.c * x * x;
    }
    derivative() {
        return new Polynomial1(this.b, this.c * 2);
    }
}
class Polynomial3 extends polynomial_Polynomial {
    a;
    b;
    c;
    d;
    constructor(a, b, c, d) {
        super([a, b, c, d]);
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
    eval(x) {
        return this.a + this.b * x + this.c * x * x + this.d * x * x * x;
    }
    derivative() {
        return new Polynomial2(this.b, this.c * 2, this.d * 3);
    }
}
class PolynomialN extends polynomial_Polynomial {
    constructor(coef) {
        super(coef);
    }
    eval(x) {
        const { coef } = this;
        const { length } = coef;
        let y = 0;
        for (let i = length - 1; i > 0; i--) {
            y = (y + coef[i]) * x;
        }
        return y + coef[0];
    }
    derivative() {
        const { coef } = this;
        const { length } = coef;
        const derivativeCoef = new Array(length - 1);
        for (let i = 1; i < length; i++) {
            derivativeCoef[i - 1] = coef[i] * i;
        }
        return polynomial_Polynomial.from(derivativeCoef);
    }
}
function trimZeros(coef) {
    let i = coef.length;
    while (i > 1 && coef[i - 1] === 0) {
        i = i - 1;
    }
    return coef.slice(0, i);
}

;// ./packages/keybr-math/lib/linear-regression.ts

function linear_regression_linearRegression(vx, vy) {
    const { length } = vx;
    if (length !== vy.length) {
        throw new Error();
    }
    if (length === 0) {
        throw new Error();
    }
    let sx = 0;
    let sy = 0;
    for (let i = 0; i < length; i++) {
        sx = sx + vx.at(i);
        sy = sy + vy.at(i);
    }
    const mx = sx / length;
    const my = sy / length;
    let s1 = 0;
    let s2 = 0;
    for (let i = 0; i < length; i++) {
        const t0 = vx.at(i) - mx;
        const t1 = vy.at(i) - my;
        s1 = s1 + t0 * t1;
        s2 = s2 + t0 * t0;
    }
    const a = my - (s1 / s2) * mx;
    const b = s1 / s2;
    return Polynomial.from([a, b]);
}

;// ./packages/keybr-math/lib/polynomial-regression.ts
// The MIT License (MIT)
//
// Copyright (c) Tom Alexander <me@tomalexander.co.nz>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



function polynomialRegression(vx, vy, degree) {
    if (degree === 1) {
        return linearRegression(vx, vy);
    }
    const { length } = vx;
    if (length !== vy.length) {
        throw new Error();
    }
    if (length === 0) {
        throw new Error();
    }
    const size = degree + 1;
    const sle = new Sle(size);
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            let t = 0;
            for (let l = 0; l < length; l++) {
                t += vx.at(l) ** (i + j);
            }
            sle.A[i][j] = t;
        }
    }
    for (let i = 0; i < size; i++) {
        let t = 0;
        for (let l = 0; l < length; l++) {
            t += vx.at(l) ** i * vy.at(l);
        }
        sle.y[i] = t;
    }
    return Polynomial.from(sle.solve());
}

;// ./packages/keybr-math/lib/index.ts












;// ./packages/keybr-result/lib/keystats.ts

function makeKeyStatsMap(letters, results) {
    const map = new MutableKeyStatsMap(letters);
    for (const result of results) {
        map.append(result);
    }
    return map.copy();
}
class MutableKeyStatsMap {
    #letters;
    #results;
    #map;
    constructor(letters) {
        this.#letters = [...letters];
        this.#results = [];
        this.#map = new Map();
        for (const letter of letters) {
            this.#map.set(letter, new MutableKeyStats(letter));
        }
    }
    get letters() {
        return this.#letters;
    }
    get results() {
        return this.#results;
    }
    get(letter) {
        return this.#map.get(letter);
    }
    [Symbol.iterator]() {
        return this.#map.values();
    }
    append(result) {
        this.#results.push(result);
        for (const item of this.#map.values()) {
            item.append(result);
        }
    }
    copy() {
        const letters = [...this.#letters];
        const results = [...this.#results];
        const map = new Map([...this.#map].map(([key, value]) => [key, value.copy()]));
        return {
            get letters() {
                return letters;
            },
            get results() {
                return results;
            },
            get(letter) {
                return map.get(letter);
            },
            [Symbol.iterator]() {
                return map.values();
            },
        };
    }
}
class MutableKeyStats {
    #letter;
    #samples;
    #filter;
    #index;
    #timeToType;
    #bestTimeToType;
    constructor(letter) {
        this.#letter = letter;
        this.#samples = [];
        this.#filter = makeFilter(0.1);
        this.#index = 0;
        this.#timeToType = null;
        this.#bestTimeToType = null;
    }
    get letter() {
        return this.#letter;
    }
    get samples() {
        return this.#samples;
    }
    get timeToType() {
        return this.#timeToType;
    }
    get bestTimeToType() {
        return this.#bestTimeToType;
    }
    append(result) {
        const { timeStamp, histogram } = result;
        const sample = histogram.get(this.#letter.codePoint);
        if (sample != null) {
            const { hitCount, missCount, timeToType } = sample;
            if (timeToType > 0) {
                const filteredTimeToType = this.#filter.add(timeToType);
                this.#samples.push({
                    index: this.#index,
                    timeStamp,
                    hitCount,
                    missCount,
                    timeToType,
                    filteredTimeToType,
                });
                this.#timeToType = filteredTimeToType;
                this.#bestTimeToType = Math.min(this.#bestTimeToType ?? Infinity, filteredTimeToType);
            }
        }
        this.#index += 1;
        return this;
    }
    copy() {
        return {
            letter: this.#letter,
            samples: [...this.#samples],
            timeToType: this.#timeToType,
            bestTimeToType: this.#bestTimeToType,
        };
    }
}

;// ./packages/keybr-result/lib/recover.ts


/**
 * Fixes the validation errors in the given results, if possible.
 */
function recoverResults(raw) {
    const results = [];
    for (const result of raw) {
        if (result.validate()) {
            results.push(result);
        }
        else {
            const recovered = new Result(result.layout, result.textType, result.timeStamp, result.length, result.time, result.errors, new Histogram([...result.histogram].filter(validateSample)));
            if (recovered.validate()) {
                results.push(recovered);
            }
        }
    }
    return results;
}

;// ./node_modules/@formatjs/fast-memoize/lib/index.js
//
// Main
//
function lib_memoize(fn, options) {
    var cache = options && options.cache ? options.cache : cacheDefault;
    var serializer = options && options.serializer ? options.serializer : serializerDefault;
    var strategy = options && options.strategy ? options.strategy : strategyDefault;
    return strategy(fn, {
        cache: cache,
        serializer: serializer,
    });
}
//
// Strategy
//
function isPrimitive(value) {
    return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
}
function monadic(fn, cache, serializer, arg) {
    var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.call(this, arg);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function variadic(fn, cache, serializer) {
    var args = Array.prototype.slice.call(arguments, 3);
    var cacheKey = serializer(args);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.apply(this, args);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function assemble(fn, context, strategy, cache, serialize) {
    return strategy.bind(context, fn, cache, serialize);
}
function strategyDefault(fn, options) {
    var strategy = fn.length === 1 ? monadic : variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
    return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
    return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
//
// Serializer
//
var serializerDefault = function () {
    return JSON.stringify(arguments);
};
//
// Cache
//
function ObjectWithoutPrototypeCache() {
    this.cache = Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function (key) {
    return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
    this.cache[key] = value;
};
var cacheDefault = {
    create: function create() {
        // @ts-ignore
        return new ObjectWithoutPrototypeCache();
    },
};
var lib_strategies = {
    variadic: strategyVariadic,
    monadic: strategyMonadic,
};

;// ./node_modules/@formatjs/intl/lib/src/utils.js




function invariant(condition, message, Err) {
    if (Err === void 0) { Err = Error; }
    if (!condition) {
        throw new Err(message);
    }
}
function filterProps(props, allowlist, defaults) {
    if (defaults === void 0) { defaults = {}; }
    return allowlist.reduce(function (filtered, name) {
        if (name in props) {
            filtered[name] = props[name];
        }
        else if (name in defaults) {
            filtered[name] = defaults[name];
        }
        return filtered;
    }, {});
}
var defaultErrorHandler = function (error) {
    // @ts-ignore just so we don't need to declare dep on @types/node
    if (false) {}
};
var defaultWarnHandler = function (warning) {
    // @ts-ignore just so we don't need to declare dep on @types/node
    if (false) {}
};
var DEFAULT_INTL_CONFIG = {
    formats: {},
    messages: {},
    timeZone: undefined,
    defaultLocale: 'en',
    defaultFormats: {},
    fallbackOnEmptyString: true,
    onError: defaultErrorHandler,
    onWarn: defaultWarnHandler,
};
function utils_createIntlCache() {
    return {
        dateTime: {},
        number: {},
        message: {},
        relativeTime: {},
        pluralRules: {},
        list: {},
        displayNames: {},
    };
}
function createFastMemoizeCache(store) {
    return {
        create: function () {
            return {
                get: function (key) {
                    return store[key];
                },
                set: function (key, value) {
                    store[key] = value;
                },
            };
        },
    };
}
/**
 * Create intl formatters and populate cache
 * @param cache explicit cache to prevent leaking memory
 */
function createFormatters(cache) {
    if (cache === void 0) { cache = utils_createIntlCache(); }
    var RelativeTimeFormat = Intl.RelativeTimeFormat;
    var ListFormat = Intl.ListFormat;
    var DisplayNames = Intl.DisplayNames;
    var getDateTimeFormat = memoize(function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
    }, {
        cache: createFastMemoizeCache(cache.dateTime),
        strategy: strategies.variadic,
    });
    var getNumberFormat = memoize(function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
    }, {
        cache: createFastMemoizeCache(cache.number),
        strategy: strategies.variadic,
    });
    var getPluralRules = memoize(function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
    }, {
        cache: createFastMemoizeCache(cache.pluralRules),
        strategy: strategies.variadic,
    });
    return {
        getDateTimeFormat: getDateTimeFormat,
        getNumberFormat: getNumberFormat,
        getMessageFormat: memoize(function (message, locales, overrideFormats, opts) {
            return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
                    getNumberFormat: getNumberFormat,
                    getDateTimeFormat: getDateTimeFormat,
                    getPluralRules: getPluralRules,
                } }, (opts || {})));
        }, {
            cache: createFastMemoizeCache(cache.message),
            strategy: strategies.variadic,
        }),
        getRelativeTimeFormat: memoize(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.relativeTime),
            strategy: strategies.variadic,
        }),
        getPluralRules: getPluralRules,
        getListFormat: memoize(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new (ListFormat.bind.apply(ListFormat, __spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.list),
            strategy: strategies.variadic,
        }),
        getDisplayNames: memoize(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new (DisplayNames.bind.apply(DisplayNames, __spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.displayNames),
            strategy: strategies.variadic,
        }),
    };
}
function getNamedFormat(formats, type, name, onError) {
    var formatType = formats && formats[type];
    var format;
    if (formatType) {
        format = formatType[name];
    }
    if (format) {
        return format;
    }
    onError(new UnsupportedFormatterError("No ".concat(type, " format named: ").concat(name)));
}

;// ./node_modules/react-intl/lib/src/utils.js



function utils_invariant(condition, message, Err) {
    if (Err === void 0) { Err = Error; }
    if (!condition) {
        throw new Err(message);
    }
}
function utils_invariantIntlContext(intl) {
    utils_invariant(intl, '[React Intl] Could not find required `intl` object. ' +
        '<IntlProvider> needs to exist in the component ancestry.');
}
var utils_DEFAULT_INTL_CONFIG = tslib_es6_assign(tslib_es6_assign({}, DEFAULT_INTL_CONFIG), { textComponent: react.Fragment });
/**
 * Takes a `formatXMLElementFn`, and composes it in function, which passes
 * argument `parts` through, assigning unique key to each part, to prevent
 * "Each child in a list should have a unique "key"" React error.
 * @param formatXMLElementFn
 */
function assignUniqueKeysToParts(formatXMLElementFn) {
    return function (parts) {
        // eslint-disable-next-line prefer-rest-params
        return formatXMLElementFn(React.Children.toArray(parts));
    };
}
function shallowEqual(objA, objB) {
    if (objA === objB) {
        return true;
    }
    if (!objA || !objB) {
        return false;
    }
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);
    var len = aKeys.length;
    if (bKeys.length !== len) {
        return false;
    }
    for (var i = 0; i < len; i++) {
        var key = aKeys[i];
        if (objA[key] !== objB[key] ||
            !Object.prototype.hasOwnProperty.call(objB, key)) {
            return false;
        }
    }
    return true;
}

// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__("./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
;// ./node_modules/react-intl/lib/src/components/injectIntl.js




function getDisplayName(Component) {
    return Component.displayName || Component.name || 'Component';
}
// This is primarily dealing with packaging systems where multiple copies of react-intl
// might exist
var IntlContext =  false
    ? 0
    : react.createContext(null);
var IntlConsumer = IntlContext.Consumer, injectIntl_IntlProvider = IntlContext.Provider;
var Provider = (/* unused pure expression or super */ null && (injectIntl_IntlProvider));
var Context = IntlContext;
function injectIntl(WrappedComponent, options) {
    var _a = options || {}, _b = _a.intlPropName, intlPropName = _b === void 0 ? 'intl' : _b, _c = _a.forwardRef, forwardRef = _c === void 0 ? false : _c, _d = _a.enforceContext, enforceContext = _d === void 0 ? true : _d;
    var WithIntl = function (props) { return (React.createElement(IntlConsumer, null, function (intl) {
        var _a;
        if (enforceContext) {
            invariantIntlContext(intl);
        }
        var intlProp = (_a = {}, _a[intlPropName] = intl, _a);
        return (React.createElement(WrappedComponent, __assign({}, props, intlProp, { ref: forwardRef ? props.forwardedRef : null })));
    })); };
    WithIntl.displayName = "injectIntl(".concat(getDisplayName(WrappedComponent), ")");
    WithIntl.WrappedComponent = WrappedComponent;
    if (forwardRef) {
        return hoistNonReactStatics(
        // @ts-expect-error
        React.forwardRef(function (props, ref) { return (React.createElement(WithIntl, __assign({}, props, { forwardedRef: ref }))); }), WrappedComponent);
    }
    return hoistNonReactStatics(WithIntl, WrappedComponent);
}

;// ./node_modules/react-intl/lib/src/components/useIntl.js



function useIntl_useIntl() {
    var intl = react.useContext(Context);
    utils_invariantIntlContext(intl);
    return intl;
}

;// ./node_modules/react-intl/lib/src/components/createFormattedComponent.js



var DisplayName;
(function (DisplayName) {
    DisplayName["formatDate"] = "FormattedDate";
    DisplayName["formatTime"] = "FormattedTime";
    DisplayName["formatNumber"] = "FormattedNumber";
    DisplayName["formatList"] = "FormattedList";
    // Note that this DisplayName is the locale display name, not to be confused with
    // the name of the enum, which is for React component display name in dev tools.
    DisplayName["formatDisplayName"] = "FormattedDisplayName";
})(DisplayName || (DisplayName = {}));
var DisplayNameParts;
(function (DisplayNameParts) {
    DisplayNameParts["formatDate"] = "FormattedDateParts";
    DisplayNameParts["formatTime"] = "FormattedTimeParts";
    DisplayNameParts["formatNumber"] = "FormattedNumberParts";
    DisplayNameParts["formatList"] = "FormattedListParts";
})(DisplayNameParts || (DisplayNameParts = {}));
var FormattedNumberParts = function (props) {
    var intl = useIntl_useIntl();
    var value = props.value, children = props.children, formatProps = tslib_es6_rest(props, ["value", "children"]);
    return children(intl.formatNumberToParts(value, formatProps));
};
FormattedNumberParts.displayName = 'FormattedNumberParts';
var FormattedListParts = function (props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
    return children(intl.formatListToParts(value, formatProps));
};
FormattedNumberParts.displayName = 'FormattedNumberParts';
function createFormattedDateTimePartsComponent(name) {
    var ComponentParts = function (props) {
        var intl = useIntl_useIntl();
        var value = props.value, children = props.children, formatProps = tslib_es6_rest(props, ["value", "children"]);
        var date = typeof value === 'string' ? new Date(value || 0) : value;
        var formattedParts = name === 'formatDate'
            ? intl.formatDateToParts(date, formatProps)
            : intl.formatTimeToParts(date, formatProps);
        return children(formattedParts);
    };
    ComponentParts.displayName = DisplayNameParts[name];
    return ComponentParts;
}
function createFormattedComponent(name) {
    var Component = function (props) {
        var intl = useIntl_useIntl();
        var value = props.value, children = props.children, formatProps = tslib_es6_rest(props
        // TODO: fix TS type definition for localeMatcher upstream
        , ["value", "children"]);
        // TODO: fix TS type definition for localeMatcher upstream
        var formattedValue = intl[name](value, formatProps);
        if (typeof children === 'function') {
            return children(formattedValue);
        }
        var Text = intl.textComponent || react.Fragment;
        return react.createElement(Text, null, formattedValue);
    };
    Component.displayName = DisplayName[name];
    return Component;
}

;// ./node_modules/react-intl/lib/index.js











function defineMessages(msgs) {
    return msgs;
}
function defineMessage(msg) {
    return msg;
}
// IMPORTANT: Explicit here to prevent api-extractor from outputing `import('./src/types').CustomFormatConfig`
var FormattedDate = createFormattedComponent('formatDate');
var FormattedTime = createFormattedComponent('formatTime');
var FormattedNumber = createFormattedComponent('formatNumber');
var FormattedList = createFormattedComponent('formatList');
var FormattedDisplayName = createFormattedComponent('formatDisplayName');
var FormattedDateParts = createFormattedDateTimePartsComponent('formatDate');
var FormattedTimeParts = createFormattedDateTimePartsComponent('formatTime');


;// ./packages/keybr-result/lib/speedunit.ts


class SpeedUnit {
    id;
    factor;
    name;
    static WPM = new SpeedUnit("wpm", 1 / 5, defineMessage({ id: "gp/YEbGZ" }));
    static WPS = new SpeedUnit("wps", 1 / 300, defineMessage({ id: "7xwPdyke" }));
    static CPM = new SpeedUnit("cpm", 1, defineMessage({ id: "1QGnSYYZ" }));
    static CPS = new SpeedUnit("cps", 1 / 60, defineMessage({ id: "SVoJEAFU" }));
    static ALL = new Enum(SpeedUnit.WPM, SpeedUnit.WPS, SpeedUnit.CPM, SpeedUnit.CPS);
    constructor(id, factor, name) {
        this.id = id;
        this.factor = factor;
        this.name = name;
        Object.freeze(this);
    }
    measure = (cpm) => {
        return cpm * this.factor;
    };
    toString() {
        return this.id;
    }
    toJSON() {
        return this.id;
    }
}

;// ./packages/keybr-result/lib/settings.ts


const uiProps = {
    speedUnit: itemProp("ui.speedUnit", SpeedUnit.ALL, SpeedUnit.WPM),
};

;// ./packages/keybr-result/lib/index.ts















;// ./node_modules/@sosimple/fsx/lib/fs.js



const access = external_node_util_default().promisify((external_node_fs_default()).access);
const accessSync = (external_node_fs_default()).accessSync;
const appendFile = external_node_util_default().promisify((external_node_fs_default()).appendFile);
const appendFileSync = (external_node_fs_default()).appendFileSync;
const chmod = external_node_util_default().promisify((external_node_fs_default()).chmod);
const chmodSync = (external_node_fs_default()).chmodSync;
const chown = external_node_util_default().promisify((external_node_fs_default()).chown);
const chownSync = (external_node_fs_default()).chownSync;
const fs_close = external_node_util_default().promisify((external_node_fs_default()).close);
const fs_closeSync = (external_node_fs_default()).closeSync;
const copyFile = external_node_util_default().promisify((external_node_fs_default()).copyFile);
const copyFileSync = (external_node_fs_default()).copyFileSync;
const cp = external_node_util_default().promisify((external_node_fs_default()).cp); // eslint-disable-line n/no-unsupported-features/node-builtins
const cpSync = (external_node_fs_default()).cpSync; // eslint-disable-line n/no-unsupported-features/node-builtins
const exists = external_node_util_default().promisify((external_node_fs_default()).exists); // eslint-disable-line n/no-deprecated-api
const existsSync = (external_node_fs_default()).existsSync;
const fchmod = external_node_util_default().promisify((external_node_fs_default()).fchmod);
const fchmodSync = (external_node_fs_default()).fchmodSync;
const fchown = external_node_util_default().promisify((external_node_fs_default()).fchown);
const fchownSync = (external_node_fs_default()).fchownSync;
const fdatasync = external_node_util_default().promisify((external_node_fs_default()).fdatasync);
const fdatasyncSync = (external_node_fs_default()).fdatasyncSync;
const fstat = external_node_util_default().promisify((external_node_fs_default()).fstat);
const fstatSync = (external_node_fs_default()).fstatSync;
const fsync = external_node_util_default().promisify((external_node_fs_default()).fsync);
const fsyncSync = (external_node_fs_default()).fsyncSync;
const ftruncate = external_node_util_default().promisify((external_node_fs_default()).ftruncate);
const ftruncateSync = (external_node_fs_default()).ftruncateSync;
const futimes = external_node_util_default().promisify((external_node_fs_default()).futimes);
const fs_futimesSync = (external_node_fs_default()).futimesSync;
const lchown = external_node_util_default().promisify((external_node_fs_default()).lchown);
const lchownSync = (external_node_fs_default()).lchownSync;
const fs_link = external_node_util_default().promisify((external_node_fs_default()).link);
const linkSync = (external_node_fs_default()).linkSync;
const lstat = external_node_util_default().promisify((external_node_fs_default()).lstat);
const fs_lstatSync = (external_node_fs_default()).lstatSync;
const lutimes = external_node_util_default().promisify((external_node_fs_default()).lutimes);
const lutimesSync = (external_node_fs_default()).lutimesSync;
const mkdir = external_node_util_default().promisify((external_node_fs_default()).mkdir);
const fs_mkdirSync = (external_node_fs_default()).mkdirSync;
const mkdtemp = external_node_util_default().promisify((external_node_fs_default()).mkdtemp);
const mkdtempSync = (external_node_fs_default()).mkdtempSync;
const fs_open = external_node_util_default().promisify((external_node_fs_default()).open);
const fs_openSync = (external_node_fs_default()).openSync;
const opendir = external_node_util_default().promisify((external_node_fs_default()).opendir);
const opendirSync = (external_node_fs_default()).opendirSync;
const read = external_node_util_default().promisify((external_node_fs_default()).read);
const readSync = (external_node_fs_default()).readSync;
const readdir = external_node_util_default().promisify((external_node_fs_default()).readdir);
const fs_readdirSync = (external_node_fs_default()).readdirSync;
const readFile = external_node_util_default().promisify((external_node_fs_default()).readFile);
const readFileSync = (external_node_fs_default()).readFileSync;
const readlink = external_node_util_default().promisify((external_node_fs_default()).readlink);
const readlinkSync = (external_node_fs_default()).readlinkSync;
const readv = external_node_util_default().promisify((external_node_fs_default()).readv);
const readvSync = (external_node_fs_default()).readvSync;
const realpath = external_node_util_default().promisify((external_node_fs_default()).realpath);
const realpathSync = (external_node_fs_default()).realpathSync;
const rename = external_node_util_default().promisify((external_node_fs_default()).rename);
const renameSync = (external_node_fs_default()).renameSync;
const rm = external_node_util_default().promisify((external_node_fs_default()).rm);
const rmSync = (external_node_fs_default()).rmSync;
const rmdir = external_node_util_default().promisify((external_node_fs_default()).rmdir);
const fs_rmdirSync = (external_node_fs_default()).rmdirSync;
const stat = external_node_util_default().promisify((external_node_fs_default()).stat);
const statSync = (external_node_fs_default()).statSync;
const symlink = external_node_util_default().promisify((external_node_fs_default()).symlink);
const symlinkSync = (external_node_fs_default()).symlinkSync;
const truncate = external_node_util_default().promisify((external_node_fs_default()).truncate);
const truncateSync = (external_node_fs_default()).truncateSync;
const unlink = external_node_util_default().promisify((external_node_fs_default()).unlink);
const fs_unlinkSync = (external_node_fs_default()).unlinkSync;
const unwatchFile = (external_node_fs_default()).unwatchFile;
const utimes = external_node_util_default().promisify((external_node_fs_default()).utimes);
const utimesSync = (external_node_fs_default()).utimesSync;
const watch = (external_node_fs_default()).watch;
const watchFile = (external_node_fs_default()).watchFile;
const write = external_node_util_default().promisify((external_node_fs_default()).write);
const writeSync = (external_node_fs_default()).writeSync;
const writeFile = external_node_util_default().promisify((external_node_fs_default()).writeFile);
const writeFileSync = (external_node_fs_default()).writeFileSync;
const writev = external_node_util_default().promisify((external_node_fs_default()).writev);
const writevSync = (external_node_fs_default()).writevSync;

;// ./node_modules/@sosimple/fsx/lib/scan.js


/**
 * Performs recursive pre-order traversal of the given directory
 * for all its contents.
 * The directory itself is excluded.
 * Symlinks are not followed.
 * @param dir The directory to scan.
 * @return An iterator of all directory contents.
 */
async function* scanDir(dir) {
    for (const item of await safeReaddir(dir)) {
        yield* scan(dir, item);
    }
}
async function* scan(dir, suffix) {
    const path = join(dir, suffix);
    const stats = await safeLstat(path);
    if (stats != null) {
        yield { path: suffix, stats };
        if (stats.isDirectory()) {
            for (const item of await safeReaddir(path)) {
                yield* scan(dir, join(suffix, item));
            }
        }
    }
}
/**
 * Performs recursive pre-order traversal of the given directory
 * for all its contents.
 * The directory itself is excluded.
 * Symlinks are not followed.
 * @param dir The directory to scan.
 * @return An iterator of all directory contents.
 */
function* scanDirSync(dir) {
    for (const item of safeReaddirSync(dir)) {
        yield* scanSync(dir, item);
    }
}
function* scanSync(dir, suffix) {
    const path = join(dir, suffix);
    const stats = safeLstatSync(path);
    if (stats != null) {
        yield { path: suffix, stats };
        if (stats.isDirectory()) {
            for (const item of safeReaddirSync(path)) {
                yield* scanSync(dir, join(suffix, item));
            }
        }
    }
}
/**
 * Recursively removes all contents form the given directory. The directory
 * itself is not removed.
 * If the directory does not exist then this method does nothing.
 * @param dir The directory to empty.
 */
async function emptyDir(dir) {
    for await (const entry of start(dir)) {
        await kill(entry);
    }
}
/**
 * Recursively removes all contents form the given directory. The directory
 * itself is not removed.
 * If the directory does not exist then this method does nothing.
 * @param dir The directory to empty.
 */
function emptyDirSync(dir) {
    for (const entry of startSync(dir)) {
        killSync(entry);
    }
}
/**
 * Recursively removes the given directory with all its content.
 * If the directory does not exist then this method does nothing.
 * @param dir The directory to remove.
 */
async function removeDir(dir) {
    for await (const entry of start(dir)) {
        await kill(entry);
    }
    try {
        await rmdir(dir);
    }
    catch (err) {
        if (err.code !== "ENOENT") {
            throw err;
        }
    }
}
/**
 * Recursively removes the given directory with all its content.
 * If the directory does not exist then this method does nothing.
 * @param dir The directory to remove.
 */
function removeDirSync(dir) {
    for (const entry of startSync(dir)) {
        killSync(entry);
    }
    try {
        rmdirSync(dir);
    }
    catch (err) {
        if (err.code !== "ENOENT") {
            throw err;
        }
    }
}
async function* start(dir) {
    for (const item of await safeReaddir(dir)) {
        yield* postOrderScan((0,external_node_path_.join)(dir, item));
    }
}
function* startSync(dir) {
    for (const item of safeReaddirSync(dir)) {
        yield* postOrderScanSync(join(dir, item));
    }
}
/**
 * Performs recursive post-order traversal of directory contents.
 */
async function* postOrderScan(dir) {
    const stats = await safeLstat(dir);
    if (stats != null) {
        if (stats.isDirectory()) {
            for (const item of await safeReaddir(dir)) {
                yield* postOrderScan((0,external_node_path_.join)(dir, item));
            }
        }
        yield { path: dir, stats };
    }
}
/**
 * Performs recursive post-order traversal of directory contents.
 */
function* postOrderScanSync(dir) {
    const stats = safeLstatSync(dir);
    if (stats != null) {
        if (stats.isDirectory()) {
            for (const item of safeReaddirSync(dir)) {
                yield* postOrderScanSync(join(dir, item));
            }
        }
        yield { path: dir, stats };
    }
}
/**
 * Deletes filesystem entry, directory or file.
 */
async function kill({ path, stats }) {
    try {
        if (stats.isDirectory()) {
            await rmdir(path);
        }
        else {
            await unlink(path);
        }
    }
    catch (err) {
        if (err.code !== "ENOENT") {
            throw err;
        }
    }
}
/**
 * Deletes filesystem entry, directory or file.
 */
function killSync({ path, stats }) {
    try {
        if (stats.isDirectory()) {
            rmdirSync(path);
        }
        else {
            unlinkSync(path);
        }
    }
    catch (err) {
        if (err.code !== "ENOENT") {
            throw err;
        }
    }
}
async function safeReaddir(path) {
    try {
        return await readdir(path);
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return [];
        }
        else {
            throw err;
        }
    }
}
function safeReaddirSync(path) {
    try {
        return readdirSync(path);
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return [];
        }
        else {
            throw err;
        }
    }
}
async function safeLstat(path) {
    try {
        return await lstat(path);
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return null;
        }
        else {
            throw err;
        }
    }
}
function safeLstatSync(path) {
    try {
        return lstatSync(path);
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return null;
        }
        else {
            throw err;
        }
    }
}

;// ./node_modules/@sosimple/fsx/lib/touch.js


/**
 * Updates the modification time the specified file.
 * If the file does not exist, a new empty one will be created.
 *
 * @param name Name of the file to touch.
 * @param options Touch options.
 * @return A boolean value indicating whether the modification time
 *         of the existing file was updated or a new empty file was created.
 */
async function touch(name, options = {}) {
    const { create = true, now = new Date() } = options;
    let flags = external_node_fs_.constants.O_RDWR;
    if (create) {
        flags = flags | external_node_fs_.constants.O_CREAT;
    }
    try {
        if (create) {
            await mkdir((0,external_node_path_.dirname)(name), { recursive: true });
        }
        const fd = await fs_open(name, flags);
        await futimes(fd, now, now);
        await fs_close(fd);
        return true;
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return false;
        }
        else {
            throw err;
        }
    }
}
/**
 * Updates the modification time the specified file.
 * If the file does not exist, a new empty one will be created.
 *
 * @param name Name of the file to touch.
 * @param options Touch options.
 * @return A boolean value indicating whether the modification time
 *         of the existing file was updated or a new empty file was created.
 */
function touchSync(name, options = {}) {
    const { create = true, now = new Date() } = options;
    let flags = constants.O_RDWR;
    if (create) {
        flags = flags | constants.O_CREAT;
    }
    try {
        if (create) {
            mkdirSync(dirname(name), { recursive: true });
        }
        const fd = openSync(name, flags);
        futimesSync(fd, now, now);
        closeSync(fd);
        return true;
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return false;
        }
        else {
            throw err;
        }
    }
}

;// ./node_modules/@sosimple/fsx/lib/index.js




;// ./node_modules/@sosimple/fsx-file/lib/util.js

const chunkSize = 16384;
/**
 * Asynchronously reads the entire contents of a file.
 */
async function readFileHandle(fd) {
    const chunks = [];
    let position = 0;
    while (true) {
        const tmp = Buffer.alloc(chunkSize);
        const { bytesRead, buffer } = await read(fd, tmp, 0, chunkSize, position);
        if (bytesRead > 0) {
            chunks.push(buffer.slice(0, bytesRead));
            position += bytesRead;
        }
        else {
            break;
        }
    }
    return Buffer.concat(chunks);
}
/**
 * Asynchronously writes data to a file, replacing any old contents.
 */
async function writeFileHandle(fd, buffer, append) {
    let remaining = buffer.length;
    let position = 0;
    if (append) {
        position = (await fstat(fd)).size;
    }
    while (remaining > 0) {
        const { bytesWritten } = await write(fd, buffer, 0, Math.min(chunkSize, buffer.length), position);
        buffer = buffer.slice(bytesWritten);
        remaining -= bytesWritten;
        position += bytesWritten;
    }
}
function toBuffer(data, encoding = "utf8") {
    if (Buffer.isBuffer(data)) {
        return data;
    }
    if (typeof data === "string") {
        return Buffer.from(data, encoding);
    }
    throw new TypeError();
}

;// ./node_modules/@sosimple/fsx-file/lib/filehandle.js


const kName = Symbol();
const kFd = Symbol();
/**
 * A `FileHandle` object is a wrapper for a numeric file descriptor.
 * Instances of `FileHandle` are distinct from numeric file descriptors in that
 * they provide an object oriented API for working with files.
 */
class FileHandle {
    static async open(name, flags, mode) {
        return new FileHandle(name, await fs_open(name, flags, mode));
    }
    [kName];
    [kFd];
    constructor(name, fd) {
        this[kName] = name;
        this[kFd] = fd;
    }
    /**
     * Gets file name.
     */
    get name() {
        return this[kName];
    }
    /**
     * Gets file descriptor.
     */
    get fd() {
        return this[kFd];
    }
    async close() {
        return fs_close(this[kFd]);
    }
    async chmod(mode) {
        return fchmod(this[kFd], mode);
    }
    async chown(uid, gid) {
        return fchown(this[kFd], uid, gid);
    }
    async stat() {
        return fstat(this[kFd]);
    }
    async utimes(atime, mtime) {
        return futimes(this[kFd], atime, mtime);
    }
    async sync() {
        return fsync(this[kFd]);
    }
    async datasync() {
        return fdatasync(this[kFd]);
    }
    async truncate(length) {
        return ftruncate(this[kFd], length);
    }
    /**
     * Asynchronously reads data from the file.
     * @param buffer The buffer that the data will be written to.
     * @param offset The offset in the buffer at which to start writing.
     * @param length The number of bytes to read.
     * @param position The offset from the beginning of the file from which data
     *                 should be read. If `null`, data will be read from the
     *                 current position.
     */
    async read(buffer, offset, length, position = null) {
        return read(this[kFd], buffer, offset, length, position);
    }
    /**
     * Asynchronously writes the given data to this file.
     * @param buffer The data to write.
     * @param offset The part of the buffer to be written. If not supplied,
     *               defaults to `0`.
     * @param length The number of bytes to write. If not supplied, defaults to
     *               `buffer.length - offset`.
     * @param position The offset from the beginning of the file where this data
     *                 should be written. If not supplied, defaults to the
     *                 current position.
     */
    async write(buffer, offset, length, position) {
        return write(this[kFd], buffer, offset, length, position);
    }
    async readFile(encoding) {
        const buffer = await readFileHandle(this[kFd]);
        if (encoding) {
            return buffer.toString(encoding);
        }
        else {
            return buffer;
        }
    }
    async writeFile(data, encoding) {
        await writeFileHandle(this[kFd], toBuffer(data, encoding), false);
    }
    async appendFile(data, encoding) {
        await writeFileHandle(this[kFd], toBuffer(data, encoding), true);
    }
    get [Symbol.toStringTag]() {
        return "FileHandle";
    }
}

;// ./node_modules/@sosimple/fsx-file/lib/file.js



class Entry {
    name;
    constructor(path) {
        this.name = (0,external_node_path_.normalize)((0,external_node_path_.resolve)(path));
    }
    async stat() {
        return stat(this.name);
    }
    async utimes(atime, mtime) {
        return utimes(this.name, atime, mtime);
    }
    async exists() {
        try {
            await access(this.name, external_node_fs_.constants.F_OK);
            return true;
        }
        catch (err) {
            if (err.code === "ENOENT") {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    async readable() {
        try {
            await access(this.name, external_node_fs_.constants.R_OK);
            return true;
        }
        catch (err) {
            if (err.code === "EACCES") {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    async writable() {
        try {
            await access(this.name, external_node_fs_.constants.W_OK);
            return true;
        }
        catch (err) {
            if (err.code === "EACCES") {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    async delete() {
        try {
            await unlink(this.name);
            return true;
        }
        catch (err) {
            if (err.code === "ENOENT") {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    toString() {
        return this.name;
    }
}
class file_Dir extends Entry {
    constructor(path) {
        super(path);
    }
    async create(recursive = true) {
        await mkdir(this.name, { recursive });
    }
    async empty() {
        await emptyDir(this.name);
    }
    async remove() {
        await removeDir(this.name);
    }
    get [Symbol.toStringTag]() {
        return "Dir";
    }
}
class File extends Entry {
    static from(name) {
        if (name instanceof File) {
            return name;
        }
        else {
            return new File(name);
        }
    }
    constructor(path) {
        super(path);
    }
    dir() {
        return new file_Dir((0,external_node_path_.dirname)(this.name));
    }
    readStream(options) {
        return (0,external_node_fs_.createReadStream)(this.name, options);
    }
    writeStream(options) {
        return (0,external_node_fs_.createWriteStream)(this.name, options);
    }
    open(flags, mode) {
        return FileHandle.open(this.name, flags, mode);
    }
    read(options) {
        return readFile(this.name, options);
    }
    async write(data, options) {
        await this.dir().create();
        try {
            await writeFile(this.name, data, options);
            return true;
        }
        catch (err) {
            if (err.code === "EEXIST") {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    async append(data, options) {
        await this.dir().create();
        try {
            await appendFile(this.name, data, options);
            return true;
        }
        catch (err) {
            if (err.code === "EEXIST") {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    async readJson(options, reviver) {
        if (options != null && typeof options === "object") {
            reviver = reviver ?? options.reviver;
        }
        return JSON.parse(String(await this.read(options)), reviver);
    }
    async writeJson(data, options, replacer, space) {
        if (options != null && typeof options === "object") {
            replacer = replacer ?? options.replacer;
            space = space ?? options.space;
        }
        await this.write(JSON.stringify(data, replacer, space), options);
    }
    async touch(options) {
        await this.dir().create();
        return await touch(this.name, options);
    }
    get [Symbol.toStringTag]() {
        return "File";
    }
}

;// ./node_modules/@sosimple/fsx-file/lib/index.js




;// ./packages/keybr-result-io/lib/errors.ts
class InvalidFormatError extends Error {
    name = "InvalidFormatError";
    constructor(message, options) {
        super(message, options);
    }
    get [Symbol.toStringTag]() {
        return "InvalidFormatError";
    }
}

;// ./packages/keybr-result-io/lib/header.ts

const HEADER_SIGNATURE = 0x4b455942;
const HEADER_VERSION = 2;
const header_HEADER = new io_Writer()
    .putInt32(HEADER_SIGNATURE)
    .putInt32(HEADER_VERSION)
    .buffer();
function validateHeader(reader) {
    return (reader.remaining() >= header_HEADER.byteLength &&
        reader.getUint32() === HEADER_SIGNATURE &&
        reader.getUint32() === HEADER_VERSION);
}

;// ./packages/keybr-result-io/lib/binary.ts





function writeResult(writer, result) {
    const samples = [...result.histogram];
    writer.putUint8(result.layout.xid);
    writer.putUint8(result.textType.xid);
    writer.putUint32(Math.round(result.timeStamp / 1000));
    writer.putUintVlq(result.time);
    writer.putUintVlq(result.length);
    writer.putUintVlq(result.errors);
    writer.putUintVlq(samples.length);
    for (const sample of samples) {
        writer.putUintVlq(sample.codePoint);
        writer.putUintVlq(sample.hitCount);
        writer.putUintVlq(sample.missCount);
        writer.putUintVlq(sample.timeToType);
    }
}
function binary_writeResults(writer, results) {
    for (const result of results) {
        writeResult(writer, result);
    }
}
function readResult(reader) {
    const layoutXId = reader.getUint8();
    const textTypeXId = reader.getUint8();
    const timestamp = reader.getUint32() * 1000;
    const time = reader.getUintVlq();
    const length = reader.getUintVlq();
    const errors = reader.getUintVlq();
    const size = reader.getUintVlq();
    const samples = [];
    for (let i = 0; i < size; i++) {
        const codePoint = reader.getUintVlq();
        const hitCount = reader.getUintVlq();
        const missCount = reader.getUintVlq();
        const timeToType = reader.getUintVlq();
        samples.push({
            codePoint,
            hitCount,
            missCount,
            timeToType,
        });
    }
    return new result_Result(layout_Layout.ALL.xget(layoutXId), texttype_TextType.ALL.xget(textTypeXId), timestamp, length, time, errors, new histogram_Histogram(samples));
}
function* readResults(reader) {
    while (reader.remaining() > 0) {
        yield readResult(reader);
    }
}
function* binary_readStructuredContent(reader) {
    if (reader.remaining() > 0) {
        if (!validateHeader(reader)) {
            throw new InvalidFormatError("Invalid header");
        }
        try {
            yield* readResults(reader);
        }
        catch (err) {
            throw new InvalidFormatError("Invalid data format", { cause: err });
        }
    }
}

;// ./packages/keybr-result-io/lib/file.ts



function fileHeader() {
    return header_HEADER;
}
function fileChunk(results) {
    const writer = new io_Writer();
    binary_writeResults(writer, results);
    return writer.buffer();
}
function parseFile(buffer) {
    return binary_readStructuredContent(new io_Reader(buffer));
}
function formatFile(results) {
    const writer = new Writer();
    writer.putBuffer(HEADER);
    writeResults(writer, results);
    return writer.buffer();
}

;// ./packages/keybr-result-io/lib/legacyjson.ts




function resultToJson(result) {
    return {
        l: result.layout.id,
        m: result.textType.id,
        ts: result.timeStamp,
        n: result.length,
        t: result.time,
        e: result.errors,
        h: histogramToJson(result.histogram),
    };
}
function histogramToJson(histogram) {
    const json = {};
    for (const { codePoint, hitCount, missCount, timeToType } of histogram) {
        json[codePoint] = {
            h: hitCount,
            m: missCount,
            t: timeToType,
        };
    }
    return json;
}
function resultFromJson(json) {
    if (!isPlainObject(json)) {
        return null;
    }
    const { l: layoutId, m: textTypeId, ts: timeStamp, n: length, t: time, e: errors, h: histogramJson, } = json;
    if (!(isString(layoutId) &&
        isString(textTypeId) &&
        Number.isSafeInteger(timeStamp) &&
        Number.isSafeInteger(length) &&
        Number.isSafeInteger(time) &&
        Number.isSafeInteger(errors))) {
        return null;
    }
    const histogram = histogramFromJson(histogramJson);
    if (histogram == null) {
        return null;
    }
    try {
        return new Result(Layout.ALL.get(fixLegacyLayoutId(layoutId)), TextType.ALL.get(fixTextTypeId(textTypeId)), timeStamp, length, time, errors, histogram);
    }
    catch {
        return null;
    }
}
function histogramFromJson(json) {
    if (!isPlainObject(json)) {
        return null;
    }
    const samples = [];
    for (const [key, sample] of Object.entries(json)) {
        const codePoint = Number(key);
        if (!(Number.isSafeInteger(codePoint) && codePoint > 0 && codePoint <= 65535)) {
            return null;
        }
        if (!isPlainObject(sample)) {
            return null;
        }
        const { h: hitCount, m: missCount, t: timeToType, } = sample;
        if (!(Number.isSafeInteger(hitCount) &&
            Number.isSafeInteger(missCount) &&
            Number.isFinite(timeToType))) {
            return null;
        }
        samples.push({
            codePoint,
            hitCount,
            missCount,
            timeToType: Math.round(timeToType),
        });
    }
    return new Histogram(samples);
}
function fixLegacyLayoutId(id) {
    // Fix layout identifiers that were changed in cfafe818d5edd3d72a738183730dae049b967ebc
    switch (id) {
        case "be":
            return Layout.BE_BY.id;
        case "cz":
            return Layout.CS_CZ.id;
        case "de":
            return Layout.DE_DE.id;
        case "fr":
            return Layout.FR_FR.id;
        case "it":
            return Layout.IT_IT.id;
        case "pl":
            return Layout.PL_PL.id;
        case "ru":
            return Layout.RU_RU.id;
        case "se":
            return Layout.SV_SE.id;
        case "ua":
            return Layout.UK_UA.id;
        case "uk":
            return Layout.EN_UK.id;
        case "us":
            return Layout.EN_US.id;
        case "us-canary-matrix":
            return Layout.EN_CANARY_MATRIX.id;
        case "us-colemak":
            return Layout.EN_COLEMAK.id;
        case "us-colemak-dh":
            return Layout.EN_COLEMAK_DH_ANSI.id;
        case "us-colemak-dh-matrix":
            return Layout.EN_COLEMAK_DH_MATRIX.id;
        case "us-dvorak":
            return Layout.EN_DVORAK.id;
        case "us-workman":
            return Layout.EN_WORKMAN.id;
        default:
            return id;
    }
}
function fixTextTypeId(id) {
    switch (id) {
        case "guided":
            return TextType.GENERATED.id;
        case "custom":
            return TextType.NATURAL.id;
        default:
            return id;
    }
}

;// ./packages/keybr-result-io/lib/sync.ts



function formatMessage(results) {
    const writer = new Writer();
    writer.putBuffer(HEADER);
    writeResults(writer, results);
    return scramble(writer.buffer());
}
function parseMessage(buffer) {
    return readStructuredContent(new Reader(unscramble(buffer)));
}

;// ./packages/keybr-result-io/lib/index.ts






;// ./packages/keybr-result-userdata/lib/userdata.ts




class UserData {
    id;
    file;
    constructor(id, file) {
        this.id = id;
        this.file = file;
    }
    async serve(ctx) {
        try {
            const stats = await this.file.stat();
            const content = this.file.readStream();
            const etag = this.etag(stats);
            ctx.response.length = stats.size;
            ctx.response.body = content;
            ctx.response.etag = etag;
            ctx.state.compress = false;
        }
        catch (err) {
            if (err.code === "ENOENT") {
                ctx.response.body = Buffer.alloc(0);
                ctx.response.etag = this.etag(null);
            }
            else {
                throw err;
            }
        }
        // The order of statements is important here.
        // Calling `attachment(...)` will overwrite type,
        // so `type = ...` must come last.
        ctx.response.type = "application/octet-stream";
        ctx.response.headers.set("Content-Disposition", `attachment; filename="stats.data"`);
        ctx.response.headers.set("Cache-Control", "private, no-cache");
    }
    async exists() {
        return await this.file.exists();
    }
    async *read() {
        if (await this.exists()) {
            const buffer = await this.file.read();
            for (const result of parseFile(buffer)) {
                yield result;
            }
        }
    }
    async append(results) {
        if (results.length > 0) {
            await this.file.append(fileHeader(), { flag: "ax" });
            for (const chunk of partition(results)) {
                await this.file.append(fileChunk(chunk), { flag: "a" });
            }
        }
    }
    async delete() {
        if (await this.file.exists()) {
            let count = 1;
            while (true) {
                const candidate = new File(this.file.name + "~" + count);
                if (await candidate.exists()) {
                    count += 1;
                }
                else {
                    await rename(this.file.name, candidate.name);
                    break;
                }
            }
        }
    }
    etag(stats) {
        const hash = (0,external_node_crypto_namespaceObject.createHash)("md5");
        hash.update(String(this.id));
        if (stats != null) {
            hash.update(String(stats.size));
            hash.update(String(stats.mtime));
        }
        else {
            hash.update("empty");
        }
        return hash.digest("hex");
    }
}
function* partition(results, size = 100) {
    let offset = 0;
    while (offset < results.length) {
        yield results.slice(offset, offset + size);
        offset += size;
    }
}

;// ./packages/keybr-result-userdata/lib/factory.ts
var factory_a;





let UserDataFactory = class UserDataFactory {
    dataDir;
    constructor(dataDir) {
        this.dataDir = dataDir;
    }
    load(id) {
        return new UserData(id, this.getFile(id));
    }
    getFile(id) {
        if (id.example) {
            throw new TypeError();
        }
        else {
            return new File(this.dataDir.userStatsFile(id.id));
        }
    }
};
UserDataFactory = __decorate([
    injectable({ singleton: true }),
    __metadata("design:paramtypes", [typeof (factory_a = typeof DataDir !== "undefined" && DataDir) === "function" ? factory_a : Object])
], UserDataFactory);


;// ./packages/keybr-result-userdata/lib/index.ts



;// ./node_modules/date-fns/constants.js
/**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "./constants/date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */

/**
 * @constant
 * @name daysInWeek
 * @summary Days in 1 week.
 */
const daysInWeek = 7;

/**
 * @constant
 * @name daysInYear
 * @summary Days in 1 year.
 *
 * @description
 * How many days in a year.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 */
const daysInYear = 365.2425;

/**
 * @constant
 * @name maxTime
 * @summary Maximum allowed time.
 *
 * @example
 * import { maxTime } from "./constants/date-fns/constants";
 *
 * const isValid = 8640000000000001 <= maxTime;
 * //=> false
 *
 * new Date(8640000000000001);
 * //=> Invalid Date
 */
const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;

/**
 * @constant
 * @name minTime
 * @summary Minimum allowed time.
 *
 * @example
 * import { minTime } from "./constants/date-fns/constants";
 *
 * const isValid = -8640000000000001 >= minTime;
 * //=> false
 *
 * new Date(-8640000000000001)
 * //=> Invalid Date
 */
const minTime = -maxTime;

/**
 * @constant
 * @name millisecondsInWeek
 * @summary Milliseconds in 1 week.
 */
const millisecondsInWeek = 604800000;

/**
 * @constant
 * @name millisecondsInDay
 * @summary Milliseconds in 1 day.
 */
const millisecondsInDay = 86400000;

/**
 * @constant
 * @name millisecondsInMinute
 * @summary Milliseconds in 1 minute
 */
const millisecondsInMinute = 60000;

/**
 * @constant
 * @name millisecondsInHour
 * @summary Milliseconds in 1 hour
 */
const millisecondsInHour = 3600000;

/**
 * @constant
 * @name millisecondsInSecond
 * @summary Milliseconds in 1 second
 */
const millisecondsInSecond = 1000;

/**
 * @constant
 * @name minutesInYear
 * @summary Minutes in 1 year.
 */
const minutesInYear = 525600;

/**
 * @constant
 * @name minutesInMonth
 * @summary Minutes in 1 month.
 */
const minutesInMonth = 43200;

/**
 * @constant
 * @name minutesInDay
 * @summary Minutes in 1 day.
 */
const minutesInDay = 1440;

/**
 * @constant
 * @name minutesInHour
 * @summary Minutes in 1 hour.
 */
const minutesInHour = 60;

/**
 * @constant
 * @name monthsInQuarter
 * @summary Months in 1 quarter.
 */
const monthsInQuarter = 3;

/**
 * @constant
 * @name monthsInYear
 * @summary Months in 1 year.
 */
const monthsInYear = 12;

/**
 * @constant
 * @name quartersInYear
 * @summary Quarters in 1 year
 */
const quartersInYear = 4;

/**
 * @constant
 * @name secondsInHour
 * @summary Seconds in 1 hour.
 */
const secondsInHour = 3600;

/**
 * @constant
 * @name secondsInMinute
 * @summary Seconds in 1 minute.
 */
const secondsInMinute = 60;

/**
 * @constant
 * @name secondsInDay
 * @summary Seconds in 1 day.
 */
const secondsInDay = secondsInHour * 24;

/**
 * @constant
 * @name secondsInWeek
 * @summary Seconds in 1 week.
 */
const secondsInWeek = secondsInDay * 7;

/**
 * @constant
 * @name secondsInYear
 * @summary Seconds in 1 year.
 */
const secondsInYear = secondsInDay * daysInYear;

/**
 * @constant
 * @name secondsInMonth
 * @summary Seconds in 1 month
 */
const secondsInMonth = secondsInYear / 12;

/**
 * @constant
 * @name secondsInQuarter
 * @summary Seconds in 1 quarter.
 */
const secondsInQuarter = secondsInMonth * 3;

/**
 * @constant
 * @name constructFromSymbol
 * @summary Symbol enabling Date extensions to inherit properties from the reference date.
 *
 * The symbol is used to enable the `constructFrom` function to construct a date
 * using a reference date and a value. It allows to transfer extra properties
 * from the reference date to the new date. It's useful for extensions like
 * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as
 * a constructor argument.
 */
const constructFromSymbol = Symbol.for("constructDateFrom");

;// ./node_modules/date-fns/constructFrom.js


/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * Starting from v3.7.0, it allows to construct a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from "./constructFrom/date-fns";
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date>(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use constructor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   );
 * }
 */
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);

  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);

  if (date instanceof Date) return new date.constructor(value);

  return new Date(value);
}

// Fallback for modularized imports:
/* harmony default export */ const date_fns_constructFrom = ((/* unused pure expression or super */ null && (constructFrom)));

;// ./node_modules/date-fns/toDate.js


/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument, context) {
  // [TODO] Get rid of `toDate` or `constructFrom`?
  return constructFrom(context || argument, argument);
}

// Fallback for modularized imports:
/* harmony default export */ const date_fns_toDate = ((/* unused pure expression or super */ null && (toDate)));

;// ./node_modules/date-fns/parseJSON.js


/**
 * The {@link parseJSON} function options.
 */

/**
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 */
function parseJSON(dateStr, options) {
  const parts = dateStr.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/,
  );

  if (!parts) return toDate(NaN, options?.in);

  return toDate(
    Date.UTC(
      +parts[1],
      +parts[2] - 1,
      +parts[3],
      +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1),
      +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1),
      +parts[6],
      +((parts[7] || "0") + "00").substring(0, 3),
    ),
    options?.in,
  );
}

// Fallback for modularized imports:
/* harmony default export */ const date_fns_parseJSON = ((/* unused pure expression or super */ null && (parseJSON)));

;// ./node_modules/date-fns/parseISO.js




/**
 * The {@link parseISO} function options.
 */

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
function parseISO(argument, options) {
  const invalidDate = () => constructFrom(options?.in, NaN);

  const additionalDigits = options?.additionalDigits ?? 2;
  const dateStrings = splitDateString(argument);

  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(+date)) return invalidDate();

  const timestamp = +date;
  let time = 0;
  let offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) return invalidDate();
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) return invalidDate();
  } else {
    const tmpDate = new Date(timestamp + time);
    const result = toDate(0, options?.in);
    result.setFullYear(
      tmpDate.getUTCFullYear(),
      tmpDate.getUTCMonth(),
      tmpDate.getUTCDate(),
    );
    result.setHours(
      tmpDate.getUTCHours(),
      tmpDate.getUTCMinutes(),
      tmpDate.getUTCSeconds(),
      tmpDate.getUTCMilliseconds(),
    );
    return result;
  }

  return toDate(timestamp + time + offset, options?.in);
}

const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/,
};

const dateRegex =
  /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex =
  /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length,
      );
    }
  }

  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" +
      (4 + additionalDigits) +
      "})|(\\d{2}|[+-]\\d{" +
      (2 + additionalDigits) +
      "})$)",
  );

  const captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return { year: NaN, restDateString: "" };

  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length),
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);

  const captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);

  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = new Date(0);
    if (
      !validateDate(year, month, day) ||
      !validateDayOfYearDate(year, dayOfYear)
    ) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return (
    hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000
  );
}

function parseTimeUnit(value) {
  return (value && parseFloat(value.replace(",", "."))) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;

  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;

  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = (captures[3] && parseInt(captures[3])) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

function validateDate(year, month, date) {
  return (
    month >= 0 &&
    month <= 11 &&
    date >= 1 &&
    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))
  );
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return (
    seconds >= 0 &&
    seconds < 60 &&
    minutes >= 0 &&
    minutes < 60 &&
    hours >= 0 &&
    hours < 25
  );
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

// Fallback for modularized imports:
/* harmony default export */ const date_fns_parseISO = ((/* unused pure expression or super */ null && (parseISO)));

;// ./packages/server-cli/lib/command/stats/userid-range.ts
class UserIdRange {
    items;
    constructor(unsorted) {
        const items = [];
        let last = null;
        for (const curr of [
            ...unsorted,
            {
                from: 0xffffffff,
                to: 0xffffffff,
            },
        ].sort(compare)) {
            if (last == null) {
                last = curr;
            }
            else {
                if (last.to + 1 < curr.from) {
                    items.push(last);
                    last = curr;
                }
                else {
                    last = { from: last.from, to: Math.max(last.to, curr.to) };
                }
            }
        }
        this.items = items;
    }
    *[Symbol.iterator]() {
        for (const { from, to } of this.items) {
            for (let n = from; n <= to; n++) {
                yield n;
            }
        }
    }
    toString() {
        return this.items
            .map(({ from, to }) => (from < to ? `${from}-${to}` : `${from}`))
            .join(",");
    }
}
function compare(a, b) {
    if (a.from < b.from) {
        return -1;
    }
    if (a.from > b.from) {
        return +1;
    }
    if (a.to < b.to) {
        return -1;
    }
    if (a.to > b.to) {
        return +1;
    }
    return 0;
}

;// ./packages/server-cli/lib/command/stats/argument.ts




function parseUserIdRange(arg) {
    const items = [];
    for (const item of arg.split(/,/)) {
        const parts = item.split(/-/, 2);
        if (parts.length === 1) {
            const n = parseUserId(parts[0]);
            items.push({ from: n, to: n });
        }
        else {
            const from = parseUserId(parts[0]);
            const to = parseUserId(parts[1]);
            if (from > to) {
                throw new InvalidArgumentError(`Invalid user id range.`);
            }
            items.push({ from, to });
        }
    }
    return new UserIdRange(items);
}
function parseUserId(arg) {
    const n = Number.parseInt(arg, 10);
    if (!Number.isInteger(n) || n <= 0 || n >= 0xffffffff) {
        throw new InvalidArgumentError(`Invalid user id.`);
    }
    return n;
}
function parseTimestamp(arg) {
    let date;
    if (Number.isFinite((date = parseJSON(arg)).getTime())) {
        return date;
    }
    if (Number.isFinite((date = parseISO(arg)).getTime())) {
        return date;
    }
    throw new InvalidArgumentError(`Invalid timestamp.`);
}
function parseSpeed(arg) {
    const m = /^(?<value>[0-9]+)(?<unit>wpm|cpm)?$/.exec(arg);
    if (m) {
        const { value, unit } = m.groups;
        const { factor } = { wpm: SpeedUnit.WPM, cpm: SpeedUnit.CPM }[unit || "wpm"];
        return Number.parseInt(value, 10) / factor;
    }
    throw new InvalidArgumentError(`Invalid speed.`);
}

;// ./packages/server-cli/lib/command/stats/check-file.ts


function checkFile(buffer, filter = {}) {
    const reader = new io_Reader(buffer);
    const results = [];
    const invalid = [];
    if (!validateHeader(reader)) {
        return { type: "bad", results, invalid };
    }
    while (reader.remaining() > 0) {
        let result;
        try {
            result = readResult(reader);
        }
        catch {
            return { type: "bad", results, invalid };
        }
        if (result.validate(filter)) {
            results.push(result);
        }
        else {
            invalid.push(result);
        }
    }
    return results.length === 0 || invalid.length > 0
        ? { type: "bad", results, invalid }
        : { type: "good", results };
}

;// ./packages/server-cli/lib/command/stats/fix-file.ts



async function fixFile(file, results) {
    await renameOldFile(file);
    if (results.length > 0) {
        await writeNewFile(file, results);
    }
}
async function renameOldFile(file) {
    const { name } = file;
    try {
        await rename(name, name + "~corrupted");
    }
    catch (err) {
        if (err.code !== "ENOENT") {
            throw err;
        }
    }
}
async function writeNewFile(file, results) {
    const writer = new io_Writer();
    writer.putBuffer(header_HEADER);
    for (const result of results) {
        writeResult(writer, result);
    }
    await file.write(writer.buffer());
}

;// ./packages/server-cli/lib/command/stats/fstat.ts
async function fstat_fstat(file) {
    try {
        return await file.stat();
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return null;
        }
        else {
            throw err;
        }
    }
}

;// ./packages/server-cli/lib/command/stats/command.ts
var command_a;










let StatsCommand = class StatsCommand {
    userDataFactory;
    constructor(userDataFactory) {
        this.userDataFactory = userDataFactory;
    }
    command() {
        return new Command("check-stats")
            .description("Check and fix user stats.")
            .addOption(new Option("--min-speed <speed>", "Minimal allowed result speed, inclusive.").argParser(parseSpeed))
            .addOption(new Option("--max-speed <speed>", "Maximal allowed result speed, inclusive.").argParser(parseSpeed))
            .addOption(new Option("--since <timestamp>", "Check only files modified since the given timestamp.").argParser(parseTimestamp))
            .addOption(new Option("--fix", "Fix damaged user stats."))
            .addOption(new Option("--verbose", "Show more diagnostic messages."))
            .addArgument(new Argument("<user-id-range>", "Range of the user ids to check.").argParser(parseUserIdRange))
            .action(this.action.bind(this));
    }
    async action(range, { minSpeed = result_Result.filter.minSpeed, maxSpeed = result_Result.filter.maxSpeed, since = new Date(0), fix = false, verbose = false, }) {
        if (since.getTime() > 0) {
            if (verbose) {
                console.log(`Checking stats modified since ${since.toISOString()}.`);
            }
        }
        for (const userId of range) {
            const file = this.userDataFactory.getFile(new PublicId(userId));
            const stat = await fstat_fstat(file);
            if (stat == null || !stat.isFile()) {
                if (verbose) {
                    console.log(`No stats of user=[${userId}], file=[${file.name}].`);
                }
                continue;
            }
            if (since.getTime() > 0 && stat.mtime.getTime() < since.getTime()) {
                if (verbose) {
                    console.log(`Skipping stats of user=[${userId}], file=[${file.name}].`);
                }
                continue;
            }
            const status = checkFile(await file.read(), { minSpeed, maxSpeed });
            switch (status.type) {
                case "good": {
                    const { results } = status;
                    if (verbose) {
                        console.log(`Good data, user=[${userId}], file=[${file.name}]. ` +
                            `Read ${results.length} results.`);
                    }
                    break;
                }
                case "bad": {
                    const { results, invalid } = status;
                    console.warn(`Bad data, user=[${userId}], file=[${file.name}]. ` +
                        `Read ${results.length} results. ` +
                        `Ignored ${invalid.length} invalid results.`);
                    if (fix) {
                        await fixFile(file, results);
                        if (verbose) {
                            console.log(`File was fixed.`);
                        }
                    }
                    break;
                }
            }
        }
    }
};
StatsCommand = __decorate([
    injectable(),
    __metadata("design:paramtypes", [typeof (command_a = typeof UserDataFactory !== "undefined" && UserDataFactory) === "function" ? command_a : Object])
], StatsCommand);


;// ./packages/server-cli/lib/command/stats/index.ts


;// ./packages/server-cli/lib/command/user-info/info.ts

function userToInfo(model) {
    if (model == null) {
        return null;
    }
    const { id, email, name, createdAt } = model;
    const publicId = String(new PublicId(id));
    const externalIds = model.externalIds.map(externalIdToInfo);
    const order = orderToInfo(model.order);
    return { id, publicId, email, name, createdAt, externalIds, order };
}
function externalIdToInfo(model) {
    if (model == null) {
        return null;
    }
    const { provider, externalId, name, url, imageUrl, createdAt } = model;
    return { provider, externalId, name, url, imageUrl, createdAt };
}
function orderToInfo(model) {
    if (model == null) {
        return null;
    }
    const { id, provider, email, name, createdAt } = model;
    return { id, provider, email, name, createdAt };
}

;// ./packages/server-cli/lib/command/user-info/command.ts





let UserInfoCommand = class UserInfoCommand {
    command() {
        return new Command("user-info")
            .description("Display user info.")
            .addArgument(new Argument("<user-id-or-email>", "User id or email."))
            .addOption(new Option("--set-email <email>", "Set a new e-mail address for a user."))
            .action(this.action.bind(this));
    }
    async action(idOrEmail, { setEmail = null }) {
        let user = await findUser(idOrEmail);
        if (user == null) {
            throw new InvalidArgumentError(`User [${idOrEmail}] not found.`);
        }
        if (setEmail) {
            const { email } = user;
            await user.$query().patch({ email: setEmail }).findById(user.id);
            user = await model_User.findById(user.id);
            if (user == null) {
                throw new Error();
            }
            console.log(`User email changed from [${email}] to [${user.email}].`);
        }
        console.log(userToInfo(user));
    }
};
UserInfoCommand = __decorate([
    injectable()
], UserInfoCommand);

async function findUser(idOrEmail) {
    if (/^[0-9]+$/.test(idOrEmail)) {
        return await model_User.findById(Number.parseInt(idOrEmail, 10));
    }
    if (/^.+@.+$/.test(idOrEmail)) {
        return await model_User.findByEmail(idOrEmail);
    }
    throw new InvalidArgumentError(`Invalid user id or email [${idOrEmail}].`);
}

;// ./packages/server-cli/lib/command/user-info/index.ts


;// ./packages/server-cli/lib/main.ts







Env.probeFilesSync();
const container = new Container();
container.load(new ConfigModule());
const knex = container.get((knex_default()));
const main_program = new Command("keybr")
    .addCommand(container.get(UserInfoCommand).command())
    .addCommand(container.get(PremiumCommand).command())
    .addCommand(container.get(StatsCommand).command());
main_program
    .parseAsync()
    .then(() => {
    knex.destroy();
})
    .catch((err) => {
    if (err instanceof CommanderError) {
        main_program.error(err.message, err);
    }
    else {
        throw err;
    }
});

})();

/******/ })()
;
//# sourceMappingURL=keybr.js.map